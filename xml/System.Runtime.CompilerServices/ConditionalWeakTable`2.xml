<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="91016ece1f3636ce7d1e55388bb6faa7891de6fd" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68399620" /></Metadata><TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ConditionalWeakTable(Of TKey, TValue)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TKey, typename TValue&gt;&#xA; where TKey : class where TValue : classpublic ref class ConditionalWeakTable sealed" />
  <TypeSignature Language="F#" Value="type ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Dynamic.Runtime</AssemblyName>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TKey">Typ odwołania, do którego pole jest dołączone.</typeparam>
    <typeparam name="TValue">Typ pola. Musi to być typ referencyjny.</typeparam>
    <summary>Umożliwia kompilatorom dynamiczne dołączanie pól obiektów do zarządzanych obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasa umożliwia kompilatorom języka dołączanie dowolnych właściwości do zarządzanych obiektów w czasie wykonywania. <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Obiekt jest słownikiem, który wiąże obiekt zarządzany, który jest reprezentowany przez klucz do dołączonej właściwości, która jest reprezentowana przez wartość. Klucze obiektu są pojedynczymi wystąpieniami `TKey` klasy, do których jest dołączona właściwość, a jej wartości są wartościami właściwości przypisanymi do odpowiednich obiektów.  
  
 Klucze muszą być unikatowe; Innymi słowy, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasa obsługuje jedną dołączoną wartość na obiekt zarządzany. Dwa klucze są równe, <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> Jeśli przekazanie ich do metody zwróci `true`metodę.  
  
> [!NOTE]
>  Nie można kontrolować porównania równości poprzez przesłanianie <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> , aby jawnie ustawić kod skrótu dla klucza. Klasa nie używa metody do obliczania kodów skrótów i w związku z tym nie wywołuje <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> zastąpień. <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602>  
  
 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Chociaż Klasa przechowuje kolekcję par klucz/wartość, najlepiej jest traktować jako tabelę, a nie obiekt słownika. <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasa różni się od słownika na kilka sposobów:  
  
-   Klucze nie są utrwalane. Oznacza to, że klucz nie jest aktywny tylko, ponieważ jest elementem członkowskim kolekcji.  
  
-   Nie zawiera on wszystkich metod (takich jak `GetEnumerator` lub `Contains`), które zwykle mają słownik.  
  
-   Nie implementuje <xref:System.Collections.Generic.IDictionary%602> interfejsu.  
  
 <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> Klasa różni się od innych obiektów kolekcji w zarządzaniu okresem istnienia obiektu kluczy przechowywanych w kolekcji. Zwykle gdy obiekt jest przechowywany w kolekcji, jego okres istnienia będzie trwać do momentu jego usunięcia (i nie ma dodatkowych odwołań do obiektu) lub do momentu zniszczenia samego obiektu kolekcji. Jednak w <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> klasie Dodawanie pary klucz/wartość do tabeli nie gwarantuje, że klucz będzie trwały, nawet jeśli można go uzyskać bezpośrednio z wartości przechowywanej w tabeli (na przykład jeśli tabela zawiera jeden klucz, a, o wartości V1 i drugi klawisz, B, o wartości P2, która zawiera odwołanie do elementu. Zamiast tego <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> program automatycznie usuwa wpis klucz/wartość, gdy tylko nie istnieją żadne inne odwołania do klucza poza tabelą. Przykład stanowi ilustrację.  
  
   
  
## Examples  
 Poniższy przykład ilustruje, że klucz przechowywany w <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabeli nie utrwala się po usunięciu odwołań do niego poza tabelą. W przykładzie zdefiniowano dwie klasy `ManagedClass`:, która reprezentuje klucz w tabeli i `ClassData`reprezentuje wartość klucza. Przykład tworzy wystąpienie trzech obiektów każdego typu. Tworzy również wystąpienie <xref:System.WeakReference> obiektu, który reprezentuje sekundę `ManagedClass`, a następnie niszczy drugie `ManagedClass` wystąpienie. Próba pobrania drugiego `ManagedClass` obiektu <xref:System.WeakReference.Target%2A> z właściwości wskazuje, że żadne odwołanie do obiektu nie pozostało.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> Wystąpienia klasy są bezpieczne wątkowo. Nie wymagają od wywołujących żadnych dodatkowych blokad.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ConditionalWeakTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktor tworzy wystąpienie pustej <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabeli. oznacza to, że tabela nie zawiera par klucz/wartość. <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> Pary klucz/wartość można dodać <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, wywołując metodę, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, lub <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> .  
  
 Każdy klucz w <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> obiekcie musi być unikatowy. Klucze nie są unikatowe, jeśli odwołują się do tego samego obiektu (oznacza to, że w przypadku przekazywania ich <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> jako argumentów `true`do metody).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.Add : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.Add (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać dodany. <paramref name="key" />reprezentuje obiekt, do którego jest dołączona właściwość.</param>
        <param name="value">Wartość właściwości klucza.</param>
        <summary>Dodaje klucz do tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy klucz w <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> obiekcie musi być unikatowy. Klucze nie są unikatowe, jeśli odwołują się do tego samego obiektu (oznacza to, że w przypadku przekazywania ich <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> jako argumentów `true`do metody).  
  
 Jeśli klucz jest odzyskiwany w trakcie operacji dodawania, istniejąca para klucz/wartość jest usuwana, a nowa para klucz/wartość jest dodawana bez zgłaszania wyjątku.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `MainClass` klasę `MainInfo` i klasę, `MainClass` która zawiera informacje o wystąpieniu. Przykład następnie wywołuje <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> metodę, aby `MainClass` dodać obiekt i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> jego dołączony `MainInfo` obiekt do tabeli. Przykład ilustruje także wywołania <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metod i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> , aby dodać pary klucz/wartość do <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> tabeli, oraz metodę, aby pobrać wartość istniejącego klucza.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="key" />już istnieje.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOrUpdate (key As TKey, value As TValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOrUpdate(TKey key, TValue value);" />
      <MemberSignature Language="F#" Value="member this.AddOrUpdate : 'Key * 'Value -&gt; unit" Usage="conditionalWeakTable.AddOrUpdate (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do dodania lub zaktualizowania. Nie może być <see langword="null" />.</param>
        <param name="value">Wartość, z <paramref name="key" />którą ma zostać skojarzona.</param>
        <summary>Dodaje klucz i wartość, jeśli klucz nie istnieje, lub aktualizuje wartość istniejącego klucza, jeśli istnieje.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="conditionalWeakTable.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści wszystkie pary klucz/wartość.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ConditionalWeakTable`2 ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="conditionalWeakTable.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zapewnia, że zasoby są zwolnione i inne operacje czyszczenia są wykonywane, gdy moduł zbierający <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> elementy bezużyteczne odzyskuje obiekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł zbierający elementy <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> bezużyteczne wywołuje, kiedy bieżący obiekt jest gotowy do sfinalizowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrCreateValue (key As TKey) As TValue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetOrCreateValue(TKey key);" />
      <MemberSignature Language="F#" Value="member this.GetOrCreateValue : 'Key -&gt; 'Value" Usage="conditionalWeakTable.GetOrCreateValue key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać wyszukany. <paramref name="key" />reprezentuje obiekt, do którego jest dołączona właściwość.</param>
        <summary>Niepodzielnie wyszukuje określony klucz w tabeli i zwraca odpowiadającą wartość. Jeśli klucz nie istnieje w tabeli, metoda wywołuje Konstruktor bez parametrów klasy, która reprezentuje wartość tabeli, aby utworzyć wartość powiązaną z określonym kluczem.</summary>
        <returns>Wartość, która odnosi się <paramref name="key" />do, <paramref name="key" /> Jeśli istnieje już w tabeli; w przeciwnym razie nowa wartość tworzona przez konstruktora bez parametrów klasy zdefiniowanej przez <paramref name="TValue" /> parametr typu ogólnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `key` nie istnieje w tabeli, Metoda dodaje go wraz z obiektem, który jest skonkretyzowany przez wywołanie konstruktora bez parametrów klasy zdefiniowanej `TValue` przez parametr typu ogólnego. Jeśli Klasa nie ma konstruktora bez parametrów <xref:System.MissingMethodException> , jest zgłaszany. `TValue`  
  
 Jest to zalecana metoda pobierania istniejącej wartości lub dodawania nowej wartości do <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabeli, jeśli Klasa wartości tabeli definiuje konstruktora bez parametrów. Jeśli nie definiuje konstruktora bez parametrów, zamiast tego można wywołać <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> metodę, która opiera się na metodzie dostarczonej z wywołaniem zwrotnym, aby utworzyć wystąpienie obiektu reprezentującego wartość tabeli  
  
 Aby pobrać wartość istniejącego klucza bez dodawania pary klucz/wartość, jeśli klucz nie zostanie znaleziony w tabeli, wywołaj <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodę.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `MainClass` klasę `MainInfo` i klasę, `MainClass` która zawiera informacje o wystąpieniu. Przykład wywołuje metodę, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> aby `MainClass` dodać obiekt i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> jego dołączony `MainInfo` obiekt do tabeli. Przykład ilustruje także wywołania <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> metod i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> , aby dodać pary klucz/wartość do <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> tabeli, oraz metodę, aby pobrać wartość istniejącego klucza.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException"><block subset="none" type="note">
            <para>  
 W programie <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET dla aplikacji ze sklepu Windows</see> lub <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">przenośnej biblioteki klas</see>Przechwyć wyjątek <see cref="T:System.MissingMemberException" />klasy bazowej, zamiast tego.  
  
</para>
          </block>  
  
 Klasa, która reprezentuje wartość tabeli, nie definiuje konstruktora bez parametrów.</exception>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TValue GetValue(TKey key, System::Runtime::CompilerServices::ConditionalWeakTable&lt;TKey, TValue&gt;::CreateValueCallback ^ createValueCallback);" />
      <MemberSignature Language="F#" Value="member this.GetValue : 'Key * System.Runtime.CompilerServices.ConditionalWeakTable&lt;'Key, 'Value (requires 'Key : null and 'Value : null)&gt;.CreateValueCallback -&gt; 'Value" Usage="conditionalWeakTable.GetValue (key, createValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który ma zostać wyszukany. <paramref name="key" />reprezentuje obiekt, do którego jest dołączona właściwość.</param>
        <param name="createValueCallback">Delegat do metody, która może utworzyć wartość dla danego <paramref name="key" />elementu. Ma jeden parametr typu <c>TKey</c>i zwraca wartość typu <c>TValue</c>.</param>
        <summary>Niepodzielnie wyszukuje określony klucz w tabeli i zwraca odpowiadającą wartość. Jeśli klucz nie istnieje w tabeli, metoda wywołuje metodę wywołania zwrotnego w celu utworzenia wartości, która jest powiązana z określonym kluczem.</summary>
        <returns>Wartość dołączona do <paramref name="key" />, jeśli <paramref name="key" /> istnieje już w tabeli; w przeciwnym razie <paramref name="createValueCallback" /> nowa wartość zwrócona przez delegata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `key` nie istnieje w tabeli, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> wywołuje metodę `createValueCallback` , która jest zdefiniowana przez parametr i przekazuje go do klucza. Nowa wartość jest powiązana z kluczem w tabeli i zwracana jako wynik.  
  
 Tej metody należy użyć tylko wtedy, gdy Klasa reprezentująca wartość tabeli nie definiuje konstruktora bez parametrów. Jeśli zdefiniowano konstruktora bez parametrów, zamiast tego użyj <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> metody. Aby pobrać wartość istniejącego klucza bez dodawania pary klucz/wartość, jeśli klucz nie zostanie znaleziony w tabeli, wywołaj <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> metodę.  
  
 Jeśli wiele wątków próbuje utworzyć ten sam klucz, `createValueCallback` można wywołać wiele razy z tym samym kluczem. Tylko jedno z tych wywołań powiedzie się, a zwrócona wartość zostanie dodana do tabeli. Który wątek kończy się powodzeniem tworzenia wartości jest nieokreślony. Ta reguła umożliwia wywoływanie `createValueCallback` tabeli poza wewnętrzną blokadą tabeli w celu zapobiegania zakleszczeniom.  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `MainClass` klasę `MainInfo` i klasę, `MainClass` która zawiera informacje o wystąpieniu. Definiuje także statyczną (`Shared` w Visual Basic) `CreateAttachedValue` metodę, która <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> może być przypisana do delegata i przeniesiona <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> do metody. Przykład wywołuje metodę, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> aby `MainClass` dodać obiekt i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> jego dołączony `MainInfo` obiekt do tabeli. Przykład ilustruje także wywołania <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> metod i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> , aby dodać pary klucz/wartość do <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> tabeli, oraz metodę, aby pobrać wartość istniejącego klucza.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />lub <paramref name="createValueCallback" /> jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
        <altmember cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As TKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Remove(TKey key);" />
      <MemberSignature Language="F#" Value="member this.Remove : 'Key -&gt; bool" Usage="conditionalWeakTable.Remove key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">Klucz do usunięcia.</param>
        <summary>Usuwa klucz i jego wartość z tabeli.</summary>
        <returns><see langword="true" />Jeśli klucz zostanie znaleziony i usunięty; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz jest odzyskiwany w trakcie tej operacji, metoda nie zgłasza wyjątku, a zwracana wartość jest niezdefiniowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of TKey, TValue)) Implements IEnumerable(Of KeyValuePair(Of TKey, TValue)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (key As TKey, ByRef value As TValue) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(TKey key, [Runtime::InteropServices::Out] TValue % value);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'Key *  -&gt; bool" Usage="conditionalWeakTable.TryGetValue (key, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Dynamic.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">Klucz, który reprezentuje obiekt z dołączoną właściwością.</param>
        <param name="value">Gdy ta metoda zwraca, zawiera wartość dołączonej właściwości. Jeśli <paramref name="key" /> nie zostanie znaleziona <paramref name="value" /> , zawiera wartość domyślną.</param>
        <summary>Pobiera wartość określonego klucza.</summary>
        <returns><see langword="true" />Jeśli <paramref name="key" /> został znaleziony; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz jest odzyskiwany w trakcie tej operacji, Metoda może zwracać `false` i ustawić `value` wartość domyślną (tak, jakby klucz nie był obecny).  
  
   
  
## Examples  
 W poniższym przykładzie zdefiniowano `MainClass` klasę `MainInfo` i klasę, `MainClass` która zawiera informacje o wystąpieniu. Przykład wywołuje <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>metody,, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>i <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> , <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> aby dodać pary klucz/wartość do tabeli. W każdym przypadku przykład wywołuje metodę, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> aby potwierdzić, że para klucz/wartość została dodana do tabeli.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" />jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
        <altmember cref="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable{`0,`1}.CreateValueCallback)" />
      </Docs>
    </Member>
  </Members>
</Type>

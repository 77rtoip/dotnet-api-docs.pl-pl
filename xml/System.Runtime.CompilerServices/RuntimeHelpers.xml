<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a702d-101">Udostępnia zestaw metod statycznych i właściwości, które zapewniają obsługę kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-101">Provides a set of static methods and properties that provide support for compilers.</span></span> <span data-ttu-id="a702d-102">Klasa ta nie może być dziedziczona.</span><span class="sxs-lookup"><span data-stu-id="a702d-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a702d-103">Poniższy przykład przedstawia sposób niezawodny sposób ustawić uchwytów przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="a702d-104">Niezawodny sposób ustawić dojścia do określonego dojścia istniejące, upewnij się, że przydziału uchwyt macierzysty i kolejne nagrywania dojścia w <xref:System.Runtime.InteropServices.SafeHandle> obiekt jest atomic.</span><span class="sxs-lookup"><span data-stu-id="a702d-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="a702d-105">Uchwyt macierzysty wycieku spowoduje niezgodności między te operacje (np. Przerwij wątku lub wyjątek braku pamięci).</span><span class="sxs-lookup"><span data-stu-id="a702d-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="a702d-106">Można użyć <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> metody, aby upewnić się, że dojście nie jest przeciek.</span><span class="sxs-lookup"><span data-stu-id="a702d-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a702d-107">Zapewnia, że pozostałego miejsca na stosie jest wystarczająco duży, aby wykonać średni funkcji .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a702d-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> zawiera informacje o sztucznie ograniczone stosu, która zachowuje za mało miejsca na wygenerowany wyjątek i podjęcie działań odzyskiwania.</span><span class="sxs-lookup"><span data-stu-id="a702d-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="a702d-109">Limit stosu sztuczne jest wybierany przez środowisko uruchomieniowe języka wspólnego, aby zapewnić wystarczającą ilość miejsca do zgłoszenia wyjątku, bezpieczne.</span><span class="sxs-lookup"><span data-stu-id="a702d-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="a702d-110">Ta metoda jest przydatna w sytuacjach, w których może wystąpić przepełnienie stosu w wyniku niepowiązaną rekursję.</span><span class="sxs-lookup"><span data-stu-id="a702d-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="a702d-111">Ma w scenariuszach usług kompilatora, mimo że jego można również bezpiecznie w innych scenariuszach programowanie.</span><span class="sxs-lookup"><span data-stu-id="a702d-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="a702d-112">Jeśli wystarcza miejsca na stosie nie wyjątku i nadal można wywołać większość typów .NET Framework i elementów członkowskich.</span><span class="sxs-lookup"><span data-stu-id="a702d-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a702d-113">Ta metoda nie jest częścią pomocy technicznej (CER) region ograniczonego wykonania i nie należy mylić z <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException"><span data-ttu-id="a702d-114">Miejsce dostępne stosu jest niewystarczający w celu wykonania średnią funkcji .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a702d-114">The available stack space is insufficient to execute the average .NET Framework function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1"><span data-ttu-id="a702d-115">Pierwszy obiekt, który ma zostać porównany.</span><span class="sxs-lookup"><span data-stu-id="a702d-115">The first object to compare.</span></span></param>
        <param name="o2"><span data-ttu-id="a702d-116">Drugi obiekt, który będzie porównywany.</span><span class="sxs-lookup"><span data-stu-id="a702d-116">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="a702d-117">Określa, czy określony <see cref="T:System.Object" /> wystąpienia są traktowane jako równe.</span><span class="sxs-lookup"><span data-stu-id="a702d-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span></span></summary>
        <returns>
          <span data-ttu-id="a702d-118"><see langword="true" /> Jeśli <paramref name="o1" /> parametr jest tym samym wystąpieniu jako <paramref name="o2" /> parametru lub obu <see langword="null" />, lub jeśli <c>o1. Equals(O2)</c> zwraca <see langword="true" />; w przeciwnym razie <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a702d-118"><see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-119">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a702d-120">W poniższym przykładzie pokazano sposób porównywania dwóch obiektów przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code"><span data-ttu-id="a702d-121">Delegat kod próby.</span><span class="sxs-lookup"><span data-stu-id="a702d-121">A delegate to the code to try.</span></span></param>
        <param name="backoutCode"><span data-ttu-id="a702d-122">Delegat kod służący do uruchamiania w przypadku wystąpienia wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a702d-122">A delegate to the code to run if an exception occurs.</span></span></param>
        <param name="userData"><span data-ttu-id="a702d-123">Dane do przekazania do <c>kod</c> i <c>backoutCode</c>.</span><span class="sxs-lookup"><span data-stu-id="a702d-123">The data to pass to <c>code</c> and <c>backoutCode</c>.</span></span></param>
        <summary><span data-ttu-id="a702d-124">Wykonuje kodu za pomocą <see cref="T:System.Delegate" /> podczas korzystania z innej <see cref="T:System.Delegate" /> wykonać dodatkowy kod w przypadku wyjątku.</span><span class="sxs-lookup"><span data-stu-id="a702d-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-125">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-126">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-126">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-127">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-127">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="a702d-128">Obiekt, który można pobrać wartość skrótu dla.</span><span class="sxs-lookup"><span data-stu-id="a702d-128">An object to retrieve the hash code for.</span></span></param>
        <summary><span data-ttu-id="a702d-129">Pełni rolę funkcji skrótu dla określonego obiektu i nadaje się do użytku w strukturach algorytmów i danych, które używają kodów skrótów, takich jak tablicy skrótów.</span><span class="sxs-lookup"><span data-stu-id="a702d-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="a702d-130">Wartość skrótu dla obiekt identyfikowane przez <paramref name="o" /> parametru.</span><span class="sxs-lookup"><span data-stu-id="a702d-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-131"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Zawsze wywołuje metodę <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> — metoda nie praktycznie, nawet wtedy, gdy typ obiektu została zastąpiona <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a702d-132">W związku z tym przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> może się różnić od wywołania `GetHashCode` bezpośrednio na obiekt z <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="a702d-133">Mimo że <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> metoda zwraca identyczne skrótu dla odwołania do obiektów identyczne, nie należy używać tej metody w celu zbadania tożsamości obiektu, ponieważ ta wartość skrótu nie identyfikuje jednoznacznie odwołanie do obiektu.</span><span class="sxs-lookup"><span data-stu-id="a702d-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="a702d-134">Aby przetestować dla obiekt zidentyfikować (to znaczy do przetestowania tego dwa obiekty odwołanie do tego samego obiektu w pamięci), wywołania <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a702d-135">Nie należy używać <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> Aby sprawdzić, czy dwa ciągi, które reprezentują odwołania do obiektów takie same, ponieważ interned jest ciąg.</span><span class="sxs-lookup"><span data-stu-id="a702d-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="a702d-136">Aby sprawdzić, czy ciąg interning, należy wywołać <xref:System.String.IsInterned%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a702d-137"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> metody różnią się w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a702d-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="a702d-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Zwraca wartość skrótu opartego na definicji obiektu równości.</span><span class="sxs-lookup"><span data-stu-id="a702d-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="a702d-139">Na przykład dwa ciągi ze identyczną zawartość będzie zwracać taką samą wartość <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a702d-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="a702d-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Zwraca wartość skrótu, która wskazuje tożsamość obiektu.</span><span class="sxs-lookup"><span data-stu-id="a702d-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="a702d-141">Oznacza to, że dwa ciągu zmiennych, których zawartość jest identyczne i reprezentują ciąg, który jest interned (zobacz [Interning ciąg](#interning) sekcji) lub kodów skrótów reprezentujące taki sam zwracany pojedynczy ciąg w pamięci.</span><span class="sxs-lookup"><span data-stu-id="a702d-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a702d-142">Należy pamiętać, że <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> zawsze zwraca identyczne skrótu dla odwołania do obiektów takie same.</span><span class="sxs-lookup"><span data-stu-id="a702d-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="a702d-143">Jednak odwrotnej nie jest prawdziwe: równy skrótu nie wskazują odwołania do obiektów takie same.</span><span class="sxs-lookup"><span data-stu-id="a702d-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="a702d-144">Wartość skrótu określonego kodu nie jest unikatowa dla konkretnego obiektu odwołania; odwołania do różnych obiektów mogą generować kody skrótów identyczne.</span><span class="sxs-lookup"><span data-stu-id="a702d-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="a702d-145">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="a702d-146">Wewnętrzne przygotowanie ciągu</span><span class="sxs-lookup"><span data-stu-id="a702d-146">String Interning</span></span>  
 <span data-ttu-id="a702d-147">Środowisko uruchomieniowe języka wspólnego (CLR) prowadzi wewnętrzny puli ciągów i przechowuje literałów w puli.</span><span class="sxs-lookup"><span data-stu-id="a702d-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="a702d-148">Jeśli dwa ciągi (na przykład `str1` i `str2`) są utworzone z identycznymi literału ciągu znaków, ustawi CLR `str1` i `str2` do punktu w tej samej lokalizacji na stercie zarządzanej w celu zachowywania pamięci.</span><span class="sxs-lookup"><span data-stu-id="a702d-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="a702d-149">Wywoływanie <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> dla tych dwóch ciągu obiektów utworzy ten sam kod skrótu w sprzeczności z drugiego elementu listy punktowane w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="a702d-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="a702d-150">Środowisko CLR dodaje tylko literały do puli.</span><span class="sxs-lookup"><span data-stu-id="a702d-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="a702d-151">Wyniki operacji ciągu, takich jak łączenie nie są dodawane do puli, chyba że kompilator rozpoznaje ciągów jako pojedynczy ciąg literału.</span><span class="sxs-lookup"><span data-stu-id="a702d-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="a702d-152">W związku z tym jeśli `str2` został utworzony w wyniku operacji łączenia i `str2` jest taka sama jak `str1`za pomocą <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> dla tych dwóch ciągu obiektów może nie być taki sam skrót.</span><span class="sxs-lookup"><span data-stu-id="a702d-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="a702d-153">Jeśli chcesz jawnie dodać połączony ciąg do puli, użyj <xref:System.String.Intern%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="a702d-154">Można również użyć <xref:System.String.IsInterned%2A?displayProperty=nameWithType> metodę sprawdzania, czy ciąg ma interned odwołania.</span><span class="sxs-lookup"><span data-stu-id="a702d-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a702d-155">W poniższym przykładzie pokazano różnicę między <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> i <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="a702d-156">Dane wyjściowe w przykładzie przedstawiono poniżej:</span><span class="sxs-lookup"><span data-stu-id="a702d-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="a702d-157">Oba zestawy skrótu dla pierwszego zestawu parametrów przekazanych do `ShowHashCodes` metody różnią się, ponieważ ciągi różnią się całkowicie.</span><span class="sxs-lookup"><span data-stu-id="a702d-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="a702d-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generuje ten sam kod skrótu dla drugi zestaw parametrów przekazanych do `ShowHashCodes` metody, ponieważ ciągi są takie same.</span><span class="sxs-lookup"><span data-stu-id="a702d-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="a702d-159">Jednak <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> nie ma metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="a702d-160">Pierwszy ciąg jest definiowana za pomocą literału ciągu, a więc interned.</span><span class="sxs-lookup"><span data-stu-id="a702d-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="a702d-161">Wartość drugi ciąg ma taki sam, ale jego jest nie interned, ponieważ jest zwracany przez wywołanie do <xref:System.String.Format%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="a702d-162">W przypadku trzeciego ciągu kodów skrótów utworzonego przez <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> dla obu ciągi są identyczne, są tak jak skrótu utworzonego przez <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a702d-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a702d-163">Jest tak, ponieważ kompilator ma traktowane wartość przypisana do obu ciągi jako pojedynczy ciąg literału i zmiennych ciągu odwoływać się do tych samych parametrach interned.</span><span class="sxs-lookup"><span data-stu-id="a702d-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="a702d-164">Typ wartości do można spakować.</span><span class="sxs-lookup"><span data-stu-id="a702d-164">The value type to be boxed.</span></span></param>
        <summary><span data-ttu-id="a702d-165">Pola typu wartości.</span><span class="sxs-lookup"><span data-stu-id="a702d-165">Boxes a value type.</span></span></summary>
        <returns><span data-ttu-id="a702d-166">Opakowany kopię <paramref name="obj" /> , jeśli jest on klasą wartości; w przeciwnym razie <paramref name="obj" /> samej siebie.</span><span class="sxs-lookup"><span data-stu-id="a702d-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-167">Konwersja boxing typów wartości tworzy obiekt i wykonuje kopię pobieżną pól typu określoną wartość do nowego obiektu.</span><span class="sxs-lookup"><span data-stu-id="a702d-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="a702d-168">Ta metoda umożliwia klasą wartości można manipulować jako obiekt podczas zachowuje zachowanie aliasów klasą wartości.</span><span class="sxs-lookup"><span data-stu-id="a702d-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="a702d-169">Zwracana wartość zależy od tego, czy klasy wartości jest modyfikowalna lub modyfikować:</span><span class="sxs-lookup"><span data-stu-id="a702d-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="a702d-170">Jeśli wartość zostanie przypisany jest klasą wartości modyfikowalne, metoda zwraca kopię pobieżną klasy, ponieważ wartość klas ma semantykę kopii.</span><span class="sxs-lookup"><span data-stu-id="a702d-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="a702d-171">Jeśli wartość zostanie przypisany jest klasą wartości niezmienne, metoda zwraca obiekt, zamiast kopiowania klasy.</span><span class="sxs-lookup"><span data-stu-id="a702d-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="a702d-172">Kompilatory językach umożliwia tej metody upewnij się, czy spakowanymi typami wartości działają tak samo na wartościach rozpakowanych.</span><span class="sxs-lookup"><span data-stu-id="a702d-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="a702d-173">Oznacza to spakowanymi typami wartości get sklonowany, gdy przekazujesz je i zawsze są one przekazywane przez wartość.</span><span class="sxs-lookup"><span data-stu-id="a702d-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="a702d-174">Kompilator może wywołać <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> można przypisać typu wartości do obiektu lub do przekazania typu wartości jako parametr typu obiektu.</span><span class="sxs-lookup"><span data-stu-id="a702d-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="a702d-175">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a702d-176">W poniższym przykładzie pokazano sposób pola klasy wartości przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="a702d-177">Aby można było zainicjować tablicy.</span><span class="sxs-lookup"><span data-stu-id="a702d-177">The array to be initialized.</span></span></param>
        <param name="fldHandle"><span data-ttu-id="a702d-178">Dojścia pola, który określa lokalizację danych używaną do inicjalizacji tablicy.</span><span class="sxs-lookup"><span data-stu-id="a702d-178">A field handle that specifies the location of the data used to initialize the array.</span></span></param>
        <summary><span data-ttu-id="a702d-179">Zapewnia możliwość szybkiego zainicjowania tablicy z danych przechowywanych w module.</span><span class="sxs-lookup"><span data-stu-id="a702d-179">Provides a fast way to initialize an array from data that is stored in a module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-180">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a702d-181">Pobiera wartość przesunięcia w bajtach do danych w ciągu.</span><span class="sxs-lookup"><span data-stu-id="a702d-181">Gets the offset, in bytes, to the data in the given string.</span></span></summary>
        <value><span data-ttu-id="a702d-182">Przesunięcie bajtów, od początku <see cref="T:System.String" /> obiektu do pierwszego znaku w ciągu.</span><span class="sxs-lookup"><span data-stu-id="a702d-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-183">Kompilatory tej właściwości należy użyć dla operacji unsafe, ale wydajne, wskaźnik w znaki w ciągu zarządzany.</span><span class="sxs-lookup"><span data-stu-id="a702d-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="a702d-184">Kompilatory powinien przypiąć ciągu względem ruchu przez moduł garbage collector przed użyciem.</span><span class="sxs-lookup"><span data-stu-id="a702d-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="a702d-185">Należy pamiętać, że ciągi środowiska uruchomieniowego języka wspólnego są niezmienne; oznacza to ich zawartość mogą być do odczytu, ale nie została zmieniona.</span><span class="sxs-lookup"><span data-stu-id="a702d-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a702d-186">Określa jednostkę kodu jako region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-186">Designates a body of code as a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-187">Kompilatory Użyj tej metody, aby oznaczyć `catch`, `finally`, i `fault` bloki jako ograniczone regiony wykonania (CERs).</span><span class="sxs-lookup"><span data-stu-id="a702d-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="a702d-188">Kod, który jest oznaczony jako region ograniczonego należy wywoływać tylko innych kodu za pomocą kontrakty niezawodności silne.</span><span class="sxs-lookup"><span data-stu-id="a702d-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="a702d-189">Nie należy przydzielić ani należy wirtualnego wywołania metod nieprzygotowany lub zawodnych, chyba że jest przygotowany do obsługi błędów.</span><span class="sxs-lookup"><span data-stu-id="a702d-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="a702d-190">Należy pamiętać, że nie pośredniego używa języka, z wyjątkiem `NOP`, między wywołania nie są dozwolone <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> — metoda i `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="a702d-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="a702d-191">Aby uzyskać więcej informacji na temat CERs Zobacz klas w <xref:System.Runtime.ConstrainedExecution> przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="a702d-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="a702d-192">CERs, które są oznaczone za pomocą <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> — metoda nie działać prawidłowo po <xref:System.StackOverflowException> są generowane na podstawie `try` bloku.</span><span class="sxs-lookup"><span data-stu-id="a702d-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="a702d-193">Aby uzyskać więcej informacji, zobacz <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="a702d-194"><xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> Wywołania metody <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a702d-195">Poniższy przykład przedstawia sposób niezawodny sposób ustawić uchwytów przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="a702d-196">Niezawodny sposób ustawić dojścia do określonego dojścia istniejące, upewnij się, że przydziału uchwyt macierzysty i kolejne nagrywania dojścia w <xref:System.Runtime.InteropServices.SafeHandle> obiekt jest atomic.</span><span class="sxs-lookup"><span data-stu-id="a702d-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="a702d-197">Uchwyt macierzysty wycieku spowoduje niezgodności między te operacje (np. Przerwij wątku lub wyjątek braku pamięci).</span><span class="sxs-lookup"><span data-stu-id="a702d-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="a702d-198">Można użyć <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> metody, aby upewnić się, że dojście nie jest przeciek.</span><span class="sxs-lookup"><span data-stu-id="a702d-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-199">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-200">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a702d-201">Określa treści kodu jako region ograniczonego wykonania (CER) bez wykonywania żadnych sondowanie.</span><span class="sxs-lookup"><span data-stu-id="a702d-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-202">Kompilatory nie należy bezpośrednio wywołać tę metodę.</span><span class="sxs-lookup"><span data-stu-id="a702d-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="a702d-203">Zamiast tego należy zdefiniować CER przez wywołanie metody <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-204">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-204">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-205">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-205">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="a702d-206">Delegat zdarzeń, aby przygotować.</span><span class="sxs-lookup"><span data-stu-id="a702d-206">The event delegate to prepare.</span></span></param>
        <summary><span data-ttu-id="a702d-207">Umożliwia aplikacjom dynamiczne przygotowanie <see cref="T:System.AppDomain" /> delegatów zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="a702d-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-208"><xref:System.AppDomain> Zdarzenie deleguje takie jak <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, i <xref:System.AppDomain.UnhandledException> nie są automatycznie przygotowany przy uruchamianiu.</span><span class="sxs-lookup"><span data-stu-id="a702d-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="a702d-209">Aby przygotować je, można użyć następujących metod:</span><span class="sxs-lookup"><span data-stu-id="a702d-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="a702d-210">Atrybut przy użyciu metody <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a702d-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="a702d-211">Atrybut przy użyciu metody <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atrybutu.</span><span class="sxs-lookup"><span data-stu-id="a702d-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="a702d-212">Wywołanie <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> metody dynamicznie przygotować delegata.</span><span class="sxs-lookup"><span data-stu-id="a702d-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="a702d-213">Aby uzyskać więcej informacji, zobacz artykuł [zachować swój kod uruchomiony przy użyciu funkcji niezawodności programu .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) w MSDN Magazine.</span><span class="sxs-lookup"><span data-stu-id="a702d-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-214">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-214">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-215">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-215">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="a702d-216">Aby przygotować typ delegata.</span><span class="sxs-lookup"><span data-stu-id="a702d-216">The delegate type to prepare.</span></span></param>
        <summary><span data-ttu-id="a702d-217">Wskazuje, że określonego delegata powinna być przygotowana do uwzględnienia w regionie ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-218">Kompilatory ta metoda służy do przygotowania delegata wywołania metody oraz na przygotowanie docelowej tego wywołania (i delegata wykresu wywołań statycznie możliwa do ustalenia) jako region ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-219">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-219">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-220">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-220">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a702d-221">Przygotowuje metody do uwzględnienia w regionie ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-221">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a702d-222">Dojście do metody w celu przygotowania.</span><span class="sxs-lookup"><span data-stu-id="a702d-222">A handle to the method to prepare.</span></span></param>
        <summary><span data-ttu-id="a702d-223">Przygotowuje metody do uwzględnienia w regionie ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-223">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-224">Użyj kompilatory <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> metody do obsługi wirtualnych wywołań w regionie ograniczonego wykonania (CER).</span><span class="sxs-lookup"><span data-stu-id="a702d-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="a702d-225">W czasie kompilacji JIT środowisko uruchomieniowe języka wspólnego nie ma zwykle wystarczającej ilości informacji o elementem docelowym wywołania wirtualnego.</span><span class="sxs-lookup"><span data-stu-id="a702d-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="a702d-226">Środowisko uruchomieniowe nie w związku z tym wstępnie przygotować tego segmentu wykresu wywołań.</span><span class="sxs-lookup"><span data-stu-id="a702d-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="a702d-227">Jeśli kod, który używa CER ma za mało informacji w celu ustalenia, element docelowy w dowolnym momencie czas, zanim CER jest w rzeczywistości wprowadzana, może wywołać <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> do przygotowania tego samego środowiska uruchomieniowego zazwyczaj wykonywane dla CER początek w określonej jako argument metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-228">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-229">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="a702d-230">Dojście do metody w celu przygotowania.</span><span class="sxs-lookup"><span data-stu-id="a702d-230">A handle to the method to prepare.</span></span></param>
        <param name="instantiation"><span data-ttu-id="a702d-231">Aby przekazać do metody wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a702d-231">The instantiation to pass to the method.</span></span></param>
        <summary><span data-ttu-id="a702d-232">Przygotowuje metody do uwzględnienia w regionie ograniczonego wykonania (CER) z określonego wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="a702d-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-233">Zapewniają ogólne obsługę kompilatory przy użyciu <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="a702d-234">Środowisko uruchomieniowe języka wspólnego nie można przygotować ograniczone regiony wykonania (CERs) umieszczone w metodzie, która ma parametry typu ogólnego (albo parametr typu klasy zawierające metody lub jedną na tej metody) po wystąpienia są tworzone tych parametrów typu jako typów referencyjnych.</span><span class="sxs-lookup"><span data-stu-id="a702d-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="a702d-235">To przeciążenie umożliwia przekazać konkretnego wystąpienia (na przykład tablicy typów), najpierw Określanie parametrów typu klasy (jeśli istnieje), a następnie parametry typu metody (jeśli istnieje).</span><span class="sxs-lookup"><span data-stu-id="a702d-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="a702d-236">Środowisko uruchomieniowe przygotowuje wystąpienia tej metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="a702d-237">(Jest to konieczne tylko wtedy, gdy wystąpień, którego używasz zawiera co najmniej jeden parametr typu odwołanie.) W związku z tym można użyć stylu CER `try` klauzuli Metoda ogólna (lub nierodzajowe metody w klasie ogólnej) i będzie działać prawidłowo z wystąpieniami <xref:System.Int32> lub innych typów wartości.</span><span class="sxs-lookup"><span data-stu-id="a702d-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="a702d-238">Można utworzyć odwołanie do takich jak typy <xref:System.String>, musisz użyć jawnego <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> metody w CER główny metody najpierw.</span><span class="sxs-lookup"><span data-stu-id="a702d-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-239">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-240">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a702d-241">Sondy dla określoną ilość miejsca na stosie aby upewnić się, że przepełnienie stosu nie może się tak zdarzyć w kolejnych bloku kodu (przy założeniu, że kod używa tylko skończona i średnią ilość miejsca na stosie).</span><span class="sxs-lookup"><span data-stu-id="a702d-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span></span> <span data-ttu-id="a702d-242">Zalecane jest użycie region ograniczonego wykonania (CER) zamiast tej metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-242">We recommend that you use a constrained execution region (CER) instead of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-243">Ta metoda jest używana przez infrastrukturę (CER) region ograniczonego wykonania podczas uruchamiania na hostach, które są odporne na przepełnienie stosu, takich jak Microsoft SQL Server i Microsoft Exchange Server.</span><span class="sxs-lookup"><span data-stu-id="a702d-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="a702d-244">Ta metoda jest obecnie sondy dla 48 KB miejsca na stosie na x86 platformy, ale dokładny mogą ulec zmianie w czasie i mogą się różnić na innych platformach.</span><span class="sxs-lookup"><span data-stu-id="a702d-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="a702d-245">Ta metoda jest również używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="a702d-246">Zamiast <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> metody, należy użyć standardowego CER.</span><span class="sxs-lookup"><span data-stu-id="a702d-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="a702d-247">Oznacza to, jeśli planujesz używać umiarkowane ilości miejsca na stosie, wywołanie <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> metody bezpośrednio przed Twojej `try` / `finally` lub `try` / `catch` bloku.</span><span class="sxs-lookup"><span data-stu-id="a702d-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="a702d-248">Wywoływana metoda rekursywna lub planujesz jej używać dużej ilości miejsca na stosie, należy użyć <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> metody.</span><span class="sxs-lookup"><span data-stu-id="a702d-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="a702d-249">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego.</span><span class="sxs-lookup"><span data-stu-id="a702d-249">requires full trust for the immediate caller.</span></span> <span data-ttu-id="a702d-250">Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</span><span class="sxs-lookup"><span data-stu-id="a702d-250">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="a702d-251">Dojście typu określający metody konstruktora klasy do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="a702d-251">A type handle that specifies the class constructor method to run.</span></span></param>
        <summary><span data-ttu-id="a702d-252">Uruchamia konstruktora określonej klasy.</span><span class="sxs-lookup"><span data-stu-id="a702d-252">Runs a specified class constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-253">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="a702d-254">Klasa inicjatora zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a702d-254">The class initializer throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module"><span data-ttu-id="a702d-255">Uchwyt określa metodę konstruktora modułu do uruchomienia.</span><span class="sxs-lookup"><span data-stu-id="a702d-255">A handle that specifies the module constructor method to run.</span></span></param>
        <summary><span data-ttu-id="a702d-256">Uruchamia określony moduł konstruktora.</span><span class="sxs-lookup"><span data-stu-id="a702d-256">Runs a specified module constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a702d-257">Ta metoda jest używana przez kompilatory.</span><span class="sxs-lookup"><span data-stu-id="a702d-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="a702d-258">Konstruktor modułu zgłasza wyjątek.</span><span class="sxs-lookup"><span data-stu-id="a702d-258">The module constructor throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
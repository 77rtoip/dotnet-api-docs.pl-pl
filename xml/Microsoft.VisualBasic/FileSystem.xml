<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8058ee2dd6ec3c4b99d565a5d45e466a5bf00f3c" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55412295" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" /> Modułu zawiera procedury, które są używane do wykonywania operacji pliku, katalogu lub folderu i systemu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż przy użyciu <see langword="FileSystem" /> modułu. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten moduł obsługuje słowa kluczowe języka Visual Basic i elementy członkowskie biblioteki wykonawczej, uzyskujących dostęp do plików i folderów.  
  
   
  
## Examples  
 W tym przykładzie użyto `GetAttr` funkcję, aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Katalogi i pliki</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Wejście i wyjście — Podsumowanie</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Słowa kluczowe (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Elementy członkowskie biblioteki wykonawczej języka Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagana. Wyrażenie ciągu, który identyfikuje, które katalogu lub folderu staje się nowego domyślnego katalogu lub folderu. <paramref name="Path" /> może zawierać dysk. Jeśli dysk nie zostanie określony, <see langword="ChDir" /> zmienia domyślnego katalogu lub folderu na bieżącym dysku.</param>
        <summary>Zmienia bieżącego katalogu lub folderu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="ChDir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Funkcji zmienia domyślnego katalogu, ale nie dysk domyślny. Na przykład jeśli domyślnym dysku C, następująca instrukcja zmienia domyślny katalog na dysku D, ale C pozostaje dysk domyślny:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Można ustawić względne zmiany w katalogu jest przez wpisanie dwóch kropek w następujący sposób:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Funkcja wymaga, aby kod niezarządzany uprawnienie, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i.  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDir` funkcję, aby zmienić bieżącego katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> jest pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Instrukcje: Analizowanie ścieżek pliku w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Tworzenie, usuwanie i przenoszenie plików i katalogów w Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia bieżący dysk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagana. Wyrażenie ciągu, który określa istniejącego dysku. Jeśli podasz ciągiem o zerowej długości (""), nie zmienia bieżący dysk. Jeśli <paramref name="Drive" /> argument jest ciąg znaków wielu <see langword="ChDrive" /> używa pierwszą literę.</param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga, aby kod niezarządzany uprawnienie, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDrive` funkcję, aby zmienić bieżący dysk. Funkcja zgłasza wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagana. Wyrażenie ciągu, który określa istniejącego dysku. Jeśli podasz ciągiem o zerowej długości (""), nie zmienia bieżący dysk. Jeśli <paramref name="Drive" /> argument jest ciąg znaków wielu <see langword="ChDrive" /> używa pierwszą literę.</param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga, aby kod niezarządzany uprawnienie, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDrive` funkcję, aby zmienić bieżący dysk. Funkcja zgłasza wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącą ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `CurDir` funkcja zwraca bieżącą ścieżkę.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Opcjonalna. <see langword="Char" /> wyrażenie określające istniejącego dysku. Jeśli dysk nie zostanie określony, lub jeśli <paramref name="Drive" /> jest ciągiem o zerowej długości (""), <see langword="CurDir" /> zwraca ścieżkę dla bieżącego dysku.</param>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącą ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `CurDir` funkcja zwraca bieżącą ścieżkę.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Funkcja obsługuje korzystanie z wielu znaków (`*`) i pojedynczych znaków (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 `VbVolume` zwraca etykietę woluminu dysku, zamiast nazwy określonego pliku.  
  
 Należy podać `PathName` przy pierwszym wywołaniu `Dir` funkcji. Aby pobrać następny element, może wykonać kolejne wywołania `Dir` funkcję bez parametrów.  
  
> [!IMPORTANT]
>  By działała poprawnie, `Dir` funkcja wymaga, aby <xref:System.Security.Permissions.FileIOPermissionAccess.Read> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Wartości wyliczenia argumentów są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Domyślnie. Określa pliki bez atrybutów.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, a także pliki bez atrybutów.|  
|`Hidden`|`vbHidden`|Określa ukryte pliki i pliki bez atrybutów.|  
|`System`|`vbSystem`|Określa pliki systemowe i pliki bez atrybutów.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli inne atrybut jest określony, `vbVolume` jest ignorowana.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery i pliki bez atrybutów.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określone przez język Visual Basic i mogą być używane w dowolnym miejscu w kodzie zamiast wartości faktycznych.  
  
   
  
## Examples  
 W tym przykładzie użyto `Dir` funkcji w celu sprawdzenia, czy istnieją określone pliki i katalogi.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcjonalna. Wyrażenie ciągu, który określa nazwę pliku, nazwa katalogu lub folderu lub etykiety woluminu dysku. Ciąg o zerowej długości (<see langword="&quot;&quot;" />) jest zwracany, jeśli <paramref name="PathName" /> nie zostanie znaleziony.</param>
        <param name="Pathname">Opcjonalna. Wyrażenie ciągu, który określa nazwę pliku, nazwa katalogu lub folderu lub etykiety woluminu dysku. Ciąg o zerowej długości (<see langword="&quot;&quot;" />) jest zwracany, jeśli <paramref name="PathName" /> nie zostanie znaleziony.</param>
        <param name="Attributes">Opcjonalna. Wyrażenie wyliczenia lub liczbowe, którego wartość określa atrybuty pliku. W przypadku pominięcia <see langword="Dir" /> zwraca pliki dopasowane <paramref name="PathName" /> , ale nie uwzględniając atrybutów.</param>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Funkcja obsługuje korzystanie z wielu znaków (`*`) i pojedynczych znaków (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 `VbVolume` zwraca etykietę woluminu dysku, zamiast nazwy określonego pliku.  
  
 Należy podać `PathName` przy pierwszym wywołaniu `Dir` funkcji. Aby pobrać następny element, może wykonać kolejne wywołania `Dir` funkcję bez parametrów.  
  
> [!IMPORTANT]
>  By działała poprawnie, `Dir` funkcja wymaga, aby <xref:System.Security.Permissions.FileIOPermissionAccess.Read> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Wartości wyliczenia argumentów są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Domyślnie. Określa pliki, które nie uwzględniając atrybutów.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, oprócz plików, które nie uwzględniając atrybutów.|  
|`Hidden`|`vbHidden`|Określa pliki ukryte, oprócz plików, które nie uwzględniając atrybutów.|  
|`System`|`vbSystem`|Określa pliki systemowe, oprócz plików, które nie uwzględniając atrybutów.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli inne atrybut jest określony, `vbVolume` jest ignorowana.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery, oprócz plików, które nie uwzględniając atrybutów.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określone przez język Visual Basic i mogą być używane w dowolnym miejscu w kodzie zamiast wartości faktycznych.  
  
   
  
## Examples  
 W tym przykładzie użyto `Dir` funkcji w celu sprawdzenia, czy istnieją określone pliki i katalogi.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Zawierający Dowolna prawidłowa liczba plików.</param>
        <summary>Zwraca wartość typu Boolean <see langword="True" /> po otwarciu końca pliku dla <see langword="Random" /> lub kolejnych <see langword="Input" /> został osiągnięty.</summary>
        <returns>Wartość logiczna <see langword="True" /> po otwarciu końca pliku dla <see langword="Random" /> lub kolejnych <see langword="Input" /> został osiągnięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `EOF` w celu uniknięcia błędów generowanych podczas próby pobrania danych wejściowych poza końcem pliku.  
  
 `EOF` Funkcja zwraca `False` dopóki nie zostanie osiągnięty koniec pliku. W przypadku plików otwartych do `Random` lub `Binary` dostęp, `EOF` zwraca `False` dopóki ostatnio wykonana `FileGet` funkcji nie może odczytać całego rekordu.  
  
 W przypadku plików otwartych do `Binary` dostęp do próba odczytania pliku przy użyciu `Input` działać do momentu `EOF` zwraca `True` generuje błąd. Użyj `LOF` i `Loc` funkcji zamiast `EOF` podczas odczytywania plików binarnych z `Input`, lub użyj `Get` przy użyciu `EOF` funkcji. W przypadku plików otwartych do `Output`, `EOF` zawsze zwraca `True`.  
  
   
  
## Examples  
 W tym przykładzie użyto `EOF` funkcję, aby wykrywać koniec pliku. W tym przykładzie założono, że `Testfile` to plik tekstowy, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" />. Dowolna prawidłowa liczba plików.</param>
        <summary>Zwraca wyliczenie reprezentującą tryb otwierania plików za pomocą <see langword="FileOpen" /> funkcji. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="FileAttr" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Następujące wartości wyliczenia wskazują tryb dostępu do pliku: 
 <list type="table"><item><term> Wartość 
 </term><description> Tryb 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja zwraca wyliczenie reprezentującą tryb otwierania plików za pomocą `FileOpen` funkcji.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileAttr` funkcja zwraca tryb pliku otwartego pliku.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Opcjonalna. Tablica parametrów 0 lub więcej kanałów zostanie zamknięty.</param>
        <summary>Zawiera wejścia/wyjścia (We/Wy) do pliku, który został otwarty przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> zapewnia lepszą szybkość i wydajność operacji We/Wy na plikach. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [jak: Odczytywanie tekstu z plików za pomocą StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [jak: Zapisywanie tekstu do plików za pomocą StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), i [instruktażu: Manipulowanie plikami i katalogami w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Jeżeli pominięto `FileNumbers`, wszystkie aktywne pliki otwierane przez `FileOpen` funkcji są zamknięte.  
  
 Podczas zamykania plików, które zostały otwarte dla `Output` lub `Append`, końcowego bufor wyjściowy jest zapisywany w buforze systemu operacyjnego dla tego pliku. Wszystkie ilość miejsca w buforze skojarzone z zamkniętej zwolnienia pliku.  
  
 Gdy `FileClose` funkcja jest wykonywana, skojarzenia plików za pomocą jego pliku numer kończy się.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileClose` funkcję, aby zamknąć plik otwarty `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End — Instrukcja</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop — Instrukcja (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Wymagana. Wyrażenie ciągu, który określa nazwę pliku, który ma być skopiowany. <paramref name="Source" /> może to obejmować katalogu lub folderu i dysk z plikiem źródłowym.</param>
        <param name="Destination">Wymagana. Wyrażenie ciągu, który określa nazwę pliku docelowego. <paramref name="Destination" /> może to obejmować katalogu lub folderu i dysk pliku docelowego.</param>
        <summary>Kopiuje plik. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą szybkość i wydajność operacji We/Wy pliku niż <see langword="FileCopy" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz użyć `FileCopy` działać na aktualnie otwartego pliku, wystąpi błąd.  
  
 `FileCopy` wymaga pełnego zaufania do pracy na dysku lokalnym.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileCopy` funkcji do kopiowania plików do innego. Dla celów tego przykładu załóżmy, że `SrcFile` jest plikiem, który zawiera dane.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> lub <paramref name="Destination" /> jest nieprawidłowy lub nieokreślony.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Instrukcje: Tworzenie kopii pliku w innym katalogu w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Instrukcje: Tworzenie kopii pliku w tym samym katalogu w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Instrukcje: Kopiowanie katalogu do innego katalogu w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. Wyrażenie ciągu, który określa nazwę pliku. <paramref name="PathName" /> może to obejmować katalogu lub folderu i dysku.</param>
        <summary>Zwraca <see langword="Date" /> wartość, która wskazuje datę i godzinę, plik został zapisany. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileDateTime" />. Aby uzyskać więcej informacji zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns><see langword="Date" /> wartość, która wskazuje, daty i godziny pliku utworzenia lub ostatniej modyfikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `FileDateTime` funkcję, aby określić datę i godzinę plik został utworzony lub Data ostatniej modyfikacji. Format daty i godziny widocznej zależy od ustawień regionalnych systemu.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą`FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora. Rozmiar i granice tablicy przekazane do, a następnie `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji`FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą`FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <param name="StringIsFixedLength">Opcjonalna. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać deskryptor dwubajtowy, który ma być ciąg, który opisuje długości. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <param name="ArrayIsDynamic">Opcjonalna. Ma zastosowanie tylko wtedy, gdy pisania tablicy. Określa, czy tablica jest traktowane jako dynamiczne i czy konieczne jest deskryptora tablicy opisujących rozmiar i granice tablicy.</param>
        <param name="StringIsFixedLength">Opcjonalna. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać deskryptor dwubajtowy, który ma być ciąg, który opisuje długości. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest dopełniana istniejącą zawartość buforu pliku. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna wczytywana jest ciągiem `FileGet` odczytuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeżeli nie zastosowano deskryptora, rozmiar i granice tablicy przekazane do `FileGet` ustalić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów w przypadku deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów w przypadku danych: (5 * 10 * 4).  
  
-   Jeśli wczytywana zmienna wczytywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FileGet` odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych odczytywanych.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePut`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne z dysku w sposób ciągły; oznacza to bez dopełnienia między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Podczas odczytu z pliku za pomocą `FileGet` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej.  <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileGetObject" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject` Funkcja jest używana zamiast `FileGet` Aby uniknąć niejednoznaczności w czasie kompilacji, jeśli typ `Object` zwracany zamiast innego typu, takie jak `Integer`, `Long`, `Short`, i tak dalej.  
  
 Jeśli zamierzasz zapisać `Variant` typu `FileGetObject` jest wymagana. W razie wątpliwości, jeśli używasz obiektu jako drugi parametr, zawsze zaleca się używanie `FilePutObject` i `FileGetObject`.  
  
 `FileGetObject` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane odczytane z `FileGetObject` są zwykle zapisywane z `FilePutObject`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, `FileGetObject` odczytuje rekord lub bajt po ostatniej `FileGetObject` lub `FilePutObject` — funkcja (albo wskazywany przez ostatnią `Seek` funkcji).  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGetObject` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest dopełniana istniejącą zawartość buforu pliku. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to dobry pomysł, aby mieć długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Jeżeli zmienna wczytywana jest ciągiem, domyślnie `FileGetObject` odczytuje dwubajtowy deskryptor, zawierająca długość ciągu, a następnie odczytuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu. Visual Basic 6.0 i starsze wersje obsługują ciągi o stałej długości i podczas odczytu pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli wczytywana zmienna jest tablicą, długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: 2 + 8 * NumberOfDimensions.  
  
     Na przykład następująca deklaracja tablicy wymaga 218 bajtów, gdy tablica jest zapisywany na dysku:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób: 18 bajtów w przypadku deskryptora (2 + 8 * 2), a 100 bajtów danych (5 * 10 * 4).  
  
-   `FileGetObject` odczytuje elementy struktury tak, jakby każdy był odczytywany indywidualnie, z tą różnicą, że nie ma żadnych uzupełnień między elementami. Na dysku tablica dynamiczna w typ zdefiniowany przez użytkownika (napisany z uwzględnieniem `FilePutObject`) jest poprzedzana deskryptorem, którego długość jest równa 2 plus 8 razy liczba wymiarów: 2 + 8 * NumberOfDimensions. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania pojedynczych elementów, w tym wszystkie tablice i ich deskryptory. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasy mogą być stosowane do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` trybie wszystkie `Random` reguły mają zastosowanie, z uwzględnieniem poniższych wyjątków:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGetObject` odczytuje wszystkie zmienne z dysku w sposób ciągły, oznacza to, za pomocą żadnych uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FileGetObject` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
 `FileGetObject` odczytuje ciągi o zmiennej długości, które nie są elementami struktury, bez uwzględnienia deskryptora o długości dwóch bajtów. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład odczytuje rekordu w pliku testu i następnie pobiera go.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. Wyrażenie ciągu, który określa plik. <paramref name="PathName" /> może to obejmować katalogu lub folderu i dysku.</param>
        <summary>Zwraca wartość, która określa długość pliku w bajtach. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileLen" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Długość pliku w bajtach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony plik jest otwarty, kiedy `FileLen` funkcja jest wywoływana, wartość zwracana reprezentuje rozmiar pliku w czasie ostatniego otwarcia.  
  
> [!NOTE]
>  Aby uzyskać bieżącą długość otwartego pliku, użyj `LOF` funkcji.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileLen` funkcja zwraca długość pliku w bajtach. Dla celów tego przykładu załóżmy, że `TestFile` jest plik, który zawiera dane.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików. Użyj <see langword="FreeFile" /> funkcję, aby uzyskać najbliższej liczby plików.</param>
        <param name="FileName">Wymagana. Wyrażenie ciągu, który określa nazwę pliku - może zawierać katalogu lub folderu i dysku.</param>
        <param name="Mode">Wymagana. Wyliczenie opisujące tryb pliku: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, lub <see langword="Random" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Opcjonalna. Wyliczenie opisujące operacje dozwolona dla otwartego pliku: <see langword="Read" />, <see langword="Write" />, lub <see langword="ReadWrite" />. Wartość domyślna to <see langword="ReadWrite" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Opcjonalna. Wyliczenie opisujące operacje jest niedozwolony otwartego pliku przez inne procesy: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, i <see langword="Lock Read Write" />. Wartość domyślna to <see langword="Lock Read Write" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Opcjonalna. Liczbę mniejszą lub równą 32 767 znaków (w bajtach). Dla plików otwartych do dostępu losowego ta wartość jest długość rekordu. Dla kolejnych plików ta wartość jest liczbą znaków buforowane.</param>
        <summary>Otwiera plik dla danych wejściowych lub wyjściowych. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileOpen" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Przed wykonaniem wszelkich operacji We/Wy na nim, należy otworzyć plik. `FileOpen` przydziela bufor dla operacji We/Wy do pliku i określa tryb dostępu do używania z buforu.  
  
> [!IMPORTANT]
>  Podczas zapisywania do pliku, aplikacja może być konieczne utworzenie pliku, jeśli plik, który próbuje zapisać nie istnieje. Aby to zrobić, musi ona uprawnienia dla katalogu, w którym ma zostać utworzony plik. Jednakże jeżeli plik określony przez `FileName` istnieje w zakresie aplikacji `Write` uprawnienia tylko do sam plik. Wszędzie tam, gdzie to możliwe, aby pomóc zwiększyć bezpieczeństwo, tworzyć plik podczas wdrożenia i przyznać `Write` uprawnienie do tego pliku tylko, a nie do całego katalogu. Aby zwiększyć bezpieczeństwo, zapisywać dane do katalogów użytkownika zamiast do katalogu głównego lub katalogu Program Files.  
  
 Kanał, aby otworzyć znajduje się za pomocą `FreeFile()` funkcji.  
  
> [!IMPORTANT]
>  `FileOpen` Funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 Ten przykład ilustruje różne przypadki użycia `FileOpen` funkcję, aby włączyć dane wejściowe i wyjściowe do pliku.  
  
 Poniższy kod zostanie otwarty plik `TestFile` w `Input` trybu.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 W tym przykładzie otwiera plik w `Binary` tryb tylko operacje zapisu.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 W poniższym przykładzie otwierany plik w `Random` trybu. Ten plik zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Ten przykład kodu otwiera plik w `Output` tryb; wszelkie może procesu Odczyt lub zapis do pliku.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Ten przykład kodu otwiera plik w `Binary` trybie do odczytu; inne procesy nie można odczytać pliku.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość rekordu jest ujemna (i nie jest równa -1).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> jest jeszcze otwarty, lub <paramref name="FileName" /> jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. F, aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący`VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w`RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <param name="StringIsFixedLength">Opcjonalna. Stosuje się tylko przy pisaniu ciągów. Określa, czy chcesz zapisać ciąg dwubajtowy deskryptor długości ciągu do pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <param name="ArrayIsDynamic">Opcjonalna. Ma zastosowanie tylko wtedy, gdy pisania tablicy. Określa, czy tablica jest traktowane jako dynamiczne i czy należy napisać deskryptor ciąg, który opisuje długość tablicy.</param>
        <param name="StringIsFixedLength">Opcjonalna. Stosuje się tylko przy pisaniu ciągów. Określa, czy chcesz zapisać ciąg dwubajtowy deskryptor długości ciągu do pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePut` są zazwyczaj odczytywane z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, następny rekord lub bajt po ostatniej `FileGet` lub `FilePut` albo wskazany przez ostatnią `Seek` funkcja została napisana.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePut` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, należy wykonać takie same, z `FileGet`, musisz się upewnić, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane wprowadzane do zmiennej. W związku z tym, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej długości ciągu.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePut` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana stanowi inny typ zmiennej (nie ciąg znaków o zmiennej długości czy obiekt), `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości danych zapisanych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każdy był zapisywany indywidualnie, z wyjątkiem nie ma żadnych uzupełnień między elementami. `VBFixedString` Atrybut można stosować do pól ciągu w strukturach, aby wskazywać wielkość ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągu, które posiadają większą liczbę bajtów, niż określa `VBFixedString` atrybutu są obcinane w trakcie zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` tryb, większość `Random` zastosować zasady dotyczące trybu, z pewnymi wyjątkami. Następujące reguły dotyczące plików otwarty w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
-   Dla tablicy innej niż tablica w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągi o zmiennej długości, które nie są elementami struktury, bez deskryptora o długości dwóch bajtów. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapisywanie do pliku za pomocą `FilePut` funkcja wymaga, aby `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcję, aby zapisywać dane w pliku. Pięć rekordów struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu) gdzie rozpoczyna się zapisywanie.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku.  <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FilePutObject" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` Funkcja jest używana zamiast `FilePut` Aby uniknąć niejednoznaczności w czasie kompilacji, jeśli typ `Object` jest przekazywany zamiast innego typu, takie jak `Integer`, `Long`, `Short`, i tak dalej.  
  
 `FilePutObject` zapisuje i odczytuje deskryptory, które opisują obiektu. Jeśli zamierzasz zapisać `Variant` typu `FilePutObject` jest wymagana. W razie wątpliwości, jeśli używasz obiektu jako drugi parametr, firma Microsoft zaleca, aby zawsze używać `FilePutObject` i `FileGetObject`.  
  
 `FilePutObject` jest prawidłowy tylko w `Random` i `Binary` trybu.  
  
 Dane zapisane z `FilePutObject` są zazwyczaj odczytywane z pliku za pomocą `FileGetObject`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeżeli pominięto `RecordNumber`, `FilePutObject` zapisuje następny rekord lub bajt po ostatniej `FileGetObject` lub `FilePutObject` — funkcja (lub rekord lub bajt wskazywany przez ostatnią `Seek` funkcji).  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmiennej czy stałej długości. `FilePutObject` nie wpisuje deskryptora długości, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePutObject`, należy wykonać takie same, z `FileGetObject`, i należy również upewnić się, że ciąg został zainicjowany do oczekiwanej długości.  
  
## <a name="random-mode"></a>Tryb losowy  
 Do plików otwieranych w `Random` tryb, są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePutObject` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest mieć długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zgłaszany jest wyjątek.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera typ liczbowy `FilePutObject` zapisuje dwa bajty identyfikujące `VarType` obiektu, a następnie zapisuje zmienną. Na przykład podczas zapisywania obiektu zawierającego liczbę całkowitą z zakresu `FilePutObject` zapisuje sześć bajtów: dwa bajty, które identyfikują obiekt jako `VarType(3)` (`Integer`) i cztery bajty, które zawierają dane. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej dwa bajty większa od rzeczywistej liczby bajtów potrzebnych do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana stanowi obiekt, który zawiera ciąg, `FilePutObject` zapisuje deskryptor dwubajtowy identyfikujący `VarType(8)` obiektu, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametru w `FileOpen` funkcja musi być co najmniej cztery bajty większa od rzeczywistej długości ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru, a wczytywany ciąg powinien mieć odpowiednią długość.  
  
-   Jeśli zmienna zapisywana jest tablica, długość rekordu określana przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych i deskryptora tablicy. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Tryb binarny  
 Do plików otwieranych w `Binary` trybie wszystkie `Random` zastosować zasady dotyczące trybu, z wyjątkiem:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePutObject` zapisuje wszystkie zmienne na dysku w sposób ciągły, to znaczy bez uzupełnień między rekordami.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePutObject` funkcję, aby zapisać ciąg do pliku.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="RecordWidth">Wymagana. Wyrażenie liczbowe w zakresie 0-255 włącznie, co oznacza liczbę znaków, są wyświetlane w wierszu, przed rozpoczęciem nowego wiersza. Jeśli <paramref name="RecordWidth" /> jest równa 0, nie ma żadnego limitu długości wiersza. Wartością domyślną dla <paramref name="RecordWidth" /> wynosi 0.</param>
        <summary>Przypisuje szerokość linii danych wyjściowych w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `FileWidth` funkcję, aby ustawić szerokość linii danych wyjściowych dla pliku.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="Integer" /> wartość reprezentująca następny dostępny do użytku przez numer pliku <see langword="FileOpen" /> funkcji.</summary>
        <returns>Wartość całkowitą, która reprezentuje następny dostępny do użytku przez numer pliku <see langword="FileOpen" /> funkcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `FreeFile` podawać numer pliku, który nie jest już używana.  
  
   
  
## Examples  
 W tym przykładzie użyto `FreeFile` funkcja zwraca następny dostępny numer pliku. Pięć plików są otwarte dla danych wyjściowych w ramach pętli i przykładowe dane są zapisywane do każdego.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Więcej niż 255 pliki są używane.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. Wyrażenie ciągu, który określa nazwę pliku, katalogu lub folderu. <paramref name="PathName" /> może zawierać katalogu lub folderu i dysku.</param>
        <summary>Zwraca <see langword="FileAttribute" /> wartość, która reprezentuje atrybuty pliku, katalogu lub folderu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="FileAttribute" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Wartość zwrócona przez obiekt <see langword="GetAttr" /> jest sumą wartości wyliczenia następujące: 
 <list type="table"><item><term> Wartość 
 </term><description> Stała 
 </description><description> Opis 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normalny.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Tylko do odczytu.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Ukryte.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System plików.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Katalogu lub folderu.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Plik ma inną nazwę.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Te wyliczenia są określane za pomocą języka Visual Basic. Nazwy mogą być używane w dowolnym miejscu w kodzie zamiast wartości faktycznych.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, które atrybuty są ustawione, użyj `And` operatora bitowego porównania wartości zwracanej przez `GetAttr` funkcji i wartość wybranego atrybutu pliku chcesz. Jeśli wynik nie wynosi zero, ten atrybut jest ustawiony dla wskazanego pliku. Na przykład, wartość zwracana przez następujące `And` wyrażenie jest zero, jeśli `Archive` nie ustawiono atrybutu:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Wartość różną od zera jest zwracany, jeśli `Archive` ma ustawioną wartość atrybutu.  
  
   
  
## Examples  
 W tym przykładzie użyto `GetAttr` funkcję, aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And — Operator (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w niemieckiej wersji, gdy wejściowe 3,14159, zwraca tylko 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmiennej, którą przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane w pliku przy użyciu `Write`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest obiektem oznaczanym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `Input` funkcja wymaga, aby `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji w celu odczytania danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` to plik zawierający kilka wierszy danych zapisanych przy użyciu `Write` funkcji, każdy wiersz zawiera ciąg w cudzysłowach i liczbę, oddzielone przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="CharCount">Wymagana. Dowolne prawidłowe wyrażenie liczbowe określającą liczbę znaków do odczytania.</param>
        <summary>Zwraca <see langword="String" /> wartość, która zawiera znaki z pliku otwarte w <see langword="Input" /> lub <see langword="Binary" /> trybu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="InputString" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Ciąg, który zawiera znaki z pliku otwarte w <see langword="Input" /> lub <see langword="Binary" /> trybu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `InputString` funkcji są zwykle zapisywane w pliku przy użyciu `Print` lub `FilePut`. Funkcja ta jest widoczny tylko w przypadku plików otwartych w `Input` lub `Binary` trybu.  
  
 W odróżnieniu od `Input` funkcji `InputString` funkcja zwraca wszystkie znaki, zostanie odczytanych. W tym przecinki, znaki powrotu karetki, wysuwu wiersza, znaki cudzysłowu i spacje.  
  
 W przypadku plików otwartych do `Binary` dostęp do próba odczytania pliku przy użyciu `InputString` działać do momentu `EOF` zwraca `True` generuje błąd. Użyj `LOF` i `Loc` funkcji zamiast `EOF` podczas odczytu plików binarnych za pomocą `InputString`, lub użyj `FileGet` zastosowania `EOF` — funkcja.  
  
> [!NOTE]
>  Podczas odczytu z plików, nie należy wprowadzać zabezpieczeń decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
   
  
## Examples  
 W tym przykładzie użyto `InputString` funkcję, aby przeczytać o jeden znak w czasie z pliku i wydrukuj go do `Output` okna. W tym przykładzie założono, że `MyFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> nie istnieje.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" /> &lt; 0 lub &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. Wyrażenie ciągu, który określa jedną lub więcej nazw plików do usunięcia. <paramref name="PathName" /> może zawierać katalogu lub folderu i dysku.</param>
        <summary>Usuwa pliki z dysku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Kill" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` obsługuje korzystanie z wielu znaków (`*`) i pojedynczych znaków (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 **Uwaga dotycząca zabezpieczeń** w celu wykonania `Kill` funkcja wymaga, aby `Read` i `PathDiscovery` flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.SecurityException> [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 W tym przykładzie użyto `Kill` funkcję, aby usunąć plik z dysku.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Otwieranie plików docelowych.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć plików docelowych.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <summary>Odczytuje pojedynczy wiersz z otwartego pliku sekwencyjnego i przypisuje go do <see langword="String" /> zmiennej.</summary>
        <returns>Odczytuje pojedynczy wiersz z otwartego pliku sekwencyjnego i przypisuje go do <see langword="String" /> zmiennej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `LineInput` są zwykle zapisywane w pliku przy użyciu `Print`.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
 `LineInput` Funkcja odczytuje z pliku o jeden znak w danym momencie, aż do napotkania znaku powrotu karetki (`Chr(13)`) lub zwrotu/wiersz źródła danych (`Chr(13) + Chr(10)`) sekwencji. Sekwencje kanału informacyjnego powrotu/wiersza powrotu karetki są pomijane zamiast dołączany do ciągu znaków.  
  
> [!IMPORTANT]
>  Podczas odczytu z pliku za pomocą `LineInput` funkcja wymaga, aby `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `LineInput` funkcję, aby odczytać wiersz z pliku sekwencyjnego i przypisać ją do zmiennej. W tym przykładzie założono, że `TestFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Osiągnięto koniec pliku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolne, prawidłowe <see langword="Integer" /> pliku numer.</param>
        <summary>Zwraca wartość określającą bieżącą pozycję odczytu/zapisu w otwartego pliku.</summary>
        <returns>Bieżąca pozycja odczytu/zapisu w otwartego pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Funkcji jest liczony od zera; korzystania z niego pobrać pierwszy bajt w pliku zwróci wartość 0.  
  
 `Loc` Funkcja zapewnia zgodność z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Poniżej opisano wartość zwracana przez każdy tryb dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Numer ostatniego rekordu odczytywany lub zapisywany do pliku.|  
|`Sequential`|Bieżące położenie bajtów w pliku podzielona przez 128. Jednak informacje zwrócone przez `Loc` dla kolejnych plików nie jest używany ani wymagane.|  
|`Binary`|Położenie ostatniego bajtu zapisu lub odczytu.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Loc` funkcja zwraca bieżącą pozycję odczytu/zapisu w otwartego pliku. W tym przykładzie założono, że `MyFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalna. Liczba tylko rekord lub bajt, aby zablokować lub odblokować.</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalna. Liczba pierwszy rekord lub bajt, aby zablokować lub odblokować.</param>
        <param name="ToRecord">Opcjonalna. Liczba ostatnich rekord lub bajt, aby zablokować lub odblokować.</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Liczba całkowita, która zawiera numer prawidłowego pliku.</param>
        <summary>Zwraca rozmiar w bajtach, w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="LOF" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Rozmiar w bajtach, w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `FileLen` funkcję, aby uzyskać długość pliku, który nie jest otwarty.  
  
   
  
## Examples  
 W tym przykładzie użyto `LOF` funkcję, aby określić rozmiar otwartego pliku. W tym przykładzie założono, że `TestFile` to plik tekstowy, który zawiera przykładowe dane.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagana. Wyrażenie ciągu, identyfikująca katalogu, który ma zostać utworzony. <paramref name="Path" /> Mogą obejmować dysku. Jeśli dysk nie zostanie określony, <see langword="MkDir" /> powoduje utworzenie nowego katalogu na bieżącym dysku.</param>
        <summary>Tworzy nowy katalog. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="MkDir" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja tworzy nowy katalog.  
  
   
  
## Examples  
 W tym przykładzie użyto `MkDir` funkcję, aby utworzyć katalog. Jeśli dysk nie zostanie określony, nowy katalog jest tworzony na bieżącym dysku.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> nie jest określona lub jest pusty.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Katalog już istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Instrukcje: Utwórz katalog w języku Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalna. Zero lub więcej rozdzielonych przecinkami wyrażenia, aby zapisać do pliku.  
  
<paramref name="Output" /> Ustawienia argumentu są: 
 <see langword="T:System.IO.IOException" />: Tryb pliku jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> nie istnieje.</param>
        <summary>Zapisy wyświetlania danych w formacie pliku sekwencyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` i `PrintLine` funkcje są zapewniane dla zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` nie ma wiersz na końcu wiersza; jednak `PrintLine` Dołącz wiersz źródła danych.  
  
 Dane zapisane z `Print` są zazwyczaj odczytywane z pliku za pomocą `LineInput` lub `Input`.  
  
 Jeżeli pominięto `Output` dla `PrintLine`, pusty wiersz zostanie wydrukowany do pliku; w przypadku `Print`, nic nie danych wyjściowych. Wiele wyrażeń oddzielone przecinkami mają zostać wyrównane na granicach kartę, ale mieszanie przecinkami i `TAB` może spowodować niespójne wyniki.  
  
 Aby uzyskać `Boolean` danych, albo `True` lub `False` zostanie wydrukowany. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
 Dane są zapisywane do pliku przy użyciu formatu daty krótkiej standardowa rozpoznany przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Jeśli nic nie jest zapisywane w pliku `Output` danych jest pusta. Jednak jeśli `Output` dane listy `DBNull`, `Null` są zapisywane do pliku.  
  
 Aby uzyskać `Error` dane wyjściowe są wyświetlane jako `Error errorcode`. `Error` — Słowo kluczowe nie jest tłumaczony niezależnie od ustawień regionalnych.  
  
 Wszystkie dane zapisane do pliku za pomocą `Print` uwzględnia ustawienia regionalne; oznacza to, dane są poprawnie sformatowane przy użyciu odpowiednich separatora dziesiętnego. Jeśli użytkownik chce do wysyłania danych do użycia przez wielu ustawień regionalnych, `Write` powinny być używane.  
  
 Zapisywanie do pliku za pomocą `Print` lub `PrintLine` functions wymaga `Write` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Print` i `PrintLine` funkcje można zapisać danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalna. Zero lub więcej rozdzielonych przecinkami wyrażenia, aby zapisać do pliku.  
  
<paramref name="Output" /> Ustawienia argumentu są: 
 <see langword="T:System.IO.IOException" />: Tryb pliku jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> nie istnieje.</param>
        <summary>Zapisy wyświetlania danych w formacie pliku sekwencyjnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` i `PrintLine` funkcje są zapewniane dla zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` nie ma wiersz na końcu wiersza; jednak`PrintLine` Dołącz wiersz źródła danych.  
  
 Dane zapisane z `Print` są zazwyczaj odczytywane z pliku za pomocą `LineInput` lub `Input`.  
  
 Jeżeli pominięto `Output` dla `PrintLine`, pusty wiersz zostanie wydrukowany do pliku; w przypadku `Print`, nic nie danych wyjściowych. Wiele wyrażeń oddzielone przecinkami mają zostać wyrównane na granicach kartę, ale mieszanie przecinkami i `TAB` może spowodować niespójne wyniki.  
  
 Aby uzyskać `Boolean` danych, albo `True` lub `False` zostanie wydrukowany. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
 Dane są zapisywane do pliku przy użyciu formatu daty krótkiej standardowa rozpoznawane przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Jeśli nic nie jest zapisywane w pliku `Output` danych jest pusta. Jednak jeśli `Output` dane listy `DBNull`, `Null` są zapisywane do pliku.  
  
 Aby uzyskać `Error` dane wyjściowe są wyświetlane jako `Error errorcode`. `Error` — Słowo kluczowe nie jest tłumaczony niezależnie od ustawień regionalnych.  
  
 Wszystkie dane zapisane do pliku za pomocą `Print` uwzględnia ustawienia regionalne; oznacza to, dane są poprawnie sformatowane przy użyciu odpowiednich separatora dziesiętnego. Jeśli użytkownik chce do wysyłania danych do użycia przez wielu ustawień regionalnych, `Write` powinny być używane.  
  
 Zapisywanie do pliku za pomocą `Print` lub `PrintLine` functions wymaga `Write` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Print` i `PrintLine` funkcje można zapisać danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Wymagana. Wyrażenie ciągu, które określa istniejącej nazwy pliku i lokalizację. <paramref name="OldPath" /> może to obejmować katalogu i dysku w pliku.</param>
        <param name="NewPath">Wymagana. Wyrażenie ciągu, który określa nową nazwę pliku i lokalizację. <paramref name="NewPath" /> może zawierać katalogu i dysk w lokalizacji docelowej. Nazwa pliku określona przez <paramref name="NewPath" /> już nie istnieje.</param>
        <summary>Zmienia nazwę pliku lub katalogu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Rename" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Funkcji zmieniania nazwy pliku i przenosi je do innego katalogu, jeśli jest to wymagane. `Rename` Funkcji można przenieść plik na dyskach, ale tylko wtedy można zmienić nazwę istniejącego katalogu podczas zarówno `NewPath` i `OldPath` znajdują się na tym samym dysku. `Rename` Nie można utworzyć nowego pliku lub katalogu.  
  
 Za pomocą `Rename` generuje błąd, funkcję dla otwartego pliku. Otwórz plik należy zamknąć przed zmianą nazwy. `Rename` argumenty nie może zawierać wielu znaków (*) i symboli wieloznacznych pojedynczych znaków (?).  
  
> [!IMPORTANT]
>  Korzystając z `Rename` do skopiowania pliku niechronionych lokalizacji do chronionej lokalizacji, plik zachowuje mniej ograniczone uprawnienia. Sprawdź, czy nie są Przedstawiamy zagrożenie bezpieczeństwa.  
  
   
  
## Examples  
 W tym przykładzie użyto `Rename` funkcję, aby zmienić nazwę pliku. Do celów tego przykładu założono, że katalogi, które są określone w już istnieje.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="OldPath" /> Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Nie można zmienić nazwy do innego urządzenia.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Instrukcje: Zmień nazwę pliku w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie dysku pliki otwierane przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Reset" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` Funkcji spowoduje zamknięcie wszystkich aktywnych plików otwartych przez `FileOpen` działa i ma taką samą funkcję jak `FileClose()` bez żadnych parametrów.  
  
   
  
## Examples  
 W tym przykładzie użyto `Reset` funkcję, aby zamknąć wszystkie otwarte pliki i zapisać zawartość wszystkie bufory plików na dysku. Zwróć uwagę na użycie `Object` zmiennej `FileNumber` zarówno jako ciąg i numeru.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End — Instrukcja</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagana. Wyrażenie ciągu, identyfikująca katalogu lub folderu, do usunięcia. <paramref name="Path" /> można dołączyć dysku. Jeśli dysk nie zostanie określony, <see langword="RmDir" /> powoduje usunięcie katalogu na bieżącym dysku.</param>
        <summary>Usuwa istniejącego katalogu. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="RmDir" />. Aby uzyskać więcej informacji, zobacz <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd występuje, Jeśli spróbujesz użyć `RmDir` w katalogu, który zawiera pliki. Użyj `Kill` funkcję, aby usunąć wszystkie pliki, zanim spróbujesz usunąć katalog.  
  
   
  
## Examples  
 W tym przykładzie użyto `RmDir` funkcję, aby usunąć istniejący katalog.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> nie jest określona lub jest pusty.</exception>
        <exception cref="T:System.IO.IOException">Katalog docelowy zawiera pliki.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Zawierający prawidłowa liczba plików.</param>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>A <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Zwraca wartość z zakresu od 1 do 2 147 483 647 (równoważne do 2 ^ 31 - 1) (włącznie).  
  
 Poniżej przedstawiono wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Liczbę odczytywanych lub zapisywanych następnego rekordu|  
|`Binary`, `Input`, `Output`, `Append`|Pozycja bajt, w którym występuje następnej operacji. Pierwszy bajt w pliku znajduje się na pozycji 1, drugi bajt na pozycji 2 i tak dalej.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Seek` funkcja zwraca bieżącą pozycję w pliku. W przykładzie założono `TestFile` to plik zawierający rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Do plików otwieranych w `Random` trybie `Seek` zwraca liczbę następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` zwraca pozycję bajt, w którym występuje następnej operacji. Załóżmy `TestFile` jest plikiem zawierającym kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 W tym przykładzie użyto `Seek` funkcję, aby ustawić położenie do następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` Ustawia położenie bajt, w którym występuje następnej operacji. Załóżmy `TestFile` jest plikiem zawierającym kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Zawierający prawidłowa liczba plików.</param>
        <param name="Position">Wymagana. Jeśli wystąpią liczbą z zakresu 1-2 147 483 647, włącznie, która wskazuje, gdzie następnego odczyt/zapis operacji.</param>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Zwraca wartość z zakresu od 1 do 2 147 483 647 (równoważne do 2 ^ 31 - 1) (włącznie).  
  
 Poniżej przedstawiono wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Liczbę odczytywanych lub zapisywanych następnego rekordu|  
|`Binary`, `Input`, `Output`, `Append`|Pozycja bajt, w którym występuje następnej operacji. Pierwszy bajt w pliku znajduje się na pozycji 1, drugi bajt na pozycji 2 i tak dalej.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Seek` funkcja zwraca bieżącą pozycję w pliku. W przykładzie założono `TestFile` to plik zawierający rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Do plików otwieranych w `Random` trybie `Seek` zwraca liczbę następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` zwraca pozycję bajt, w którym występuje następnej operacji. Załóżmy `TestFile` jest plikiem zawierającym kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 W tym przykładzie użyto `Seek` funkcję, aby ustawić położenie do następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` Ustawia położenie bajt, w którym występuje następnej operacji. Załóżmy `TestFile` jest plikiem zawierającym kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. Wyrażenie ciągu, który określa nazwę pliku. <paramref name="PathName" /> może zawierać katalogu lub folderu i dysku.</param>
        <param name="Attributes">Wymagana. Wyrażenie stałe i liczbowego, w których suma określa atrybuty pliku.</param>
        <summary>Ustawia atrybut informacji dla pliku. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="SetAttr" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd czasu wykonywania występuje, Jeśli spróbujesz ustawić atrybuty otwartego pliku.  
  
 `Attributes` Wartości wyliczenia argumentów są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbNormal`|Normalny (domyślnie).|  
|`ReadOnly`|`vbReadOnly`|Tylko do odczytu.|  
|`Hidden`|`vbHidden`|Ukryte.|  
|`System`|`vbSystem`|System plików.|  
|`Volume`|`vbVolume`|Etykieta woluminu|  
|`Directory`|`vbDirectory`|Katalogu lub folderu.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane za pomocą języka Visual Basic. Nazwy mogą być używane w dowolnym miejscu w kodzie zamiast wartości faktycznych.  
  
   
  
## Examples  
 W tym przykładzie użyto `SetAttr` funkcję, aby ustawić atrybutów pliku.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" /> Typ jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Wymagana. Liczba miejsc do magazynowania, aby wstawić przed wyświetleniem lub drukowanie następnego wyrażenia na liście.</param>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcji do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcji do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Count` jest mniejsza niż szerokość linii danych wyjściowych, natychmiast następną pozycję wydruku następuje liczba wydrukowanych spacji. Jeśli`Count` jest większa niż szerokość linii danych wyjściowych, `SPC` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Na przykład, jeśli bieżącej pozycji drukowania jest 24, szerokość linii danych wyjściowych to 80 i określeniu `SPC(90)`, drukowania dalej rozpocznie się od pozycji 34 (bieżącej pozycji drukowania + pozostałą część 90/80). Jeśli różnica między bieżącą pozycję wydruku i szerokości linii danych wyjściowych jest mniejsza niż `Count` (lub `Count` `Mod` *szerokość*), `SPC` funkcji nakłada się na początku następnego wiersza i generuje miejsca do magazynowania jest równa `Count` -(*szerokość* - *bieżąca_pozycja_wydruku*).  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są dostatecznie szeroka umożliwić szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie użyto `SPC` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większy niż `Column`, `TAB` przejdzie do wartości kolumny równej `Column` w następnym wierszu danych wyjściowych. Jeśli `Column` jest mniejszy niż 1 `TAB` Przenosi pozycję wydruku do kolumny 1. Jeśli `Column` jest większa niż szerokość linii danych wyjściowych, `TAB` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 Mod szerokość kolumny  
  
 Na przykład jeśli *szerokość* to 80 i określeniu `TAB(90)`, drukowania dalej rozpocznie się w kolumnie 10 (reszta 90/80). Jeśli `Column` jest mniejsza od bieżącej pozycji drukowania drukowania rozpoczyna się w następnym wierszu na obliczonej pozycji drukowania. Jeśli obliczonej pozycji drukowania jest większy niż bieżąca pozycja drukowania, drukowanie rozpoczyna się na obliczony wydrukować pozycji w tym samym wierszu.  
  
 Skrajnie po lewej stronie pozycji drukowania w wierszu danych wyjściowych ma zawsze numer 1. Kiedy używasz `Print` lub `PrintLine` funkcji Drukowanie do plików, po prawej stronie pozycji drukowania jest szerokość bieżącego pliku wyjściowego, który można ustawić za pomocą `FileWidth` funkcji.  
  
 `TAB` Funkcji można używać z `WriteLine` funkcji. Nie można używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są dostatecznie szeroka, aby zawierać litery szerokości.  
  
   
  
## Examples  
 W tym przykładzie użyto `TAB` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Opcjonalna. Numer kolumny, przenieść przed wyświetleniem lub drukowanie następnego wyrażenia na liście. W przypadku pominięcia <see langword="TAB" /> przenosi punkt wstawiania do początku następnego strefy drukowania.</param>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większa niż `Column`, `TAB` przejdzie do wartości kolumny równej `Column` w następnym wierszu danych wyjściowych. Jeśli `Column` jest mniejszy niż 1 `TAB` Przenosi pozycję wydruku do kolumny 1. Jeśli `Column` jest większa niż szerokość linii danych wyjściowych, `TAB` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 Mod szerokość kolumny  
  
 Na przykład jeśli *szerokość* to 80 i określeniu `TAB(90)`, drukowania dalej rozpocznie się w kolumnie 10 (reszta 90/80). Jeśli `Column` jest mniejsza od bieżącej pozycji drukowania drukowania rozpoczyna się w następnym wierszu na obliczonej pozycji drukowania. Jeśli obliczonej pozycji drukowania jest większa od bieżącej pozycji drukowania, drukowanie rozpoczyna się na obliczony wydrukować pozycji w tym samym wierszu.  
  
 Skrajnie po lewej stronie pozycji drukowania w wierszu danych wyjściowych ma zawsze numer 1. Kiedy używasz `Print` lub `PrintLine` funkcji Drukowanie do plików, po prawej stronie pozycji drukowania jest szerokość bieżącego pliku wyjściowego, który można ustawić za pomocą `FileWidth` funkcji.  
  
 `TAB` Funkcji można używać z `WriteLine` funkcji. Nie można używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są dostatecznie szeroka, aby zawierać litery szerokości.  
  
   
  
## Examples  
 W tym przykładzie użyto `TAB` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalna. Liczba tylko rekord lub bajt do zablokowania lub odblokowania</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalna. Liczba pierwszy rekord lub bajt, aby zablokować lub odblokować.</param>
        <param name="ToRecord">Opcjonalna. Liczba ostatnich rekord lub bajt, aby zablokować lub odblokować.</param>
        <summary>Służy do sterowania dostępem innych procesów do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą szybkość i wydajność w operacjach we/wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w których kilka procesów wymaga dostępu do tego samego pliku.  
  
 `Lock` i `Unlock` funkcje są zawsze używane w parach. Argumenty `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostanie podany, blokada obejmie cały plik. Jeśli `Record` samodzielnie zostanie określony pojedynczy rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` dotyczą całego pliku, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` to plik zawierający rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Wyrażenia zawierającego Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalna. Co najmniej jednego rozdzielonych przecinkami wyrażenia można zapisać do pliku.</param>
        <summary>Zapisuje dane do pliku sekwencyjnego. Dane zapisane z <see langword="Write" /> są zazwyczaj odczytywane z pliku za pomocą <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` i `WriteLine` funkcje są zapewniane dla zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Jeżeli pominięto `Output`, wydrukowaniu pusty wiersz do pliku. Wiele wyrażeń mogą być oddzielone przecinkami.  
  
 W odróżnieniu od `Print` funkcji `Write` funkcji wstawia przecinkami, między elementami i ciągi w cudzysłowie, ponieważ są one zapisywane do pliku. Nie trzeba umieścić jawne ograniczniki na liście. Gdy `Write` służy do zapisywania danych do pliku, tylko liczbowe, `Boolean`, Data, null, i `Error` formatów danych są obsługiwane. Następujące założenia uniwersalne są przestrzegane, dzięki czemu dane mogą zawsze odczytać i poprawnie interpretowany przy użyciu `Input`, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane używającego kropki jako separatora dziesiętnego.  
  
-   Aby uzyskać `Boolean` danych, albo `#TRUE#` lub `#FALSE#` zostanie wydrukowany. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
-   Dane daty są zapisywane do pliku przy użyciu formatu daty uniwersalnych. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Jeśli nic nie jest zapisywane w pliku `Output` danych jest pusta. Jednak w przypadku danych o wartości null `#NULL#` są zapisywane.  
  
-   Aby uzyskać `Error` dane wyjściowe są wyświetlane jako `#ERROR errorcode#`. `Error` — Słowo kluczowe nie są tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine` Wstawia znak nowego wiersza (czyli kanału informacyjnego powrotu karetki/wiersza lub `Chr(13) + Chr(10)`) po zapisane ostatni znak `Output` do pliku.  
  
 Możesz osadzić znaki cudzysłowu w ciągu za pomocą podwójnego cudzysłowu lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg zawierający wartość `Double quotation marks aren't "difficult" to handle`.  
  
 Zapisywanie do pliku za pomocą `Write` lub `WriteLine` functions wymaga `Append` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Write` funkcji do zapisu danych pierwotnych pliku sekwencyjnego.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Wyrażenia zawierającego Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalna. Co najmniej jednego rozdzielonych przecinkami wyrażenia można zapisać do pliku.</param>
        <summary>Zapisuje dane do pliku sekwencyjnego. Dane zapisane z <see langword="Write" /> są zazwyczaj odczytywane z pliku za pomocą <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` i `WriteLine` funkcje są zapewniane dla zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji innych niż ZASTANE `My.Computer.FileSystem` obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Jeżeli pominięto `Output`, wydrukowaniu pusty wiersz do pliku. Wiele wyrażeń mogą być oddzielone przecinkami.  
  
 W odróżnieniu od `Print` funkcji `Write` funkcji wstawia przecinkami, między elementami i ciągi w cudzysłowie, ponieważ są one zapisywane do pliku. Nie trzeba umieścić jawne ograniczniki na liście. Gdy `Write` służy do zapisywania danych do pliku, tylko liczbowe, `Boolean`, Data, null, i `Error` formatów danych są obsługiwane. Następujące założenia uniwersalne są przestrzegane, dzięki czemu dane mogą zawsze odczytać i poprawnie interpretowany przy użyciu `Input`, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane używającego kropki jako separatora dziesiętnego.  
  
-   Aby uzyskać `Boolean` danych, albo `#TRUE#` lub `#FALSE#` zostanie wydrukowany. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
-   Dane daty są zapisywane do pliku przy użyciu formatu daty uniwersalnych. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Jeśli nic nie jest zapisywane w pliku `Output` danych jest pusta. Jednak w przypadku danych o wartości null `#NULL#` są zapisywane.  
  
-   Aby uzyskać `Error` dane wyjściowe są wyświetlane jako `#ERROR errorcode#`. `Error` — Słowo kluczowe nie są tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine` Wstawia znak nowego wiersza (czyli kanału informacyjnego powrotu karetki/wiersza lub `Chr(13) + Chr(10)`) po zapisane ostatni znak `Output` do pliku.  
  
 Możesz osadzić znaki cudzysłowu w ciągu za pomocą podwójnego cudzysłowu lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg zawierający wartość `Double quotation marks aren't "difficult" to handle`.  
  
 Zapisywanie do pliku za pomocą `Write` lub `WriteLine` functions wymaga `Append` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Write` funkcji do zapisu danych pierwotnych pliku sekwencyjnego.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisywanie tekstu do plików w języku Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisywanie tekstu do pliku za pomocą Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>
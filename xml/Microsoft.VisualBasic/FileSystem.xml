<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="588728944ca294baca2932f2aae0887dfd3ec4be" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30435042" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="FileSystem" /> Moduł zawiera procedury, które są używane do wykonywania operacji pliku, katalogu lub folderu i systemu. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż przy użyciu <see langword="FileSystem" /> modułu. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten moduł obsługuje słów kluczowych języka Visual Basic i elementy członkowskie biblioteki wykonawczej, które uzyskują dostęp do plików i folderów.  
  
   
  
## Examples  
 W tym przykładzie użyto `GetAttr` funkcji, aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagany. A <see langword="String" /> Wyrażenie identyfikujące które katalogu lub folderu staje się nowego domyślnego katalogu lub folderu. <c>Ścieżka</c> mogą obejmować dysku. Jeśli dysk nie zostanie wskazany, <see langword="ChDir" /> zmiany domyślnego katalogu lub folderu na bieżącym dysku.</param>
        <summary>Zmiany bieżącego katalogu lub folderu. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="ChDir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Funkcja zmiany domyślnego katalogu, ale nie domyślnym dysku. Na przykład, jeśli dysk domyślny jest C, następująca instrukcja zmiany domyślnego katalogu na dysku D, ale pozostanie na domyślnym dysku C:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Można ustawić względne zmiany katalogu jest przez wpisanie dwóch kropek w następujący sposób:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i.  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDir` funkcji, aby zmienić bieżącego katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> jest pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia bieżący dysk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagany. Wyrażenia ciągu, który określa istniejący dysk. Jeśli podasz ciąg o zerowej długości (""), nie powoduje zmiany bieżącego dysku. Jeśli <c>dysków</c> argument jest ciąg znaków wielu <see langword="ChDrive" /> używa pierwszą literę.</param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDrive` funkcji, aby zmienić bieżącego dysku. Funkcja zwraca wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagany. Wyrażenia ciągu, który określa istniejący dysk. Jeśli podasz ciąg o zerowej długości (""), nie powoduje zmiany bieżącego dysku. Jeśli <c>dysków</c> argument jest ciąg znaków wielu <see langword="ChDrive" /> używa pierwszą literę.</param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto `ChDrive` funkcji, aby zmienić bieżącego dysku. Funkcja zwraca wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `CurDir` funkcja zwracająca bieżącej ścieżki.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Opcjonalny. <see langword="Char" /> wyrażenie określające istniejący dysk. Jeśli dysk nie zostanie wskazany lub <c>dysku</c> jest ciągiem o zerowej długości (""), <see langword="CurDir" /> zwraca ścieżkę dla bieżącego dysku.</param>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="CurDir" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącej ścieżki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `CurDir` funkcja zwracająca bieżącej ścieżki.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Funkcja obsługuje korzystanie z wielu znaków (`*`) i jednego znaku (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 `VbVolume` zwraca etykietę woluminu dla dysku zamiast określoną nazwą pliku.  
  
 Należy podać `PathName` po raz pierwszy należy wywołać `Dir` funkcji. Aby pobrać następny element, należy wybrać kolejnych wywołań `Dir` funkcji bez parametrów.  
  
> [!IMPORTANT]
>  By działała poprawnie, `Dir` wymaga funkcji <xref:System.Security.Permissions.FileIOPermissionAccess.Read> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Argumentu wyliczenia wartości są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Domyślne. Określa pliki bez atrybutów.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, a także pliki bez atrybutów.|  
|`Hidden`|`vbHidden`|Określa ukryte pliki i pliki bez atrybutów.|  
|`System`|`vbSystem`|Określa pliki systemowe i pliki bez atrybutów.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli określono inny atrybut, `vbVolume` jest ignorowana.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery i pliki bez atrybutów.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic i mogą być używane w dowolne miejsce w kodzie, a nie rzeczywiste wartości.  
  
   
  
## Examples  
 W tym przykładzie użyto `Dir` funkcji w celu sprawdzenia, czy istnieją niektórych plików i katalogów.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcjonalny. <see langword="String" /> wyrażenie, które określa nazwę pliku, nazwy katalogu lub folderu lub etykiety woluminu dysku. Ciąg o zerowej długości (<see langword="&quot;&quot;" />) jest zwracany, jeśli <c>PathName</c> nie znaleziono.</param>
        <param name="Attributes">Opcjonalny. Określa atrybutów pliku, którego wartość wyrażenie wyliczenia lub liczbowe. Pominięcie <see langword="Dir" /> zwraca plików zgodnych ze <c>PathName</c> , ale żadne atrybuty nie miały.</param>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Dir" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dir` Funkcja obsługuje korzystanie z wielu znaków (`*`) i jednego znaku (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 `VbVolume` zwraca etykietę woluminu dla dysku zamiast określoną nazwą pliku.  
  
 Należy podać `PathName` po raz pierwszy należy wywołać `Dir` funkcji. Aby pobrać następny element, należy wybrać kolejnych wywołań `Dir` funkcji bez parametrów.  
  
> [!IMPORTANT]
>  By działała poprawnie, `Dir` wymaga funkcji <xref:System.Security.Permissions.FileIOPermissionAccess.Read> i <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 `Attributes` Argumentu wyliczenia wartości są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Domyślne. Określa pliki, które nie atrybuty nie miały.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, oprócz plików, które nie atrybuty nie miały.|  
|`Hidden`|`vbHidden`|Określa pliki ukryte, oprócz plików, które nie atrybuty nie miały.|  
|`System`|`vbSystem`|Określa pliki systemowe, oprócz plików, które nie atrybuty nie miały.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli określono inny atrybut, `vbVolume` jest ignorowana.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery, oprócz plików, które nie atrybuty nie miały.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic i mogą być używane w dowolne miejsce w kodzie zamiast wartości rzeczywistych.  
  
   
  
## Examples  
 W tym przykładzie użyto `Dir` funkcji w celu sprawdzenia, czy istnieją niektórych plików i katalogów.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawiera dowolną liczbę prawidłowy plik.</param>
        <summary>Zwraca wartość logiczną <see langword="True" /> otwarcia koniec pliku dla <see langword="Random" /> lub kolejnych <see langword="Input" /> został osiągnięty.</summary>
        <returns>Zwraca wartość logiczną <see langword="True" /> otwarcia koniec pliku dla <see langword="Random" /> lub kolejnych <see langword="Input" /> został osiągnięty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `EOF` w celu uniknięcia błędów generowanych podczas próby pobrania danych wejściowych poza końcem pliku.  
  
 `EOF` Funkcja zwraca `False` dopóki nie zostanie osiągnięty koniec pliku. W przypadku plików otwartych dla `Random` lub `Binary` dostępu, `EOF` zwraca `False` dopóki ostatnio wykonana `FileGet` funkcji nie może odczytać całego rekordu.  
  
 W przypadku plików otwartych dla `Binary` dostępu, próba odczytania pliku przy użyciu `Input` działać do czasu `EOF` zwraca `True` generuje błąd. Użyj `LOF` i `Loc` funkcje zamiast `EOF` podczas odczytywania plików binarnych z `Input`, lub użyj `Get` przy użyciu `EOF` funkcji. W przypadku plików otwartych dla `Output`, `EOF` zawsze zwraca `True`.  
  
   
  
## Examples  
 W tym przykładzie użyto `EOF` funkcji, aby wykryć koniec pliku. W tym przykładzie założono, że `Testfile` to plik tekstowy, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" />. Dowolna prawidłowa liczba plików.</param>
        <summary>Zwraca wyliczenie reprezentującą tryb otwierania plików za pomocą <see langword="FileOpen" /> funkcji. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileAttr" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Następujące wartości wyliczenia wskazują tryb dostępu do pliku:  
  
 <list type="table"><item><term> Wartość  
  
 </term><description> Tryb  
  
 </description></item><item><term> 1  
  
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2  
  
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4  
  
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8  
  
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32  
  
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja zwraca wartość reprezentującą tryb otwierania plików za pomocą wyliczenie `FileOpen` funkcji.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileAttr` funkcja zwraca tryb pliku otwartego pliku.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Opcjonalny. Tablica parametrów 0 lub więcej kanałów zostanie zamknięty.</param>
        <summary>Na koniec zostanie wejścia/wyjścia (We/Wy) do pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> zapewnia lepszą wydajność i wydajność w operacji We/Wy na plikach. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [porady: Odczyt tekstu z plików za pomocą StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md),[porady: pisanie tekstu do plików za pomocą StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), i [wskazówki: manipulowanie plików i katalogów w Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 W przypadku pominięcia `FileNumbers`, wszystkie pliki active otwarty przez `FileOpen` funkcji są zamknięte.  
  
 Podczas zamykania pliki, które zostały otwarte dla `Output` lub `Append`, końcowego buforu danych wyjściowych jest zapisywany w buforze systemu operacyjnego dla tego pliku. Wszystkie ilość miejsca w buforze skojarzone z zamkniętego pliku.  
  
 Gdy `FileClose` funkcja jest wykonywana, skojarzenie pliku z jego plików numer kończy się.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileClose` funkcji, aby zamknąć plik otwarty do `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Wymagany. <see langword="String" /> wyrażenie, które określa nazwę pliku, który ma zostać skopiowany. <c>Źródło</c> mogą obejmować katalogu lub folderu i dysku z plikiem źródłowym.</param>
        <param name="Destination">Wymagany. <see langword="String" /> wyrażenie określające nazwa pliku docelowego. <c>Docelowy</c> mogą obejmować katalogu lub folderu i dysku, plik docelowy.</param>
        <summary>Kopiuje plik. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileCopy" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz użyć `FileCopy` działać na aktualnie otwarty plik, występuje błąd.  
  
 `FileCopy` wymaga pełnego zaufania do pracy na dysku lokalnym.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileCopy` funkcji do kopiowania plików do innego. Do celów tego przykładu, zakłada, że `SrcFile` plik, który zawiera dane.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> lub <paramref name="Destination" /> jest nieprawidłowa lub nie została określona.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. <see langword="String" /> wyrażenie, które określa nazwę pliku. <c>Nazwa ścieżki</c> mogą obejmować katalogu lub folderu i dysku.</param>
        <summary>Zwraca <see langword="Date" /> wartość, która wskazuje datę i godzinę pliku zostało zapisane. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileDateTime" />. Aby uzyskać więcej informacji zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns>
          <see langword="Date" /> wartość, która wskazuje datę i godzinę pliku utworzenia lub ostatniej modyfikacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `FileDateTime` funkcji, aby określić datę i godzinę plik został utworzony lub ostatniej modyfikacji. Format daty i godziny wyświetlane zależy od ustawień regionalnych systemu.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą`FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli nie jest używany deskryptora. Następnie rozmiaru i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji`FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą`FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy można zapisać deskryptor dwubajtowego ciąg opisujący długość. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <param name="ArrayIsDynamic">Opcjonalny. Ma zastosowanie tylko wtedy, gdy zapisywania tablicy. Określa, czy tablica jest traktowane jako dynamiczny i czy jest konieczne deskryptora tablica zawierająca opis rozmiaru i granice tablicy.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy można zapisać deskryptor dwubajtowego ciąg opisujący długość. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGet" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGet` są zwykle zapisywane do pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, następnego rekordu lub od ostatniego bajtu `FileGet` lub `FilePut` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji) jest do odczytu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGet` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między zakończeniem jeden rekord a rozpoczęciem następnego rekordu są dopełniane przy użyciu istniejącej zawartości buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, gdy zmienna odczytywane w ciągu `FileGet` odczytuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie odczytuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy przekazany `FileGet` określenia, jakie można odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów danych: [5 * 10 * 4].  
  
-   Jeśli zmienna do odczytu jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FileGet` odczytuje tylko danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości odczytywane dane.  
  
-   `FileGet` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePut`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do odczytu poszczególne elementy. Obejmuje to wszystkie tablice i ich deskryptory. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciągiem, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGet` odczytuje wszystkie zmienne ciągłym; z dysku oznacza to bez dopełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczyt z pliku za pomocą `FileGet` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> plików trybu) lub liczbę bajtów (<see langword="Binary" /> plików trybu), w których odczytu rozpoczyna się.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej.  <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileGetObject" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGetObject` Funkcja jest używana zamiast `FileGet` Aby uniknąć niejednoznaczności w czasie kompilacji, jeśli typ `Object` jest zwracana zamiast innego typu, takich jak `Integer`, `Long`, `Short`, itd.  
  
 Jeśli zamierzasz zapisać `Variant` typu `FileGetObject` jest wymagana. W razie wątpliwości, jeśli używasz obiektu dla drugiego parametru, zawsze zalecane jest używanie `FilePutObject` i `FileGetObject`.  
  
 `FileGetObject` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane odczytane z `FileGetObject` są zwykle zapisywane z `FilePutObject`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, `FileGetObject` odczytuje rekord lub byte po ostatniej `FileGetObject` lub `FilePutObject` — funkcja (lub wskazywana przez ostatnich `Seek` funkcji).  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość odczytywane dane jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FileGetObject` odczytuje kolejne rekordy na granicach długość rekordu. Odstęp między zakończeniem jeden rekord a początek następnego rekordu są dopełniane przy użyciu istniejącej zawartości buforu plików. Ponieważ ilość danych dopełnienia nie można precyzyjnie ustalić, to warto mieć długość rekordu jest zgodna z długością odczytywane dane.  
  
-   Jeśli zmienna do odczytu jest ciągiem, domyślnie `FileGetObject` odczytuje deskryptor dwubajtowego zawierająca długość ciągu i odczytuje danych, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty. Visual Basic 6.0 i starsze wersje obsługują ciągi o stałej długości i odczytywana do pliku, deskryptora długości nie jest zapisywany. Jeśli chcesz odczytać ciągu bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Gdy zmienna odczytywane w tablicy, a następnie rekordów długości określonej przez `RecordLength` parametru w `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: 2 + 8 * NumberOfDimensions.  
  
     Na przykład następujące deklaracja tablicy wymaga 218 bajtów podczas tablicy są zapisywane na dysku:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     Bajty 218 są rozpowszechniane w następujący sposób: 18 bajtów dla deskryptora (2 + 8 * 2) i 100 bajtów danych (5 * 10 * 4).  
  
-   `FileGetObject` odczytuje elementy struktury tak, jakby każda odczytu oddzielnie, z wyjątkiem tego, że nie istnieje żadne uzupełnienie między elementami. Na dysku dynamicznym tablica z typu zdefiniowanego przez użytkownika (napisany za pomocą `FilePutObject`) jest poprzedzony deskryptor o długości 2 plus 8 godzin jest równa liczbie wymiarów: 2 + 8 * NumberOfDimensions. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich bajtów, które są wymagane do poszczególnych elementów, w tym wszystkie tablice i ich deskryptory odczytu. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasy mogą być stosowane do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie wszystkie `Random` zastosować reguły, z następującymi wyjątkami:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FileGetObject` odczytuje wszystkie zmienne z dysku ciągłym, czyli z nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FileGetObject` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
 `FileGetObject` odczytuje ciągów o zmiennej długości, które nie są elementami struktur nie oczekuje deskryptora dwóch bajtów długości. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plik źródłowy języka Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład odczytuje rekord w pliku testu, a następnie pobierze go.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. <see langword="String" /> wyrażenie, które określa plik. <c>Nazwa ścieżki</c> mogą obejmować katalogu lub folderu i dysku.</param>
        <summary>Zwraca <see langword="Long" /> wartość określająca długość pliku w bajtach. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileLen" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>
          <see langword="Long" /> Wartość określająca długość pliku w bajtach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony plik jest otwarty, kiedy `FileLen` funkcja jest wywoływana, zwracana wartość reprezentuje rozmiar pliku w czasie zostało otwarte.  
  
> [!NOTE]
>  Aby uzyskać bieżącą długość otwartego pliku, użyj `LOF` funkcji.  
  
   
  
## Examples  
 W tym przykładzie użyto `FileLen` funkcja zwraca długość pliku w bajtach. Do celów tego przykładu, zakłada, że `TestFile` plik, który zawiera niektóre dane.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików. Użyj <see langword="FreeFile" /> funkcji, aby uzyskać następny dostępny numer pliku.</param>
        <param name="FileName">Wymagany. <see langword="String" /> wyrażenie, które określa nazwę pliku — może obejmować katalogu lub folderu i dysku.</param>
        <param name="Mode">Wymagany. Wyliczenie opisujące tryb pliku: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, lub <see langword="Random" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</param>
        <param name="Access">Opcjonalny. Wyliczenie opisujące operacje dozwolone na otwieranie pliku: <see langword="Read" />, <see langword="Write" />, lub <see langword="ReadWrite" />. Domyślnie <see langword="ReadWrite" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</param>
        <param name="Share">Opcjonalny. Wyliczenie opisujące operacje nie zezwala na otwieranie pliku przez inne procesy: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, i <see langword="Lock Read Write" />. Domyślnie <see langword="Lock Read Write" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</param>
        <param name="RecordLength">Opcjonalny. Liczba mniejsza lub równa 32 767 (w bajtach). W przypadku plików na dostępie swobodnym ta wartość jest długość rekordu. Sekwencyjnych plików ta wartość jest liczbą znaków buforowane.</param>
        <summary>Otwiera plik dla danych wejściowych lub wyjściowych. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileOpen" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Aby można było wykonać żadnej operacji We/Wy na nim należy otworzyć plik. `FileOpen` przydziela buforu dla operacji We/Wy do pliku i określa tryb dostępu do użycia z buforu.  
  
> [!IMPORTANT]
>  Podczas zapisywania do pliku, aplikacja może być konieczne utworzenie pliku, jeśli plik, do którego próbuje zapisać nie istnieje. Aby to zrobić, wymaganych uprawnień dla katalogu, w którym ma być utworzony plik. Jednak jeśli plik określony przez `FileName` istnieje aplikacji należy `Write` uprawnienia tylko w samym pliku. Wszędzie tam, gdzie to możliwe, aby zwiększyć bezpieczeństwo, tworzenie pliku podczas wdrażania i przyznać `Write` uprawnienia do tego pliku tylko, a nie całego katalogu. Aby zwiększyć bezpieczeństwo, zapisać danych do katalogów użytkowników zamiast do katalogu głównego lub katalog Program Files.  
  
 Kanał, aby otworzyć znajduje się za pomocą `FreeFile()` funkcji.  
  
> [!IMPORTANT]
>  `FileOpen` Wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia, które mogą wpłynąć na jej wykonanie w sytuacji, w częściowej relacji zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono różnych zastosowań `FileOpen` funkcji, aby włączyć dane wejściowe i wyjściowe do pliku.  
  
 Poniższy kod otwiera plik `TestFile` w `Input` tryb.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 W tym przykładzie powoduje otwarcie tego pliku w `Binary` tryb operacji tylko do zapisu.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Poniższy przykład powoduje otwarcie tego pliku w `Random` tryb. Plik zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 W tym przykładzie kodu otwiera plik w `Output` tryb; żadnych może proces odczytu lub zapisu do pliku.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 W tym przykładzie kodu otwiera plik w `Binary` trybie do odczytu; inne procesy nie można odczytać pliku.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość rekordu jest ujemny (i nie jest równa -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> jest już otwarty, lub <paramref name="FileName" /> jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. F, aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo`VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w`RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy można zapisać do pliku dwubajtowego ciągu deskryptora długość ciągu. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />...</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <param name="ArrayIsDynamic">Opcjonalny. Ma zastosowanie tylko wtedy, gdy zapisywania tablicy. Określa, czy tablica jest traktowane jako dynamiczny oraz czy zapisać deskryptora ciąg opisujący długość tablicy.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy można zapisać do pliku dwubajtowego ciągu deskryptora długość ciągu. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePut" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePut` jest zwykle do odczytu z pliku za pomocą `FileGet`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, dalej rekord lub byte po ostatniej `FileGet` lub `FilePut` funkcji lub wskazywana przez ostatnich `Seek` funkcji są zapisywane.  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePut` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePut`, musisz wykonać taki sam jak `FileGet`, i upewnij się, że zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePut` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie wygenerowany wyjątek.  
  
-   Jeśli zmienna zapisywana jest ciągiem, `FilePut` zapisuje deskryptora dwubajtowego, który zawiera długość ciągu, a następnie zapisuje dane, który jest przesyłany do zmiennej. W związku z tym długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePut` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePut` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePut` zapisuje identyfikowanie deskryptora dwubajtowo `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby napisać deskryptora, ustaw `ArrayIsDynamic` parametr `True`. Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions). Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zmienna zapisywana jest innego typu zmiennej (nie ciągiem o długości zmiennej lub obiektu), `FilePut` zapisuje danych zmiennej. Długość rekordu określony przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut` Zapisuje elementy struktury tak, jakby każda napisanych oddzielnie, z wyjątkiem nie istnieje żadne uzupełnienie między elementami. `VBFixedString` Atrybut można stosować do pól ciągów w strukturach rozmiaru ciąg, gdy zapisywane na dysku.  
  
    > [!NOTE]
    >  Pola, które mają więcej bajtów niż określona przez ciąg `VBFixedString` atrybutu są obcinane, gdy zapisywane na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie większość `Random` zasady trybu się z kilkoma wyjątkami. Następujące reguły pliki otwarte w `Binary` tryb różnią się od reguł dla `Random` trybu:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePut` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
-   Dla tablicy niż tablicy w strukturze `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut` zapisuje ciągów o zmiennej długości, które nie są elementami struktury bez deskryptora dwóch bajtów długości. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis do pliku przy użyciu `FilePut` wymaga funkcji `Write` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePut` funkcji można zapisać danych do pliku. Rejestruje pięć struktury `Person` są zapisywane do pliku.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 i nie jest równa -1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> tryb pliki) lub liczbę bajtów (<see langword="Binary" /> plików trybu) na piśmie, które uruchamia.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku.  <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FilePutObject" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePutObject` Funkcja jest używana zamiast `FilePut` Aby uniknąć niejednoznaczności w czasie kompilacji, jeśli typ `Object` przekazany zamiast innego typu, takich jak `Integer`, `Long`, `Short`, itd.  
  
 `FilePutObject` zapisuje i odczytuje deskryptory, które opisują obiektu. Jeśli zamierzasz zapisać `Variant` typu `FilePutObject` jest wymagana. W razie wątpliwości, jeśli używasz obiektu dla drugiego parametru, firma Microsoft zaleca, aby zawsze używać `FilePutObject` i `FileGetObject`.  
  
 `FilePutObject` jest prawidłowy tylko w `Random` i `Binary` tryb.  
  
 Dane zapisywane z `FilePutObject` jest zwykle do odczytu z pliku za pomocą `FileGetObject`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W przypadku pominięcia `RecordNumber`, `FilePutObject` zapisuje dalej rekord lub byte po ostatniej `FileGetObject` lub `FilePutObject` — funkcja (lub rekordu lub byte wskazywana przez ostatnich `Seek` funkcji).  
  
 `StringIsFixedLength` Argument określa, czy funkcja interpretuje ciągi jako zmienna lub stała długość. `FilePutObject` zapisuje deskryptora długość, gdy argument jest `True`. Jeśli używasz `StringIsFixedLength`  =  `True` z `FilePutObject`, musisz wykonać taki sam jak `FileGetObject`, i musi również upewnij się, zainicjowanej Oczekiwana długość ciągu.  
  
## <a name="random-mode"></a>Tryb losowy  
 Dla plików otwieranych w `Random` tryb, obowiązują następujące reguły:  
  
-   Jeśli długość danych zapisywanych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji `FilePutObject` zapisuje kolejne rekordy na granicach długość rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilość danych dopełnienia nie można precyzyjnie ustalić, zazwyczaj jest warto mieć długość rekordu jest zgodna z długością zapisywanych danych. Jeśli długość danych zapisywanych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, jest zgłaszany wyjątek.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera typ liczbowy `FilePutObject` zapisuje dwa bajty identyfikowanie `VarType` obiektu, a następnie zapisuje zmiennej. Na przykład podczas zapisu obiektu zawiera całkowitą, `FilePutObject` zapisuje bajty sześciu: dwa bajty, które identyfikują obiektu jako `VarType(3)` (`Integer`) i czterech bajtów, które zawierają dane. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista liczba bajtów wymaganą do zapisania zmiennej co najmniej dwa bajty.  
  
-   Jeśli zmienna zapisywana jest obiekt, który zawiera ciąg, `FilePutObject` zapisuje identyfikowanie deskryptora dwubajtowego `VarType(8)` obiektu deskryptora dwubajtowego wskazującym długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określony przez `RecordLength` parametru w `FileOpen` funkcja musi być większa niż rzeczywista długość ciągu co najmniej cztery bajtów. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` do `StringIsFixedLength` parametru i odczytu do powinna być poprawna długość ciągu.  
  
-   Jeśli zmienna zapisywana jest tablicą, a następnie rekordów długości określonej przez `RecordLength` w klauzuli `FileOpen` funkcja musi być większa lub równa sumie wszystkich wymaganych do zapisania danych tablicy i deskryptora tablicy bajtów. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Liczba wymiarów czasu jego długość jest równa 2 plus 8: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Tryb binarny  
 Dla plików otwieranych w `Binary` trybie wszystkie `Random` tryb reguły mają zastosowanie, z wyjątkiem:  
  
-   `RecordLength` w klauzuli `FileOpen` funkcja nie ma wpływu. `FilePutObject` zapisuje wszystkie zmienne do ciągłym, dysku, oznacza to, że nie uzupełnienie między rekordów.  
  
   
  
## Examples  
 W tym przykładzie użyto `FilePutObject` funkcji, aby zapisać ciąg do pliku.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="RecordWidth">Wymagany. Wyrażenie liczbowe w zakresie od 0 do 255 włącznie, która określa, ile znaków pojawiać się w wierszu przed uruchomieniem nowego wiersza. Jeśli <c>RecordWidth</c> jest równe 0, nie ma żadnego limitu długości wiersza. Wartość domyślna dla <c>RecordWidth</c> ma wartość 0.</param>
        <summary>Przypisuje szerokość linii dane wyjściowe do pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 W tym przykładzie użyto `FileWidth` funkcji, aby ustawić szerokość linii dane wyjściowe do pliku.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see langword="Integer" /> wartość, która reprezentuje kolejny numer pliku dostępne do użycia przez <see langword="FileOpen" /> funkcji.</summary>
        <returns>Zwraca <see langword="Integer" /> wartość, która reprezentuje kolejny numer pliku dostępne do użycia przez <see langword="FileOpen" /> funkcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `FreeFile` podać numer pliku, który nie jest już jest używany.  
  
   
  
## Examples  
 W tym przykładzie użyto `FreeFile` funkcja zwraca następny dostępny numer pliku. Pięć plików są otwarte dla danych wyjściowych w pętli, a niektóre przykładowe dane są zapisywane do każdego.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Więcej niż 255 pliki są używane.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. <see langword="String" /> wyrażenie, które określa nazwę pliku, katalogu lub folderu. <c>Nazwa ścieżki</c> mogą obejmować katalogu lub folderu i dysku.</param>
        <summary>Zwraca <see langword="FileAttribute" /> wartość, która reprezentuje atrybuty pliku, katalogu lub folderu. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="FileAttribute" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Wartość zwrócona przez <see langword="GetAttr" /> jest sumą wartości wyliczenia następujące:  
  
 <list type="table"><item><term> Wartość  
  
 </term><description> Stała  
  
 </description><description> Opis elementu  
  
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normalny.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Tylko do odczytu.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Ukryte.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> System plików.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Katalogu lub folderu.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> Plik zmienił się od czasu ostatniej kopii zapasowej.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> Plik ma inną nazwę.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Te wyliczenia są określane przez język Visual Basic. Nazwy mogą być użyte w dowolne miejsce w kodzie zamiast wartości rzeczywistych.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, które atrybuty są ustawione, użyj `And` operatora, aby wykonać porównanie bitowe wartości zwróconej przez `GetAttr` funkcji i wartość atrybutu pojedynczy plik ma. Jeśli wynik nie jest równa zero, ten atrybut jest ustawiony dla wskazanego pliku. Na przykład, wartość zwracana następujące `And` wyrażenie jest zero, jeśli `Archive` nie ustawiono atrybutu:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Zwracana wartość niezerową, gdy `Archive` ustawiono atrybut.  
  
   
  
## Examples  
 W tym przykładzie użyto `GetAttr` funkcji, aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w niemieckiej wersji, jeśli wejściowych 3,14159, zwraca tylko 3, ponieważ przecinek jest traktowane jako separator zmiennej zamiast jako separatorem dziesiętnym.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, której przypisano wartości odczytane z pliku — nie może być zmienną tablicy lub obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `Input` są zwykle zapisywane do pliku przy użyciu `Write`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR `errornumber`#|`errornumber` (zmienna jest oznaczone jako błąd obiektu)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest lokalizowany. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `Input` wymaga funkcji `Read` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Input` funkcji można odczytać danych z pliku do dwóch zmiennych. W tym przykładzie założono, że `TestFile` plik, który ma kilka wierszy dane zapisane za pomocą `Write` działanie, każdy wiersz zawierający ciąg w ofert oraz numer rozdzielonych przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="CharCount">Wymagany. Dowolne prawidłowe wyrażenie liczbowe określająca liczbę znaków do odczytania.</param>
        <summary>Zwraca <see langword="String" /> wartości, która zawiera znaki z pliku otwartym w <see langword="Input" /> lub <see langword="Binary" /> tryb. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="InputString" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Zwraca <see langword="String" /> wartości, która zawiera znaki z pliku otwartym w <see langword="Input" /> lub <see langword="Binary" /> tryb. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `InputString` funkcji są zwykle zapisywane do pliku przy użyciu `Print` lub `FilePut`. Użyj tej funkcji tylko w przypadku plików otwartych w `Input` lub `Binary` tryb.  
  
 W odróżnieniu od `Input` funkcji `InputString` funkcja zwraca wszystkie znaki tekstu. W tym przecinki, znaki powrotu karetki znaki wysuwu wiersza, cudzysłowy i spacje początkowe.  
  
 W przypadku plików otwartych dla `Binary` dostępu, próba odczytania pliku przy użyciu `InputString` działać do czasu `EOF` zwraca `True` generuje błąd. Użyj `LOF` i `Loc` funkcje zamiast `EOF` odczytywana plików binarnych za pomocą `InputString`, lub użyj `FileGet` korzystając `EOF` funkcji.  
  
> [!NOTE]
>  Podczas odczytu z plików, nie należy wprowadzać zabezpieczeń decyzje dotyczące zawartości pliku, na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plik źródłowy języka Visual Basic.  
  
   
  
## Examples  
 W tym przykładzie użyto `InputString` funkcji, aby przeczytać o jeden znak w czasie z pliku i wydrukuj go do `Output` okna. W tym przykładzie założono, że `MyFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> nie istnieje.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 lub &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. <see langword="String" /> wyrażenie określające jedną lub więcej nazw plików do usunięcia. <c>Nazwa ścieżki</c> mogą obejmować katalogu lub folderu i dysku.</param>
        <summary>Usuwa pliki z dysku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Kill" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` obsługuje korzystanie z wielu znaków (`*`) i jednego znaku (`?`) symboli wieloznacznych do określenia wielu plików.  
  
 **Uwaga dotycząca zabezpieczeń** w celu wykonania, `Kill` wymaga funkcji `Read` i `PathDiscovery` flagi <xref:System.Security.Permissions.FileIOPermission> mieć uprawnienia do wykonywania kodu. Aby uzyskać więcej informacji, zobacz <xref:System.Security.SecurityException> [uprawnienia dostępu kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 W tym przykładzie użyto `Kill` funkcji, aby usunąć plik z dysku.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Otwieranie plików docelowych.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie można odnaleźć plików docelowych.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Odczytuje pojedynczy wiersz z otwartego pliku sekwencyjnych i przypisuje go do <see langword="String" /> zmiennej.</summary>
        <returns>Odczytuje pojedynczy wiersz z otwartego pliku sekwencyjnych i przypisuje go do <see langword="String" /> zmiennej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane z `LineInput` są zwykle zapisywane do pliku przy użyciu `Print`.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
 `LineInput` Funkcja odczytuje z pliku znak w chwili, aż do napotkania powrotu karetki (`Chr(13)`) lub powrotu/wiersza kanału informacyjnego (`Chr(13) + Chr(10)`) sekwencji. Sekwencje źródła powrotu i wiersza karetki są pomijane zamiast dołączony do ciągu znaków.  
  
> [!IMPORTANT]
>  Odczyt z pliku za pomocą `LineInput` wymaga funkcji `Read` dostęp z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie użyto `LineInput` funkcji do odczytywania wiersz z pliku sekwencyjnego i przypisz go do zmiennej. W tym przykładzie założono, że `TestFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Osiągnięto koniec pliku.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Wszystkie prawidłowe <see langword="Integer" /> numer pliku.</param>
        <summary>Zwraca <see langword="Long" /> wartość, która określa bieżącą pozycję odczytu/zapisu, w której plik otwarty.</summary>
        <returns>Zwraca <see langword="Long" /> wartość, która określa bieżącą pozycję odczytu/zapisu, w której plik otwarty.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Funkcji jest liczony od zera; użyciem jej do pierwszego bajtu w pliku pobrać zwraca wartość 0.  
  
 `Loc` Funkcja zapewnia zgodność z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Poniżej opisano wartość zwracana dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Numer ostatniego rekordu odczytu lub zapisu do pliku.|  
|`Sequential`|Pozycja bieżącego bajtu podzielona przez 128. Jednak informacje zwracane przez `Loc` dla kolejnych plików nie jest używany ani wymagane.|  
|`Binary`|Położenie ostatniego bajtu zapisu lub odczytu.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Loc` funkcja zwraca bieżącą pozycję odczytu/zapisu, w której plik otwarty. W tym przykładzie założono, że `MyFile` to plik tekstowy, który ma kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalny. Liczba tylko rekordu lub byte, aby zablokować lub odblokować</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalny. Liczba pierwszy rekord lub byte, aby zablokować lub odblokować.</param>
        <param name="ToRecord">Opcjonalny. Liczba ostatnich rekordu lub byte, aby zablokować lub odblokować.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawierającą numer prawidłowy plik.</param>
        <summary>Zwraca <see langword="Long" /> reprezentującą rozmiar w bajtach plik otwarty przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="LOF" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Zwraca <see langword="Long" /> reprezentującą rozmiar w bajtach plik otwarty przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `FileLen` funkcji, aby uzyskać długość pliku, który nie jest otwarty.  
  
   
  
## Examples  
 W tym przykładzie użyto `LOF` funkcji, aby określić rozmiar otwartego pliku. W tym przykładzie założono, że `TestFile` to plik tekstowy, który zawiera przykładowe dane.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagany. <see langword="String" /> wyrażenie, które identyfikuje katalog ma zostać utworzony. <c>Ścieżki</c> mogą obejmować dysku. Jeśli dysk nie zostanie wskazany, <see langword="MkDir" /> tworzy nowy katalog na bieżącym dysku.</param>
        <summary>Tworzy nowy katalog. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="MkDir" />. Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja tworzy nowy katalog.  
  
   
  
## Examples  
 W tym przykładzie użyto `MkDir` funkcji do tworzenia katalogu. Jeśli dysk nie zostanie określony, nowy katalog jest tworzony na bieżącym dysku.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> nie jest określony lub jest pusty.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Katalog już istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalny. Zero lub więcej rozdzielana przecinkami wyrażenia można zapisać do pliku.  
  
 <c>Dane wyjściowe</c> ustawienia argumentu są:  
  
 <see langword="T:System.IO.IOException" />: Tryb plik jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <c>Numer_pliku</c> nie istnieje.</param>
        <summary>Zapisy wyświetlania danych w formacie pliku sekwencyjnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` i `PrintLine` funkcje są udostępniane dla zgodności z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` nie ma wiersz na końcu wiersza; jednak `PrintLine` obejmują wysuwu wiersza.  
  
 Dane zapisywane z `Print` jest zwykle do odczytu z pliku za pomocą `LineInput` lub `Input`.  
  
 W przypadku pominięcia `Output` dla `PrintLine`, pusty wiersz jest drukowany do pliku, na `Print`, nie ma danych wyjściowych. Wiele wyrażeń oddzielonych przecinkami będzie wyrównane na granicach kartę, ale mieszania przecinkami i `TAB` może spowodować niespójne wyniki.  
  
 Aby uzyskać `Boolean` danych, albo `True` lub `False` drukowania. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
 Dane daty są zapisywane do pliku w formacie daty krótkiej standardowe rozpoznany przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Jeśli nic nie są zapisywane do pliku `Output` danych jest pusta. Jednak jeśli `Output` dane listy jest `DBNull`, `Null` są zapisywane do pliku.  
  
 Aby uzyskać `Error` dane, dane wyjściowe są wyświetlane jako `Error errorcode`. `Error` — Słowo kluczowe nie jest translacja niezależnie od ustawień regionalnych.  
  
 Wszystkie dane zapisane do pliku przy użyciu `Print` uwzględnia ustawienia regionalne; oznacza to, danych jest poprawnie sformatowany przy użyciu odpowiednich separatorem dziesiętnym. Jeśli użytkownik żąda do wysyłania danych do użycia przez wielu ustawień regionalnych, `Write` powinien być używany.  
  
 Zapis do pliku przy użyciu `Print` lub `PrintLine` wymaga funkcji `Write` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Print` i `PrintLine` funkcji można zapisać danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalny. Zero lub więcej rozdzielana przecinkami wyrażenia można zapisać do pliku.  
  
 <c>Dane wyjściowe</c> ustawienia argumentu są:  
  
 <see langword="T:System.IO.IOException" />: Tryb plik jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <c>Numer_pliku</c> nie istnieje.</param>
        <summary>Zapisy wyświetlania danych w formacie pliku sekwencyjnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Print` i `PrintLine` funkcje są udostępniane dla zgodności z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` nie ma wiersz na końcu wiersza; jednak`PrintLine` obejmują wysuwu wiersza.  
  
 Dane zapisywane z `Print` jest zwykle do odczytu z pliku za pomocą `LineInput` lub `Input`.  
  
 W przypadku pominięcia `Output` dla `PrintLine`, pusty wiersz jest drukowany do pliku, na `Print`, nie ma danych wyjściowych. Wiele wyrażeń oddzielonych przecinkami będzie wyrównane na granicach kartę, ale mieszania przecinkami i `TAB` może spowodować niespójne wyniki.  
  
 Aby uzyskać `Boolean` danych, albo `True` lub `False` drukowania. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
 Dane daty są zapisywane do pliku w formacie daty krótkiej standardowe rozpoznawane przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Jeśli nic nie są zapisywane do pliku `Output` danych jest pusta. Jednak jeśli `Output` dane listy jest `DBNull`, `Null` są zapisywane do pliku.  
  
 Aby uzyskać `Error` dane, dane wyjściowe są wyświetlane jako `Error errorcode`. `Error` — Słowo kluczowe nie jest translacja niezależnie od ustawień regionalnych.  
  
 Wszystkie dane zapisane do pliku przy użyciu `Print` uwzględnia ustawienia regionalne; oznacza to, danych jest poprawnie sformatowany przy użyciu odpowiednich separatorem dziesiętnym. Jeśli użytkownik żąda do wysyłania danych do użycia przez wielu ustawień regionalnych, `Write` powinien być używany.  
  
 Zapis do pliku przy użyciu `Print` lub `PrintLine` wymaga funkcji `Write` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Print` i `PrintLine` funkcji można zapisać danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Wymagany. <see langword="String" /> wyrażenie określające istniejącą nazwę pliku i lokalizację. <c>OldPath</c> może obejmować katalogu i dysku w pliku.</param>
        <param name="NewPath">Wymagany. <see langword="String" /> wyrażenie, które określa nową nazwę pliku i lokalizację. <c>Nowa_ścieżka</c> mogą obejmować katalogu oraz dysk w lokalizacji docelowej. Nazwa pliku określona przez <c>Nowa_ścieżka</c> już nie istnieje.</param>
        <summary>Zmienia nazwę pliku lub katalogu. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Rename" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Funkcji zmienia nazwę pliku i przenosi ją do innego katalogu, jeśli jest to wymagane. `Rename` Funkcja może przenieść plik na dyskach, ale tylko wtedy można zmienić nazwę istniejącego katalogu po obu `NewPath` i `OldPath` znajdują się na tym samym dysku. `Rename` Nie można utworzyć nowego pliku lub katalogu.  
  
 Przy użyciu `Rename` funkcji, dla której plik otwarty powoduje błąd. Otwórz plik należy zamknąć przed zmianą nazwy. `Rename` argumenty nie może zawierać wielu znaków (*) i symboli wieloznacznych, jednoznakowym (?).  
  
> [!IMPORTANT]
>  Korzystając z `Rename` kopiowania pliku z lokalizacji niechronione do chronionej lokalizacji, plik zachowuje mniej ograniczone uprawnienia. Sprawdź, czy nie są wprowadzenie zagrożenie bezpieczeństwa.  
  
   
  
## Examples  
 W tym przykładzie użyto `Rename` funkcji, aby zmienić nazwę pliku. Do celów tego przykładu założono, że katalogi, które są określone już istnieje.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="OldPath" /> Plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Nie można zmienić nazwy na innym urządzeniu.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie dysku pliki otwierane przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Reset" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Reset` Funkcja zamyka wszystkie aktywne pliki otwarte przez `FileOpen` funkcji i ma taką samą funkcję jak `FileClose()` bez żadnych parametrów.  
  
   
  
## Examples  
 W tym przykładzie użyto `Reset` funkcji, aby zamknąć wszystkie otwarte pliki i zapisać zawartość buforów plików na dysku. Zwróć uwagę na użycie `Object` zmiennej `FileNumber` zarówno jako ciąg i numeru.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagany. <see langword="String" /> wyrażenie, które identyfikuje katalogu lub folderu do usunięcia. <c>Ścieżka</c> można dołączyć dysku. Jeśli dysk nie zostanie wskazany, <see langword="RmDir" /> usuwa katalogu na bieżącym dysku.</param>
        <summary>Usuwa istniejący katalog. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="RmDir" />. Aby uzyskać więcej informacji, zobacz <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd występuje, gdy użytkownik próbuje użyć `RmDir` w katalogu, który zawiera pliki. Użyj `Kill` funkcji, aby usunąć wszystkie pliki przed podjęciem próby usunięcia katalogu.  
  
   
  
## Examples  
 W tym przykładzie użyto `RmDir` funkcji, aby usunąć istniejący katalog.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> nie jest określony lub jest pusty.</exception>
        <exception cref="T:System.IO.IOException">Katalog docelowy zawiera pliki.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji lub Ustawia położenie w następnej operacji odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawierającą numer prawidłowy plik.</param>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji lub Ustawia położenie w następnej operacji odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji lub Ustawia położenie w następnej operacji odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Zwraca wartość z zakresu od 1 do 2 147 483 647 (odpowiednikiem 2 ^ 31 – 1) włącznie.  
  
 Poniżej opisano wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Liczba następnego rekordu odczytu lub zapisu|  
|`Binary`, `Input`, `Output`, `Append`|Pozycja bajtów, jaką występuje następnej operacji. Pierwszy bajt w pliku od pozycji 1, drugi bajt znajduje się na pozycji nr 2 i tak dalej.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Seek` funkcja zwraca bieżące położenie pliku. W przykładzie założono `TestFile` plik, który zawiera rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Dla plików otwieranych w `Random` trybie `Seek` zwraca liczbę następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` zwraca pozycję bajt, w którym występuje następnej operacji. Załóżmy `TestFile` plik, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 W tym przykładzie użyto `Seek` funkcja ustawienia pozycji dla następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` Ustawia położenie bajtów, jaką występuje następnej operacji. Załóżmy `TestFile` plik, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawierającą numer prawidłowy plik.</param>
        <param name="Position">Wymagany. Liczba z zakresu 1 – 2 147 483 647, włącznie, która wskazuje, gdzie następnej odczytu/zapisu operacji powinien wystąpić.</param>
        <summary>Zwraca <see langword="Long" /> określającą bieżącą pozycję odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji lub Ustawia położenie w następnej operacji odczytu/zapisu w pliku otworzyć za pomocą <see langword="FileOpen" /> funkcji. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Seek" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Zwraca wartość z zakresu od 1 do 2 147 483 647 (odpowiednikiem 2 ^ 31 – 1) włącznie.  
  
 Poniżej opisano wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Liczba następnego rekordu odczytu lub zapisu|  
|`Binary`, `Input`, `Output`, `Append`|Pozycja bajtów, jaką występuje następnej operacji. Pierwszy bajt w pliku od pozycji 1, drugi bajt znajduje się na pozycji nr 2 i tak dalej.|  
  
   
  
## Examples  
 W tym przykładzie użyto `Seek` funkcja zwraca bieżące położenie pliku. W przykładzie założono `TestFile` plik, który zawiera rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Dla plików otwieranych w `Random` trybie `Seek` zwraca liczbę następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` zwraca pozycję bajt, w którym występuje następnej operacji. Załóżmy `TestFile` plik, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 W tym przykładzie użyto `Seek` funkcja ustawienia pozycji dla następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybach innych niż `Random` trybie `Seek` Ustawia położenie bajtów, jaką występuje następnej operacji. Załóżmy `TestFile` plik, który zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. <see langword="String" /> wyrażenie, które określa nazwę pliku. <c>Nazwa ścieżki</c> mogą obejmować katalogu lub folderu i dysku.</param>
        <param name="Attributes">Wymagany. Wyrażenie stałej lub liczbowego, którego suma określa atrybuty pliku.</param>
        <summary>Ustawia atrybut informacji dla pliku. <see langword="My" /> Funkcji zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="SetAttr" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd czasu wykonywania występuje, Jeśli spróbujesz ustawić atrybuty otwartego pliku.  
  
 `Attributes` Argumentu wyliczenia wartości są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbNormal`|Normalny (domyślnie).|  
|`ReadOnly`|`vbReadOnly`|Tylko do odczytu.|  
|`Hidden`|`vbHidden`|Ukryte.|  
|`System`|`vbSystem`|System plików.|  
|`Volume`|`vbVolume`|Etykieta woluminu|  
|`Directory`|`vbDirectory`|Katalogu lub folderu.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic. Nazwy mogą być użyte w dowolne miejsce w kodzie, a nie rzeczywiste wartości.  
  
   
  
## Examples  
 W tym przykładzie użyto `SetAttr` funkcji można ustawić atrybutów pliku.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Attribute" /> Typ jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Wymagany. Liczba spacji do wstawienia przed wyświetleniem lub wydrukowaniem następnego wyrażenia na liście.</param>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcji do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcji do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Count` jest mniejsza niż szerokość linii danych wyjściowych, natychmiast następną pozycję wydruku następuje liczba wydrukowanych spacji. Jeśli`Count` jest większa niż szerokość linii danych wyjściowych, `SPC` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Na przykład, czy bieżące położenie wydruku jest 24, szerokość linii danych wyjściowych 80, a określisz `SPC(90)`, wydruk rozpocznie się na pozycji 34 (bieżąca pozycja wydruku + pozostałej części 90/80). Jeśli różnica między bieżącą pozycję wydruku i szerokości linii danych wyjściowych jest mniejsza niż `Count` (lub `Count` `Mod` *szerokość*), `SPC` funkcja przejdzie do rozpoczęcia następnego wiersza i generuje spacje równa `Count` — (*szerokość* — *bieżąca_pozycja_wydruku*).  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są wystarczająco szerokie umożliwić szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie użyto `SPC` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcje do pozycjonowania danych wyjściowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcje do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcje do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większy niż `Column`, `TAB` przejdzie do wartości kolumny równej `Column` w następnym wierszu danych wyjściowych. Jeśli `Column` jest mniejszy niż 1 `TAB` przesunie pozycję wydruku do kolumny 1. Jeśli `Column` jest większy niż szerokość linii danych wyjściowych, `TAB` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 Mod szerokość kolumny  
  
 Na przykład jeśli *szerokość* to 80 i określeniu `TAB(90)`, wydruk zostaną uruchomione w kolumnie 10 (w pozostałej części 90/80). Jeśli `Column` jest mniejsza od bieżącej pozycji drukowania, uruchamia drukowanie w następnym wierszu na obliczonej pozycji drukowania. Jeśli obliczonej pozycji drukowania jest większy niż bieżącej pozycji drukowania, drukowania rozpoczyna się od obliczony drukowanie pozycji w tym samym wierszu.  
  
 Po lewej stronie pozycja drukowania w wierszu wydruku ma zawsze numer 1. Jeśli używasz `Print` lub `PrintLine` funkcje drukowania do plików, po prawej stronie pozycja drukowania jest bieżąca szerokość pliku wyjściowego, którą można ustawić za pomocą `FileWidth` funkcji.  
  
 `TAB` Funkcji można również używać razem `WriteLine` funkcji. Nie można używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są dostatecznie szerokie, zawierają szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie użyto `TAB` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Opcjonalny. Numer kolumny przeniesione do przed wyświetleniem lub wydrukowaniem następnego wyrażenia na liście. Pominięcie <see langword="TAB" /> przenosi punkt wstawiania na początek następnego strefy wydruku.</param>
        <summary>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcje do pozycjonowania danych wyjściowych.</summary>
        <returns>Używane z <see langword="Print" /> lub <see langword="PrintLine" /> funkcje do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większa niż `Column`, `TAB` przejdzie do wartości kolumny równej `Column` w następnym wierszu danych wyjściowych. Jeśli `Column` jest mniejszy niż 1 `TAB` przesunie pozycję wydruku do kolumny 1. Jeśli `Column` jest większa niż szerokość linii danych wyjściowych, `TAB` oblicza następną pozycję wydruku przy użyciu formuły:  
  
 Mod szerokość kolumny  
  
 Na przykład jeśli *szerokość* to 80 i określeniu `TAB(90)`, wydruk zostaną uruchomione w kolumnie 10 (w pozostałej części 90/80). Jeśli `Column` jest mniejsza od bieżącej pozycji drukowania, uruchamia drukowanie w następnym wierszu na obliczonej pozycji drukowania. Jeśli obliczonej pozycji drukowania jest większa niż bieżące położenie wydruku, drukowania rozpoczyna się od obliczony drukowanie pozycji w tym samym wierszu.  
  
 Po lewej stronie pozycja drukowania w wierszu wydruku ma zawsze numer 1. Jeśli używasz `Print` lub `PrintLine` funkcje drukowania do plików, po prawej stronie pozycja drukowania jest bieżąca szerokość pliku wyjściowego, którą można ustawić za pomocą `FileWidth` funkcji.  
  
 `TAB` Funkcji można również używać razem `WriteLine` funkcji. Nie można używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> lub <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabel są dostatecznie szerokie, zawierają szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie użyto `TAB` funkcji do pozycjonowania danych wyjściowych w pliku, a w **dane wyjściowe** okna.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalny. Liczba tylko rekordu lub byte, aby zablokować lub odblokować</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalny. Liczba pierwszy rekord lub byte, aby zablokować lub odblokować.</param>
        <param name="ToRecord">Opcjonalny. Liczba ostatnich rekordu lub byte, aby zablokować lub odblokować.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. <see langword="My" /> Funkcja zapewnia lepszą wydajność i wydajności w ramach operacji We/Wy pliku niż <see langword="Lock" /> i <see langword="Unlock" />. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` i `Unlock` funkcje są używane w środowiskach, w której kilka procesów może muszą mieć dostęp do tego samego pliku.  
  
 `Lock` i `Unlock` funkcji zawsze są używane w parach. Argumenty `Lock` i `Unlock` muszą być takie same.  
  
 Jeśli `Record`, lub `FromRecord` i `ToRecord` są nie zostaną podane, blokada będzie cały plik. Jeśli `Record` samodzielnie określono pojedynczy rekord będzie zablokowany odblokowane.  
  
 Jeśli plik został otwarty do sekwencyjnego danych wejściowych lub wyjściowych, `Lock` i `Unlock` mają wpływ na cały plik, niezależnie od tego, w zakresie określonym przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 W tym przykładzie przedstawiono użycie `Lock` i `Unlock` funkcji. W tym przykładzie założono, że `People.txt` plik, który zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Wyrażenie, które zawiera dowolną liczbę prawidłowy plik.</param>
        <param name="Output">Opcjonalny. Co najmniej jednego rozdzielana przecinkami wyrażenia można zapisać do pliku.</param>
        <summary>Zapisuje dane do pliku sekwencyjnych. Dane zapisywane z <see langword="Write" /> jest zwykle do odczytu z pliku za pomocą <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` i `WriteLine` funkcje są udostępniane dla zgodności z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 W przypadku pominięcia `Output`, pusty wiersz jest drukowany w pliku. Wiele wyrażeń mogą być oddzielone przecinkami.  
  
 W odróżnieniu od `Print` funkcji `Write` funkcja wstawia przecinkami między elementami i ciągi w cudzysłowie, ponieważ są one zapisywane do pliku. Nie trzeba umieścić jawne ograniczniki na liście. Gdy `Write` służy do zapisywania danych do pliku, tylko numeryczne `Boolean`, Data, null, i `Error` formaty danych są obsługiwane. Następujące założenia uniwersalnych zostaną wykonane, dane mogą zawsze odczytać i prawidłowo interpretowane przy użyciu `Input`, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane przy użyciu okresu jako separator dziesiętny.  
  
-   Aby uzyskać `Boolean` danych, albo `#TRUE#` lub `#FALSE#` drukowania. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
-   Data dane zostają zapisane do pliku w formacie uniwersalnego daty. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Jeśli nic nie są zapisywane do pliku `Output` danych jest pusta. Jednak w przypadku wartości null danych `#NULL#` są zapisywane.  
  
-   Aby uzyskać `Error` dane, dane wyjściowe są wyświetlane jako `#ERROR errorcode#`. `Error` — Słowo kluczowe nie są tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine` Wstawia znaku nowego wiersza (to znaczy źródła powrotu karetki/wiersza lub `Chr(13) + Chr(10)`), po zostaną zapisane ostatni znak `Output` do pliku.  
  
 Znaki cudzysłowu w ciągu można osadzić przy użyciu podwójnych cudzysłowów prostych, lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg zawierający wartość `Double quotation marks aren't "difficult" to handle`.  
  
 Zapis do pliku przy użyciu `Write` lub `WriteLine` wymaga funkcji `Append` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Write` funkcji do zapisania danych pierwotnych do pliku sekwencyjnych.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Wyrażenie, które zawiera dowolną liczbę prawidłowy plik.</param>
        <param name="Output">Opcjonalny. Co najmniej jednego rozdzielana przecinkami wyrażenia można zapisać do pliku.</param>
        <summary>Zapisuje dane do pliku sekwencyjnych. Dane zapisywane z <see langword="Write" /> jest zwykle do odczytu z pliku za pomocą <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Write` i `WriteLine` funkcje są udostępniane dla zgodności z poprzednimi wersjami i mogą wpływać na wydajność. W przypadku aplikacji starszym `My.Computer.FileSystem` obiektu zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików za pomocą Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 W przypadku pominięcia `Output`, pusty wiersz jest drukowany w pliku. Wiele wyrażeń mogą być oddzielone przecinkami.  
  
 W odróżnieniu od `Print` funkcji `Write` funkcja wstawia przecinkami między elementami i ciągi w cudzysłowie, ponieważ są one zapisywane do pliku. Nie trzeba umieścić jawne ograniczniki na liście. Gdy `Write` służy do zapisywania danych do pliku, tylko numeryczne `Boolean`, Data, null, i `Error` formaty danych są obsługiwane. Następujące założenia uniwersalnych zostaną wykonane, dane mogą zawsze odczytać i prawidłowo interpretowane przy użyciu `Input`, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane przy użyciu okresu jako separator dziesiętny.  
  
-   Aby uzyskać `Boolean` danych, albo `#TRUE#` lub `#FALSE#` drukowania. `True` i `False` słowa kluczowe nie są przekształcane, niezależnie od ustawień regionalnych.  
  
-   Data dane zostają zapisane do pliku w formacie uniwersalnego daty. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Jeśli nic nie są zapisywane do pliku `Output` danych jest pusta. Jednak w przypadku wartości null danych `#NULL#` są zapisywane.  
  
-   Aby uzyskać `Error` dane, dane wyjściowe są wyświetlane jako `#ERROR errorcode#`. `Error` — Słowo kluczowe nie są tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine` Wstawia znaku nowego wiersza (to znaczy źródła powrotu karetki/wiersza lub `Chr(13) + Chr(10)`), po zostaną zapisane ostatni znak `Output` do pliku.  
  
 Znaki cudzysłowu w ciągu można osadzić przy użyciu podwójnych cudzysłowów prostych, lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg zawierający wartość `Double quotation marks aren't "difficult" to handle`.  
  
 Zapis do pliku przy użyciu `Write` lub `WriteLine` wymaga funkcji `Append` dostęp z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess> .  
  
   
  
## Examples  
 W tym przykładzie użyto `Write` funkcji do zapisania danych pierwotnych do pliku sekwencyjnych.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      </Docs>
    </Member>
  </Members>
</Type>
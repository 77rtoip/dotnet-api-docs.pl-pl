<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8affba69c9ea52a1bf3e93c3b9d5d4a2d6fd1f8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69317701" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" /> Moduł zawiera procedury, które są używane do wykonywania operacji na plikach, katalogach i folderach oraz operacje systemu. Ta <see langword="My" /> funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="FileSystem" /> przy użyciu modułu. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten moduł obsługuje słowa kluczowe języka Visual Basic i elementy członkowskie biblioteki wykonawczej, które uzyskują dostęp do plików i folderów.  
  
   
  
## Examples  
 Ten przykład używa funkcji `GetAttr` , aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Katalogi i pliki</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Wejście i wyjście — Podsumowanie</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Słowa kluczowe (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic elementy członkowskie biblioteki wykonawczej</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagany. Wyrażenie ciągu, które identyfikuje katalog lub folder, który zostaje nowym katalogiem domyślnym lub folderem. <paramref name="Path" />może zawierać dysk. Jeśli dysk nie zostanie określony, <see langword="ChDir" /> program zmieni katalog domyślny lub folder na bieżącym dysku.</param>
        <summary>Zmienia bieżący katalog lub folder. Funkcja zapewnia lepszą wydajność i wydajność w przypadku operacji we/wy na plikach <see langword="ChDir" /> niż funkcja. <see langword="My" /> Aby uzyskać więcej informacji, <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir` Funkcja zmienia katalog domyślny, ale nie dysku domyślnego. Na przykład, jeśli dyskiem domyślnym jest C, Poniższa instrukcja zmienia katalog domyślny na dysku D, ale C pozostaje dyskiem domyślnym:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Względne zmiany w katalogu można wprowadzać przez wpisanie dwóch okresów w następujący sposób:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir` Funkcja wymaga uprawnień do kodu niezarządzanego, co może mieć wpływ na wykonywanie w sytuacjach częściowej relacji zaufania. Aby uzyskać więcej informacji, <xref:System.Security.Permissions.SecurityPermission> Zobacz i.  
  
   
  
## Examples  
 Ten przykład używa funkcji `ChDir` , aby zmienić bieżący katalog lub folder.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" />jest puste.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Instrukcje: Analizowanie ścieżek plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Tworzenie, usuwanie i przenoszenie plików i katalogów w Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zmienia bieżący dysk.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagana. Wyrażenie ciągu określające istniejący dysk. Jeśli podasz ciąg o zerowej długości (""), bieżący dysk nie zostanie zmieniony. Jeśli argument jest ciągiem wielokrotnym, <see langword="ChDrive" /> używa tylko pierwszej litery. <paramref name="Drive" /></param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga uprawnień do kodu niezarządzanego, co może mieć wpływ na wykonywanie w sytuacjach częściowej relacji zaufania. Aby uzyskać więcej informacji, <xref:System.Security.Permissions.SecurityPermission> Zobacz i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Ten przykład używa funkcji `ChDrive` , aby zmienić bieżący dysk. Funkcja zgłasza wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Wymagany. Wyrażenie ciągu określające istniejący dysk. Jeśli podasz ciąg o zerowej długości (""), bieżący dysk nie zostanie zmieniony. Jeśli argument jest ciągiem wielokrotnym, <see langword="ChDrive" /> używa tylko pierwszej litery. <paramref name="Drive" /></param>
        <summary>Zmienia bieżący dysk.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive` Funkcja wymaga uprawnień do kodu niezarządzanego, co może mieć wpływ na wykonywanie w sytuacjach częściowej relacji zaufania. Aby uzyskać więcej informacji, <xref:System.Security.Permissions.SecurityPermission> Zobacz i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Ten przykład używa funkcji `ChDrive` , aby zmienić bieżący dysk. Funkcja zgłasza wyjątek, jeśli dysk nie istnieje.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Określono nieprawidłowy dysk lub dysk jest niedostępny.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. Zapewnia lepszą produktywność i wydajność operacji we/wy na plikach niż <see langword="CurDir" />. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. Zapewnia lepszą produktywność i wydajność operacji we/wy na plikach niż <see langword="CurDir" />. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącą ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład używa funkcji `CurDir` , aby zwrócić bieżącą ścieżkę.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Opcjonalny. <see langword="Char" />wyrażenie określające istniejący dysk. Jeśli nie określono dysku lub jeśli <paramref name="Drive" /> jest ciągiem o zerowej długości (""), <see langword="CurDir" /> funkcja zwraca ścieżkę dla bieżącego dysku.</param>
        <summary>Zwraca ciąg reprezentujący bieżącą ścieżkę. Zapewnia lepszą produktywność i wydajność operacji we/wy na plikach niż <see langword="CurDir" />. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Ciąg reprezentujący bieżącą ścieżkę.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład używa funkcji `CurDir` , aby zwrócić bieżącą ścieżkę.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. Zapewnia lepszą wydajność i wydajność operacji we/wy na plikach <see langword="Dir" /> niż funkcja. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. Zapewnia lepszą wydajność i wydajność operacji we/wy na plikach <see langword="Dir" /> niż funkcja. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja obsługuje używanie wielu znaków (`*`) i symboli wieloznacznych (`?`) do określenia wielu plików. `Dir`  
  
 `VbVolume`zwraca etykietę woluminu dla dysku, a nie określoną nazwę pliku.  
  
 Musisz podać `PathName` przy pierwszym `Dir` wywołaniu funkcji. Aby pobrać następny element, można wykonać kolejne wywołania `Dir` funkcji bez parametrów.  
  
> [!IMPORTANT]
>  Aby działać poprawnie `Dir` , funkcja <xref:System.Security.Permissions.FileIOPermissionAccess.Read> wymaga, <xref:System.Security.Permissions.FileIOPermission> aby flagi <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> i zostały przyznane do wykonywania kodu. Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermission>zobacz <xref:System.Security.SecurityException>, i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 Wartości `Attributes` wyliczenia argumentów są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Wartooć. Określa pliki bez atrybutów.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, a także pliki bez atrybutów.|  
|`Hidden`|`vbHidden`|Określa pliki ukryte, a także pliki bez atrybutów.|  
|`System`|`vbSystem`|Określa pliki systemowe, a także pliki bez atrybutów.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli jakikolwiek inny atrybut jest określony, `vbVolume` jest ignorowany.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery, a także pliki bez atrybutów.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic i mogą być używane w dowolnym miejscu w kodzie, a nie rzeczywistymi wartościami.  
  
   
  
## Examples  
 Ten przykład używa funkcji `Dir` , aby sprawdzić, czy istnieją pewne pliki i katalogi.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcjonalny. Wyrażenie ciągu określające nazwę pliku, nazwę katalogu lub folderu lub etykietę woluminu dysku. <see langword="&quot;&quot;" /> Jeśli<paramref name="PathName" /> nie zostanie znaleziony ciąg o zerowej długości ().</param>
        <param name="Pathname">Opcjonalny. Wyrażenie ciągu określające nazwę pliku, nazwę katalogu lub folderu lub etykietę woluminu dysku. <see langword="&quot;&quot;" /> Jeśli<paramref name="Pathname" /> nie zostanie znaleziony ciąg o zerowej długości ().</param>
        <param name="Attributes">Opcjonalny. Wyliczenie lub wyrażenie liczbowe, którego wartość określa atrybuty pliku. W <see langword="Dir" /> przypadku pominięcia zwraca pliki, <paramref name="Pathname" /> które pasują do siebie, ale nie mają atrybutów.</param>
        <summary>Zwraca ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku. Zapewnia lepszą wydajność i wydajność operacji we/wy na plikach <see langword="Dir" /> niż funkcja. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />.</summary>
        <returns>Ciąg reprezentujący nazwę pliku, katalogu lub folderu odpowiadającego określonemu wzorcowi, atrybutowi pliku lub etykietom woluminu dysku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja obsługuje używanie wielu znaków (`*`) i symboli wieloznacznych (`?`) do określenia wielu plików. `Dir`  
 `VbVolume`zwraca etykietę woluminu dla dysku, a nie określoną nazwę pliku.  
 Musisz podać `PathName` przy pierwszym `Dir` wywołaniu funkcji. Aby pobrać następny element, można wykonać kolejne wywołania `Dir` funkcji bez parametrów.  
> [!IMPORTANT]
>  Aby działać poprawnie `Dir` , funkcja <xref:System.Security.Permissions.FileIOPermissionAccess.Read> wymaga, <xref:System.Security.Permissions.FileIOPermission> aby flagi <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> i zostały przyznane do wykonywania kodu. Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermission>zobacz <xref:System.Security.SecurityException>, i [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
 Wartości `Attributes` wyliczenia argumentów są następujące:  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbnormal`|Wartooć. Określa pliki, które nie mają atrybutów.|  
|`ReadOnly`|`vbReadOnly`|Określa pliki tylko do odczytu, oprócz plików, które nie mają atrybutów.|  
|`Hidden`|`vbHidden`|Określa pliki ukryte, oprócz plików, które nie mają atrybutów.|  
|`System`|`vbSystem`|Określa pliki systemowe, oprócz plików, które nie mają atrybutów.|  
|`Volume`|`vbVolume`|Określa etykietę woluminu; Jeśli jakikolwiek inny atrybut jest określony, `vbVolume` jest ignorowany.|  
|`Directory`|`vbDirectory`|Określa katalogi lub foldery, oprócz plików, które nie mają atrybutów.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic i mogą być używane w dowolnym miejscu w kodzie zamiast rzeczywistych wartości.  
## Examples  
 Ten przykład używa funkcji `Dir` , aby sprawdzić, czy istnieją pewne pliki i katalogi.  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawiera dowolny prawidłowy numer pliku.</param>
        <summary>Zwraca wartość <see langword="True" /> logiczną, gdy osiągnięto koniec pliku otwartego dla <see langword="Random" /> lub sekwencyjnego. <see langword="Input" /></summary>
        <returns>Wartość <see langword="True" /> logiczna, gdy zostanie osiągnięty koniec pliku <see langword="Random" /> otwartego lub sekwencyjnego <see langword="Input" /> .</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `EOF` , aby uniknąć wygenerowania błędu przez próba pobrania danych wejściowych poza końcem pliku.  
  
 `EOF` Funkcja zwraca`False` do momentu osiągnięcia końca pliku. W przypadku plików otwartych `Random` dla `Binary` lub dostępu `EOF` program `False` zwraca do momentu `FileGet` , aż Ostatnia wykonana funkcja nie będzie mogła odczytać całego rekordu.  
  
 W przypadku plików otwartych `Binary` na potrzeby dostępu próbuje odczytać plik `Input` za pomocą funkcji, dopóki funkcja `EOF` Return `True` nie wygeneruje błędu. `Loc` `Input` `Get` Używajfunkcji`EOF` i zamiast `EOF` odczytywania plików binarnych za pomocą, lub używać przy użyciu funkcji. `LOF` Program z plikami otwartymi `EOF` dla programu `True` `Output`zawsze zwraca wartość.  
  
   
  
## Examples  
 W tym przykładzie `EOF` funkcja służy do wykrywania końca pliku. W tym przykładzie przyjęto założenie, że `Testfile` jest plikiem tekstowym zawierającym kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" />. Dowolna prawidłowa liczba plików.</param>
        <summary>Zwraca Wyliczenie reprezentujące tryb pliku dla plików otwartych przy użyciu <see langword="FileOpen" /> funkcji. Zapewnia lepszą wydajność i wydajność operacji we/wy na plikach <see langword="FileAttr" /> niż funkcja. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Następujące wartości wyliczenia wskazują tryb dostępu do pliku: 
 <list type="table"><item><term> Wartość 
 </term><description> Tryb 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja zwraca Wyliczenie reprezentujące tryb pliku dla plików otwartych przy użyciu `FileOpen` funkcji.  
  
   
  
## Examples  
 Ten przykład używa funkcji `FileAttr` , aby zwrócić tryb pliku otwartego pliku.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Opcjonalny. Tablica parametrów dla 0 lub więcej kanałów do zamknięcia.</param>
        <summary>Zawiera dane wejściowe/wyjściowe (we/wy) do pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji. <see langword="My" />zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach. Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileClose` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [jak: Odczytywanie tekstu z plików za pomocą](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)StreamReader [, jak: Zapisuj tekst w plikach za pomocą StreamWriter —](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)i [instruktażu: Manipulowanie plikami i katalogami w](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)Visual Basic.  
  
 W przypadku pominięcia `FileNumbers`zostaną zamknięte wszystkie aktywne pliki `FileOpen` otwarte przez funkcję.  
  
 Po zamknięciu plików, które zostały otwarte `Output` dla `Append`lub, końcowy bufor danych wyjściowych jest zapisywana w buforze systemu operacyjnego dla tego pliku. Wszystkie miejsca na bufory skojarzone z zamkniętym plikiem są wydane.  
  
 `FileClose` Gdy funkcja jest wykonywana, skojarzenie pliku z numerem jego pliku zostanie zakończone.  
  
   
  
## Examples  
 W tym przykładzie `FileClose` funkcja służy do zamykania pliku otwartego dla `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" />nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End — Instrukcja</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop — Instrukcja (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Wymagane. Wyrażenie ciągu określające nazwę pliku, który ma zostać skopiowany. <paramref name="Source" />może obejmować katalog lub folder oraz dysk pliku źródłowego.</param>
        <param name="Destination">Wymagane. Wyrażenie ciągu określające nazwę pliku docelowego. <paramref name="Destination" />może obejmować katalog lub folder oraz dysk pliku docelowego.</param>
        <summary>Kopiuje plik. Zapewnia lepszą produktywność i wydajność operacji we/wy na plikach niż <see langword="FileCopy" />. <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz użyć `FileCopy` funkcji w aktualnie otwartym pliku, wystąpi błąd.  
  
 `FileCopy`wymaga pełnego zaufania do pracy na dysku lokalnym.  
  
   
  
## Examples  
 Ten przykład używa `FileCopy` funkcji do kopiowania jednego pliku do innego. Na potrzeby tego przykładu Załóżmy, że `SrcFile` jest plikiem zawierającym dane.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" />lub <paramref name="Destination" /> jest nieprawidłowy lub nie został określony.</exception>
        <exception cref="T:System.IO.IOException">Plik jest już otwarty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Instrukcje: Utwórz kopię pliku w innym katalogu w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Instrukcje: Utwórz kopię pliku w tym samym katalogu w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Instrukcje: Kopiowanie katalogu do innego katalogu w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. Wyrażenie ciągu określające nazwę pliku. <paramref name="PathName" />może obejmować katalog lub folder, a także dysk.</param>
        <summary><see langword="Date" /> Zwraca wartość wskazującą datę i godzinę zapisania pliku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileDateTime" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></summary>
        <returns><see langword="Date" />wartość, która wskazuje datę i godzinę utworzenia lub ostatniej modyfikacji pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład używa funkcji `FileDateTime` , aby określić datę i godzinę utworzenia lub ostatniej modyfikacji pliku. Format wyświetlanej daty i godziny zależy od ustawień regionalnych systemu.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" />jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu`FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany. Następnie rozmiar i granice tablicy przekazały `FileGet` się, aby określić, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku z `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program`FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu`FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać dwubajtowy deskryptor dla ciągu, który opisuje długość. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <param name="ArrayIsDynamic">Opcjonalna. Ma zastosowanie tylko w przypadku pisania tablicy. Określa, czy tablica ma być traktowana jako dynamiczna, oraz czy konieczne jest określenie deskryptora tablicy opisującego rozmiar i granice tablicy.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać dwubajtowy deskryptor dla ciągu, który opisuje długość. Wartość domyślna to <see langword="False" />.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGet" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGet` dane są zwykle zapisywane w pliku przy użyciu `FilePut`.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji (lub wskazywanym przez ostatnią `Seek` funkcję) jest odczytywany.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGet` odczytuje kolejne rekordy w granicach długości rekordu. Miejsce między końcem jednego rekordu a początkiem następnego rekordu jest uzupełnione istniejącą zawartością buforu pliku. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Domyślnie, jeśli zmienna, do której jest odczytywany, jest ciągiem `FileGet` , odczytuje deskryptor dwubajtowy, który zawiera długość ciągu, a następnie odczytuje dane, które są przechowywane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Program Visual Basic 6.0 i jego starsze wersje obsługują ciągi o stałej długości; przy wprowadzaniu do pliku, deskryptor długości nie jest zapisywany. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli wczytywana zmienna jest tablicą, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas odczytywania tablicy należy dopasować sposób zapisu tablicy. Jeśli został on zapisany z deskryptorem, należy odczytać deskryptor. Jeśli deskryptor nie jest używany, rozmiar i granice tablicy są przesyłane w `FileGet` celu określenia, co należy odczytać.  
  
     Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób:  
  
    -   18 bajtów dla deskryptora: (2 + 8 * 2)  
  
    -   200 bajtów dla danych: (5 * 10 * 4).  
  
-   Jeśli zmienna, do której jest odczytywany, jest dowolnym innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem `FileGet` ), odczytuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości odczytywanych danych.  
  
-   `FileGet`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePut`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów. Obejmuje to wszystkie tablice i ich deskryptory. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGet`odczytuje ze sobą wszystkie zmienne z dysku; oznacza to, że bez uzupełniania między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGet` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
-   `FileGet`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
    > [!IMPORTANT]
    >  Odczytywanie z pliku przy użyciu `FileGet` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, do której wczytywane są dane.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), w którym rozpocznie się odczytywanie.</param>
        <summary>Wczytuje dane z otwartego pliku dysku do zmiennej.  Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileGetObject" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Integer` `Object` `Long` `Short`Funkcja jest używana `FileGet` zamiast, aby uniknąć niejasności w czasie kompilacji, jeśli typ jest zwracany zamiast innego typu, takiego jak,, i tak dalej. `FileGetObject`  
  
 Jeśli zamierzasz napisać `Variant` typ, `FileGetObject` jest wymagany. Gdy jest to możliwe, jeśli używasz obiektu dla drugiego parametru, zawsze jest Sugerowane użycie `FilePutObject` i. `FileGetObject`  
  
 `FileGetObject`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Odczytane `FileGetObject` dane są zwykle zapisywane `FilePutObject`z.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W `RecordNumber`przypadku pominięcia `Seek` program `FileGetObject` odczytuje rekord lub bajt po ostatnim `FileGetObject` lub `FilePutObject` funkcji (lub wskazywane przez ostatnią funkcję).  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość odczytywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FileGetObject` odczytuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest uzupełniony do istniejącej zawartości buforu pliku. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to dobrym pomysłem jest, że długość rekordu jest zgodna z długością odczytywanych danych.  
  
-   Jeśli zmienna, do której jest odczytywany, jest ciągiem, `FileGetObject` domyślnie odczytuje dwubajtowy deskryptor zawierający długość ciągu, a następnie odczytuje dane, które są umieszczane w zmiennej. W związku z tym, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu. Visual Basic 6,0 i wcześniejsze wersje obsługują ciągi o stałej długości i podczas odczytu do pliku, deskryptor długości nie jest zapisywana. Jeśli chcesz odczytać ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg, w którym czytasz, powinien być poprawną długością.  
  
-   Jeśli zmienna, do której jest odczytywany, jest tablicą, Długość rekordu określana `RecordLength` przez parametr `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: 2 + 8 * NumberOfDimensions.  
  
     Na przykład następująca deklaracja tablicy wymaga 218 bajtów, gdy tablica jest zapisywana na dysku:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 bajtów zostało rozdzielonych w następujący sposób: 18 bajtów dla deskryptora (2 + 8 * 2) i 100 bajtów dla danych (5 * 10 * 4).  
  
-   `FileGetObject`odczytuje elementy struktur tak, jakby były odczytywane indywidualnie, z tą różnicą, że nie ma dopełnienia między elementami. Na dysku dynamiczna tablica w typie zdefiniowanym przez użytkownika (z `FilePutObject`prefiksem) jest poprzedzona przez deskryptor, którego długość jest równa 2 plus 8 razy liczba wymiarów: 2 + 8 * NumberOfDimensions. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do odczytania poszczególnych elementów, w tym dowolnych tablic i ich deskryptorów. <xref:Microsoft.VisualBasic.VBFixedStringAttribute> Klasa może być stosowana do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie wszystkie `Random` reguły mają zastosowanie z następującymi wyjątkami:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FileGetObject`odczytuje wszystkie zmienne z dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   Dla każdej tablicy innej niż tablica w strukturze program `FileGetObject` odczytuje tylko dane. Deskryptor nie jest odczytywany.  
  
 `FileGetObject`odczytuje ciągi o zmiennej długości, które nie są elementami struktur bez oczekiwania deskryptora długości dwubajtowej. Liczba bajtów odczytanych jest równa liczbie znaków znajdujących się już w ciągu.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1. vb nie może być plikiem źródłowym Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład odczytuje rekord do pliku testowego, a następnie pobiera go.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagane. Wyrażenie ciągu określające plik. <paramref name="PathName" />może obejmować katalog lub folder, a także dysk.</param>
        <summary>Zwraca wartość określającą długość pliku w bajtach. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileLen" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Długość pliku w bajtach.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony plik jest otwarty, gdy `FileLen` wywoływana jest funkcja, zwracana wartość reprezentuje rozmiar pliku w momencie otwarcia.  
  
> [!NOTE]
>  Aby uzyskać bieżącą długość otwartego pliku, użyj `LOF` funkcji.  
  
   
  
## Examples  
 Ten przykład używa funkcji `FileLen` , aby zwrócić długość pliku w bajtach. Na potrzeby tego przykładu Załóżmy, że `TestFile` jest plikiem zawierającym pewne dane.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Plik nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików. Użyj funkcji <see langword="FreeFile" /> , aby uzyskać następny dostępny numer pliku.</param>
        <param name="FileName">Wymagany. Wyrażenie ciągu określające nazwę pliku — może zawierać katalog lub folder i dysk.</param>
        <param name="Mode">Wymagana. Wyliczenie określające tryb pliku: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" /> <see langword="Output" />, lub <see langword="Random" />. Aby uzyskać więcej informacji, <see cref="T:Microsoft.VisualBasic.OpenMode" /> Zobacz.</param>
        <param name="Access">Opcjonalny. Wyliczenie określające operacje dozwolone w otwartym pliku: <see langword="Read" />, <see langword="Write" />, lub <see langword="ReadWrite" />. Wartość domyślna to <see langword="ReadWrite" />. Aby uzyskać więcej informacji, <see cref="T:Microsoft.VisualBasic.OpenAccess" /> Zobacz.</param>
        <param name="Share">Opcjonalny. Wyliczenie określające operacje niedozwolone w otwartym pliku przez inne procesy: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, i <see langword="Lock Read Write" />. Wartość domyślna to <see langword="Lock Read Write" />. Aby uzyskać więcej informacji, <see cref="T:Microsoft.VisualBasic.OpenShare" /> Zobacz.</param>
        <param name="RecordLength">Opcjonalna. Liczba mniejsza lub równa 32 767 (bajty). W przypadku plików otwartych dla dostępu losowego ta wartość jest długością rekordu. W przypadku sekwencyjnych plików ta wartość jest liczbą znaków w buforze.</param>
        <summary>Otwiera plik dla danych wejściowych lub wyjściowych. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileOpen" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileOpen` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Aby można było wykonać operację we/wy, należy otworzyć plik. `FileOpen`przydziela bufor dla operacji we/wy do pliku i określa tryb dostępu do użycia z buforem.  
  
> [!IMPORTANT]
>  Podczas zapisywania do pliku aplikacja może mieć możliwość utworzenia pliku, jeśli plik, do którego ma nastąpić zapis, nie istnieje. W tym celu musi mieć uprawnienia do katalogu, w którym ma zostać utworzony plik. Jeśli jednak plik określony przez `FileName` istnieje, aplikacja musi mieć `Write` uprawnienia tylko do samego pliku. Gdy to możliwe, aby zwiększyć bezpieczeństwo, należy utworzyć plik podczas wdrażania i udzielić `Write` uprawnienia tylko do tego pliku, a nie do całego katalogu. Aby zwiększyć bezpieczeństwo, Zapisz dane w katalogach użytkowników, a nie w katalogu głównym lub w katalogu Program Files.  
  
 Kanał do otwarcia można znaleźć za pomocą `FreeFile()` funkcji.  
  
> [!IMPORTANT]
>  Funkcja wymaga `Read` dostępu z`FileIOPermissionAccess` wyliczenia, co może mieć wpływ na wykonywanie w częściowej sytuacji zaufania. `FileOpen` Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermissionAccess> zobacz Wyliczenie.  
  
   
  
## Examples  
 Ten przykład ilustruje różne zastosowania `FileOpen` funkcji w celu włączenia danych wejściowych i wyjściowych do pliku.  
  
 Poniższy kod otwiera plik `TestFile` w `Input` trybie.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Ten przykład otwiera plik w `Binary` trybie tylko do zapisywania operacji.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 Poniższy przykład otwiera plik w `Random` trybie. Plik zawiera rekordy struktury `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Ten przykład kodu otwiera plik w `Output` trybie; każdy proces może odczytywać lub zapisywać plik.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Ten przykład kodu otwiera plik w `Binary` trybie do odczytu; inne procesy nie mogą odczytać pliku.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Długość rekordu jest ujemna (a nie równa-1).</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" />jest już otwarty lub <paramref name="FileName" /> jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> F Aby uzyskać więcej informacji, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />Zobacz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy`VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalna. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w`RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać dwubajtowy deskryptor długości ciągu dla ciągu do pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <param name="ArrayIsDynamic">Opcjonalna. Ma zastosowanie tylko w przypadku pisania tablicy. Określa, czy tablica ma być traktowana jako dynamiczna, oraz czy należy napisać deskryptor tablicy dla ciągu opisującego długość.</param>
        <param name="StringIsFixedLength">Opcjonalny. Stosuje się tylko przy pisaniu ciągów. Określa, czy należy napisać dwubajtowy deskryptor długości ciągu dla ciągu do pliku. Wartość domyślna to <see langword="False" />.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePut" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePut` programie są zwykle odczytywane z pliku przy `FileGet`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. Jeśli pominięto `RecordNumber`, następny rekord lub bajt po ostatnim `FileGet` lub `FilePut` funkcji lub wskazywanym przez ostatnią `Seek` funkcję jest zapisywana.  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePut`nie zapisuje deskryptora długości, gdy argument jest `True`. `StringIsFixedLength` Jeśliużywasz`FilePut` `FileGet`programu z programem, musisz wykonać te same czynności z programem, aby upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  =   
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePut` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, to zazwyczaj dobrze jest, gdy długość rekordu jest zgodna z długością zapisanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zostanie zgłoszony wyjątek.  
  
-   Jeśli zmienna jest zapisywana, `FilePut` zapisuje dwubajtowy deskryptor, który zawiera długość ciągu, a następnie zapisuje dane, które są przechowywane w zmiennej. W związku z tym długość rekordu określana `RecordLength` przez klauzulę `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista długość ciągu.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePut` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePut` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePut` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeżeli zapisywaną zmienną jest tablica, można wybrać, czy odczytać deskryptor, by uzyskać informacje o wielkości i wymiarze tablicy. Visual Basic 6.0 i starsze wersje zapisują deskryptor plików dla tablic dynamicznych, bez uwzględniania tablicy o stałym rozmiarze. Według domyślnych ustawień programu Visual Basic 2005 deskryptor nie jest zapisywany. Aby zapisać deskryptor, ustaw `ArrayIsDynamic` parametr na. `True` Podczas zapisywania tablicy należy dopasować sposób odczytywania tablicy; jeśli będzie odczytywana z deskryptorem, należy napisać deskryptor. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions). Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Na przykład następująca deklaracja tablicy wymaga 218 bajtów, jeśli tablica zapisywana jest na dysku.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Jeśli zapisywana zmienna jest jakimkolwiek innym typem zmiennej (a nie ciągiem o zmiennej długości czy obiektem), program `FilePut` zapisuje tylko dane zmienne. Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa długości zapisywanych danych.  
  
-   `FilePut`Zapisuje elementy struktur tak, jakby każda została zapisywana pojedynczo, z tą różnicą, że nie istnieje uzupełnienie między elementami. Ten `VBFixedString` atrybut może być stosowany do pól ciągu w strukturach, aby wskazać rozmiar ciągu podczas zapisywania na dysku.  
  
    > [!NOTE]
    >  Pola ciągów, które mają więcej bajtów niż określa `VBFixedString` atrybut, są obcinane podczas zapisywania na dysku,  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie większość `Random` reguł trybu ma zastosowanie z pewnymi wyjątkami. Następujące reguły dla plików otwartych w `Binary` trybie różnią się w zależności od zasad dla `Random` trybu:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePut`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
-   W przypadku każdej tablicy innej niż tablica w strukturze program `FilePut` zapisuje tylko dane. Deskryptor nie jest zapisywany.  
  
-   `FilePut`zapisuje ciągi o zmiennej długości, które nie są elementami struktur bez deskryptora długości dwubajtowej. Liczba bajtów zapisanych jest równa liczbie znaków znajdujących się już w ciągu. Na przykład poniższe instrukcje zapisują 11 bajtów do pliku numer 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   Zapis w pliku przy użyciu `FilePut` funkcji wymaga `Write` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 W tym przykładzie `FilePut` funkcja służy do zapisywania danych do pliku. W pliku Zapisano pięć rekordów `Person` struktury.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" />&lt; 1 i nie równa-1.</exception>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Prawidłowa nazwa zmiennej, która zawiera dane zapisane na dysku.</param>
        <param name="RecordNumber">Opcjonalny. Numer rekordu (<see langword="Random" /> pliki trybu) lub liczba bajtów (<see langword="Binary" /> pliki trybu), które zaczynają pisać.</param>
        <summary>Zapisuje dane ze zmiennej do pliku na dysku.  Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FilePutObject" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Integer` `Object` `Long` `Short`Funkcja jest używana `FilePut` zamiast, aby uniknąć niejasności w czasie kompilacji, jeśli typ jest przekazywać zamiast innego typu, takiego jak,, i tak dalej. `FilePutObject`  
  
 `FilePutObject`zapisuje i odczytuje deskryptory opisujące obiekt. Jeśli zamierzasz napisać `Variant` typ, `FilePutObject` jest wymagany. W razie wątpliwości, jeśli używasz obiektu dla drugiego parametru, zalecamy, aby zawsze używać `FilePutObject` i. `FileGetObject`  
  
 `FilePutObject`jest prawidłowy tylko w `Random` trybie `Binary` i.  
  
 Dane zapisywane w `FilePutObject` programie są zwykle odczytywane z pliku przy `FileGetObject`użyciu.  
  
 Pierwszy rekord lub bajt w pliku znajduje się na pozycji 1, drugi rekord lub bajt na pozycji 2 i tak dalej. W `RecordNumber`przypadku pominięcia `Seek` program `FilePutObject` zapisuje następny rekord lub bajt po ostatniej `FileGetObject` lub `FilePutObject` funkcji (lub rekordu lub bajtu wskazywanym przez ostatnią funkcję).  
  
 `StringIsFixedLength` Argument kontroluje, czy funkcja interpretuje ciągi jako zmienną lub stałą długość. `FilePutObject`nie zapisuje deskryptora długości, gdy argument jest `True`. W przypadku korzystania `StringIsFixedLength`  =  `FilePutObject` `FileGetObject`z programu z programem należy wykonać te same czynności w programie, a ponadto należy upewnić się, że ciąg jest zainicjowany do oczekiwanej długości. `True`  
  
## <a name="random-mode"></a>Tryb losowy  
 W przypadku plików otwartych `Random` w trybie są stosowane następujące reguły:  
  
-   Jeśli długość zapisywanych danych jest mniejsza niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, program `FilePutObject` zapisuje kolejne rekordy w granicach długości rekordu. Odstęp między końcem jednego rekordu a początkiem następnego rekordu jest wypełniany istniejącą zawartością buforu plików. Ponieważ ilości danych uzupełniania nie można dokładnie określić, zazwyczaj dobrym pomysłem jest, aby długość rekordu była zgodna z długością zapisywanych danych. Jeśli długość zapisywanych danych jest większa niż długość określona w `RecordLength` klauzuli `FileOpen` funkcji, zgłaszany jest wyjątek.  
  
-   Jeśli zmienna, która jest zapisywana, jest obiektem, który zawiera `FilePutObject` typ liczbowy, zapisuje dwa `VarType` bajty identyfikujące obiekt, a następnie zapisuje zmienną. Na przykład podczas pisania obiektu, który zawiera liczbę całkowitą, program `FilePutObject` zapisuje sześć bajtów: dwa bajty, które identyfikują `VarType(3)` obiekt`Integer`jako () i cztery bajty zawierające dane. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej dwa bajty większe niż rzeczywista liczba bajtów wymagana do przechowania zmiennej.  
  
-   Jeśli zmienna zapisywana jest obiektem, który zawiera ciąg, `FilePutObject` Zapisuje deskryptor dwubajtowy `VarType(8)` identyfikujący obiekt, deskryptor dwubajtowy wskazujący długość ciągu, a następnie zapisuje dane ciągu. Długość rekordu określana przez `RecordLength` parametr `FileOpen` w funkcji musi być co najmniej cztery bajty większą niż rzeczywista długość ciągu. Jeśli chcesz umieścić ciąg bez deskryptora, należy przekazać `True` `StringIsFixedLength` do parametru, a ciąg odczytywany powinien być poprawną długością.  
  
-   Jeśli zmienna zapisywana jest tablicą, Długość rekordu określana przez `RecordLength` klauzulę `FileOpen` w funkcji musi być większa lub równa sumie wszystkich bajtów wymaganych do zapisania danych tablicowych i deskryptora tablicy. Deskryptor określa rangę tablicy, rozmiar i dolne granice dla każdej rangi. Jego długość jest równa 2 plus 8 razy liczba wymiarów: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Tryb binarny  
 W przypadku plików otwartych `Binary` w trybie wszystkie reguły `Random` trybu są stosowane, z wyjątkiem:  
  
-   `RecordLength` Klauzula`FileOpen` w funkcji nie ma żadnego wpływu. `FilePutObject`zapisuje wszystkie zmienne na dysku w sposób ciągły, czyli bez dopełnienia między rekordami.  
  
   
  
## Examples  
 Ten przykład używa funkcji `FilePutObject` , aby napisać ciąg do pliku.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="RecordWidth">Wymagana. Wyrażenie liczbowe w zakresie 0-255, włącznie, które wskazuje liczbę znaków wyświetlanych w wierszu przed rozpoczęciem nowego wiersza. Jeśli <paramref name="RecordWidth" /> wartość jest równa 0, nie ma limitu długości wiersza. Wartość domyślna dla <paramref name="RecordWidth" /> jest równa 0.</param>
        <summary>Przypisuje szerokość linii wyjściowej do pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Ten przykład używa funkcji `FileWidth` , aby ustawić szerokość linii wyjściowej dla pliku.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość reprezentującą następny numer pliku, który jest dostępny do użycia <see langword="FileOpen" /> przez funkcję. <see langword="Integer" /></summary>
        <returns>Wartość całkowita, która reprezentuje następny numer pliku, który jest dostępny do użycia <see langword="FileOpen" /> przez funkcję.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `FreeFile` , aby podać numer pliku, który nie jest jeszcze używany.  
  
   
  
## Examples  
 Ten przykład używa funkcji `FreeFile` , aby zwrócić następny dostępny numer pliku. Do danych wyjściowych w pętli są otwierane pięć plików, a niektóre przykładowe dane są zapisywane w każdym z nich.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Więcej niż 255 plików jest używanych.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. Wyrażenie ciągu określające nazwę pliku, katalogu lub folderu. <paramref name="PathName" />może obejmować katalog lub folder, a także dysk.</param>
        <summary><see langword="FileAttribute" /> Zwraca wartość, która reprezentuje atrybuty pliku, katalogu lub folderu. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="FileAttribute" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Bitowe połączenie wartości wyliczenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić, które atrybuty są ustawione, użyj `And` operatora, aby wykonać bitowe porównanie wartości zwracanej `GetAttr` przez funkcję i wartość określonego atrybutu pliku. Jeśli wynik jest różny od zera, ten atrybut jest ustawiany dla nazwanego pliku. Na przykład zwracaną wartością następującego `And` wyrażenia jest zero, `Archive` Jeśli atrybut nie jest ustawiony:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Wartość różna od zera jest zwracana, `Archive` Jeśli atrybut jest ustawiony.  
  
   
  
## Examples  
 Ten przykład używa funkcji `GetAttr` , aby określić atrybuty pliku i katalogu lub folderu.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" />jest nieprawidłowa lub zawiera symbole wieloznaczne.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Plik docelowy nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And — Operator (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera pewne wiersze danych, `Write` za pomocą funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera pewne wiersze danych, `Write` za pomocą funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagana. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej, jeśli wprowadzasz 3, 14159, zwraca tylko 3, ponieważ przecinek jest traktowany jako separator zmiennej, a nie jako punkt dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagany. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Value">Wymagane. Zmienna, do której przypisano wartości odczytane z pliku — nie może być tablicą ani zmienną obiektu.</param>
        <summary>Wczytuje dane z otwartego pliku sekwencyjnego i przypisuje dane do zmiennych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Input` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `Input` dane są zwykle zapisywane w pliku przy użyciu `Write`. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic 2005.  
  
 Podczas odczytu ciąg standardowy lub dane liczbowe przypisywane są do zmiennych bez żadnych modyfikacji. Następująca tabela ilustruje, jak postępować z innymi danymi wejściowymi.  
  
|Dane|Wartość przypisana do zmiennej|  
|-|-|  
|Przecinek rozdzielający lub pusty wiersz|Pusty|  
|#NULL #|`DBNull`|  
|#PRAWDA # lub #FAŁSZ #|`True` lub `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|Data i/lub godzina reprezentowana przez wyrażenie|  
|#ERROR`errornumber`#|`errornumber`(zmienna jest obiektem oznaczonym jako błąd)|  
  
 Jeśli dojdziesz do końca pliku, w trakcie wprowadzania elementu danych, dane wejściowe zostaną zatrzymane i wystąpi błąd.  
  
> [!NOTE]
>  `Input` Funkcja nie jest zlokalizowana. Na przykład w wersji niemieckiej wpisanie wartości 3,14159 spowoduje zwrócenie liczby 3, ponieważ przecinek jest traktowany jako separator zmiennej a nie jako separator dziesiętny.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `Input` funkcji wymaga `Read` dostępu z `FileIOPermissionAccess` wyliczenia. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 W tym przykładzie `Input` funkcja służy do odczytywania danych z pliku w dwóch zmiennych. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem, który zawiera kilka wierszy danych, `Write` przy użyciu funkcji, każdy wiersz zawierający ciąg w cudzysłowach i liczbę oddzieloną przecinkami, na przykład: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="CharCount">Wymagany. Dowolne prawidłowe wyrażenie liczbowe określające liczbę znaków do odczytania.</param>
        <summary>Zwraca <see langword="String" /> wartość zawierającą znaki z pliku otwartego w <see langword="Input" /> trybie <see langword="Binary" /> lub. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="InputString" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Ciąg zawierający znaki z pliku otwartego w lub <see langword="Input" /> <see langword="Binary" /> w trybie. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="InputString" />operacjach we/wy na plikach. <see langword="My" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InputString` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dane odczytane `InputString` za pomocą funkcji są zwykle zapisywane w pliku przy `Print` użyciu `FilePut`lub. Tej funkcji należy używać tylko z plikami otwartymi `Binary` w `Input` trybie lub.  
  
 `Input` W`InputString` przeciwieństwie do funkcji, funkcja zwraca wszystkie znaki, które odczytuje. Dotyczy to przecinków, znaków powrotu karetki, znaków cudzysłowu i spacji wiodących.  
  
 W przypadku plików otwartych `Binary` na potrzeby dostępu próbuje odczytać plik za `InputString` pomocą funkcji, dopóki funkcja Return `EOF` `True` nie wygeneruje błędu. `Loc` `InputString` `FileGet` `EOF` Użyj funkcji `LOF` i zamiast`EOF` podczas odczytywania plików binarnych za pomocą, lub użyj podczas korzystania z funkcji.  
  
> [!NOTE]
>  Podczas odczytywania z plików nie należy podejmować decyzji dotyczących zabezpieczeń dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1. vb nie może być plikiem źródłowym Visual Basic.  
  
   
  
## Examples  
 Ten przykład używa funkcji `InputString` , aby odczytać jeden znak na raz z pliku i wydrukować go `Output` w oknie. W tym przykładzie przyjęto założenie, że `MyFile` jest plikiem tekstowym, który zawiera kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" />nie istnieje.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" />&lt; 0 lub&gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagane. Wyrażenie ciągu określające co najmniej jedną nazwę pliku do usunięcia. <paramref name="PathName" />może obejmować katalog lub folder, a także dysk.</param>
        <summary>Usuwa pliki z dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Kill" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> Zobacz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill`obsługuje używanie wielu znaków (`*`) i symboli wieloznacznych (`?`) do określenia wielu plików.  
  
 **Uwaga dotycząca zabezpieczeń** Aby można `Kill` było wykonać, funkcja wymaga `Read` i `PathDiscovery` flags <xref:System.Security.Permissions.FileIOPermission> , aby zostać przyznany kod wykonywany. Aby uzyskać więcej informacji, <xref:System.Security.SecurityException>zobacz [uprawnienia dostępu kodu](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Ten przykład używa funkcji `Kill` , aby usunąć plik z dysku.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Pliki docelowe zostały otwarte.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono plików docelowych.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Odczytuje pojedynczy wiersz z otwartego sekwencyjnego pliku i przypisuje go do <see langword="String" /> zmiennej.</summary>
        <returns>Odczytuje pojedynczy wiersz z otwartego sekwencyjnego pliku i przypisuje go do <see langword="String" /> zmiennej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `LineInput` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Odczytane `LineInput` dane są zwykle zapisywane w pliku przy użyciu `Print`.  
  
> [!IMPORTANT]
>  Podczas odczytu z plików, nie należy podejmować decyzji dotyczących zawartości pliku na podstawie rozszerzenia nazwy pliku. Na przykład plik o nazwie Form1.vb nie może być plikiem źródłowym programu Visual Basic.  
  
 Funkcja odczytuje z pliku jeden znak naraz do momentu napotkania powrotu karetki (`Chr(13)`) lub powrotu karetki/wysuwu wiersza (`Chr(13) + Chr(10)`). `LineInput` Sekwencje powrotu karetki i wysuwu wiersza są pomijane zamiast dołączane do ciągu znaków.  
  
> [!IMPORTANT]
>  Odczytywanie z pliku przy użyciu `LineInput` funkcji wymaga `Read` dostępu z <xref:System.Security.Permissions.FileIOPermissionAccess> wyliczenia.  
  
   
  
## Examples  
 Ten przykład używa funkcji `LineInput` , aby odczytać wiersz z sekwencyjnego pliku i przypisać go do zmiennej. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem tekstowym, który zawiera kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Osiągnięto koniec pliku.</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" />nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolny prawidłowy <see langword="Integer" /> numer pliku.</param>
        <summary>Zwraca wartość określającą bieżącą pozycję odczytu/zapisu w otwartym pliku.</summary>
        <returns>Bieżąca pozycja odczytu/zapisu w otwartym pliku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc` Funkcja jest zależna od zera; użycie jej do pobrania pierwszego bajtu w pliku zwróci wartość 0.  
  
 `Loc` Funkcja jest zapewniana w celu zapewnienia zgodności z poprzednimi wersjami i może mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Poniżej opisano wartość zwracaną dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Numer ostatniego rekordu odczytanego lub zarejestrowanego w pliku.|  
|`Sequential`|Bieżąca pozycja bajtu w pliku podzielona przez 128. Jednak informacje zwracane przez dla `Loc` sekwencyjnych plików nie są ani używane, ani wymagane.|  
|`Binary`|Pozycja ostatniego bajtu odczytu lub zapisu.|  
  
   
  
## Examples  
 Ten przykład używa funkcji `Loc` , aby zwrócić bieżącą pozycję odczytu/zapisu w otwartym pliku. W tym przykładzie przyjęto założenie, że `MyFile` jest plikiem tekstowym, który zawiera kilka wierszy przykładowych danych.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalny. Numer jedynego rekordu lub bajtu do zablokowania lub odblokowania.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalny. Numer pierwszego rekordu lub bajtu do zablokowania lub odblokowania.</param>
        <param name="ToRecord">Opcjonalny. Numer ostatniego rekordu lub bajtu do zablokowania lub odblokowania.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Liczba całkowita, która zawiera prawidłowy numer pliku.</param>
        <summary>Zwraca rozmiar (w bajtach) pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="LOF" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Rozmiar pliku otwartego przy użyciu <see langword="FileOpen" /> funkcji w bajtach. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="LOF" />operacjach we/wy na plikach. <see langword="My" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj funkcji `FileLen` , aby uzyskać długość pliku, który nie jest otwarty.  
  
   
  
## Examples  
 Ten przykład używa funkcji `LOF` , aby określić rozmiar otwartego pliku. W tym przykładzie przyjęto założenie, że `TestFile` jest plikiem tekstowym zawierającym przykładowe dane.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagane. Wyrażenie ciągu, które identyfikuje katalog, który ma zostać utworzony. <paramref name="Path" /> Może to być dysk. Jeśli dysk nie zostanie określony, <see langword="MkDir" /> program tworzy nowy katalog na bieżącym dysku.</param>
        <summary>Tworzy nowy katalog. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="MkDir" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta funkcja tworzy nowy katalog.  
  
   
  
## Examples  
 Ten przykład używa `MkDir` funkcji do utworzenia katalogu. Jeśli stacja dysków nie jest określona, nowy katalog zostanie utworzony na bieżącym dysku.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" />nie została określona lub jest pusta.</exception>
        <exception cref="T:System.Security.SecurityException">Odmowa uprawnień.</exception>
        <exception cref="T:System.IO.IOException">Katalog już istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Instrukcje: Tworzenie katalogu w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalny. Zero lub więcej wyrażeń rozdzielanych przecinkami do zapisu w pliku.  
  
Ustawienia <paramref name="Output" /> argumentu są następujące: 
 <see langword="T:System.IO.IOException" />: Tryb pliku jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> nie istnieje.</param>
        <summary>Zapisuje dane w formacie wyświetlanym w postaci sekwencyjnego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje `Print` i`PrintLine` są dostępne w celu zapewnienia zgodności z poprzednimi wersjami i mogą mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print`nie zawiera kanału informacyjnego wiersza na końcu wiersza; Jednak program `PrintLine` zawiera znak wysuwu wiersza.  
  
 Dane zapisywane w `Print` programie są zwykle odczytywane z pliku przy `LineInput` użyciu `Input`lub.  
  
 Jeśli pominięto `Output` dla `PrintLine`, pusty wiersz jest drukowany do pliku; w przypadku `Print`, nic nie jest wyjściowe. Wiele wyrażeń oddzielonych przecinkami będzie wyrównanych na granicach tabulacji, ale `TAB` mogą być nastosowane niespójne wyniki.  
  
 Dla `Boolean` danych `True` , lub`False` jest drukowana. Słowa kluczowe `False` i nie są tłumaczone, niezależnie od ustawień regionalnych. `True`  
  
 Dane daty są zapisywane w pliku przy użyciu standardowego formatu daty krótkiej rozpoznawanego przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Żadne elementy nie są zapisywane w pliku `Output` , jeśli dane są puste. Jeśli `Output` jednak lista zawiera `DBNull`dane, `Null` jest zapisywana w pliku.  
  
 W `Error` przypadku danych dane wyjściowe są wyświetlane `Error errorcode`jako. `Error` Słowo kluczowe nie jest tłumaczone niezależnie od ustawień regionalnych.  
  
 Wszystkie dane, które są zapisywane w pliku `Print` przy użyciu, są oparte na międzynarodowej. oznacza to, że dane są poprawnie sformatowane przy użyciu odpowiedniego separatora dziesiętnego. Jeśli użytkownik chce, aby dane wyjściowe były używane przez wiele ustawień regionalnych, `Write` należy użyć.  
  
 Zapis `Print` w pliku przy użyciu `PrintLine` funkcjilub`Write` wymaga dostępu z wyliczenia.`FileIOPermissionAccess` Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermissionAccess> Zobacz.  
  
   
  
## Examples  
 W tym przykładzie funkcja `Print` i `PrintLine` służy do zapisywania danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="Output">Opcjonalna. Zero lub więcej wyrażeń rozdzielanych przecinkami do zapisu w pliku.  
  
Ustawienia <paramref name="Output" /> argumentu są następujące: 
 <see langword="T:System.IO.IOException" />: Tryb pliku jest nieprawidłowy.  
  
 <see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> nie istnieje.</param>
        <summary>Zapisuje dane w formacie wyświetlanym w postaci sekwencyjnego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje `Print` i`PrintLine` są dostępne w celu zapewnienia zgodności z poprzednimi wersjami i mogą mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print`nie zawiera kanału informacyjnego wiersza na końcu wiersza; Jednak program`PrintLine` zawiera znak wysuwu wiersza.  
  
 Dane zapisywane w `Print` programie są zwykle odczytywane z pliku przy `LineInput` użyciu `Input`lub.  
  
 Jeśli pominięto `Output` dla `PrintLine`, pusty wiersz jest drukowany do pliku; w przypadku `Print`, nic nie jest wyjściowe. Wiele wyrażeń oddzielonych przecinkami będzie wyrównanych na granicach tabulacji, ale `TAB` mogą być nastosowane niespójne wyniki.  
  
 Dla `Boolean` danych `True` , lub`False` jest drukowana. Słowa kluczowe `False` i nie są tłumaczone, niezależnie od ustawień regionalnych. `True`  
  
 Dane daty są zapisywane w pliku przy użyciu standardowego formatu daty krótkiej rozpoznawanego przez system. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
 Żadne elementy nie są zapisywane w pliku `Output` , jeśli dane są puste. Jeśli `Output` jednak lista zawiera `DBNull`dane, `Null` jest zapisywana w pliku.  
  
 W `Error` przypadku danych dane wyjściowe są wyświetlane `Error errorcode`jako. `Error` Słowo kluczowe nie jest tłumaczone niezależnie od ustawień regionalnych.  
  
 Wszystkie dane, które są zapisywane w pliku `Print` przy użyciu, są oparte na międzynarodowej. oznacza to, że dane są poprawnie sformatowane przy użyciu odpowiedniego separatora dziesiętnego. Jeśli użytkownik chce, aby dane wyjściowe były używane przez wiele ustawień regionalnych, `Write` należy użyć.  
  
 Zapis `Print` w pliku przy użyciu `PrintLine` funkcjilub`Write` wymaga dostępu z wyliczenia.`FileIOPermissionAccess` Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermissionAccess> Zobacz.  
  
   
  
## Examples  
 W tym przykładzie funkcja `Print` i `PrintLine` służy do zapisywania danych do pliku.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Wymagana. Wyrażenie ciągu określające istniejącą nazwę i lokalizację pliku. <paramref name="OldPath" />może zawierać katalog i dysk pliku.</param>
        <param name="NewPath">Wymagane. Wyrażenie ciągu określające nową nazwę i lokalizację pliku. <paramref name="NewPath" />może zawierać katalog i dysk lokalizacji docelowej. Nazwa pliku określona przez <paramref name="NewPath" /> nie może już istnieć.</param>
        <summary>Zmienia nazwę pliku lub katalogu dysku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Rename" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Rename` Funkcja zmienia nazwę pliku i przenosi go do innego katalogu, jeśli jest to wymagane. Funkcja może przenosić plik między dyskami, ale może zmienić nazwę istniejącego katalogu tylko wtedy, gdy `OldPath` oba `NewPath` znajdują się na tym samym dysku. `Rename` `Rename`nie można utworzyć nowego pliku lub katalogu.  
  
 `Rename` Użycie funkcji w otwartym pliku powoduje wystąpienie błędu. Przed zmianą nazwy należy zamknąć otwarty plik. `Rename`argumenty nie mogą zawierać wielu znaków (*) i symboli wieloznakowych (?).  
  
> [!IMPORTANT]
>  `Rename` W przypadku kopiowania pliku z lokalizacji niechronionej do lokalizacji chronionej plik zachowuje mniej ograniczone prawa. Upewnij się, że nie wprowadzono potencjalnego zagrożenia bezpieczeństwa.  
  
   
  
## Examples  
 Ten przykład używa funkcji `Rename` , aby zmienić nazwę pliku. Na potrzeby tego przykładu Załóżmy, że katalogi, które zostały określone, już istnieją.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka jest nieprawidłowa.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="OldPath" />plik nie istnieje.</exception>
        <exception cref="T:System.IO.IOException">Nie można zmienić nazwy na inne urządzenie.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Instrukcje: Zmień nazwę pliku w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka wszystkie pliki dysku otwierane za pomocą <see langword="FileOpen" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Reset" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja zamyka wszystkie aktywne pliki otwarte `FileOpen` przez funkcję i ma tę samą funkcję jak `FileClose()` bez żadnych parametrów. `Reset`  
  
   
  
## Examples  
 Ten przykład używa funkcji `Reset` , aby zamknąć wszystkie otwarte pliki i zapisać zawartość wszystkich buforów plików na dysku. Zwróć uwagę na użycie `Object` zmiennej `FileNumber` jako ciągu i liczby.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End — Instrukcja</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Wymagane. Wyrażenie ciągu określające katalog lub folder, który ma zostać usunięty. <paramref name="Path" />może zawierać dysk. Jeśli dysk nie zostanie określony, <see langword="RmDir" /> program usuwa katalog na bieżącym dysku.</param>
        <summary>Usuwa istniejący katalog. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="RmDir" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli próbujesz użyć `RmDir` w katalogu zawierającym pliki, występuje błąd. Przed podjęciem próby usunięcia katalogu należy użyć funkcji, `Kill` aby usunąć wszystkie pliki.  
  
   
  
## Examples  
 Ten przykład używa funkcji `RmDir` , aby usunąć istniejący katalog.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" />nie została określona lub jest pusta.</exception>
        <exception cref="T:System.IO.IOException">Katalog docelowy zawiera pliki.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Katalog nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca wartość <see langword="FileOpen" /> <see langword="FileOpen" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą funkcji. <see langword="Long" /> Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Seek" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. <see langword="Integer" /> Zawiera prawidłowy numer pliku.</param>
        <summary>Zwraca wartość <see langword="FileOpen" /> <see langword="FileOpen" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą funkcji. <see langword="Long" /> Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Seek" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Określanie bieżącej pozycji odczytu/zapisu w pliku otwartym za <see langword="FileOpen" /> pomocą funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w <see langword="FileOpen" /> pliku otwartym za pomocą funkcji. <see langword="Long" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`Zwraca wartość z przedziału od 1 do 2 147 483 647 (odpowiednik 2 ^ 31-1) włącznie.  
  
 Poniżej opisano wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Numer następnego rekordu do odczytu lub zapisu|  
|`Binary`, `Input`, `Output`, `Append`|Położenie w bajtach, w którym występuje następna operacja. Pierwszy bajt w pliku znajduje się na pozycji 1, drugi bajt znajduje się na pozycji 2 itd.|  
  
   
  
## Examples  
 Ten przykład używa funkcji `Seek` , aby zwrócić bieżącą pozycję pliku. Przykład zakłada `TestFile` się, że jest plikiem zawierającym rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 W przypadku plików otwartych `Random` w `Seek` trybie funkcja zwraca numer następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybie innym `Random` niż tryb `Seek` , zwraca pozycję bajtu, przy której występuje następna operacja. Załóżmy `TestFile` , że plik zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Ten przykład używa funkcji `Seek` , aby ustawić położenie dla następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybie innym `Random` niż tryb `Seek` , ustawia pozycję bajtu, w którym występuje następna operacja. Załóżmy `TestFile` , że plik zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. <see langword="Integer" /> Zawiera prawidłowy numer pliku.</param>
        <param name="Position">Wymagany. Liczba z zakresu od 1 do 2147483647 włącznie, która wskazuje, gdzie powinna wystąpić następna operacja odczytu/zapisu.</param>
        <summary>Zwraca wartość <see langword="FileOpen" /> <see langword="FileOpen" /> określającą bieżącą pozycję odczytu/zapisu w pliku otwartym za pomocą funkcji lub ustawia pozycję dla następnej operacji odczytu/zapisu w pliku otwartym za pomocą funkcji. <see langword="Long" /> Funkcja zapewnia lepszą wydajność i wydajność w <see langword="Seek" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`Zwraca wartość z przedziału od 1 do 2 147 483 647 (odpowiednik 2 ^ 31-1) włącznie.  
  
 Poniżej opisano wartości zwracane dla każdego trybu dostępu do pliku:  
  
|Tryb|Wartość zwracana|  
|-|-|  
|`Random`|Numer następnego rekordu do odczytu lub zapisu|  
|`Binary`, `Input`, `Output`, `Append`|Położenie w bajtach, w którym występuje następna operacja. Pierwszy bajt w pliku znajduje się na pozycji 1, drugi bajt znajduje się na pozycji 2 itd.|  
  
   
  
## Examples  
 Ten przykład używa funkcji `Seek` , aby zwrócić bieżącą pozycję pliku. Przykład zakłada `TestFile` się, że jest plikiem zawierającym rekordy struktury `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 W przypadku plików otwartych `Random` w `Seek` trybie funkcja zwraca numer następnego rekordu.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 W przypadku plików otwartych w trybie innym `Random` niż tryb `Seek` , zwraca pozycję bajtu, przy której występuje następna operacja. Załóżmy `TestFile` , że plik zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Ten przykład używa funkcji `Seek` , aby ustawić położenie dla następnego odczytu lub zapisu w pliku.  
  
 W przypadku plików otwartych w trybie innym `Random` niż tryb `Seek` , ustawia pozycję bajtu, w którym występuje następna operacja. Załóżmy `TestFile` , że plik zawiera kilka wierszy tekstu.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Odczyt z plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Zapisywanie w plikach w Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagany. Wyrażenie ciągu określające nazwę pliku. <paramref name="PathName" />może zawierać katalog lub folder i dysk.</param>
        <param name="Attributes">Wymagana. Wyrażenie stałe lub liczbowe, którego suma określa atrybuty pliku.</param>
        <summary>Ustawia informacje o atrybucie dla pliku. Funkcja zapewnia lepszą wydajność i wydajność w <see langword="SetAttr" />operacjach we/wy na plikach. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Błąd czasu wykonywania występuje, gdy spróbujesz ustawić atrybuty otwartego pliku.  
  
 Wartości `Attributes` wyliczenia argumentów są następujące:  
  
|Wartość|Stała|Opis|  
|-|-|-|  
|`Normal`|`vbNormal`|Normalne (domyślne).|  
|`ReadOnly`|`vbReadOnly`|Tylko do odczytu.|  
|`Hidden`|`vbHidden`|Ukryte.|  
|`System`|`vbSystem`|Plik systemowy.|  
|`Volume`|`vbVolume`|Etykieta woluminu|  
|`Directory`|`vbDirectory`|Katalog lub folder.|  
|`Archive`|`vbArchive`|Plik został zmieniony od czasu wykonania ostatniej kopii zapasowej.|  
|`Alias`|`vbAlias`|Plik ma inną nazwę.|  
  
> [!NOTE]
>  Te wyliczenia są określane przez język Visual Basic. Nazwy mogą być używane w dowolnym miejscu w kodzie, a nie rzeczywistymi wartościami.  
  
   
  
## Examples  
 W tym przykładzie `SetAttr` funkcja służy do ustawiania atrybutów pliku.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" />Typ jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Wymagany. Liczba spacji do wstawienia przed wyświetleniem lub wydrukowaniem następnego wyrażenia na liście.</param>
        <summary>Używany z <see langword="Print" /> funkcją lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
        <returns>Używany z <see langword="Print" /> funkcją lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Count` jest mniejsza niż szerokość linii wyjściowej, następna pozycja drukowania następuje natychmiast po liczbie wydrukowanych miejsc. Jeśli`Count` jest większa niż szerokość linii wyjściowej, `SPC` oblicza następną pozycję drukowania przy użyciu formuły:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Jeśli na przykład bieżąca pozycja drukowania to 24, Szerokość linii wyjściowej to 80, a `SPC(90)`następnie zostanie wybrana następna wartość wydruku zostanie rozpoczęta na pozycji 34 (bieżąca pozycja drukowania + reszta z 90/80). Jeśli różnica między bieżącą pozycją drukowania a szerokością linii wyjściowej jest mniejsza niż `Count` (lub `Count` `Mod` *Szerokość*), `SPC` funkcja pomija początek następnego wiersza i generuje spacje równe `Count`-(*Szerokość* - *currentprintposition*).  
  
> [!NOTE]
>  Upewnij się, że kolumny tabelaryczne są wystarczająco szerokie, aby umożliwić korzystanie z szerokich liter.  
  
   
  
## Examples  
 W tym przykładzie `SPC` funkcja służy do pozycjonowania danych wyjściowych w pliku i w oknie **danych wyjściowych** .  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Używany z <see langword="Print" /> funkcjami lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Używany z <see langword="Print" /> funkcjami lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
        <returns>Używany z <see langword="Print" /> funkcjami lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większa niż `Column`, program `TAB` pomija wartość kolumny równą `Column` w następnej linii wyjściowej. Jeśli `Column` jest mniejsza niż 1, `TAB` przenosi pozycję drukowania do kolumny 1. Jeśli `Column` jest większa niż szerokość linii wyjściowej, `TAB` oblicza następną pozycję drukowania przy użyciu formuły:  
  
 Szerokość w kolumnie  
  
 Na przykład jeśli *Szerokość* to 80 i określisz `TAB(90)`, następne drukowanie rozpocznie się w kolumnie 10 (reszta z 90/80). Jeśli `Column` jest mniejsza niż bieżąca pozycja drukowania, drukowanie rozpocznie się w następnym wierszu na obliczonej pozycji wydruku. Jeśli obliczona pozycja drukowania jest większa niż bieżąca pozycja drukowania, drukowanie rozpocznie się w obliczonej pozycji drukowania w tym samym wierszu.  
  
 Pozycja drukowania z lewej strony w wierszu danych wyjściowych jest zawsze 1. W przypadku użycia `Print` funkcji lub `PrintLine` do drukowania do plików, pozycja drukowania z prawej na początku jest bieżącą szerokością pliku wyjściowego, który można ustawić przy użyciu `FileWidth` funkcji.  
  
 Funkcja może być również używana `WriteLine` z funkcją. `TAB` Nie można jej używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ani <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabelaryczne są wystarczająco szerokie, aby zawierały szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie `TAB` funkcja służy do pozycjonowania danych wyjściowych w pliku i w oknie **danych wyjściowych** .  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Opcjonalny. Numer kolumny jest przenoszony do przed wyświetleniem lub wydrukowaniem następnego wyrażenia na liście. W przypadku pominięcia <see langword="TAB" /> przenosi punkt wstawiania do początku następnej strefy drukowania.</param>
        <summary>Używany z <see langword="Print" /> funkcjami lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</summary>
        <returns>Używany z <see langword="Print" /> funkcjami lub <see langword="PrintLine" /> do pozycjonowania danych wyjściowych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli bieżąca pozycja drukowania w bieżącym wierszu jest większa niż `Column`, `TAB` pomija wartość kolumny równą `Column` wartości w następnej linii wyjściowej. Jeśli `Column` jest mniejsza niż 1, `TAB` przenosi pozycję drukowania do kolumny 1. Jeśli `Column` jest większa niż szerokość linii wyjściowej, `TAB` oblicza następną pozycję drukowania przy użyciu formuły:  
  
 Szerokość w kolumnie  
  
 Na przykład jeśli *Szerokość* to 80 i określisz `TAB(90)`, następne drukowanie rozpocznie się w kolumnie 10 (reszta z 90/80). Jeśli `Column` jest mniejsza niż bieżąca pozycja drukowania, drukowanie rozpocznie się w następnym wierszu na obliczonej pozycji wydruku. Jeśli obliczona pozycja drukowania jest większa niż bieżąca pozycja drukowania, drukowanie rozpocznie się w obliczonej pozycji drukowania w tym samym wierszu.  
  
 Pozycja drukowania z lewej strony w wierszu danych wyjściowych jest zawsze 1. W przypadku użycia `Print` funkcji lub `PrintLine` do drukowania do plików, pozycja drukowania z prawej na początku jest bieżącą szerokością pliku wyjściowego, który można ustawić przy użyciu `FileWidth` funkcji.  
  
 Funkcja może być również używana `WriteLine` z funkcją. `TAB` Nie można jej używać z <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ani <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Upewnij się, że kolumny tabelaryczne są wystarczająco szerokie, aby zawierały szerokie litery.  
  
   
  
## Examples  
 W tym przykładzie `TAB` funkcja służy do pozycjonowania danych wyjściowych w pliku i w oknie **danych wyjściowych** .  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod — Operator (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagany. Dowolna prawidłowa liczba plików.</param>
        <param name="Record">Opcjonalny. Numer jedynego rekordu lub bajtu do zablokowania lub odblokowania</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. Dowolna prawidłowa liczba plików.</param>
        <param name="FromRecord">Opcjonalny. Numer pierwszego rekordu lub bajtu do zablokowania lub odblokowania.</param>
        <param name="ToRecord">Opcjonalny. Numer ostatniego rekordu lub bajtu do zablokowania lub odblokowania.</param>
        <summary>Kontroluje dostęp przez inne procesy do całości lub części pliku otwartego przy użyciu <see langword="Open" /> funkcji. Funkcja zapewnia lepszą wydajność i wydajność w operacjach we/wy na plikach niż <see langword="Lock" /> i <see langword="Unlock" />. <see langword="My" /> Aby uzyskać więcej informacji, zobacz <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje i są używane w środowiskach, `Unlock` w których kilka procesów może potrzebować dostępu do tego samego pliku. `Lock`  
  
 `Lock`i `Unlock` funkcje są zawsze używane w parach. Argumenty do `Lock` i `Unlock` muszą być identyczne.  
  
 Jeśli `Record`lub `FromRecord` i`ToRecord` nie są podane, blokada będzie dla całego pliku. Jeśli `Record` określono tylko jeden rekord zostanie zablokowany/odblokowany.  
  
 Jeśli plik został otwarty do sekwencyjnego wejścia lub `Lock` wyjścia i `Unlock` ma wpływ na cały plik, niezależnie od zakresu określonego przez `FromRecord` i`ToRecord`.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Lock` funkcji i. `Unlock` W tym przykładzie przyjęto założenie, że `People.txt` jest plikiem zawierającym rekordy struktury. `Person`  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagana. <see langword="Integer" /> Wyrażenie zawierające dowolny prawidłowy numer pliku.</param>
        <param name="Output">Opcjonalny. Co najmniej jedno wyrażenie rozdzielane przecinkami do zapisu w pliku.</param>
        <summary>Zapisuje dane do sekwencyjnego pliku. Dane zapisywane w <see langword="Write" /> programie są zwykle odczytywane z pliku przy <see langword="Input" />użyciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje `Write` i`WriteLine` są dostępne w celu zapewnienia zgodności z poprzednimi wersjami i mogą mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 W przypadku pominięcia `Output`do pliku zostanie wydrukowany pusty wiersz. Wiele wyrażeń można rozdzielić przecinkami.  
  
 `Print` W`Write` przeciwieństwie do funkcji, funkcja wstawia przecinki między elementami i znakami cudzysłowu otaczającymi ciągi w miarę ich zapisywania w pliku. Nie trzeba umieszczać jawnych ograniczników na liście. Gdy `Write` jest używany do zapisywania danych do pliku, obsługiwane są tylko formaty `Boolean`liczbowe,, daty, wartości `Error` null i dane. Następujące uniwersalne założenia są stosowane, aby dane były zawsze odczytywane i prawidłowo interpretowane przy `Input`użyciu, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane przy użyciu kropki jako separatora dziesiętnego.  
  
-   Dla `Boolean` danych `#TRUE#` , lub`#FALSE#` jest drukowana. Słowa kluczowe `False` i nie są tłumaczone, niezależnie od ustawień regionalnych. `True`  
  
-   Dane daty są zapisywane w pliku przy użyciu uniwersalnego formatu daty. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Żadne elementy nie są zapisywane w pliku `Output` , jeśli dane są puste. Jednak w przypadku danych `#NULL#` o wartości null jest zapisywana.  
  
-   W `Error` przypadku danych dane wyjściowe są wyświetlane `#ERROR errorcode#`jako. `Error` Słowo kluczowe nie jest tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine`Wstawia znak nowego wiersza (oznacza to, powrotu karetki lub wysuwu wiersza lub `Chr(13) + Chr(10)`), po zapisaniu znaku końcowego w `Output` pliku.  
  
 Znaki cudzysłowu można osadzić w ciągu przy użyciu podwójnych cudzysłowów lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg o wartości `Double quotation marks aren't "difficult" to handle`.  
  
 Zapis `Write` w pliku przy użyciu `WriteLine` funkcjilub`Append` wymaga dostępu z wyliczenia.`FileIOPermissionAccess` Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermissionAccess> Zobacz.  
  
   
  
## Examples  
 W tym przykładzie `Write` funkcja służy do zapisywania nieprzetworzonych danych do sekwencyjnego pliku.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tryb pliku jest nieprawidłowy.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Wymagane. <see langword="Integer" /> Wyrażenie zawierające dowolny prawidłowy numer pliku.</param>
        <param name="Output">Opcjonalny. Co najmniej jedno wyrażenie rozdzielane przecinkami do zapisu w pliku.</param>
        <summary>Zapisuje dane do sekwencyjnego pliku. Dane zapisywane w <see langword="Write" /> programie są zwykle odczytywane z pliku przy <see langword="Input" />użyciu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcje `Write` i`WriteLine` są dostępne w celu zapewnienia zgodności z poprzednimi wersjami i mogą mieć wpływ na wydajność. W przypadku aplikacji, które nie są `My.Computer.FileSystem` starsze, obiekt zapewnia lepszą wydajność. Aby uzyskać więcej informacji, zobacz [dostęp do plików przy użyciu Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 W przypadku pominięcia `Output`do pliku zostanie wydrukowany pusty wiersz. Wiele wyrażeń można rozdzielić przecinkami.  
  
 `Print` W`Write` przeciwieństwie do funkcji, funkcja wstawia przecinki między elementami i znakami cudzysłowu otaczającymi ciągi w miarę ich zapisywania w pliku. Nie trzeba umieszczać jawnych ograniczników na liście. Gdy `Write` jest używany do zapisywania danych do pliku, obsługiwane są tylko formaty `Boolean`liczbowe,, daty, wartości `Error` null i dane. Następujące uniwersalne założenia są stosowane, aby dane były zawsze odczytywane i prawidłowo interpretowane przy `Input`użyciu, niezależnie od ustawień regionalnych:  
  
-   Dane liczbowe są zawsze zapisywane przy użyciu kropki jako separatora dziesiętnego.  
  
-   Dla `Boolean` danych `#TRUE#` , lub`#FALSE#` jest drukowana. Słowa kluczowe `False` i nie są tłumaczone, niezależnie od ustawień regionalnych. `True`  
  
-   Dane daty są zapisywane w pliku przy użyciu uniwersalnego formatu daty. Gdy składnik daty lub godziny jest nieobecny lub równy zero, tylko podana część jest zapisywana do pliku.  
  
-   Żadne elementy nie są zapisywane w pliku `Output` , jeśli dane są puste. Jednak w przypadku danych `#NULL#` o wartości null jest zapisywana.  
  
-   W `Error` przypadku danych dane wyjściowe są wyświetlane `#ERROR errorcode#`jako. `Error` Słowo kluczowe nie jest tłumaczone, niezależnie od ustawień regionalnych.  
  
 `WriteLine`Wstawia znak nowego wiersza (oznacza to, powrotu karetki lub wysuwu wiersza lub `Chr(13) + Chr(10)`), po zapisaniu znaku końcowego w `Output` pliku.  
  
 Znaki cudzysłowu można osadzić w ciągu przy użyciu podwójnych cudzysłowów lub "". Na przykład  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Zwraca ciąg o wartości `Double quotation marks aren't "difficult" to handle`.  
  
 Zapis `Write` w pliku przy użyciu `WriteLine` funkcjilub`Append` wymaga dostępu z wyliczenia.`FileIOPermissionAccess` Aby uzyskać więcej informacji, <xref:System.Security.Permissions.FileIOPermissionAccess> Zobacz.  
  
   
  
## Examples  
 W tym przykładzie `Write` funkcja służy do zapisywania nieprzetworzonych danych do sekwencyjnego pliku.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Dostęp do plików za pomocą Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Instrukcje: Zapisz tekst do plików w Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Instrukcje: Zapisz tekst w pliku z StreamWriter — (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>

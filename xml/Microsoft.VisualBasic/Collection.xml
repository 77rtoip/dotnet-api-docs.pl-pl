<Type Name="Collection" FullName="Microsoft.VisualBasic.Collection">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1ca6fe3852375bfd178d47665e7c10e4e6270c01" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53226532" /></Metadata><TypeSignature Language="C#" Value="public sealed class Collection : System.Collections.IList, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed Collection extends System.Object implements class System.Collections.ICollection, class System.Collections.IList, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Collection" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Collection&#xA;Implements IDeserializationCallback, IList, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Collection sealed : System::Collections::IList, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Collection = class&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(Microsoft.VisualBasic.Collection/CollectionDebugView))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>W języku Visual Basic <see langword="Collection" /> jest uporządkowany zestaw elementów, które mogą być określane jako jednostka.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli to możliwe, należy używać ogólnych kolekcji w <xref:System.Collections.Generic?displayProperty=nameWithType> przestrzeni nazw lub <xref:System.Collections.Concurrent> przestrzeni nazw, a nie w języku Visual Basic `Collection`. Aby uzyskać więcej informacji, zobacz [kolekcje](https://msdn.microsoft.com/library/e76533a9-5033-4a0b-b003-9c2be60d185b).  
  
 Visual Basic `Collection` obiekt zapewnia wygodny sposób odwoływania się do powiązanej grupy elementów jako pojedynczy obiekt. Elementy, lub *elementy*w kolekcji tylko potrzebne związane z faktem, że istnieją one w kolekcji. Elementy kolekcji nie należy udostępniać tego samego typu danych.  
  
 Można utworzyć kolekcję na taki sam sposób utworzyć inne obiekty, tak jak pokazano w poniższym przykładzie.  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 Po utworzeniu kolekcji, możesz wykonać dowolną z następujących czynności:  
  
-   Dodaj element z <xref:Microsoft.VisualBasic.Collection.Add%2A> metody.  
  
-   Usuń element z <xref:Microsoft.VisualBasic.Collection.Remove%2A> metody.  
  
-   Usuń wszystkie elementy z <xref:Microsoft.VisualBasic.Collection.Clear%2A> metody.  
  
-   Dowiedz się, jak wiele elementów, które zawiera kolekcję <xref:Microsoft.VisualBasic.Collection.Count%2A> właściwości.  
  
-   Sprawdź, czy określony element jest obecny przy użyciu <xref:Microsoft.VisualBasic.Collection.Contains%2A> metody.  
  
-   Zwraca określony element z kolekcji przy użyciu <xref:Microsoft.VisualBasic.Collection.Item%2A> właściwości.  
  
-   Iterację całą kolekcję z [For Each... Następna instrukcja](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md).  
  
    > [!NOTE]
    >  Mimo że Visual Basic `Collection` obiekt ma funkcjonalność jest taka sama jak `Collection` obiektu w Visual Basic 6.0, dwa nie może współpracować w środowisku COM.  
  
    > [!CAUTION]
    >  Iteracji w Visual Basic `Collection` nie jest procedurą odporną. Nawet jeśli kolekcja jest synchronizowana, inne wątki nadal mogą ją modyfikować kolekcji, powodując modułu wyliczającego do zgłoszenia wyjątku. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, zablokować kolekcję albo rejestrować wyjątki wynikłe ze zmian wprowadzanych przez inne wątki. Aby uzyskać więcej informacji na temat blokowania elementu programistycznego, zobacz [SyncLock — instrukcja](~/docs/visual-basic/language-reference/statements/synclock-statement.md).  
  
   
  
## Examples  
 Poniższy przykład tworzy `Collection` obiektu `names` i okno dialogowe, za pomocą którego użytkownik może dodawać obiekty (nazwy) w kolekcji. Następnie wyświetla nazwy w kolekcji, a na koniec opróżnia kolekcji bez usuwania `Collection` sam obiekt.  
  
 Aby zobaczyć, jak to działa, wybierz **Dodaj klasę** polecenia **projektu** menu i Zadeklaruj zmienną publicznego o nazwie `instanceName` na poziomie modułu `nameClass` (typ `Public instanceName`) do przechowywania nazwy poszczególnych wystąpień. Pozostaw nazwę domyślną `nameClass`. Skopiuj i wklej następujący kod do **ogólne** części innego modułu, a następnie uruchom go z instrukcją `classNamer` w innej procedury. (Ten przykład działa tylko w przypadku aplikacji hosta obsługujących klasy).  
  
 [!code-vb[VbVbalrCollectionObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Collection ();" />
      <MemberSignature Language="ILAsm" Value=".method public specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Collection();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca nowy języka Visual Basic <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolekcji Visual Basic, zwrócony przez ten konstruktor jest pusta i nie ma żadnych pojemność przydzielone.  
  
 Kolekcje w języku Visual Basic nie są zgodne z [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] dostępne w kolekcji <xref:System.Collections?displayProperty=nameWithType>, <xref:System.Collections.Generic?displayProperty=nameWithType>, i <xref:System.Collections.Specialized?displayProperty=nameWithType> przestrzeni nazw.  
  
   
  
## Examples  
 Poniższy przykład tworzy nową kolekcję języka Visual Basic, a następnie przypisuje go do zmiennej `coll`:  
  
```vb  
Dim coll As New Microsoft.VisualBasic.Collection()  
```  
  
 To `Collection` obiekt jest jednobazowa, co oznacza, że wartości indeksów elementów zakresu od 1 do wartości `Count` właściwości. Visual Basic kolekcje przechowują elementów typu <xref:System.Object>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object Item, string Key = null, object Before = null, object After = null);" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Add(object Item, string Key, object Before, object After) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Add(System.Object,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (Item As Object, Optional Key As String = null, Optional Before As Object = null, Optional After As Object = null)" />
      <MemberSignature Language="F#" Value="member this.Add : obj * string * obj * obj -&gt; unit" Usage="collection.Add (Item, Key, Before, After)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Before" Type="System.Object" />
        <Parameter Name="After" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Item">Wymagana. Obiekt dowolnego typu, który określa element do dodania do kolekcji.</param>
        <param name="Key">Opcjonalna. Unikatowy <see langword="String" /> wyrażenie, które określa klucza parametry, których można używać zamiast pozycyjne indeksu umożliwiają dostęp do tego nowego elementu w kolekcji.</param>
        <param name="Before">Opcjonalna. Wyrażenie, który określa względne położenie w kolekcji. Element, który ma zostać dodany zostanie umieszczony w kolekcji przed elementem identyfikowane przez <paramref name="Before" /> argumentu. Jeśli <paramref name="Before" /> jest wyrażeniem numeryczne, musi być liczba z przedziału od 1 do wartości kolekcji <see cref="P:Microsoft.VisualBasic.Collection.Count" /> właściwości. Jeśli <paramref name="Before" /> jest <see langword="String" /> wyrażenia, jego musi odpowiadać ciąg klucza określone, gdy element przywoływanego została dodana do kolekcji. Nie można określić zarówno <paramref name="Before" /> i <paramref name="After" />.</param>
        <param name="After">Opcjonalna. Wyrażenie, który określa względne położenie w kolekcji. Element, który ma zostać dodany zostanie umieszczony w kolekcji po elemencie identyfikowane przez <paramref name="After" /> argumentu. Jeśli <paramref name="After" /> jest wyrażeniem numeryczne, musi być liczba z przedziału od 1 do wartości kolekcji <see langword="Count" /> właściwości. Jeśli <paramref name="After" /> jest <see langword="String" /> wyrażenia, jego musi odpowiadać ciąg klucza określone, gdy element przywoływany została dodana do kolekcji. Nie można określić zarówno <paramref name="Before" /> i <paramref name="After" />.</param>
        <summary>Dodaje element do <see langword="Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Before` Lub `After` argumentu musi odwoływać się do istniejącego elementu kolekcji; w przeciwnym razie wystąpi błąd.  
  
 Jeśli oba `Before` i `After` argumenty są pomijane, nowy obiekt zostanie dodany na końcu kolekcji.  
  
 Błąd występuje także w przypadku określonego `Key` wartość jest zgodny z kluczem dla istniejącego elementu kolekcji.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Add` metody w celu dodania `child` obiektów - wystąpienia klasy o nazwie `child` zawierający `Public` właściwość `name` — do kolekcji o nazwie `family`. Aby zobaczyć, jak to działa, Utwórz <xref:System.Windows.Forms.Form> przy użyciu dwóch <xref:System.Windows.Forms.Button> kontrolek i ustaw ich <xref:System.Windows.Forms.Control.Text%2A> właściwości `Add` i `List`. Dodaj `child` definicji klasy i `family` deklaracji w kodzie formularza. Modyfikowanie `_Click` programy obsługi zdarzeń dla **Dodaj** i **listy** przyciski, jak pokazano. **Dodaj** przycisk służy do dodawania elementów podrzędnych. **Listy** przycisku Wyświetla nazwy wszystkich elementów podrzędnych.  
  
 [!code-vb[VbVbalrCollectionObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="collection.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy w języku Visual Basic <see langword="Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Clear` Metoda kolekcji opróżnia i resetuje jego <xref:Microsoft.VisualBasic.Collection.Count%2A> właściwości na wartość 0.  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public instance bool Contains(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (Key As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="collection.Contains Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Wymagana. A <see langword="String" /> wyrażenie określające klucz do wyszukania elementów kolekcji.</param>
        <summary>Zwraca <see langword="Boolean" /> wartość wskazującą, czy w języku Visual Basic <see langword="Collection" /> obiekt zawiera element z określonym kluczem.</summary>
        <returns>Zwraca <see langword="Boolean" /> wartość wskazującą, czy w języku Visual Basic <see langword="Collection" /> obiekt zawiera element z określonym kluczem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Contains` Zwraca `True` Jeśli kolekcja zawiera element z kluczem dokładnie pasujących `Key`. W przeciwnym razie `Contains` zwraca `False`. Wielkość liter jest ignorowana podczas dopasowywania wartości klucza.  
  
 W języku Visual Basic `Collection` może zawierać pewne elementy, które mają klucze i inne elementy bez kluczy. To zależy od tego, czy wywołanie <xref:Microsoft.VisualBasic.Collection.Add%2A> metoda dostarcza argumentu opcjonalnego `Key` parametru.  
  
   
  
## Examples  
 [!code-vb[VbVbalrCollectionObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#4)]  
  
 Jeśli zamierzasz wyszukiwania kolekcji dla elementów przy użyciu ich kluczy, pamiętaj, aby podać `Key` argument za każdym razem, gdy wywołujesz `Add` metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="Microsoft.VisualBasic.Collection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca <see langword="Integer" /> zawierającą liczbę elementów w kolekcji. Tylko do odczytu.</summary>
        <value>Zwraca <see langword="Integer" /> zawierającą liczbę elementów w kolekcji. Tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `Count` właściwości, aby określić liczbę elementów w `Collection` obiektu.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Count` właściwość, aby wyświetlić liczbę elementów w <xref:Microsoft.VisualBasic.Collection> obiektu w zmiennej `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#6)]  
  
 `Collection` Obiekt jest jednobazowa, co oznacza, że wartości indeksów elementów zakresu od 1 do wartości `Count` właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="collection.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca odwołanie do obiektu moduł wyliczający, który jest używany do wykonywania iteracji <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</summary>
        <returns>Zwraca odwołanie do obiektu moduł wyliczający, który jest używany do wykonywania iteracji <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [For Each... Następna instrukcja](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) wywołania `GetEnumerator` uzyskać obiekt modułu wyliczającego do obsługi iteracji przez elementy kolekcji. Zazwyczaj używasz `For Each`... `Next` przechodzenia kolekcji lub tablicy w pętli i nie trzeba wywoływać `GetEnumerator` jawnie.  
  
 Jeśli potrzebujesz ściślejszej kontroli nad iteracji niż `For Each`... `Next` zapewniają instrukcji, można użyć `GetEnumerator` metodę w celu przechodzenia dostosowane. Poniżej przedstawiono niektóre przypadki, w których konieczne może być to zrobić.  
  
-   Możesz chcieć powrotu do kolekcji i uruchomić ponownie iteracji, przed zakończeniem.  
  
-   Można pominąć jeden lub więcej elementów z różnych powodów.  
  
-   Może być konieczne zmiany elementów kolekcji w trakcie przechodzenia. W takim przypadku musisz uzyskać nowy obiekt modułu wyliczającego, ponieważ poprzednia zostaje unieważniony.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać `GetEnumerator` można pobrać wszystkie elementy `Collection` obiektu.  
  
 [!code-vb[VbVbalrCollectionObject#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#7)]  
  
 `GetEnumerator` Tworzy i zwraca obiekt modułu wyliczającego, która implementuje <xref:System.Collections.IEnumerator> interfejsu <xref:System.Collections> przestrzeni nazw. Obiekt modułu wyliczającego udostępnia <xref:System.Collections.IEnumerator.Current%2A> właściwości i <xref:System.Collections.IEnumerator.MoveNext%2A> i <xref:System.Collections.IEnumerator.Reset%2A> metody. Aby uzyskać więcej informacji, zobacz [For Each... Następna instrukcja](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int] { System::Object ^ get(int Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">(A wyrażenia liczbowego, który określa położenie elementu w kolekcji. <paramref name="Index" /> musi być liczbą z przedziału od 1 do wartości kolekcji <see cref="P:Microsoft.VisualBasic.Collection.Count" /> właściwości. Lub (B) <see langword="Object" /> wyrażenie, które określa ciąg pozycji lub klucza elementu kolekcji.</param>
        <summary>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</summary>
        <value>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Index` typu `Object`, `Item` próbuje go traktować jako właściwość `String`, `Char`, `Char` tablicy lub liczbą całkowitą. Jeśli `Item` nie można przekonwertować `Index` do `String` lub `Integer`, wyniku weryfikacji zgłasza wyjątek <xref:System.ArgumentException> wyjątku.  
  
 `Item` Właściwość jest właściwością domyślną dla kolekcji. W związku z tym następujące wiersze kodu są równoważne.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Item` właściwość, aby pobrać odwołanie do obiektu w kolekcji. Tworzy `birthdays` jako `Collection` obiektu, a następnie pobiera obiekt reprezentujący datę urodzin na rachunku, przy użyciu klucza `"Bill"` jako `Index` argumentu.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Należy zauważyć, że pierwsze wywołanie jawnie określa `Item` właściwości, ale druga nie. Oba wywołania działa, ponieważ `Item` właściwość jest domyślną właściwością `Collection` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">(A wyrażenia liczbowego, który określa położenie elementu w kolekcji. <paramref name="Index" /> musi być liczbą z przedziału od 1 do wartości kolekcji <see cref="P:Microsoft.VisualBasic.Collection.Count" /> właściwości. Lub (B) <see langword="Object" /> wyrażenie, które określa ciąg pozycji lub klucza elementu kolekcji.</param>
        <summary>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</summary>
        <value>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Index` typu `Object`, `Item` próbuje go traktować jako właściwość `String`, `Char`, `Char` tablicy lub liczbą całkowitą. Jeśli `Item` nie można przekonwertować `Index` do `String` lub `Integer`, wyniku weryfikacji zgłasza wyjątek <xref:System.ArgumentException> wyjątku.  
  
 `Item` Właściwość jest właściwością domyślną dla kolekcji. W związku z tym następujące wiersze kodu są równoważne.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Item` właściwość, aby pobrać odwołanie do obiektu w kolekcji. Tworzy `birthdays` jako `Collection` obiektu, a następnie pobiera obiekt reprezentujący datę urodzin na rachunku, przy użyciu klucza `"Bill"` jako `Index` argumentu.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Należy zauważyć, że pierwsze wywołanie jawnie określa `Item` właściwości, ale druga nie. Oba wywołania działa, ponieważ `Item` właściwość jest domyślną właściwością `Collection` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[string Key] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ Key); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj" Usage="Microsoft.VisualBasic.Collection.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Unikatowy <see langword="String" /> wyrażenie określające klucza ciąg, który pozwala, zamiast indeksu pozycyjne, uzyskiwanie dostępu do elementu kolekcji. <paramref name="Key" /> musi odpowiadać <paramref name="Key" /> argument określony, gdy element został dodany do kolekcji.</param>
        <summary>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</summary>
        <value>Zwraca określony element obiektu <see langword="Collection" /> obiektów według pozycji lub klucza. Tylko do odczytu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Index` typu `Object`, `Item` próbuje go traktować jako właściwość `String`, `Char`, `Char` tablicy lub liczbą całkowitą. Jeśli `Item` nie można przekonwertować `Index` do `String` lub `Integer`, wyniku weryfikacji zgłasza wyjątek <xref:System.ArgumentException> wyjątku.  
  
 `Item` Właściwość jest właściwością domyślną dla kolekcji. W związku z tym następujące wiersze kodu są równoważne.  
  
```  
MsgBox(CStr(customers.Item(1)))  
MsgBox(CStr(customers(1)))  
```  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Item` właściwość, aby pobrać odwołanie do obiektu w kolekcji. Tworzy `birthdays` jako `Collection` obiektu, a następnie pobiera obiekt reprezentujący datę urodzin na rachunku, przy użyciu klucza `"Bill"` jako `Index` argumentu.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#8)]  
  
 Należy zauważyć, że pierwsze wywołanie jawnie określa `Item` właściwości, ale druga nie. Oba wywołania działa, ponieważ `Item` właściwość jest domyślną właściwością `Collection` obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa element z <see langword="Collection" /> obiektu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(int32 Index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; unit" Usage="collection.Remove Index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Wyrażenie liczbowe, która określa położenie elementu w kolekcji. <paramref name="Index" /> musi być liczbą z przedziału od 1 do wartości kolekcji <see cref="P:Microsoft.VisualBasic.Collection.Count" /> właściwości.</param>
        <summary>Usuwa element z <see langword="Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `Remove` usuwa element z kolekcji, jego zmniejsza kolekcji <xref:Microsoft.VisualBasic.Collection.Count%2A> właściwość, według jedną. On również zmniejsza `Index` wartość każdego elementu, która wcześniej usuniętego elementu w kolekcji.  
  
 Jeśli element został dodany do kolekcji bez `Key`, należy użyć jego `Index` go usunąć.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Remove` metodę, aby usunąć obiekty <xref:Microsoft.VisualBasic.Collection> obiektu w zmiennej `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 Następujące cztery wywołania `Add` metody `Count` właściwość zawiera 4, element `"Bill"` ma indeks o wartości 1 i element `"Pete"` ma wartość indeksu 4.  
  
 Po pierwsze wywołanie `Remove`, `Count` to 3, element `"Bill"` zostanie usunięty i elementu `"Pete"` ma wartość indeksu 3.  
  
 Po drugie wywołanie `Remove`, `Count` 2, element `"Mike"` zostanie usunięty, a element `"Pete"` ma wartość indeksu 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (string Key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.Remove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Key As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::String ^ Key);" />
      <MemberSignature Language="F#" Value="member this.Remove : string -&gt; unit" Usage="collection.Remove Key" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Key">Unikatowy <see langword="String" /> wyrażenie określające klucza ciąg, który pozwala, zamiast indeksu pozycyjne, uzyskiwanie dostępu do elementu kolekcji. <paramref name="Key" /> musi odpowiadać <paramref name="Key" /> argument określony, gdy element został dodany do kolekcji.</param>
        <summary>Usuwa element z <see langword="Collection" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy `Remove` usuwa element z kolekcji, jego zmniejsza kolekcji <xref:Microsoft.VisualBasic.Collection.Count%2A> właściwość, według jedną. On również zmniejsza `Index` wartość każdego elementu, która wcześniej usuniętego elementu w kolekcji.  
  
 Jeśli element został dodany do kolekcji bez `Key`, należy użyć jego `Index` go usunąć.  
  
   
  
## Examples  
 Ten przykład ilustruje użycie `Remove` metodę, aby usunąć obiekty <xref:Microsoft.VisualBasic.Collection> obiektu w zmiennej `birthdays`.  
  
 [!code-vb[VbVbalrCollectionObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#5)]  
[!code-vb[VbVbalrCollectionObject#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCollectionObject/VB/Class1.vb#9)]  
  
 Następujące cztery wywołania `Add` metody `Count` właściwość zawiera 4, element `"Bill"` ma indeks o wartości 1 i element `"Pete"` ma wartość indeksu 4.  
  
 Po pierwsze wywołanie `Remove`, `Count` to 3, element `"Bill"` zostanie usunięty i elementu `"Pete"` ma wartość indeksu 3.  
  
 Po drugie wywołanie `Remove`, `Count` 2, element `"Mike"` zostanie usunięty, a element `"Pete"` ma wartość indeksu 2.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo" ExplicitInterfaceMemberName="ICollectionCopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void ICollectionCopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionCopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void ICollectionCopyTo(Array ^ array, int index) = System::Collections::ICollection::CopyTo;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Jednowymiarowy <see cref="T:System.Array" /> czyli miejscem docelowym elementów kopiowanych z <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. <see cref="T:System.Array" /> Musi mieć Indeksowanie oparte na zerze.</param>
        <param name="index">Liczony od zera indeks w <paramref name="array" /> od rozpoczyna się kopiowanie które.</param>
        <summary>Kopiuje elementy ze <see cref="T:Microsoft.VisualBasic.Collection" /> do <see cref="T:System.Array" />, rozpoczynając od określonego <see cref="T:System.Array" /> indeksu. Implementuje <see cref="T:System.Collections.ICollection" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy są kopiowane do <xref:System.Array> w tej samej kolejności, w której moduł wyliczający iterację <xref:Microsoft.VisualBasic.Collection> obiektu.  
  
 Ta metoda jest O (`n`) operacji, gdzie `n` są uzyskiwane z <xref:Microsoft.VisualBasic.Collection.System%23Collections%23ICollection%23Count>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> jest mniejsza niż zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> ma charakter wielowymiarowy.  
  
—lub— 
Liczba elementów w źródle <see cref="T:Microsoft.VisualBasic.Collection" /> obiekt jest większy niż dostępna ilość miejsca od <paramref name="index" /> do końca tablicy docelowej <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidCastException">Typ źródła <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu nie można automatycznie rzutować na typ docelowej tablicy <paramref name="array" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count" ExplicitInterfaceMemberName="ICollectionCount">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ICollectionCount" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionCount" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionCount As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized" ExplicitInterfaceMemberName="ICollectionIsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ICollectionIsSynchronized" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionIsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionIsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot" ExplicitInterfaceMemberName="ICollectionSyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ICollectionSyncRoot" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.ICollectionSyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property ICollectionSyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator" ExplicitInterfaceMemberName="ICollectionGetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance class System.Collections.IEnumerator ICollectionGetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.ICollectionGetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function ICollectionGetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ ICollectionGetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca moduł wyliczający, który dokonuje iteracji w kolekcji. Implementuje <see cref="T:System.Collections.ICollection" /> interfejsu.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Obiekt, który może służyć do iterowania po kolekcji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 `foreach` Instrukcja języka C# (`for each` w języku Visual Basic) powoduje ukrycie złożoności modułów wyliczających. W związku z tym, za pomocą `foreach` jest to zalecane, zamiast bezpośredniego wykonywania operacji modułu wyliczającego.  
  
 Moduły wyliczające mogą służyć do odczytu danych w kolekcji, ale nie można za ich pomocą modyfikować kolekcji źródłowej.  
  
 Początkowo moduł wyliczający jest umieszczony przed pierwszym elementem w kolekcji. <xref:System.Collections.IEnumerator.Reset%2A> Metoda przełącza moduł wyliczający do tej pozycji. W tym miejscu <xref:System.Collections.IEnumerator.Current%2A> właściwość jest niezdefiniowana. W związku z tym, należy wywołać <xref:System.Collections.IEnumerator.MoveNext%2A> metody wyprzedzeniem modułu wyliczającego do pierwszego elementu kolekcji przed odczytaniem wartości właściwości <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> zwraca ten sam obiekt, do momentu <xref:System.Collections.IEnumerator.MoveNext%2A> lub <xref:System.Collections.IEnumerator.Reset%2A> jest wywoływana. <xref:System.Collections.IEnumerator.MoveNext%2A> Ustawia <xref:System.Collections.IEnumerator.Current%2A> do następnego elementu.  
  
 Jeśli <xref:System.Collections.IEnumerator.MoveNext%2A> przebiegów koniec kolekcji, moduł wyliczający jest umieszczany za ostatnim elementem w kolekcji i <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`. Gdy moduł wyliczający jest w tym miejscu, kolejne wywołania <xref:System.Collections.IEnumerator.MoveNext%2A> również zwracać `false`. Jeśli ostatnie wywołanie <xref:System.Collections.IEnumerator.MoveNext%2A> zwraca `false`, <xref:System.Collections.IEnumerator.Current%2A> jest niezdefiniowana. Aby ustawić <xref:System.Collections.IEnumerator.Current%2A> do pierwszego elementu w kolekcji ponownie wywołaj <xref:System.Collections.IEnumerator.Reset%2A> następuje <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Moduł wyliczający zachowuje ważność tak długo, jak długo kolekcja pozostaje niezmieniona. Jeśli w kolekcji zostaną wprowadzone zmiany, takie jak dodanie, zmodyfikowanie czy usunięcie elementów, moduł wyliczający jest nieodwracalnie unieważniany, a jego zachowanie staje się niezdefiniowane.  
  
 Moduł wyliczający nie ma wyłącznego dostępu do kolekcji, w związku z tym wyliczanie w kolekcji nie jest wewnętrznie procedurą odporną na wielowątkowość. Aby zagwarantować bezpieczeństwo wątków podczas wyliczania, można zablokować kolekcję podczas całego procesu wyliczania. Aby zezwolić wielu wątkom na dostęp do kolekcji w celu odczytu i zapisu danych, należy zaimplementować własny mechanizm synchronizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="M:System.Collections.IEnumerable.GetEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add" ExplicitInterfaceMemberName="IListAdd">
      <MemberSignature Language="C#" Value="int IList.Add (object Item);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object Item) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListAdd(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (Item As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ Item) = System::Collections::IList::Add;" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="int IList.Add (object value);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListAdd(object value) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Function IListAdd (value As Object) As Integer Implements IList.Add" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListAdd(System::Object ^ value) = System::Collections::IList::Add;" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Item" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do dodania do <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <param name="Item">To be added.</param>
        <summary>Dodaje element do <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <returns>Pozycja, do którego dodano nowy element.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można również użyć <xref:Microsoft.VisualBasic.Collection.Item%2A> właściwości, aby dodać nowe elementy, ustawiając wartość klucza, który nie istnieje w <xref:Microsoft.VisualBasic.Collection> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt jest tylko do odczytu.  
  
—lub— 
<see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt ma stały rozmiar.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Add(System.Object)" />
        <altmember cref="P:Microsoft.VisualBasic.Collection.Item(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear" ExplicitInterfaceMemberName="IListClear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListClear() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListClear" />
      <MemberSignature Language="VB.NET" Value="Sub IListClear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListClear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda usuwa wszystkie elementy z <xref:Microsoft.VisualBasic.Collection> obiektu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> Jest tylko do odczytu.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.Hashtable.Clear" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains" ExplicitInterfaceMemberName="IListContains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance bool IListContains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListContains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListContains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool IListContains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <summary>Określa, czy <see cref="T:Microsoft.VisualBasic.Collection" /> obiekt zawiera określoną wartość. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <returns>Zwraca <see langword="True" /> Jeśli <see cref="T:System.Object" /> znajduje się w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu; w przeciwnym razie <see langword="False" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa, czy <xref:Microsoft.VisualBasic.Collection> obiekt zawiera określoną wartość.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf" ExplicitInterfaceMemberName="IListIndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance int32 IListIndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListIndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IListIndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int IListIndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do zlokalizowania w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <summary>Określa indeks konkretny element w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <returns>Indeks <paramref name="value" /> Jeśli w kolekcji; w przeciwnym razie wartość -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda określa indeks konkretny element w <xref:Microsoft.VisualBasic.Collection> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.IndexOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert" ExplicitInterfaceMemberName="IListInsert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListInsert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListInsert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListInsert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListInsert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <paramref name="value" /> powinien zostać wstawiony.</param>
        <param name="value"><see cref="T:System.Object" /> Do wstawienia do <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <summary>Wstawia element do <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu pod określonym indeksem. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `index` jest równa liczbie elementów w <xref:Microsoft.VisualBasic.Collection> obiektu następnie `value` jest dołączany na końcu.  
  
 W kolekcjach elementów sąsiadujących, takich jak listy, elementy umieszczone po punkcie wstawienia przesuwają się w dół, aby zwolnić miejsce na nowy element. Jeśli kolekcja jest indeksowana, indeksy przeniesionych elementów również są aktualizowane. To zachowanie nie dotyczy kolekcji, w których elementy są pod względem koncepcyjnym pogrupowane w przedziały, np. tablic skrótów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt jest tylko do odczytu.  
  
—lub— 
<see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt ma stały rozmiar.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> to odwołanie o wartości null w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize" ExplicitInterfaceMemberName="IListIsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsFixedSize" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly" ExplicitInterfaceMemberName="IListIsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IListIsReadOnly" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListIsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IListIsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item" ExplicitInterfaceMemberName="IListItem">
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int Index] { get; set; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".property instance object IListItem(int32)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.VisualBasic.Collection.IListItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(Index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int Index); void set(int Index, System::Object ^ value); };" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="object System.Collections.IList.IListItem[int index] { get; set; }" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="VB.NET" Value=" Property IListItem(index As Integer) As Object Implements IList.IListItem" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.IListItem[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2" />
      <MemberSignature Language="F#" Usage="Microsoft.VisualBasic.Collection.IListItem" FrameworkAlternate="netframework-2.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove" ExplicitInterfaceMemberName="IListRemove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><see cref="T:System.Object" /> Do usunięcia z <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <summary>Usuwa pierwsze wystąpienie określonego obiektu z <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcjach elementów sąsiadujących, takich jak listy, elementy umieszczone po usuniętym elemencie przesuwają się w górę, aby zająć zwolnione miejsce. Jeśli kolekcja jest indeksowana, indeksy przeniesionych elementów również są aktualizowane. To zachowanie nie dotyczy kolekcji, w których elementy są pod względem koncepcyjnym pogrupowane w przedziały, np. tablic skrótów. Jeśli `value` nie zostanie znaleziony w <xref:Microsoft.VisualBasic.Collection> obiektu <xref:Microsoft.VisualBasic.Collection> obiektu pozostaje bez zmian i jest zgłaszany żaden wyjątek.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt jest tylko do odczytu.  
  
—lub— 
<see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt ma stały rozmiar.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.Remove(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt" ExplicitInterfaceMemberName="IListRemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void IListRemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.IListRemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub IListRemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void IListRemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu element pod określonym indeksem. Implementuje <see cref="T:System.Collections.IList" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kolekcjach elementów sąsiadujących, takich jak listy, elementy umieszczone po usuniętym elemencie przesuwają się w górę, aby zająć zwolnione miejsce. Jeśli kolekcja jest indeksowana, indeksy przeniesionych elementów również są aktualizowane. To zachowanie nie dotyczy kolekcji, w których elementy są pod względem koncepcyjnym pogrupowane w przedziały, np. tablic skrótów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> nie jest prawidłowym indeksem w <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt jest tylko do odczytu.  
  
—lub— 
<see cref="T:Microsoft.VisualBasic.Collection" /> Obiekt ma stały rozmiar.</exception>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Collections.IList.RemoveAt(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization" ExplicitInterfaceMemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">Obiekt, który zainicjował wywołanie zwrotne.</param>
        <summary>Jest uruchamiany po całej <see cref="T:Microsoft.VisualBasic.Collection" /> wykonać deserializacji wykresu obiektu. Implementuje <see cref="T:System.Runtime.Serialization.IDeserializationCallback" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana po całej <xref:Microsoft.VisualBasic.Collection> wykonać deserializacji wykresu obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
        <altmember cref="M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData" ExplicitInterfaceMemberName="GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Collection.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> obiekt zawierający informacje wymagane do wykonywania serializacji <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> obiekt zawierający źródłowe i docelowe serializowanym strumieniu skojarzone z <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu.</param>
        <summary>Zwraca dane potrzebne do serializacji <see cref="T:Microsoft.VisualBasic.Collection" /> obiektu. Implementuje <see cref="T:System.Runtime.Serialization.ISerializable" /> interfejsu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca dane potrzebne do serializacji <xref:Microsoft.VisualBasic.Collection> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:Microsoft.VisualBasic.Collection" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <altmember cref="M:System.Collections.Hashtable.OnDeserialization(System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>
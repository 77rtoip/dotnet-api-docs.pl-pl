<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cec0c607fc2b7dd375bd0d2fa79de046945ffe69" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174291" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <see langword="Interaction" /> Moduł zawiera procedury służy do interakcji z obiektami, aplikacji i systemów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten moduł obsługuje słów kluczowych języka Visual Basic i elementy członkowskie biblioteki wykonawczej, które uruchomić inne programy, wywołanie metody lub właściwości dźwiękowej Sygnalizuj z komputera, podać parametry wiersza polecenia, modyfikowania obiektów COM i kontrolować okien dialogowych.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Shell` funkcji, aby uruchomić aplikację, określone przez użytkownika. Określanie <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> jako drugi argument otwiera aplikację w normalny rozmiar i nadaje mu fokus.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
' The preceding path is for Windows XP.  
' The Windows 2000 path is C:\WINNT\system32\calc.exe.  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktywuje aplikację, która jest już uruchomiona.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId">
          <see langword="Integer" /> Określanie identyfikator procesu Win32 przypisane do tego procesu. Można użyć Identyfikatora zwróconego przez <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, o ile nie jest zerowy.</param>
        <summary>Aktywuje aplikację, która jest już uruchomiona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć `AppActivate` do zapewnienia aktywnego okna aplikacji fokus. Może nie mieć dojście lub odwołanie do aktywnego okna lub nawet wiedzieć, który okno jest aktywne w danym momencie. W takim przypadku nie można użyć <xref:System.Windows.Forms.Control.Focus%2A> metody.  
  
 `AppActivate` Funkcji zmiany fokusu do okna lub aplikacji o nazwie, ale nie ma wpływu na czy zminimalizowane lub zmaksymalizowane. Poza oknem aktywowana aplikacja przenosi fokus, gdy użytkownik wykona akcję do fokusu lub zamknąć okno. Można użyć `Shell` funkcji, aby uruchomić aplikację i ustaw styl okna.  
  
 Jeśli używasz `Title` parametru `AppActivate` porównania bez uwzględniania wielkości liter, ale w przeciwnym razie wymaga dokładnego dopasowania z zawartością paska tytułu. Najpierw wyszukiwana za pomocą okien najwyższego poziomy, a następnie za pomocą okien podrzędnych. Jeśli nie można odnaleźć dopasowania, zgłasza <xref:System.ArgumentException>.  
  
 Można użyć `AppActivate` tylko z procesów, które posiadają systemu windows. Większość aplikacji konsoli nie ma systemu windows, co oznacza, że nie są wyświetlane na liście procesów, które `AppActivate` wyszukiwania. Podczas uruchamiania z aplikacji konsoli, system tworzy osobnych procesach, aby uruchomić aplikację i zwraca wyniki do procesu konsoli. W związku z tym gdy użytkownik żąda bieżący identyfikator procesu, otrzymasz identyfikator procesu tego procesu oddzielne zamiast identyfikatora procesu aplikacji konsoli.  
  
 W czasie wykonywania `AppActivate` funkcja aktywuje żadnych działającej aplikacji o tytule, który odpowiada `Title` lub za pomocą Identyfikatora procesu, który odpowiada `ProcessId`. Jeśli nie brak dokładnego dopasowania, zostaje uaktywniony dowolnej aplikacji, których ciąg tytułu kończy się wyrazem `Title`. Jeśli istnieje więcej niż jedną aplikację o nazwie `Title`, `AppActivate` funkcja arbitralnie wybiera jeden do aktywacji.  
  
> [!NOTE]
>  `AppActivate` Wymaga funkcji `UIPermission` na <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> poziomu, który może mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 W tym przykładzie przedstawiono różnych zastosowań `AppActivate` funkcji, aby aktywować okna aplikacji. Jeśli nie jest uruchomiony proces Notatnik, zgłasza przykładzie <xref:System.ArgumentException>. `Shell` Procedurze przyjęto założenie, znajdują się w określonej ścieżce.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title">
          <see langword="String" /> wyrażenie określające tytuł na pasku tytułu aplikacji, którą chcesz aktywować. Można użyć nazwy przypisane do aplikacji, gdy została ona uruchomiona.</param>
        <summary>Aktywuje aplikację, która jest już uruchomiona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć `AppActivate` do zapewnienia aktywnego okna aplikacji fokus. Może nie mieć dojście lub odwołanie do aktywnego okna lub nawet wiedzieć, który okno jest aktywne w danym momencie. W takim przypadku nie można użyć <xref:System.Windows.Forms.Control.Focus%2A> metody.  
  
 `AppActivate` Funkcji zmiany fokusu do okna lub aplikacji o nazwie, ale nie ma wpływu na czy zminimalizowane lub zmaksymalizowane. Poza oknem aktywowana aplikacja przenosi fokus, gdy użytkownik wykona akcję do fokusu lub zamknąć okno. Można użyć `Shell` funkcji, aby uruchomić aplikację i ustaw styl okna.  
  
 Jeśli używasz `Title` parametru `AppActivate` porównania bez uwzględniania wielkości liter, ale w przeciwnym razie wymaga dokładnego dopasowania z zawartością paska tytułu. Najpierw wyszukiwana za pomocą okien najwyższego poziomy, a następnie za pomocą okien podrzędnych. Jeśli nie można odnaleźć dopasowania, zgłasza <xref:System.ArgumentException>.  
  
 Można użyć `AppActivate` tylko z procesów, które posiadają systemu windows. Większość aplikacji konsoli nie ma systemu windows, co oznacza, że nie są wyświetlane na liście procesów, które `AppActivate` wyszukiwania. Podczas uruchamiania z aplikacji konsoli, system tworzy osobnych procesach, aby uruchomić aplikację i zwraca wyniki do procesu konsoli. W związku z tym gdy użytkownik żąda bieżący identyfikator procesu, otrzymasz identyfikator procesu tego procesu oddzielne zamiast identyfikatora procesu aplikacji konsoli.  
  
 W czasie wykonywania `AppActivate` funkcja aktywuje żadnych działającej aplikacji o tytule, który odpowiada `Title` lub za pomocą Identyfikatora procesu, który odpowiada `ProcessId`. Jeśli nie brak dokładnego dopasowania, zostaje uaktywniony dowolnej aplikacji, których ciąg tytułu kończy się wyrazem `Title`. Jeśli istnieje więcej niż jedną aplikację o nazwie `Title`, `AppActivate` funkcja arbitralnie wybiera jeden do aktywacji.  
  
> [!NOTE]
>  `AppActivate` Wymaga funkcji `UIPermission` na <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> poziomu, który może mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 W tym przykładzie przedstawiono różnych zastosowań `AppActivate` funkcji, aby aktywować okna aplikacji. Jeśli nie jest uruchomiony proces Notatnik, zgłasza przykładzie <xref:System.ArgumentException>. `Shell` Procedurze przyjęto założenie, znajdują się w określonej ścieżce.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dźwięki sygnał przez osoby mówiącej komputera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gęstość i czas trwania dźwięku zależą od sprzętu i systemu oprogramowania i w związku z tym różnią się między komputerami.  
  
> [!NOTE]
>  `Beep` Wymaga funkcji `UIPermission` na <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> poziomu, który może mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 W tym przykładzie użyto `Beep` funkcja dźwiękowy sygnał przez osoby mówiącej komputera.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Wymagana. <see langword="Object" />. Wskaźnik do obiektu udostępnianie właściwości lub metody.</param>
        <param name="ProcName">Wymagana. <see langword="String" />. Wyrażenia ciągu zawierającego nazwę właściwości lub metody obiektu.</param>
        <param name="UseCallType">Wymagana. Element członkowski wyliczenia typu <see cref="T:Microsoft.VisualBasic.CallType" /> reprezentujący typ procedury. Wartość <see langword="CallType" /> może być <see langword="Method" />, <see langword="Get" />, lub <see langword="Set" />.</param>
        <param name="Args">Opcjonalna. <see langword="ParamArray" />. Tablica parametrów zawierający argumenty do przekazania do właściwości lub metody.</param>
        <summary>Wykonuje metodę obiektu lub ustawia lub zwraca wartość właściwości w obiekcie.</summary>
        <returns>Wykonuje metodę obiektu lub ustawia lub zwraca wartość właściwości w obiekcie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CallByName` Funkcja jest używana w czasie wykonywania, Pobierz właściwość, ustaw właściwość lub wywołanie metody.  
  
   
  
## Examples  
 W poniższym przykładzie używa pierwszego wiersza `CallByName` można ustawić `Text` właściwości pola tekstowego, drugi wiersz pobiera wartość `Text` właściwości, a trzeci wiersz wywołuje `Move` metodę, aby przenieść pole tekstowe.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 W następnym przykładzie użyto `CallByName` funkcji do wywołania `Add` i `Item` metody obiektu kolekcji.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nieprawidłowy <paramref name="UseCallType" /> wartości; musi być <see langword="Method" />, <see langword="Get" />, lub <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Wymagana. <see langword="Double" />. Przekazano wyrażenia liczbowego, których wynikiem jest wartość z zakresu od 1 do liczby elementów <c>wybór</c> argumentu.</param>
        <param name="Choice">Wymagana. <see langword="Object" /> Tablica parametrów. Można podać zmiennej lub wyrażenie obliczane do <see langword="Object" /> typu danych, aby uzyskać listę <see langword="Object" /> zmiennych lub wyrażeń oddzielonych przecinkami lub tablicy jednowymiarowej <see langword="Object" /> elementów.</param>
        <summary>Wybiera i zwraca wartość z listy argumentów.</summary>
        <returns>Wybiera i zwraca wartość z listy argumentów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Choose` Funkcja zwraca element członkowski listy przekazano `Choice()`, na podstawie wartości z `Index`. Wybrano pierwszego elementu członkowskiego listy podczas `Index` 1. Wybrano ostatniego członka listy podczas `Index` jest `UBound`(`Choice()`). Jeśli `Index` znajduje się poza tymi limitami `Choose` zwraca `Nothing`.  
  
 Jeśli `Index` nie jest liczbą całkowitą, zostanie zaokrąglony do najbliższej liczby całkowitej przed rozpoczęciem przetwarzania.  
  
 Można użyć `Choose` wartość na liście możliwości.  
  
> [!NOTE]
>  Wyrażenia na liście argument może zawierać wywołania funkcji. W ramach przygotowania do listy argumentów dla wywołania `Choose`, kompilator Visual Basic wywołuje funkcję co w każdym wyrażeniu. Oznacza to, że nie może zależeć konkretną funkcję nie wywoływana zaznaczenie innego wyrażenia przez `Index`.  
  
   
  
## Examples  
 W tym przykładzie użyto `Choose` funkcji, aby wyświetlić nazwę w odpowiedzi na indeks, który został przekazany do procedury w `Ind` parametru.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca część argumentu wiersza polecenia używane do uruchamiania programu Visual Basic lub program wykonywalny utworzonych w języku Visual Basic. <see langword="My" /> Funkcja zapewnia większą wydajność i wydajność niż <see langword="Command" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>Zwraca część argumentu wiersza polecenia używane do uruchamiania programu Visual Basic lub program wykonywalny utworzonych w języku Visual Basic.  <see langword="My" /> Funkcja zapewnia większą wydajność i wydajność niż <see langword="Command" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po zwróceniu argumenty, możesz wyszukać ograniczniki, takie jak spacje, ukośniki wstecz lub do przodu, łączniki lub znaki cudzysłowu, aby podzielić lub wyszukaj ciąg dla poszczególnych parametrów.  
  
 W przypadku aplikacji utworzonych w języku Visual Basic i kompilowane do plików .exe `Command` funkcja zwraca argumenty, które są wyświetlane po nazwie aplikacji w wierszu polecenia, w tym formularzu: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 W tym przykładzie użyto `Command` funkcja zwracająca argumenty wiersza polecenia w obiekt, który zawiera tablicę.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Wymagana. <see langword="String" />. Identyfikator programu obiektu do utworzenia.</param>
        <param name="ServerName">Opcjonalna. <see langword="String" />. Nazwa serwera sieci, gdzie można utworzyć obiektu. Jeśli <c>ServerName</c> to ciąg pusty (""), używany jest komputer lokalny.</param>
        <summary>Tworzy i zwraca odwołanie do obiektu COM. <see langword="CreateObject" /> Nie można użyć do utworzenia wystąpienia klas w języku Visual Basic, chyba że te klasy jawnie są widoczne jako składniki COM.</summary>
        <returns>Tworzy i zwraca odwołanie do obiektu COM. <see langword="CreateObject" /> Nie można użyć do utworzenia wystąpienia klas w języku Visual Basic, chyba że te klasy jawnie są widoczne jako składniki COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Do utworzenia wystąpienia składnika modelu COM, należy przypisać obiekt zwrócony przez `CreateObject` zmiennej obiektu:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 Typ zmiennej obiektu, który służy do przechowywania zwrócony obiekt może wpłynąć na wydajność aplikacji. Deklarowanie zmiennej obiektu z `As Object` klauzuli tworzy zmienną, która może zawierać odwołania do dowolnego typu obiektu. Dostęp do obiektu za pomocą tej zmiennej jest jednak *późnym wiązaniem*, oznacza to, że powiązanie występuje po uruchomieniu programu. Istnieje wiele przyczyn, że należy unikać późne wiązanie, łącznie z mniejszą wydajność aplikacji.  
  
 Można utworzyć zmiennej obiektu, który powoduje wczesnego wiązania — wiązanie oznacza to, gdy programu Microsoft. Aby to zrobić, Dodaj odwołanie do biblioteki typów dla obiekt z **COM** karcie **Dodaj odwołanie** okno dialogowe na **projektu** menu. Następnie należy zadeklarować zmienną obiektu określonego typu obiektu. W większości przypadków jest bardziej wydajne, aby użyć `Dim` instrukcji i podstawowego zestawu międzyoperacyjnego do tworzenia obiektów, niż można użyć `CreateObject` funkcji.  
  
## <a name="interacting-with-unmanaged-code"></a>Interakcja z niezarządzanym kodem  
 Inny problem jest, obiekty COM wykorzystania kodu niezarządzanego — kodu bez korzyści środowisko uruchomieniowe języka wspólnego. Pewnym stopniu złożoności jest objętego mieszanie kodu zarządzanego języka Visual Basic z kodem niezarządzanym z modelu COM. Podczas dodawania odwołania do obiektu COM, Visual Basic wyszukuje podstawowy zestaw międzyoperacyjny (PIA) dla tej biblioteki; w przypadku ich znalezienia, a następnie go używa. Jeśli podstawowy zestaw MIĘDZYOPERACYJNY nie zostanie znaleziona, następnie tworzy zestaw współdziałanie, który zawiera klasy lokalnej współdziałania dla każdej klasy biblioteki COM. Aby uzyskać więcej informacji, zobacz [współdziałanie COM w aplikacjach .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Zwykle należy używać silnie powiązanych obiektów i podstawowe zestawy międzyoperacyjne, jeśli to możliwe. Przykłady poniżej użyj `CreateObject` funkcji z obiektami programu Microsoft Office do pokazania tylko do celów. Jednak te obiekty są łatwiejsze w użyciu i bardziej niezawodny, gdy jest używany z odpowiednią podstawowego zestawu międzyoperacyjnego.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Tworzenie obiektu na komputerze zdalnym  
 Można utworzyć obiektu na zdalnym komputerze sieciowym, przekazując nazwy komputera do `ServerName` argumentu `CreateObject` funkcji. Ta nazwa jest taka sama jak nazwa komputera część nazwę udziału: udziału o nazwie "\\\MyServer\Public," `ServerName` jest "MójSerwer".  
  
> [!NOTE]
>  Zapoznaj się z dokumentacją modelu COM (zobacz w witrynie Microsoft Developer Network) Aby uzyskać dodatkowe informacje dotyczące tworzenia aplikacji dostępny na zdalnym komputerze sieciowym. Może być konieczne dodanie klucza rejestru dla aplikacji.  
  
 Poniższy kod zwraca numer wersji wystąpienia programu Excel uruchomiona na komputerze zdalnym o nazwie `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Jeśli nazwa serwera zdalnego jest nieprawidłowa lub jest niedostępna, występuje błąd w czasie wykonywania.  
  
> [!NOTE]
>  Użyj `CreateObject` po nie bieżącego wystąpienia obiektu. Jeśli wystąpienie obiektu jest już uruchomione, nowe wystąpienie została uruchomiona, i utworzono obiekt określonego typu. Aby użyć bieżącego wystąpienia lub aby uruchomić aplikację i załadować pliku, należy użyć `GetObject` funkcji. Jeśli obiekt zarejestrował się jako obiekt jednego wystąpienia, tylko jedno wystąpienie obiektu jest tworzony, niezależnie od tego, jak często `CreateObject` jest wykonywana.  
  
## <a name="creating-framework-objects"></a>Tworzenie obiektów szablonu  
 Można użyć `CreateObject` funkcja tylko w celu utworzenia obiektu COM. Gdy nie istnieje równoważne dokładny mechanizm do tworzenia obiektu .NET Framework <xref:System.Activator> w <xref:System> przestrzeń nazw zawiera metody służące do tworzenia obiektów lokalnym lub zdalnym. W szczególności <xref:System.Activator.CreateInstance%2A> metody lub <xref:System.Activator.CreateInstanceFrom%2A> metoda może być przydatna.  
  
> [!IMPORTANT]
>  `CreateObject` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `CreateObject` działać do utworzenia arkusza programu Microsoft Excel i zapisuje w pliku arkusza. Aby użyć tego przykładu, Excel, należy skonfigurować na komputerze, na którym działa ten program. Ponadto należy dodać odwołanie do biblioteki typów z **COM** karty **Dodaj odwołanie** okno dialogowe na **projektu** menu. Nazwa biblioteki typu różni się w zależności od używanej wersji programu Excel zainstalowany na tym komputerze. Na przykład, nosi nazwę biblioteki typów dla programu Microsoft Excel 2002 **biblioteki obiektów programu Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Serwer jest niedostępny</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie istnieje żaden obiekt określonego typu</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę aplikacji lub projektu, do którego stosuje się ustawienia sekcji lub klucza.</param>
        <param name="Section">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę sekcji, z którego jest usuwany ustawienie klucza. Jeśli tylko <c>AppName</c> i <c>sekcji</c> są dostarczane, określona sekcja jest usuwany wraz ze wszystkich powiązanych ustawień klucza.</param>
        <param name="Key">Opcjonalna. <see langword="String" /> w wyrażeniu zawierającym nazwę ustawienia klucza usuwany.</param>
        <summary>Usuwa sekcji lub ustawienie klucza z wpisu aplikacji w rejestrze systemu Windows. <see langword="My" /> Funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="DeleteSetting" /> funkcji. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" /> .</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wszystkie argumenty są dostarczane, określonego ustawienia zostaną usunięte. Występuje błąd czasu wykonywania, jeśli próba użycia `DeleteSetting` w sekcji nieistniejącą lub ustawienie klucza.  
  
 `DeleteSetting` wymaga, czy użytkownik jest zalogowany ponieważ działa ona w obszarze `HKEY_LOCAL_USER` klucz rejestru, który nie jest aktywne, dopóki użytkownik loguje się interaktywnie.  
  
 Ustawienia rejestru, które ma być uzyskiwany dostęp z innego nieinteraktywnego procesu (na przykład Mtx.exe) powinny być przechowywane w obszarze albo `HKEY_LOCAL_MACHINE\Software\` lub `HKEY_USER\DEFAULT\Software` kluczy rejestru.  
  
   
  
## Examples  
 W poniższym przykładzie najpierw użyto `SaveSetting` procedurę, aby tworzyć wpisy w rejestrze systemu Windows dla `MyApp` aplikacji, a następnie używa `DeleteSetting` funkcji, aby je usunąć. Ponieważ nie `Key` argument zostanie określony, cała `Startup` sekcji zostanie usunięty, w tym nazwy sekcji i wszystkich jego kluczy.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Użytkownik nie jest zalogowany.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca ciąg skojarzony ze zmienną środowiskową systemu operacyjnego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Wymagana. Wyrażenie obliczane albo ciąg zawierający nazwę zmiennej środowiskowej lub integer odpowiadającego kolejności numerycznej ciągu środowiska w tabeli ciągów środowiska.</param>
        <summary>Zwraca ciąg skojarzony ze zmienną środowiskową systemu operacyjnego.</summary>
        <returns>Zwraca ciąg skojarzony ze zmienną środowiskową systemu operacyjnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Expression` zawiera ciąg, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funkcja zwraca tekst przypisany do określonego środowiska ciąg — to znaczy tekst po znaku równości (=) w tabeli ciągów środowiska dla tej zmiennej środowiskowej. Jeśli ciąg w `Expression` nie można znaleźć w tabeli ciągów środowiska ciąg o zerowej długości ("") jest zwracany.  
  
 Jeśli `Expression` zawiera liczba całkowita, ciąg zajmujące, zwracany jest pozycji liczbowych w tabeli ciągów środowiska. W takim przypadku <xref:Microsoft.VisualBasic.Interaction.Environ%2A> zwraca cały tekst, łącznie z nazwą zmiennej środowiskowej. Jeśli w określonej pozycji nie ma ciągu środowiska <xref:Microsoft.VisualBasic.Interaction.Environ%2A> zwraca ciąg o zerowej długości.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funkcja wymaga środowiska uprawnienia, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funkcji, aby podać numer i długość `PATH` instrukcji z tabeli ciągów środowiska.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> Brak.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Wymagana. Wyrażenie obliczane albo ciąg zawierający nazwę zmiennej środowiskowej lub integer odpowiadającego kolejności numerycznej ciągu środowiska w tabeli ciągów środowiska.</param>
        <summary>Zwraca ciąg skojarzony ze zmienną środowiskową systemu operacyjnego.</summary>
        <returns>Zwraca ciąg skojarzony ze zmienną środowiskową systemu operacyjnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `Expression` zawiera ciąg, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funkcja zwraca tekst przypisany do określonego środowiska ciąg — to znaczy tekst po znaku równości (=) w tabeli ciągów środowiska dla tej zmiennej środowiskowej. Jeśli ciąg w `Expression` nie można znaleźć w tabeli ciągów środowiska ciąg o zerowej długości ("") jest zwracany.  
  
 Jeśli `Expression` zawiera liczba całkowita, ciąg zajmujące, zwracany jest pozycji liczbowych w tabeli ciągów środowiska. W takim przypadku <xref:Microsoft.VisualBasic.Interaction.Environ%2A> zwraca cały tekst, łącznie z nazwą zmiennej środowiskowej. Jeśli w określonej pozycji nie ma ciągu środowiska <xref:Microsoft.VisualBasic.Interaction.Environ%2A> zwraca ciąg o zerowej długości.  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A> Funkcja wymaga środowiska uprawnienia, które mogą mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W tym przykładzie użyto <xref:Microsoft.VisualBasic.Interaction.Environ%2A> funkcji, aby podać numer i długość `PATH` instrukcji z tabeli ciągów środowiska.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Expression" /> Brak.</exception>
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę aplikacji lub projektu, którego ustawienia klucza są wymagane.</param>
        <param name="Section">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę sekcji, w których ustawień klucza są wymagane. <see langword="GetAllSettings" /> Zwraca obiekt, który zawiera dwuwymiarowa tablicy ciągów. Ciągi zawiera wszystkie ustawienia kluczy w określonej sekcji, a także ich wartości.</param>
        <summary>Zwraca listę ustawień klucza i odpowiadających im wartości (pierwotnie utworzone <see langword="SaveSetting" />) z wpisu aplikacji w rejestrze systemu Windows. Przy użyciu <see langword="My" /> funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="GetAllSettings" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Zwraca listę ustawień klucza i odpowiadających im wartości (pierwotnie utworzone <see langword="SaveSetting" />) z wpisu aplikacji w rejestrze systemu Windows.  Przy użyciu <see langword="My" /> funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="GetAllSettings" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Zwraca niezainicjowanej `Object` Jeśli `AppName` lub `Section` nie istnieje.  
  
 Ponieważ działa ona w obszarze `HKEY_LOCAL_USER` klucz rejestru, który nie jest aktywne, dopóki użytkownik loguje się interaktywnie, `GetAllSettings` wymaga się, że użytkownik jest zalogowany.  
  
 Ustawienia rejestru, które ma być uzyskiwany dostęp z innego nieinteraktywnego procesu (na przykład Mtx.exe) powinny być przechowywane w obszarze albo `HKEY_LOCAL_MACHINE\Software\` lub `HKEY_USER\DEFAULT\Software` kluczy rejestru.  
  
   
  
## Examples  
 W tym przykładzie najpierw używane `SaveSetting` funkcji, aby tworzyć wpisy w rejestrze systemu Windows dla aplikacji, określony jako `AppName`, następnie używa `GetAllSettings` funkcji, aby wyświetlić ustawienia. Należy pamiętać, że aplikacja nazwy i `Section` nazwy nie można pobrać z `GetAllSettings`. Na koniec `DeleteSetting` funkcja usuwa wpisy aplikacji.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Użytkownik nie jest zalogowany.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcjonalna. <see langword="String" />. Pełna ścieżka i nazwa pliku zawierającego obiekt do pobrania. Jeśli <c>PathName</c> zostanie pominięty, <c>klasy</c> jest wymagana.</param>
        <param name="Class">Jeśli wymagane <c>PathName</c> nie jest dostarczony. <see langword="String" />. Ciąg reprezentujący klasę obiektu. <c>Klasy</c> argument ma następujące składni i części: <c>appname</c><c>.</c><c>objecttype</c> [1 | 1] parametru [1 | 2] opis [2 | 1] <c>appname</c> [2 | 2] wymagany. <see langword="String" />. Nazwa aplikacji dostarczającej obiekt.  [3 | 1] <c>objecttype</c> [3 | 2] wymagany. <see langword="String" />. Typ lub klasę obiektu, które można utworzyć.</param>
        <summary>Zwraca odwołanie do obiektu dostarczonego przez składnik COM.</summary>
        <returns>Zwraca odwołanie do obiektu dostarczonego przez składnik COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj `GetObject` funkcji w celu załadowania wystąpienia składnika modelu COM z pliku. Ilustruje to poniższy przykład.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Po uruchomieniu tego kodu, aplikację skojarzoną z określonym `PathName` uruchamiania i aktywacji obiektu w określonym pliku.  
  
## <a name="default-cases"></a>Przypadki domyślne  
 Jeśli `PathName` jest ciągiem o zerowej długości (`""`), `GetObject` zwraca nowe wystąpienie obiektu typu określonej klasy. Jeśli `PathName` argument zostanie pominięty, `GetObject` zwraca aktualnie aktywny obiekt typu klasy określony w `Class`. Jeśli nie istnieje żaden obiekt określonego typu, wystąpi błąd.  
  
## <a name="accessing-a-subobject"></a>Uzyskiwanie dostępu do podobiektów.  
 Niektóre aplikacje umożliwiają uaktywnienie podobiektów, skojarzonych z plikiem. Aby to zrobić, należy dodać wykrzyknik (`!`) na końcu nazwy pliku i wykonaj go ciągiem, który identyfikuje części pliku chcesz aktywować. Aby uzyskać informacje dotyczące sposobu tworzenia tych parametrów zobacz dokumentację dla aplikacji, który utworzył obiekt.  
  
 Na przykład w aplikacji do rysowania może mieć wiele warstw do rysunku przechowywane w pliku. Można użyć poniższego kodu, aby aktywować warstwy w rysunku o nazwie `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Określanie klasy  
 Jeśli nie określisz obiektu `Class`, automatyzacji określa aplikacji do uruchomienia i obiektu do aktywacji, na podstawie nazwy pliku, należy podać. Niektóre pliki, jednak może obsługiwać więcej niż jedną klasę obiektu. Przykładowo, rysunek może obsługiwać trzy różne typy obiektów: `Application` obiektu `Drawing` obiektu, a `Toolbar` obiektów, które są częścią tego samego pliku. Aby określić, w pliku obiektu, który chcesz aktywować, Użyj opcjonalnego `Class` argumentu. Ilustruje to poniższy przykład.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 W powyższym przykładzie `Figment` jest nazwą aplikacji do rysowania i `Drawing` jest jednym z obsługiwanych typów obiektów.  
  
## <a name="using-the-object"></a>Używanie obiektu  
 Po uaktywnieniu obiektu możesz odwołuje się do niego w kodzie przy użyciu zadeklarowania zmiennej obiektu. W powyższym przykładzie uzyskujesz dostęp właściwości i metody dla nowego obiektu przy użyciu zmiennej obiektu `drawObj`. Ilustruje to poniższy przykład.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Użyj `GetObject` działać po bieżącego wystąpienia obiektu lub jeśli chcesz utworzyć obiekt przy użyciu pliku załadowane. Jeśli istnieje nie bieżącego wystąpienia, a nie chcesz, aby uruchomić obiektu załadowany plik, użyj <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> funkcji.  
>   
>  Jeśli obiekt zarejestrował się jako obiekt jednego wystąpienia ActiveX, tylko jedno wystąpienie obiektu jest tworzony, niezależnie od tego, jak często `CreateObject` jest wywoływana. W przypadku obiektu jednego wystąpienia `GetObject` zawsze zwraca to samo wystąpienie wywołanego z ciągiem o zerowej długości (`""`) składni i powoduje błąd, jeśli `PathName` zostanie pominięty argument. Nie można użyć `GetObject` uzyskać odwołania do klasy utworzonej za pomocą Visual Basic.  
  
> [!IMPORTANT]
>  `GetObject` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `GetObject` funkcji, aby uzyskać odwołania do konkretnego arkusza programu Microsoft Excel (`excelObj`). Używa arkusza `Application` właściwości, aby wyświetlić programu Excel, zamknij go i wykonywać inne akcje. Przy użyciu dwóch wywołań interfejsu API, `detectExcel` procedura wygląda dla programu Excel i jeśli została uruchomiona, wprowadza go do tabeli z obiektu. W pierwszym wywołaniu `GetObject` powoduje błąd w przypadku programu Excel nie jest już uruchomiona, który w tym przykładzie powoduje, że `excelWasNotRunning` flagi należy ustawić `True`. Drugie wywołanie `GetObject` Określa plik, aby otworzyć. Jeśli program Excel nie jest już uruchomiona, drugie wywołanie uruchomi go i zwraca odwołanie do arkusza reprezentowanego przez określony plik `test.xls`. Plik musi istnieć w określonej lokalizacji. w przeciwnym razie zwraca Visual Basic <xref:System.IO.FileNotFoundException>. Następnie przykładowy kod sprawia, że program Excel, jak i okna zawierającego określony arkusz.  
  
 W tym przykładzie wymaga `Option Strict Off` ponieważ używa późne wiązanie, których obiekty są przypisywane do zmiennych typu `Object`. Można określić `Option Strict On` i zadeklarować obiekty w określonych typów obiektów, jeśli Dodaj odwołanie do biblioteki typów programu Excel z **COM** karcie **Dodaj odwołanie** okna dialogowego ** Projekt** menu w programie Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Podczas wywoływania `getExcel` funkcji, dokonuje czy Excel jest już uruchomione. Jeśli nie, tworzone jest wystąpienie.  
  
> [!IMPORTANT]
>  Dla uproszczenia poprzednim przykładzie przyjęto założenie, że wszystkie okna o nazwie `XLMAIN` należy do wystąpienia programu Microsoft Excel. Jeśli inny obiekt, prawdopodobnie jest uruchamiana przez nielegalnemu naruszeniu utworzony okna o tej nazwie, otrzyma wszystkie wiadomości, które są przeznaczone dla programu Excel. W aplikacji do użycia w środowisku produkcyjnym, należy uwzględnić niektórych bardziej rygorystyczne testy w celu sprawdzenia, czy `XLMAIN` rzeczywiście należy do programu Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Nie istnieje żaden obiekt typu określonej klasy.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie obiektu o określonej nazwie i ścieżka pliku nie istnieje.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę aplikacji lub projektu, którego ustawienia klucza jest wymagane.</param>
        <param name="Section">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę sekcji, w którym znajduje się ustawienie klucza.</param>
        <param name="Key">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę ustawienia klucza do zwrócenia.</param>
        <param name="Default">Opcjonalna. Wyrażenia zawierającego wartość do zwrócenia, jeśli wartość nie została ustawiona <c>klucza</c> ustawienie. Pominięcie <c>domyślne</c> zakłada, że ciąg o zerowej długości ("").</param>
        <summary>Zwraca wartość ustawienia klucza z wpisu aplikacji w rejestrze systemu Windows. <see langword="My" /> Funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="GetAllSettings" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Zwraca wartość ustawienia klucza z wpisu aplikacji w rejestrze systemu Windows.  <see langword="My" /> Funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dowolny z elementów o nazwie w `GetSetting` argumenty nie istnieją, `GetSetting` zwraca wartość `Default`.  
  
 Ponieważ działa ona w obszarze `HKEY_LOCAL_USER` klucz rejestru, który nie jest aktywne, dopóki użytkownik loguje się interaktywnie, `GetSetting` wymaga się, że użytkownik jest zalogowany.  
  
 Ustawienia rejestru, które ma być uzyskiwany dostęp z innego nieinteraktywnego procesu (na przykład Mtx.exe) powinny być przechowywane w obszarze albo `HKEY_LOCAL_MACHINE\Software\` lub `HKEY_USER\DEFAULT\Software` kluczy rejestru.  
  
 `GetSetting` wymaga `Read` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 W tym przykładzie najpierw używane `SaveSetting` funkcji, aby tworzyć wpisy w rejestrze systemu Windows dla aplikacji, określony jako `AppName`, a następnie używa `GetSetting` funkcji do wyświetlania, jedno z ustawień. Ponieważ `Default` argument zostanie określony, zwracana jest gwarantowana niektóre wartości. Zwróć uwagę, że `Section` nazwy nie można pobrać z `GetSetting`. Na koniec `DeleteSetting` funkcja usuwa wpisy wszystkich aplikacji.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Jeden lub więcej argumentów nie są <see langword="String" /> wyrażeń lub użytkownik nie jest zalogowany.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Wymagana. <see langword="Boolean" />. Wyrażenie, które chcesz ocenić.</param>
        <param name="TruePart">Wymagana. <see langword="Object" />. Jeśli zwrócony <c>wyrażenie</c> daje w wyniku <see langword="True" />.</param>
        <param name="FalsePart">Wymagana. <see langword="Object" />. Jeśli zwrócony <c>wyrażenie</c> daje w wyniku <see langword="False" />.</param>
        <summary>Zwraca jedną z dwóch obiektów, zależnie od wyniku obliczenia wyrażenia.</summary>
        <returns>Zwraca jedną z dwóch obiektów, zależnie od wyniku obliczenia wyrażenia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IIf` Funkcja udostępnia odpowiednik dla trójargumentowy [Operator warunkowy:?:](http://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) w programie Visual C++.  
  
   
  
## Examples  
 W tym przykładzie użyto `IIf` funkcji, aby ocenić `testMe` parametr `checkIt` procedury i zwraca word "Duże" Jeśli kwota jest większa niż 1000; w przeciwnym razie zwraca słowo "Mała".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Należy pamiętać, że jeśli `Option Strict` jest `On`, należy użyć `CStr` — słowo kluczowe można jawnie przekonwertować powrót z `Object` do `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Wymagane <see langword="String" /> wyrażenie wyświetlany jako komunikat w oknie dialogowym. Maksymalna długość <c>monitu</c> wynosi około 1024 znaków, w zależności od szerokość znaków używany. Jeśli <c>monitu</c> składa się z więcej niż jeden wiersz, można oddzielić wiersze przy użyciu znak powrotu karetki (<see langword="Chr(" />13<see langword=")" />), znak wysuwu wiersza (<see langword="Chr(" />10<see langword=")" />), lub powrotu karetki/wiersza źródła danych kombinacja (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) między każdym wierszu.</param>
        <param name="Title">Opcjonalna. <see langword="String" /> wyrażenie wyświetlany w pasku tytułu okna dialogowego. W przypadku pominięcia <c>tytuł</c>, nazwa aplikacji jest umieszczona na pasku tytułu.</param>
        <param name="DefaultResponse">Opcjonalna. <see langword="String" /> wyrażenie jest wyświetlana w polu tekstowym jako domyślny, jeśli podano żadnych innych danych wejściowych. W przypadku pominięcia <c>DefaultResponse</c>, pola tekstowego wyświetlany jest pusty.</param>
        <param name="XPos">Opcjonalna. Wyrażenia liczbowego, który określa odległość od lewej krawędzi okna dialogowego od lewej krawędzi ekranu w twipach. W przypadku pominięcia <c>Pozycja_x</c>, okno dialogowe jest wyśrodkowywana w poziomie.</param>
        <param name="YPos">Opcjonalna. Wyrażenia liczbowego, który określa odległość górnej krawędzi okna dialogowego, w górnej części ekranu w twipach. W przypadku pominięcia <c>Pozycja_y</c>, okno dialogowe znajduje się w pionie około jednej trzeciej sposób w dół ekranu.</param>
        <summary>Wyświetla monit w oknie dialogowym, czeka na użytkownikowi wprowadzenie tekstu, lub kliknij przycisk, a następnie zwraca ciąg zawierający zawartość pola tekstowego.</summary>
        <returns>Wyświetla monit w oknie dialogowym, czeka na użytkownikowi wprowadzenie tekstu, lub kliknij przycisk, a następnie zwraca ciąg zawierający zawartość pola tekstowego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik kliknie **anulować**, zostanie zwrócony ciąg o zerowej długości.  
  
 Aby określić więcej niż pierwszy argument, należy użyć `InputBox` funkcja w wyrażeniu. Jeśli pominięto żadnych argumentów pozycyjnych muszą zachować odpowiedni ogranicznik przecinkami.  
  
> [!NOTE]
>  `InputBox` Wymaga funkcji `UIPermission` na <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> poziomu, który może mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz i <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 W tym przykładzie przedstawiono różne sposoby użycia `InputBox` funkcja monitowanie użytkownika o wprowadzenie wartości. Jeśli x i y położenia zostały pominięte, okno dialogowe jest automatycznie wyśrodkowywany dla odpowiednich osi. Zmienna `MyValue` zawiera wartości wprowadzone przez użytkownika, gdy użytkownik kliknie przycisk OK lub naciśnie klawisz ENTER.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Wymagana. <see langword="String" /> wyrażenie jest wyświetlany jako komunikat w oknie dialogowym. Maksymalna długość <c>monitu</c> wynosi około 1024 znaków, w zależności od szerokość znaków używany. Jeśli <c>monitu</c> składa się z więcej niż jeden wiersz, można oddzielić wiersze przy użyciu znak powrotu karetki (<see langword="Chr(" />13<see langword=")" />), znak wysuwu wiersza (<see langword="Chr(" />10<see langword=")" />), lub znak powrotu karetki / połączenia tych znaków (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) między każdym wierszu.</param>
        <param name="Buttons">Opcjonalna. Wyrażenia liczbowego, który jest sumą wartości określających liczbę i typ przycisków do wyświetlenia, styl ikony do użycia, tożsamość przycisk domyślny i warunki w oknie komunikatu. W przypadku pominięcia <c>przyciski</c>, wartością domyślną jest zero.</param>
        <param name="Title">Opcjonalna. <see langword="String" /> wyrażenie wyświetlany w pasku tytułu okna dialogowego. W przypadku pominięcia <c>tytuł</c>, nazwa aplikacji jest umieszczona na pasku tytułu.</param>
        <summary>Wyświetla komunikat w oknie dialogowym, czeka na użytkownika, kliknij przycisk, a następnie zwraca liczbę całkowitą wskazującą, który użytkownik kliknął przycisk.</summary>
        <returns>
          <list type="table">
            <item>
              <term> Stała </term>
              <description> wartość </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pominięto żadnych argumentów pozycyjnych muszą zachować odpowiedni ogranicznik przecinkami.  
  
 Jeśli Wyświetla okno dialogowe **anulować** działa tak samo jak kliknięcie przycisku, naciskając klawisz ESC **Anuluj**  
  
 Jeśli okno dialogowe zawiera **pomocy** przycisk, jest dostępna Pomoc kontekstowa dla okna dialogowego. Jednak żadnej wartości jest zwrócona, dopóki nie wybrano jeden z innych przycisków. W aplikacjach formularzy systemu Windows, wybierając **pomocy** wykonuje przycisk <xref:System.Windows.Forms.Control.HelpRequested> zdarzenie dla formularza.  
  
> [!NOTE]
>  `MsgBox` Wymaga funkcji `UIPermission` na <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> poziomu, który może mieć wpływ na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.UIPermission>.  
  
 `MsgBoxStyle` Wartości wyliczenia są wymienione w poniższej tabeli.  
  
|Element członkowski|Wartość|Opis|  
|-|-|-|  
|Element członkowski|Wartość|Opis|  
|`OKOnly`|0|Tylko przycisk wyświetla OK.|  
|`OKCancel`|1|Przyciski Anuluj i wyświetla OK.|  
|`AbortRetryIgnore`|2|Wyświetla przyciski przerwania, ponów próbę i Ignoruj.|  
|`YesNoCancel`|3|Wyświetla tak, nie i przyciski "Anuluj".|  
|`YesNo`|4|Wyświetla przyciski Tak i nie.|  
|`RetryCancel`|5|Wyświetla przyciski ponawiania i Anuluj.|  
|`Critical`|16|Wyświetla ikonę krytyczny komunikat.|  
|`Question`|32|Wyświetla ikonę ostrzeżenia zapytania.|  
|`Exclamation`|48|Wyświetla ikonę ostrzeżenia.|  
|`Information`|64|Wyświetla komunikat z informacjami ikona.|  
|`DefaultButton1`|0|Pierwszy przycisk jest domyślnym.|  
|`DefaultButton2`|256|Drugi przycisk jest domyślnym.|  
|`DefaultButton3`|512|Trzeci przycisk jest domyślnym.|  
|`ApplicationModal`|0|Aplikacja jest modalne. Użytkownik musi odpowiedzieć w oknie komunikatu przed kontynuowaniem pracy w bieżącej aplikacji.|  
|`SystemModal`|4096|System jest modalne. Wszystkie aplikacje są wstrzymywane, dopóki użytkownik nie wykona w oknie komunikatu.|  
|`MsgBoxSetForeground`|65536|Określa okno komunikatu jako okno na pierwszym planie.|  
|`MsgBoxRight`|524288|Tekst jest wyrównany do prawej.|  
|`MsgBoxRtlReading`|1048576|Określa, że tekst powinien być wyświetlany w prawej do lewej odczytu w systemach hebrajski i arabski.|  
  
 Pierwsza grupa wartości (0 – 5) określa liczbę i typ przycisków wyświetlanych w oknie dialogowym. Drugiej grupy (16, 32, 48, 64) opisuje styl ikony. Trzecia grupa (0, 256, 512) określa przycisk domyślny. Czwarta grupa (0, 4096) określa modalność pola wiadomości i piątej grupy określa, czy okno komunikatu jest oknem pierwszego planu, wraz z wyrównanie i kierunek tekstu. Podczas dodawania liczb w celu utworzenia końcowej dla `Buttons` argumentu, użyj tylko jeden numer z każdej grupy.  
  
   
  
## Examples  
 W tym przykładzie użyto `MsgBox` funkcji, aby wyświetlić komunikat Błąd krytyczny w oknie dialogowym z przyciski Tak i nie. Przycisk nie jest określony jako domyślny. Odbywa się przez połączenie `MsgBox` wartości stałych do jednego wyrażenia liczbowego. W takim przypadku Dodawanie 4 (kombinacja przycisku tak/nie) i 16 ( **krytyczny komunikat** okna) i 256 (drugi przycisk jako przycisk domyślny) daje łączną liczbę 276. Wartość zwrócona przez `MsgBox` funkcji zależy od przycisku wybranego przez użytkownika: tak zwraca wartość 6. Nie zwraca wartości 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Prompt" /> nie jest <see langword="String" /> wyrażenie lub <paramref name="Title" /> jest nieprawidłowy.</exception>
        <exception cref="T:System.InvalidOperationException">Proces nie jest uruchomiony w trybie interakcyjnym użytkownika.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Jeden lub więcej parametrów nie w elemencie członkowskim o <see langword="MsgBoxResult" /> lub <see langword="MsgBoxStyle" /> wyliczenia.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Wymagana. <see langword="Long" />. Liczba całkowita, która ma zostać umieszczony w obrębie jednego z zakresów obliczeniowej.</param>
        <param name="Start">Wymagana. <see langword="Long" />. Liczba całkowita wskazująca początek zestawu obliczeniowej zakresów. <c>Uruchom</c> nie może być mniejsza niż 0.</param>
        <param name="Stop">Wymagana. <see langword="Long" />. Liczba całkowita, który wskazuje koniec zbiór obliczeniowe zakresy. <c>Zatrzymaj</c> nie może być mniejsza lub równa <c>Start</c>.</param>
        <param name="Interval">Wymagana. <see langword="Long" />. Liczba całkowita, która wskazuje rozmiar każdego zakresu obliczana między <c>Start</c> i <c>zatrzymać</c>. <c>Interwał</c> nie może być mniejsza niż 1.</param>
        <summary>Zwraca ciąg reprezentujący obliczony zakres, która zawiera numer.</summary>
        <returns>Zwraca ciąg reprezentujący obliczony zakres, która zawiera numer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Partition` Funkcja oblicza zestaw zakresów liczbowych, każda z nich zawiera liczbę wartości określonych przez `Interval`. Pierwszy zakres zaczyna się od `Start`, a ostatni zakres kończy się na `Stop`. `Partition` Funkcja następnie identyfikuje zakres, który zawiera `Number` i zwraca ciąg opisujący ten zakres. Zakres jest reprezentowana w ciągu jako "*lowervalue*:*wartość_górna*", gdzie Niski końca zakresu (*lowervalue*) jest oddzielony od górną granicę (* wartość_górna*) dwukropkiem (:).  
  
 W razie potrzeby `Partition` funkcja wstawia początkowe spacje przed *lowervalue* i *wartość_górna* , aby miały taką samą liczbę znaków jako reprezentację ciągu (wartość `Stop` + 1). Gwarantuje to, że jeśli używasz dane wyjściowe `Partition` funkcji z wartościami kilka `Number`, tekst wynikowy będzie obsługiwane poprawnie podczas operacji wszystkie kolejne sortowania.  
  
 W poniższej tabeli przedstawiono niektóre przykładowe ciągi dla zakresów obliczane przy użyciu trzech zestawów `Start`, `Stop`, i `Interval`. "Najpierw należeć do zakresu" i kolumny "Ostatni zakres" Pokaż najmniejsza i największa zakresy możliwe podane wartości `Start` i `Stop`. "Przed pierwszym zakresem" i "po ostatni zakres" kolumny zawierają ciągi dla wartości zwracane `Number` mniej niż `Start` i większa od `Stop`odpowiednio.  
  
|`Start`|`Stop`|`Interval`|Przed pierwszym zakresu|Pierwszy zakres|Ostatni zakres|Po ostatni zakres|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"0: 4"|"95: 99"|"100:"|  
|20|199|10|": 19"|"20:29"|"190:199"|"200:"|  
|100|1010|20|": 99"|"100: 119"|"1000:1010"|"1011:"|  
  
 W powyższej tabeli trzeci wiersz zawiera wynik po `Start` i `Stop` zdefiniuj zbioru liczb, którego nie można podzielić równomiernie przez `Interval`. Ostatni zakres kończy się na `Stop`, dzięki czemu tylko 11 cyfr, nawet jeśli `Interval` wynosi 20.  
  
 Jeśli `Interval` 1, jest zakresem "`Number`:`Number`", niezależnie od `Start` i `Stop` argumentów. Na przykład jeśli `Number` jest 267, `Stop` wynosi 1000, a `Interval` 1, `Partition` zwraca "267: 267".  
  
 `Partition` mogą być przydatne podczas tworzenia zapytań bazy danych. Można utworzyć zapytanie SELECT, która zawiera liczby zamówień występować w różnych zakresach wartość, na przykład z faktury wartości z zakresu od 1 do 1000, 1001 do 2000 i tak dalej.  
  
   
  
## Examples  
 Poniższy przykład przedstawia serię zakresów dla dekad z 1950 do 2049. Klient zlokalizuje wartość `year` w odpowiedni zakres i zwraca `String` przedstawiający zakres wartości. Jeśli `year` ma wartość 1984, na przykład `Partition` zwraca "1980:1989".  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt; =  <paramref name="Start" />, lub <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę aplikacji lub projektu, do którego stosuje się ustawienia.</param>
        <param name="Section">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę sekcji, w którym zapisany jest ustawienie klucza.</param>
        <param name="Key">Wymagana. <see langword="String" /> w wyrażeniu zawierającym nazwę klucza ustawienia są zapisywane.</param>
        <param name="Setting">Wymagana. Wyrażenia zawierającego wartość, do której <c>klucza</c> jest ustawiany.</param>
        <summary>Zapisuje lub utworzenie aplikacji wpis w rejestrze systemu Windows. <see langword="My" /> Funkcja zapewnia większą wydajność i wydajności podczas wykonywania operacji rejestru niż <see langword="SaveSetting" />. Aby uzyskać więcej informacji, zobacz <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `SaveSetting` Funkcja dodaje klucz do `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Jeśli z jakiegoś powodu nie można zapisać ustawienia klucza, występuje błąd.  
  
 `SaveSetting` wymaga, czy użytkownik jest zalogowany ponieważ działa ona w obszarze `HKEY_LOCAL_USER` klucz rejestru, który nie jest aktywne, dopóki użytkownik loguje się interaktywnie.  
  
 Ustawienia rejestru, które ma być uzyskiwany dostęp z innego nieinteraktywnego procesu (na przykład Mtx.exe) powinny być przechowywane w obszarze albo `HKEY_LOCAL_MACHINE\Software\` lub `HKEY_USER\DEFAULT\Software` kluczy rejestru.  
  
 `SaveSetting` wymaga `Write` i `Create` <xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 W poniższym przykładzie najpierw użyto `SaveSetting` funkcji, aby tworzyć wpisy w rejestrze systemu Windows dla `MyApp` aplikacji, a następnie używa `DeleteSetting` funkcji, aby je usunąć.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie można utworzyć klucza rejestru lub użytkownik nie jest zalogowany.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" />
        <Parameter Name="Wait" Type="System.Boolean" />
        <Parameter Name="Timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="PathName">Wymagana. <see langword="String" />. Nazwa programu do wykonania, oraz wszelkie wymagane argumenty i przełączniki wiersza polecenia. <c>Nazwa ścieżki</c> mogą również obejmować dysk i ścieżkę katalogu lub folderu.  Jeśli nie znasz ścieżkę do programu, można użyć <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> ich wyszukanie. Na przykład można wywołać <c>My.Computer.FileSystem.GetFiles ("C:\", ma wartość True,"Plik_testowy.txt")</c>, która zwraca pełną ścieżkę każdego pliku o nazwie <c>Plik_testowy.txt</c> dowolne miejsce na dysku C:\\ .</param>
        <param name="Style">Opcjonalna. <see langword="AppWinStyle" />. Wartość wybranego spośród <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> określenie styl okna, w którym jest uruchomienie programu. Jeśli <c>styl</c> zostanie pominięty, <see langword="Shell" /> używa <see langword="AppWinStyle.MinimizedFocus" />, który uruchamia program w trybie zminimalizowanym i z fokusem.</param>
        <param name="Wait">Opcjonalna. <see langword="Boolean" />. Wartość wskazującą czy <see langword="Shell" /> funkcji ma oczekiwać na zakończenie pracy programu. Jeśli <c>oczekiwania</c> zostanie pominięty, <see langword="Shell" /> używa <see langword="False" />.</param>
        <param name="Timeout">Opcjonalna. <see langword="Integer" />. Wyrażony w milisekundach czas oczekiwania na ukończenie, jeśli <c>oczekiwania</c> jest <see langword="True" />. Jeśli <c>limitu czasu</c> zostanie pominięty, <see langword="Shell" /> używa -1, co oznacza brak limitu czasu i <see langword="Shell" /> nie może zwracać zakończenie program. W związku z tym w przypadku pominięcia <c>limitu czasu</c> lub zestawu do jego-1, istnieje możliwość, która <see langword="Shell" /> nigdy nie może zwrócić kontrolkę do programu.</param>
        <summary>Uruchamia program wykonywalny i zwraca całkowitą reprezentującą identyfikator procesu programu, jeśli jest nadal uruchomiona.</summary>
        <returns>Uruchamia program wykonywalny i zwraca całkowitą reprezentującą identyfikator procesu programu, jeśli jest nadal uruchomiona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość zwracana `Shell` funkcji zależy od tego, czy program o nazwie w `PathName` jest nadal wykonywane podczas `Shell` zwraca. Jeśli ustawisz `Wait` do `True` i zakończeniu program przed upływem limitu czasu, `Shell` zwraca zero. Po przekroczeniu limitu czasu lub w przypadku pominięcia `Wait` lub ustaw ją na `False`, `Shell` zwraca identyfikator procesu programu. Identyfikator procesu jest unikatowy numer identyfikujący uruchomiony program.  
  
## <a name="failure-to-start"></a>Błąd przy uruchomieniu  
 Jeśli `Shell` funkcji nie można uruchomić program o nazwie <xref:System.IO.FileNotFoundException> wystąpi błąd. To może się zdarzyć, na przykład przy próbie uruchomienia programu 16-bitowych, takich jak `command.com`, z aplikacji przy użyciu <xref:System.Windows.Forms?displayProperty=nameWithType>. Obejście tego problemu możesz uruchomić program 32-bitowy, który wywołuje żądany program 16-bitowych. W przypadku liczby `command.com`, możesz uruchomić `cmd.exe` jako alternatywę.  
  
## <a name="waiting-for-completion"></a>Oczekiwanie na ukończenie  
 Domyślnie `Shell` funkcja uruchamia program asynchronicznie. Oznacza to, że program uruchomiony przy użyciu `Shell` funkcja może nie zakończyć wykonywania przed następujące instrukcje `Shell` funkcji są wykonywane. Jeśli chcesz czekać na zakończenie przed programu kontynuować, ustaw `Wait` do `True`.  
  
## <a name="determining-the-exit-code"></a>Określanie kodu wyjścia  
 Proces może zwrócić *kod zakończenia* gdy zostaje zakończone. Nie można jednak użyć `Shell` pobrać ten kod zakończenia, ponieważ `Shell` zwraca zero, jeśli oczekuje na zakończenie, a także ponieważ proces działa w różnych obiektów z `Shell`.  
  
 Aby pobrać kodu zakończenia z procesem, musi być zapisana kodu do rozpoczęcia procesu i poczekaj na zakończenie. Poniższy przykład pokazuje, jak zainicjować proces, zaczekaj na jej zakończenie i pobrać jego kod zakończenia.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Ochrona specyfikacji pliku  
 Cały specyfikacji i ścieżka pliku należy zawsze ująć w cudzysłowy, jak przedstawiono na poniższym przykładzie.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Każda para sąsiadujących podwójnych cudzysłowów (`" "`) w ciągu literału jest interpretowana jako znak jednego podwójnego cudzysłowu w ciągu. W związku z tym przedstawia poniższy ciąg, aby w poprzednim przykładzie `Shell` funkcji:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Jeśli nie masz ścieżki ujęta w znaki cudzysłowu, system Windows będzie szukać w pliku o nazwie `Program.exe` w katalogu C:\ zamiast `display.exe` w katalogu C:\Program Files.  
  
> [!IMPORTANT]
>  Jeśli specyfikacja i ścieżka pliku nie należy ująć w cudzysłów, stanowi zagrożenie bezpieczeństwa, jeśli nazwa pliku lub ścieżka węzła zawiera spacje. W powyższym przykładzie węzeł ścieżki `\Program Files` zawiera spację. Jeśli nie zostały wewnątrz cudzysłowów program o nazwie specyfikację `Program.exe` były zainstalowane w C:\\, na przykład przez nielegalnemu naruszeniu systemu Windows jest wykonywany go zamiast `display.exe`.  
  
> [!IMPORTANT]
>  `Shell` Funkcja wymaga uprawnień kodu niezarządzanego, co może wpływać na jej wykonanie w sytuacjach częściowego zaufania. Aby uzyskać więcej informacji, zobacz <xref:System.Security.Permissions.SecurityPermission> i [uprawnienia dostępu do kodu](http://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Shell` funkcji, aby uruchomić aplikację, określone przez użytkownika. Określanie <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> jako drugi argument otwiera aplikację w normalny rozmiar i nadaje mu fokus.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Style" /> nie jest w zakresie od 0 do 9, włącznie.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <see langword="Shell" /> Nie można odnaleźć <paramref name="PathName" /> pliku.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="PathName" /> jest <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Wymagana. <see langword="Object" /> Tablica parametrów. Musi być parzystą liczbą elementów. Możesz podać listę <see langword="Object" /> zmiennych lub wyrażeń oddzielonych przecinkami lub tablicy jednowymiarowej z <see langword="Object" /> elementów.</param>
        <summary>Oblicza listę wyrażeń i zwraca <see langword="Object" /> wartość odpowiadającą pierwszemu wyrażeniu, na liście jest <see langword="True" />.</summary>
        <returns>Oblicza listę wyrażeń i zwraca <see langword="Object" /> wartość odpowiadającą pierwszemu wyrażeniu, na liście jest <see langword="True" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Argument przekazany do `VarExpr` składa się z par wyrażeń i wartości. `Switch` Funkcja ocenia wyrażenia nieparzystą z najniższą do najwyższej indeksu w `VarExpr`i zwraca wartość parzystych skojarzoną z pierwszym wyrażeniem, która daje w wyniku `True`. Na przykład jeśli `VarExpr(0)` jest `True`, `Switch` zwraca `VarExpr(1)`, a jeśli `VarExpr(0)` jest `False` , ale `VarExpr(2)` jest `True`, `Switch` zwraca `VarExpr(3)`i tak dalej.  
  
 Jeśli nie podasz `VarExpr` argumentu, `Switch` zwraca `Nothing`.  
  
> [!NOTE]
>  Wyrażenia na liście argument może zawierać wywołania funkcji. W ramach przygotowania do listy argumentów dla wywołania `Switch`, kompilator Visual Basic wywołuje funkcję co w każdym wyrażeniu. Oznacza to, że nie może zależeć określonej funkcji nie jest wywoływana, gdy wyrażenie wcześniej w liście argumentów jest `True`.  
  
   
  
## Examples  
 W poniższym przykładzie użyto `Switch` funkcji, aby zwrócić nazwę języka, która jest zgodna z nazwą miasta. Wymaga, aby `Option Strict` można `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Ponieważ <xref:System.Diagnostics> przestrzeń nazw zawiera również klasy o nazwie <xref:System.Diagnostics.Switch>, wywołanie `Switch` funkcja musi być kwalifikowana za <xref:Microsoft.VisualBasic> przestrzeni nazw.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Liczba argumentów jest nieparzysta.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>
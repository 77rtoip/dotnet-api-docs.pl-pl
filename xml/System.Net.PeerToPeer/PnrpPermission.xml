<Type Name="PnrpPermission" FullName="System.Net.PeerToPeer.PnrpPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="82146f4eb64aeac31530a110cae1b16a2ad1dd5d" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48613713" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class PnrpPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit PnrpPermission extends System.Security.CodeAccessPermission implements class System.Security.Permissions.IUnrestrictedPermission" />
  <TypeSignature Language="DocId" Value="T:System.Net.PeerToPeer.PnrpPermission" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class PnrpPermission&#xA;Inherits CodeAccessPermission&#xA;Implements IUnrestrictedPermission" />
  <TypeSignature Language="C++ CLI" Value="public ref class PnrpPermission sealed : System::Security::CodeAccessPermission, System::Security::Permissions::IUnrestrictedPermission" />
  <TypeSignature Language="F#" Value="type PnrpPermission = class&#xA;    inherit CodeAccessPermission&#xA;    interface IUnrestrictedPermission" />
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.CodeAccessPermission</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Permissions.IUnrestrictedPermission</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Określa wartości, które są używane w <see cref="N:System.Net.PeerToPeer" /> obiekt uprawnień.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uprawnienia domyślne zezwalają na wszystkie lokalne i aplikacje strefy Intranet na dostęp do usług protokołu PNRP. Jeśli domyślne uprawnienia nie są zmieniane, wszystkie połączenia lokalnego i lokalne aplikacje mają dostęp do usług Peer-to-Peer, ale aplikacje globalne (internet) nie mają dostępu.  
  
 Tego typu wystąpieniom mają dwa stany uprawnień: one albo nie mają dostępu do zasobów chronionych przez uprawnienia lub mają one nieograniczony pełny dostęp do tych zasobów.  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
    <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
    <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
    <altmember cref="N:System.Security.Permissions" />
    <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink?LinkID=92731">Interfejs API dostawcy Namespace PNRP</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PnrpPermission (System.Security.Permissions.PermissionState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Security.Permissions.PermissionState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.#ctor(System.Security.Permissions.PermissionState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (state As PermissionState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PnrpPermission(System::Security::Permissions::PermissionState state);" />
      <MemberSignature Language="F#" Value="new System.Net.PeerToPeer.PnrpPermission : System.Security.Permissions.PermissionState -&gt; System.Net.PeerToPeer.PnrpPermission" Usage="new System.Net.PeerToPeer.PnrpPermission state" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="state" Type="System.Security.Permissions.PermissionState" />
      </Parameters>
      <Docs>
        <param name="state">Jedna z wartości w <see cref="T:System.Security.Permissions.PermissionState" /> wyliczenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> klasy ze stanem podane uprawnienia początkowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego typu wystąpieniom mają dwa stany uprawnień: one albo nie mają dostępu do zasobów chronionych przez uprawnienia lub mają one nieograniczony pełny dostęp do tych zasobów.  
  
 Jeśli `state` jest nieograniczony, wystąpienie PnrpPermission przekazuje wszystkie żądania. Jeśli `state` zawiera jakąkolwiek inną wartość, wystąpienie PnrpPermission wszystkich potrzeb zakończy się niepowodzeniem.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission&#xA;override this.Copy : unit -&gt; System.Security.IPermission" Usage="pnrpPermission.Copy " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy i zwraca identyczną kopię bieżącego <see cref="T:System.Net.PeerToPeer.PnrpPermission" />.</summary>
        <returns>Obiekt z interfejsem interfejsu IPermission, w których wystąpienie zawiera kopię bieżącego wystąpienia <see cref="T:System.Net.PeerToPeer.PnrpPermission" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kopiuj uprawnienia reprezentuje taki sam dostęp do zasobów jako uprawnienie oryginalne.  
  
 Tego typu wystąpieniom mają dwa stany uprawnień: one albo nie mają dostępu do zasobów chronionych przez uprawnienia lub mają one nieograniczony pełny dostęp do tych zasobów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">— Parametr nie jest prawidłowym <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> elementu.  
  
Numer wersji parametr nie jest obsługiwane.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr jest <see langword="null" /> odwołania (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
        <related type="ExternalDocumentation" href="http://go.microsoft.com/fwlink?LinkID=92731">Interfejs API dostawcy Namespace PNRP</related>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public override void FromXml (System.Security.SecurityElement e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXml(class System.Security.SecurityElement e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXml (e As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXml(System::Security::SecurityElement ^ e);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit&#xA;override this.FromXml : System.Security.SecurityElement -&gt; unit" Usage="pnrpPermission.FromXml e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="e">Kodowanie XML na potrzeby rekonstrukcji uprawnienia.</param>
        <summary>Rekonstruuje obiektu zabezpieczeń przy użyciu określonego stanu z Kodowanie XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Reprezentuje model obiektów XML do kodowania obiektów zabezpieczeń. Klasa ta nie może być dziedziczona.  
  
 Ta klasa ma być uproszczone wykonania prostego modelu obiektów XML do użycia w ramach systemu zabezpieczeń, a nie do użytku jako ogólne model obiektów XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">— Parametr nie jest prawidłowym <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> elementu.  
  
Numer wersji parametr nie jest obsługiwane.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr jest <see langword="null" /> odwołania (<see langword="Nothing" /> w języku Visual Basic).</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="T:System.Security.SecurityElement" />
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="pnrpPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienia do <see cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" /> z uprawnieniami bieżącego. Należy się tego samego typu jak bieżące uprawnienia.</param>
        <summary>Tworzy i zwraca uprawnienia, które jest częścią bieżącego wspólną <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> i określone uprawnienie.</summary>
        <returns>Nowe uprawnienia, które reprezentuje część wspólną bieżącego <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> i określone uprawnienie. Jest to nowe uprawnienie <see langword="null" /> odwołania (<see langword="Nothing" /> w języku Visual Basic) jeżeli wspólną jest pusta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Część wspólną dwóch uprawnień jest uprawnień, który opisuje zestaw operacji, które opisują one zarówno we wspólnych. Żądanie, który przekazuje zarówno pierwotnych uprawnień zostaną spełnione część wspólną.  
  
 Poniższe instrukcje muszą być `true` dla wszystkich implementacji metody Intersect. Reprezentują X i Y <xref:System.Security.IPermission> odwołania do obiektów, które nie są `null` odwołania (Nothing w języku Visual Basic).  
  
-   X.Intersect(X) zwraca wartość równa X.  
  
-   X.Intersect(Y) zwraca taką samą wartość jak Y.Intersect(X).  
  
-   X.Intersect ( `null` odwołania (`Nothing` w języku Visual Basic)) zwraca `null` odwołania (`Nothing` w języku Visual Basic).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr docelowy nie jest <see langword="null" /> odwołania (<see langword="Nothing" /> w języku Visual Basic) i nie jest wystąpieniem tej samej klasy jako bieżące uprawnienia.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public override bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool&#xA;override this.IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="pnrpPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienia, które ma zostać przetestowana dla relacji podzbioru. To uprawnienie musi być tego samego typu jak bieżące uprawnienia.</param>
        <summary>Określa, czy bieżący <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> jest podzbiorem określone uprawnienie.</summary>
        <returns>
          <see langword="True" /> Jeśli bieżący <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> jest podzbiorem określone uprawnienie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżący <xref:System.Net.PeerToPeer.PnrpPermission> jest podzbiorem określonego uprawnienia, jeśli bieżące uprawnienia określa zestaw operacji, który jest całkowicie zawarty w określone uprawnienie. Na przykład reprezentującą dostępu do uprawnienia "*C:\example.txt*"stanowią podzbiór zestawu uprawnień, która reprezentuje dostęp do "*C:\\*". Jeśli ta metoda zwraca `true`, bieżące uprawnienia reprezentuje nie uzyskać dostęp do chronionych zasobów niż określone uprawnienie.  
  
 Poniższe instrukcje muszą być `true` dla wszystkich implementacjach issubsetof — metoda. Reprezentują X, Y i Z <xref:System.Security.IPermission> obiekty, które nie są `null` odwołania (`Nothing` w języku Visual Basic).  
  
-   Zwraca X.IsSubsetOf(X) `true`.  
  
-   X.IsSubsetOf(Y) zwraca taką samą wartość jak Y.IsSubsetOf(X) tylko wtedy, gdy X i Y reprezentują ten sam zestaw uprawnień.  
  
-   Jeśli X.IsSubsetOf(Y) i Y.IsSubsetOf(Z) oba zwracają `true`, zwraca X.IsSubsetOf(Z) `true`.  
  
-  
  
 Jeśli X reprezentuje pustego obiektu interfejsu IPermission ze stanem uprawnień *Brak* i Y reprezentuje obiekt interfejsu IPermission `null` odwołania (`Nothing` w języku Visual Basic), zwraca X.IsSubsetOf(Y) `true`. Jeśli Z również jest pusty uprawnień, operacja X.Union(Z) ustawienia złożony. Zwraca także IsSubsetOf(Y) `true` ponieważ <xref:System.Net.PeerToPeer.PnrpPermission.Union%2A> dwa uprawnienia puste jest pusty uprawnień.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Parametr docelowy nie jest <see langword="null" /> odwołania (<see langword="Nothing" /> w języku Visual Basic) i nie jest wystąpieniem tej samej klasy jako bieżące uprawnienia.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
      </Docs>
    </Member>
    <Member MemberName="IsUnrestricted">
      <MemberSignature Language="C#" Value="public bool IsUnrestricted ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsUnrestricted() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
      <MemberSignature Language="VB.NET" Value="Public Function IsUnrestricted () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsUnrestricted();" />
      <MemberSignature Language="F#" Value="abstract member IsUnrestricted : unit -&gt; bool&#xA;override this.IsUnrestricted : unit -&gt; bool" Usage="pnrpPermission.IsUnrestricted " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wartość określająca czy bieżący <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> jest nieograniczony.</summary>
        <returns>
          <see langword="True" /> Jeśli bieżący uprawnienie jest nieograniczony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nieograniczone uprawnienia reprezentuje dostęp do wszystkich zasobów chronionych przez uprawnienia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="T:System.Net.PeerToPeer.PnrpPermissionAttribute" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public override System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement&#xA;override this.ToXml : unit -&gt; System.Security.SecurityElement" Usage="pnrpPermission.ToXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy XML kodowanie <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> i bieżącego stanu.</summary>
        <returns>A <see cref="T:System.Security.SecurityElement" /> obiekt, który zawiera kodowanie XML uprawnień, w tym wszelkich informacji o stanie.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Copy" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.FromXml(System.Security.SecurityElement)" />
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public override System.Security.IPermission Union (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.IPermission Union(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Union (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::IPermission ^ Union(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="pnrpPermission.Union target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">Uprawnienie do łączenia z uprawnieniami bieżącego. Należy się tego samego typu jak bieżące uprawnienia.</param>
        <summary>Tworzy uprawnienia, które sumę bieżącą <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> i określone uprawnienie.</summary>
        <returns>Nowe uprawnienie, który reprezentuje <see cref="M:System.Net.PeerToPeer.PnrpPermission.Union(System.Security.IPermission)" /> bieżącego <see cref="T:System.Net.PeerToPeer.PnrpPermission" /> i określone uprawnienie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wynik wywołania <xref:System.Net.PeerToPeer.PnrpPermission.Union%2A> uprawnienia, który reprezentuje wszystkie operacje, które są reprezentowane przez oba bieżącą <xref:System.Net.PeerToPeer.PnrpPermission> i określone uprawnienie. Wszelkie żądania spełniającą albo uprawnienie przekazuje ich Unii.  
  
 Poniższe instrukcje muszą być `true` dla wszystkich implementacji metody Unii. Reprezentują X i Y <xref:System.Security.IPermission> obiekty, które nie są `null` odwołania (`Nothing` w języku Visual Basic).  
  
-   X.Union(X) zwraca obiekt, który ma taką samą wartość jak X.  
  
-   X.Union(Y) zwraca obiekt, który ma taką samą wartość jak obiektu zwróconego przez Y.Union(X).  
  
-   X.Union ( `null` odwołania (`Nothing` w języku Visual Basic)) zwraca obiekt, który ma taką samą wartość jak X.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> parametr jest nieprawidłowy.</exception>
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.Intersect(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsSubsetOf(System.Security.IPermission)" />
        <altmember cref="M:System.Net.PeerToPeer.PnrpPermission.IsUnrestricted" />
      </Docs>
    </Member>
  </Members>
</Type>
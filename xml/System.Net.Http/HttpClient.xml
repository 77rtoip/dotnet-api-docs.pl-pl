<Type Name="HttpClient" FullName="System.Net.Http.HttpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="74ff44a707bc142463a2ebc8e731df5d9bb6554a" /><Meta Name="ms.sourcegitcommit" Value="f991677a7374c45590a432ff7ab830beb05f2ccd" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/27/2019" /><Meta Name="ms.locfileid" Value="68591123" /></Metadata><TypeSignature Language="C#" Value="public class HttpClient : System.Net.Http.HttpMessageInvoker" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit HttpClient extends System.Net.Http.HttpMessageInvoker" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.HttpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class HttpClient&#xA;Inherits HttpMessageInvoker" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpClient : System::Net::Http::HttpMessageInvoker" />
  <TypeSignature Language="F#" Value="type HttpClient = class&#xA;    inherit HttpMessageInvoker" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpMessageInvoker</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="c29f5-101">Udostępnia klasę bazową do wysyłania żądań HTTP i otrzymywania odpowiedzi HTTP z zasobu identyfikowanego za pomocą identyfikatora URI.</span><span class="sxs-lookup"><span data-stu-id="c29f5-101">Provides a base class for sending HTTP requests and receiving HTTP responses from a resource identified by a URI.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-102">Wystąpienie <xref:System.Net.Http.HttpClient> klasy pełni rolę sesji wysyłania żądań HTTP.</span><span class="sxs-lookup"><span data-stu-id="c29f5-102">The <xref:System.Net.Http.HttpClient> class instance acts as a session to send HTTP requests.</span></span> <span data-ttu-id="c29f5-103"><xref:System.Net.Http.HttpClient> Wystąpienie jest kolekcją ustawień zastosowanych do wszystkich żądań wykonywanych przez to wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-103">An <xref:System.Net.Http.HttpClient> instance is a collection of settings applied to all requests executed by that instance.</span></span> <span data-ttu-id="c29f5-104">Ponadto każde <xref:System.Net.Http.HttpClient> wystąpienie używa własnej puli połączeń, izolując żądania od żądań wykonywanych przez inne <xref:System.Net.Http.HttpClient> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c29f5-104">In addition, every <xref:System.Net.Http.HttpClient> instance uses its own connection pool, isolating its requests from requests executed by other <xref:System.Net.Http.HttpClient> instances.</span></span>  
  
 <span data-ttu-id="c29f5-105">Działa <xref:System.Net.Http.HttpClient> również jako klasa bazowa dla bardziej szczegółowych klientów http.</span><span class="sxs-lookup"><span data-stu-id="c29f5-105">The <xref:System.Net.Http.HttpClient> also acts as a base class for more specific HTTP clients.</span></span> <span data-ttu-id="c29f5-106">Przykładem może być FacebookHttpClient z dodatkowymi metodami specyficznymi dla usługi sieci Web w serwisie Facebook (na przykład Metoda getfriends).</span><span class="sxs-lookup"><span data-stu-id="c29f5-106">An example would be a FacebookHttpClient providing additional methods specific to a Facebook web service (a GetFriends method, for instance).</span></span> <span data-ttu-id="c29f5-107">Klasy pochodne nie powinny przesłaniać metod wirtualnych w klasie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-107">Derived classes should not override the virtual methods on the class.</span></span> <span data-ttu-id="c29f5-108">Zamiast tego należy użyć przeciążenia konstruktora, które <xref:System.Net.Http.HttpMessageHandler> akceptuje w celu skonfigurowania dowolnego przetwarzania przed lub po żądaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-108">Instead, use a constructor overload that accepts <xref:System.Net.Http.HttpMessageHandler> to configure any pre- or post-request processing instead.</span></span>
  
 <span data-ttu-id="c29f5-109">Domyślnie na .NET Framework i mono <xref:System.Net.HttpWebRequest> jest używany do wysyłania żądań do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-109">By default on .NET Framework and Mono, <xref:System.Net.HttpWebRequest> is used to send requests to the server.</span></span> <span data-ttu-id="c29f5-110">To zachowanie można zmodyfikować, określając inny kanał w jednym z przeciążeń konstruktora, pobierając <xref:System.Net.Http.HttpMessageHandler> wystąpienie jako parametr.</span><span class="sxs-lookup"><span data-stu-id="c29f5-110">This behavior can be modified by specifying a different channel in one of the constructor overloads taking a <xref:System.Net.Http.HttpMessageHandler> instance as parameter.</span></span> <span data-ttu-id="c29f5-111">Jeśli wymagane są funkcje, takie jak uwierzytelnianie lub <xref:System.Net.Http.WebRequestHandler> buforowanie, można użyć do skonfigurowania ustawień, a wystąpienie można przesłać do konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c29f5-111">If features like authentication or caching are required, <xref:System.Net.Http.WebRequestHandler> can be used to configure settings and the instance can be passed to the constructor.</span></span> <span data-ttu-id="c29f5-112">Zwrócony program obsługi może być przekazana do jednego z przeciążeń konstruktora <xref:System.Net.Http.HttpMessageHandler> pobierającego parametr.</span><span class="sxs-lookup"><span data-stu-id="c29f5-112">The returned handler can be passed to one of the constructor overloads taking a <xref:System.Net.Http.HttpMessageHandler> parameter.</span></span>  
  
 <span data-ttu-id="c29f5-113">Jeśli aplikacja używająca <xref:System.Net.Http.HttpClient> i powiązana klas <xref:System.Net.Http> w przestrzeni nazw zamierza pobrać duże ilości danych (50 megabajtów lub więcej), aplikacja powinna przesyłać strumieniowo te pliki do pobrania i nie używać domyślnego buforowania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-113">If an app using <xref:System.Net.Http.HttpClient> and related classes in the <xref:System.Net.Http> namespace intends to download large amounts of data (50 megabytes or more), then the app should stream those downloads and not use the default buffering.</span></span> <span data-ttu-id="c29f5-114">Jeśli domyślne buforowanie jest używane, użycie pamięci przez klienta będzie bardzo duże, co może znacznie zmniejszyć wydajność.</span><span class="sxs-lookup"><span data-stu-id="c29f5-114">If the default buffering is used the client memory usage will get very large, potentially resulting in substantially reduced performance.</span></span>  
  
 <span data-ttu-id="c29f5-115">Następujące metody są bezpieczne dla wątków:</span><span class="sxs-lookup"><span data-stu-id="c29f5-115">The following methods are thread safe:</span></span>  
  
1.  <xref:System.Net.Http.HttpClient.CancelPendingRequests%2A>  
  
2.  <xref:System.Net.Http.HttpClient.DeleteAsync%2A>  
  
3.  <xref:System.Net.Http.HttpClient.GetAsync%2A>  
  
4.  <xref:System.Net.Http.HttpClient.GetByteArrayAsync%2A>  
  
5.  <xref:System.Net.Http.HttpClient.GetStreamAsync%2A>  
  
6.  <xref:System.Net.Http.HttpClient.GetStringAsync%2A>  
  
7.  <xref:System.Net.Http.HttpClient.PostAsync%2A>  
  
8.  <xref:System.Net.Http.HttpClient.PutAsync%2A>  
  
9. <xref:System.Net.Http.HttpClient.SendAsync%2A>  
  
 <span data-ttu-id="c29f5-116"><xref:System.Net.Http.HttpClient>jest przeznaczony do tworzenia wystąpień i ponownego wykorzystania przez cały czas życia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-116"><xref:System.Net.Http.HttpClient> is intended to be instantiated once and re-used throughout the life of an application.</span></span> <span data-ttu-id="c29f5-117">Utworzenie wystąpienia klasy HttpClient dla każdego żądania spowoduje wyczerpanie liczby gniazd dostępnych w ramach dużych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="c29f5-117">Instantiating an HttpClient class for every request will exhaust the number of sockets available under heavy loads.</span></span> <span data-ttu-id="c29f5-118">Spowoduje to błędy Gniazdaexception.</span><span class="sxs-lookup"><span data-stu-id="c29f5-118">This will result in SocketException errors.</span></span> <span data-ttu-id="c29f5-119">Poniżej przedstawiono przykład użycia HttpClient prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="c29f5-119">Below is an example using HttpClient correctly.</span></span>  
  
```csharp
public class GoodController : ApiController
{
    // OK
    private static readonly HttpClient HttpClient;

    static GoodController()
    {
        HttpClient = new HttpClient();
    }
}
```  
  
<span data-ttu-id="c29f5-120"><xref:System.Net.Http.HttpClient> Jest to interfejs API wysokiego poziomu, który otacza funkcje niższego poziomu dostępne na każdej platformie, na której działa.</span><span class="sxs-lookup"><span data-stu-id="c29f5-120">The <xref:System.Net.Http.HttpClient> is a high-level API that wraps the lower-level functionality available on each platform where it runs.</span></span>

<span data-ttu-id="c29f5-121">Na każdej platformie program <xref:System.Net.Http.HttpClient> próbuje użyć najlepszego dostępnego transportu:</span><span class="sxs-lookup"><span data-stu-id="c29f5-121">On each platform, <xref:System.Net.Http.HttpClient> tries to use the best available transport:</span></span>

| <span data-ttu-id="c29f5-122">**Host/środowisko uruchomieniowe**</span><span class="sxs-lookup"><span data-stu-id="c29f5-122">**Host/Runtime**</span></span>            | <span data-ttu-id="c29f5-123">**Danych**</span><span class="sxs-lookup"><span data-stu-id="c29f5-123">**Backend**</span></span>                                                                               |
| --------------------------- | ----------------------------------------------------------------------------------------- |
| <span data-ttu-id="c29f5-124">Windows/.NET Framework</span><span class="sxs-lookup"><span data-stu-id="c29f5-124">Windows/.NET Framework</span></span>      | <xref:System.Net.HttpWebRequest>                                                          |
| <span data-ttu-id="c29f5-125">Windows/Mono</span><span class="sxs-lookup"><span data-stu-id="c29f5-125">Windows/Mono</span></span>                | <xref:System.Net.HttpWebRequest>                                                          |
| <span data-ttu-id="c29f5-126">Windows/UWP</span><span class="sxs-lookup"><span data-stu-id="c29f5-126">Windows/UWP</span></span>                 | <span data-ttu-id="c29f5-127">Windows Native <xref:System.Net.Http.WinHttpHandler> (obsługujący protokół HTTP 2,0)</span><span class="sxs-lookup"><span data-stu-id="c29f5-127">Windows native <xref:System.Net.Http.WinHttpHandler> (HTTP 2.0 capable)</span></span>                   |
| <span data-ttu-id="c29f5-128">Windows/. NET Core 1.0-2.0</span><span class="sxs-lookup"><span data-stu-id="c29f5-128">Windows/.NET Core 1.0-2.0</span></span>   | <span data-ttu-id="c29f5-129">Windows Native <xref:System.Net.Http.WinHttpHandler> (obsługujący protokół HTTP 2,0)</span><span class="sxs-lookup"><span data-stu-id="c29f5-129">Windows native <xref:System.Net.Http.WinHttpHandler> (HTTP 2.0 capable)</span></span>                   |
| <span data-ttu-id="c29f5-130">Android/Xamarin</span><span class="sxs-lookup"><span data-stu-id="c29f5-130">Android/Xamarin</span></span>             | <span data-ttu-id="c29f5-131">Wybrane w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-131">Selected at build-time.</span></span> <span data-ttu-id="c29f5-132">Można użyć <xref:System.Net.HttpWebRequest> lub skonfigurować do korzystania z natywnego systemu Android[`HttpURLConnection`](https://developer.xamarin.com/api/type/Java.Net.HttpURLConnection/)</span><span class="sxs-lookup"><span data-stu-id="c29f5-132">Can either use <xref:System.Net.HttpWebRequest> or be configured to use Android's native [`HttpURLConnection`](https://developer.xamarin.com/api/type/Java.Net.HttpURLConnection/)</span></span> |
| <span data-ttu-id="c29f5-133">iOS, systemu tvOS, systemu watchOS/Xamarin</span><span class="sxs-lookup"><span data-stu-id="c29f5-133">iOS, tvOS, watchOS/Xamarin</span></span>  | <span data-ttu-id="c29f5-134">Wybrane w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-134">Selected at build-time.</span></span> <span data-ttu-id="c29f5-135">Można użyć <xref:System.Net.HttpWebRequest> lub skonfigurować do korzystania z [`NSUrlSession`](https://developer.xamarin.com/api/type/MonoTouch.Foundation.NSUrlSession/) firmy Apple (obsługującej protokół HTTP 2,0).</span><span class="sxs-lookup"><span data-stu-id="c29f5-135">Can either use <xref:System.Net.HttpWebRequest> or be configured to use Apple's [`NSUrlSession`](https://developer.xamarin.com/api/type/MonoTouch.Foundation.NSUrlSession/) (HTTP 2.0 capable)</span></span> |
| <span data-ttu-id="c29f5-136">macOS/Xamarin</span><span class="sxs-lookup"><span data-stu-id="c29f5-136">macOS/Xamarin</span></span>               | <span data-ttu-id="c29f5-137">Wybrane w czasie kompilacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-137">Selected at build-time.</span></span> <span data-ttu-id="c29f5-138">Można użyć <xref:System.Net.HttpWebRequest> lub skonfigurować do korzystania z [`NSUrlSession`](https://developer.xamarin.com/api/type/MonoTouch.Foundation.NSUrlSession/) firmy Apple (obsługującej protokół HTTP 2,0).</span><span class="sxs-lookup"><span data-stu-id="c29f5-138">Can either use <xref:System.Net.HttpWebRequest> or be configured to use Apple's [`NSUrlSession`](https://developer.xamarin.com/api/type/MonoTouch.Foundation.NSUrlSession/) (HTTP 2.0 capable)</span></span> |
| <span data-ttu-id="c29f5-139">macOS/Mono</span><span class="sxs-lookup"><span data-stu-id="c29f5-139">macOS/Mono</span></span>                  | <xref:System.Net.HttpWebRequest>                                                          |
| <span data-ttu-id="c29f5-140">macOS/. NET Core 1.0-2.0</span><span class="sxs-lookup"><span data-stu-id="c29f5-140">macOS/.NET Core 1.0-2.0</span></span>     | <span data-ttu-id="c29f5-141">`libcurl`transport HTTP oparty na standardzie http 2,0</span><span class="sxs-lookup"><span data-stu-id="c29f5-141">`libcurl`-based HTTP transport (HTTP 2.0 capable)</span></span>                                         |
| <span data-ttu-id="c29f5-142">Linux/Mono</span><span class="sxs-lookup"><span data-stu-id="c29f5-142">Linux/Mono</span></span>                  | <xref:System.Net.HttpWebRequest>                                                          |
| <span data-ttu-id="c29f5-143">Linux/. NET Core 1.0-2.0</span><span class="sxs-lookup"><span data-stu-id="c29f5-143">Linux/.NET Core 1.0-2.0</span></span>     | <span data-ttu-id="c29f5-144">`libcurl`transport HTTP oparty na standardzie http 2,0</span><span class="sxs-lookup"><span data-stu-id="c29f5-144">`libcurl`-based HTTP transport (HTTP 2.0 capable)</span></span>                                         |
| <span data-ttu-id="c29f5-145">.NET Core 2,1 i nowsze</span><span class="sxs-lookup"><span data-stu-id="c29f5-145">.NET Core 2.1 and later</span></span>     | <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType>                    |

<span data-ttu-id="c29f5-146">Użytkownicy mogą również konfigurować określony transport dla <xref:System.Net.Http.HttpClient> przez <xref:System.Net.Http.HttpClient.%23ctor*> wywoływanie konstruktora, który przyjmuje <xref:System.Net.Http.HttpMessageHandler>.</span><span class="sxs-lookup"><span data-stu-id="c29f5-146">Users can also configure a specific transport for <xref:System.Net.Http.HttpClient> by invoking the <xref:System.Net.Http.HttpClient.%23ctor*> constructor that takes an <xref:System.Net.Http.HttpMessageHandler>.</span></span>

### <a name="httpclient-and-net-core"></a><span data-ttu-id="c29f5-147">HttpClient i .NET Core</span><span class="sxs-lookup"><span data-stu-id="c29f5-147">HttpClient and .NET Core</span></span>

<span data-ttu-id="c29f5-148">Począwszy od platformy .NET Core 2,1, <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> Klasa `HttpClientHandler` zamiast zapewnia implementację używaną przez klasy sieci http wyższego poziomu, takie `HttpClient`jak.</span><span class="sxs-lookup"><span data-stu-id="c29f5-148">Starting with .NET Core 2.1, the <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> class instead of `HttpClientHandler` provides the implementation used by higher-level HTTP networking classes such as `HttpClient`.</span></span> <span data-ttu-id="c29f5-149">Korzystanie z <xref:System.Net.Http.SocketsHttpHandler> oferty oferuje wiele korzyści:</span><span class="sxs-lookup"><span data-stu-id="c29f5-149">The use of <xref:System.Net.Http.SocketsHttpHandler> offers a number of advantages:</span></span>

- <span data-ttu-id="c29f5-150">Znaczący wzrost wydajności w porównaniu z poprzednią implementacją.</span><span class="sxs-lookup"><span data-stu-id="c29f5-150">A significant performance improvement when compared with the previous implementation.</span></span>

- <span data-ttu-id="c29f5-151">Eliminacja zależności platformy, która upraszcza wdrażanie i obsługę.</span><span class="sxs-lookup"><span data-stu-id="c29f5-151">The elimination of platform dependencies, which simplifies deployment and servicing.</span></span> <span data-ttu-id="c29f5-152">Na przykład `libcurl` nie jest już zależność od platformy .NET Core dla macOS i .NET Core dla systemu Linux.</span><span class="sxs-lookup"><span data-stu-id="c29f5-152">For example, `libcurl` is no longer a dependency on .NET Core for macOS and .NET Core for Linux.</span></span>

- <span data-ttu-id="c29f5-153">Spójne zachowanie na wszystkich platformach .NET.</span><span class="sxs-lookup"><span data-stu-id="c29f5-153">Consistent behavior across all .NET platforms.</span></span>

<span data-ttu-id="c29f5-154">Jeśli ta zmiana jest niepożądana, można skonfigurować aplikację tak, aby korzystała ze starszej <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> wersji na kilka sposobów:</span><span class="sxs-lookup"><span data-stu-id="c29f5-154">If this change is undesirable, you can configure your application to use the older <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> instead in a number of ways:</span></span>

- <span data-ttu-id="c29f5-155">Przez wywołanie <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> metody w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="c29f5-155">By calling the <xref:System.AppContext.SetSwitch%2A?displayProperty=nameWithType> method as follows:</span></span>

   ```csharp
   AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", false);
   ```

   ```vb
   AppContext.SetSwitch("System.Net.Http.UseSocketsHttpHandler", False)
   ``` 
- <span data-ttu-id="c29f5-156">Definiując `System.Net.Http.UseSocketsHttpHandler` przełącznik w pliku konfiguracji *. servicecore. runtimeconfig. JSON* :</span><span class="sxs-lookup"><span data-stu-id="c29f5-156">By defining the `System.Net.Http.UseSocketsHttpHandler` switch in the *.netcore.runtimeconfig.json* configuration file:</span></span>

  ```json
  "runtimeOptions": {
    "configProperties": {
        "System.Net.Http.UseSocketsHttpHandler": false
    }
  }
  ```
  
- <span data-ttu-id="c29f5-157">Przez zdefiniowanie zmiennej środowiskowej `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` o nazwie i ustawienie jej `false` na wartość lub 0.</span><span class="sxs-lookup"><span data-stu-id="c29f5-157">By defining an environment variable named `DOTNET_SYSTEM_NET_HTTP_USESOCKETSHTTPHANDLER` and setting it to either `false` or 0.</span></span>

## Examples  
 [!code-csharp[System.Net.Http.HttpClient#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.http.httpclient/cs/source.cs#1)]  
  
 <span data-ttu-id="c29f5-158">Poprzedni przykład kodu używa `async Task Main()` punktu wejścia.</span><span class="sxs-lookup"><span data-stu-id="c29f5-158">The preceding code example uses an `async Task Main()` entry point.</span></span> <span data-ttu-id="c29f5-159">Ta funkcja wymaga C# 7,1 lub nowszej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-159">That feature requires C# 7.1 or later.</span></span>
 
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkID=245696"><span data-ttu-id="c29f5-160">Łączenie z usługą sieci Web</span><span class="sxs-lookup"><span data-stu-id="c29f5-160">Connecting to a web service</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245697"><span data-ttu-id="c29f5-161">Szybki start: Nawiązywanie połączenia przy użyciu HttpClient</span><span class="sxs-lookup"><span data-stu-id="c29f5-161">Quickstart: Connecting using HttpClient</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245699"><span data-ttu-id="c29f5-162">Jak używać programów obsługi HttpClient</span><span class="sxs-lookup"><span data-stu-id="c29f5-162">How to use HttpClient handlers</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=245698"><span data-ttu-id="c29f5-163">Jak zabezpieczyć połączenia HttpClient</span><span class="sxs-lookup"><span data-stu-id="c29f5-163">How to secure HttpClient connections</span></span></related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=242550"><span data-ttu-id="c29f5-164">Przykład HttpClient</span><span class="sxs-lookup"><span data-stu-id="c29f5-164">HttpClient Sample</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-165">Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Http.HttpClient" /> klasy.</span><span class="sxs-lookup"><span data-stu-id="c29f5-165">Initializes a new instance of the <see cref="T:System.Net.Http.HttpClient" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-166"><xref:System.Net.Http.HttpClient>jest przeznaczony do tworzenia wystąpień i ponownego wykorzystania przez cały czas życia aplikacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-166"><xref:System.Net.Http.HttpClient> is intended to be instantiated once and re-used throughout the life of an application.</span></span> <span data-ttu-id="c29f5-167">Utworzenie wystąpienia klasy HttpClient dla każdego żądania spowoduje wyczerpanie liczby gniazd dostępnych w ramach dużych obciążeń.</span><span class="sxs-lookup"><span data-stu-id="c29f5-167">Instantiating an HttpClient class for every request will exhaust the number of sockets available under heavy loads.</span></span> <span data-ttu-id="c29f5-168">Spowoduje to błędy Gniazdaexception.</span><span class="sxs-lookup"><span data-stu-id="c29f5-168">This will result in SocketException errors.</span></span> <span data-ttu-id="c29f5-169">Poniżej przedstawiono przykład użycia HttpClient prawidłowo.</span><span class="sxs-lookup"><span data-stu-id="c29f5-169">Below is an example using HttpClient correctly.</span></span>  
  
```csharp  
public class GoodController : ApiController  
{  
    // OK  
    private static readonly HttpClient HttpClient;  
  
    static GoodController()  
    {  
        HttpClient = new HttpClient();  
    }  
}  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c29f5-170">Inicjuje nowe wystąpienie <see cref="T:System.Net.Http.HttpClient" /> klasy przy użyciu elementu <see cref="T:System.Net.Http.HttpClientHandler" /> , który jest usuwany, gdy to wystąpienie zostanie usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-170">Initializes a new instance of the <see cref="T:System.Net.Http.HttpClient" /> class using a <see cref="T:System.Net.Http.HttpClientHandler" /> that is disposed when this instance is disposed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[    
## Remarks  
<span data-ttu-id="c29f5-171">Użycie tego konstruktora jest równoważne z wywołaniem [`HttpClient(new HttpClientHandler(), true)`](xref:System.Net.Http.HttpClient.%23ctor(System.Net.Http.HttpMessageHandler,System.Boolean)) konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c29f5-171">Using this constructor is equivalent to calling the [`HttpClient(new HttpClientHandler(), true)`](xref:System.Net.Http.HttpClient.%23ctor(System.Net.Http.HttpMessageHandler,System.Boolean)) constructor.</span></span>
]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpClient (System.Net.Http.HttpMessageHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Http.HttpMessageHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.#ctor(System.Net.Http.HttpMessageHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handler As HttpMessageHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpClient(System::Net::Http::HttpMessageHandler ^ handler);" />
      <MemberSignature Language="F#" Value="new System.Net.Http.HttpClient : System.Net.Http.HttpMessageHandler -&gt; System.Net.Http.HttpClient" Usage="new System.Net.Http.HttpClient handler" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handler" Type="System.Net.Http.HttpMessageHandler" />
      </Parameters>
      <Docs>
        <param name="handler"><span data-ttu-id="c29f5-172">Stos obsługi protokołu HTTP, który będzie używany do wysyłania żądań.</span><span class="sxs-lookup"><span data-stu-id="c29f5-172">The HTTP handler stack to use for sending requests.</span></span></param>
        <summary><span data-ttu-id="c29f5-173">Inicjuje nowe wystąpienie <see cref="T:System.Net.Http.HttpClient" /> klasy z określonym programem obsługi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-173">Initializes a new instance of the <see cref="T:System.Net.Http.HttpClient" /> class with the specified handler.</span></span> <span data-ttu-id="c29f5-174">Procedura obsługi jest usuwana, gdy to wystąpienie zostanie usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-174">The handler is disposed when this instance is disposed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[    
## Remarks  
<span data-ttu-id="c29f5-175">Użycie tego konstruktora jest równoważne z wywołaniem [`HttpClient(handler, true)`](xref:System.Net.Http.HttpClient.%23ctor(System.Net.Http.HttpMessageHandler,System.Boolean)) konstruktora.</span><span class="sxs-lookup"><span data-stu-id="c29f5-175">Using this constructor is equivalent to calling the [`HttpClient(handler, true)`](xref:System.Net.Http.HttpClient.%23ctor(System.Net.Http.HttpMessageHandler,System.Boolean)) constructor.</span></span>

<span data-ttu-id="c29f5-176">Określony `handler` zostanie usunięty przez wywołanie [HttpClient. Dispose](xref:System.Net.Http.HttpMessageInvoker.Dispose).</span><span class="sxs-lookup"><span data-stu-id="c29f5-176">The specified `handler` will be disposed of by calling [HttpClient.Dispose](xref:System.Net.Http.HttpMessageInvoker.Dispose).</span></span>  
]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-177"><paramref name="handler" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-177">The <paramref name="handler" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpClient (System.Net.Http.HttpMessageHandler handler, bool disposeHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Http.HttpMessageHandler handler, bool disposeHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.#ctor(System.Net.Http.HttpMessageHandler,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handler As HttpMessageHandler, disposeHandler As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpClient(System::Net::Http::HttpMessageHandler ^ handler, bool disposeHandler);" />
      <MemberSignature Language="F#" Value="new System.Net.Http.HttpClient : System.Net.Http.HttpMessageHandler * bool -&gt; System.Net.Http.HttpClient" Usage="new System.Net.Http.HttpClient (handler, disposeHandler)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handler" Type="System.Net.Http.HttpMessageHandler" />
        <Parameter Name="disposeHandler" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handler"><span data-ttu-id="c29f5-178"><see cref="T:System.Net.Http.HttpMessageHandler" /> Osoba odpowiedzialna za przetwarzanie komunikatów odpowiedzi HTTP.</span><span class="sxs-lookup"><span data-stu-id="c29f5-178">The <see cref="T:System.Net.Http.HttpMessageHandler" /> responsible for processing the HTTP response messages.</span></span></param>
        <param name="disposeHandler"><span data-ttu-id="c29f5-179"><see langword="true" />Jeśli wewnętrzna procedura obsługi powinna zostać usunięta przez [HttpClient. Dispose](xref:System.Net.Http.HttpMessageInvoker.Dispose); <see langword="false" /> Jeśli zamierzasz ponownie użyć wewnętrznej procedury obsługi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-179"><see langword="true" /> if the inner handler should be disposed of by [HttpClient.Dispose](xref:System.Net.Http.HttpMessageInvoker.Dispose); <see langword="false" /> if you intend to reuse the inner handler.</span></span></param>
        <summary><span data-ttu-id="c29f5-180">Inicjuje nowe wystąpienie <see cref="T:System.Net.Http.HttpClient" /> klasy za pomocą podanej procedury obsługi i określa, czy ta procedura obsługi powinna zostać usunięta, gdy to wystąpienie zostanie usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-180">Initializes a new instance of the <see cref="T:System.Net.Http.HttpClient" /> class with the provided handler, and specifies whether that handler should be disposed when this instance is disposed.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-181"><paramref name="handler" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-181">The <paramref name="handler" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BaseAddress">
      <MemberSignature Language="C#" Value="public Uri BaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri BaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.BaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ BaseAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BaseAddress : Uri with get, set" Usage="System.Net.Http.HttpClient.BaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-182">Pobiera lub ustawia adres podstawowy Uniform Resource Identifier (URI) zasobu internetowego używany podczas wysyłania żądań.</span><span class="sxs-lookup"><span data-stu-id="c29f5-182">Gets or sets the base address of Uniform Resource Identifier (URI) of the Internet resource used when sending requests.</span></span></summary>
        <value><span data-ttu-id="c29f5-183">Adres podstawowy Uniform Resource Identifier (URI) zasobu internetowego używany podczas wysyłania żądań.</span><span class="sxs-lookup"><span data-stu-id="c29f5-183">The base address of Uniform Resource Identifier (URI) of the Internet resource used when sending requests.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-184">W przypadku wysyłania <xref:System.Net.Http.HttpRequestMessage> z względnym identyfikatorem URI do <xref:System.Net.Http.HttpClient.BaseAddress%2A> właściwości zostanie dodany identyfikator URI komunikatu w celu utworzenia bezwzględnego identyfikatora URI.</span><span class="sxs-lookup"><span data-stu-id="c29f5-184">When sending a <xref:System.Net.Http.HttpRequestMessage> with a relative Uri, the message Uri will be added to the <xref:System.Net.Http.HttpClient.BaseAddress%2A> property to create an absolute Uri.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelPendingRequests">
      <MemberSignature Language="C#" Value="public void CancelPendingRequests ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelPendingRequests() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.CancelPendingRequests" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelPendingRequests ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelPendingRequests();" />
      <MemberSignature Language="F#" Value="member this.CancelPendingRequests : unit -&gt; unit" Usage="httpClient.CancelPendingRequests " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c29f5-185">Anuluj wszystkie oczekujące żądania w tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-185">Cancel all pending requests on this instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-186">Po wywołaniu tej metody <xref:System.Net.Http.HttpClient> wystąpienie może być nadal używane do wykonywania dodatkowych żądań.</span><span class="sxs-lookup"><span data-stu-id="c29f5-186">After calling this method, the <xref:System.Net.Http.HttpClient> instance can still be used to execute additional requests.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultProxy">
      <MemberSignature Language="C#" Value="public static System.Net.IWebProxy DefaultProxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.IWebProxy DefaultProxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.DefaultProxy" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property DefaultProxy As IWebProxy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Net::IWebProxy ^ DefaultProxy { System::Net::IWebProxy ^ get(); void set(System::Net::IWebProxy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultProxy : System.Net.IWebProxy with get, set" Usage="System.Net.Http.HttpClient.DefaultProxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-187">Pobiera lub ustawia globalny serwer proxy HTTP.</span><span class="sxs-lookup"><span data-stu-id="c29f5-187">Gets or sets the global Http proxy.</span></span></summary>
        <value><span data-ttu-id="c29f5-188">Serwer proxy używany przez każde wywołanie, które tworzy <see cref="T:System.Net.HttpWebRequest" />wystąpienie klasy.</span><span class="sxs-lookup"><span data-stu-id="c29f5-188">A proxy used by every call that instantiates a <see cref="T:System.Net.HttpWebRequest" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
<span data-ttu-id="c29f5-189">Ta właściwość statyczna określa domyślny serwer proxy używany <xref:System.Net.Http.HttpClient>przez wszystkie wystąpienia, jeśli żaden serwer proxy nie <xref:System.Net.Http.HttpClientHandler> został jawnie ustawiony w przekazaniu przez jego Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="c29f5-189">This static property determines the default proxy that all <xref:System.Net.Http.HttpClient> instances use if no proxy is set explicitly in the <xref:System.Net.Http.HttpClientHandler> passed through its constructor.</span></span> 

<span data-ttu-id="c29f5-190">Wystąpienie domyślne zwrócone przez tę właściwość będzie inicjowane po różnym zestawie reguł w zależności od platformy:</span><span class="sxs-lookup"><span data-stu-id="c29f5-190">The default instance returned by this property will initialize following a different set of rules depending on your platform:</span></span>
* <span data-ttu-id="c29f5-191">**Dla systemu Windows:** Odczytuje konfigurację serwera proxy ze zmiennych środowiskowych lub, jeśli te nie są zdefiniowane, z ustawień serwera proxy użytkownika.</span><span class="sxs-lookup"><span data-stu-id="c29f5-191">**For Windows:** Reads proxy configuration from environment variables or, if those are not defined, from the user's proxy settings.</span></span>

* <span data-ttu-id="c29f5-192">**Dla macOS:** Odczytuje konfigurację serwera proxy ze zmiennych środowiskowych lub, jeśli te nie są zdefiniowane, z ustawień serwera proxy systemu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-192">**For macOS:** Reads proxy configuration from environment variables or, if those are not defined, from the system's proxy settings.</span></span>

* <span data-ttu-id="c29f5-193">**Dla systemu Linux:** Odczytuje konfigurację serwera proxy ze zmiennych środowiskowych lub, w przypadku, gdy nie są zdefiniowane, ta właściwość inicjuje nieskonfigurowane wystąpienie, które pomija wszystkie adresy.</span><span class="sxs-lookup"><span data-stu-id="c29f5-193">**For Linux:** Reads proxy configuration from environment variables or, in case those are not defined, this property initializes a non-configured instance that bypasses all addresses.</span></span>

<span data-ttu-id="c29f5-194">Zmienne środowiskowe używane do `DefaultProxy` inicjowania na platformach opartych na systemie Windows i UNIX są następujące:</span><span class="sxs-lookup"><span data-stu-id="c29f5-194">The environment variables used for `DefaultProxy` initialization on Windows and Unix-based platforms are:</span></span>
* <span data-ttu-id="c29f5-195">HTTP_PROXY: Nazwa hosta lub adres IP serwera proxy używany w żądaniach HTTP.</span><span class="sxs-lookup"><span data-stu-id="c29f5-195">HTTP_PROXY: the hostname or IP address of the proxy server used on HTTP requests.</span></span>
* <span data-ttu-id="c29f5-196">HTTPS_PROXY: Nazwa hosta lub adres IP serwera proxy używany w żądaniach HTTPS.</span><span class="sxs-lookup"><span data-stu-id="c29f5-196">HTTPS_PROXY: the hostname or IP address of the proxy server used on HTTPS requests.</span></span>
* <span data-ttu-id="c29f5-197">ALL_PROXY: Nazwa hosta lub adres IP serwera proxy używany w żądaniach HTTP i/lub HTTPS w przypadku HTTP_PROXY i/lub HTTPS_PROXY nie są zdefiniowane.</span><span class="sxs-lookup"><span data-stu-id="c29f5-197">ALL_PROXY: the hostname or IP address of the proxy server used on HTTP and/or HTTPS requests in case HTTP_PROXY and/or HTTPS_PROXY are not defined.</span></span>
* <span data-ttu-id="c29f5-198">NO_PROXY: rozdzielona przecinkami lista nazw hostów, które powinny być wykluczone z proxy.</span><span class="sxs-lookup"><span data-stu-id="c29f5-198">NO_PROXY: a comma-separated list of hostnames that should be excluded from proxying.</span></span>

 ]]></format>
      </remarks>
      <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-199">Przeniesiona wartość nie może <see langword="null" />być.</span><span class="sxs-lookup"><span data-stu-id="c29f5-199">The value passed cannot be <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultRequestHeaders">
      <MemberSignature Language="C#" Value="public System.Net.Http.Headers.HttpRequestHeaders DefaultRequestHeaders { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Http.Headers.HttpRequestHeaders DefaultRequestHeaders" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.DefaultRequestHeaders" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultRequestHeaders As HttpRequestHeaders" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Http::Headers::HttpRequestHeaders ^ DefaultRequestHeaders { System::Net::Http::Headers::HttpRequestHeaders ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultRequestHeaders : System.Net.Http.Headers.HttpRequestHeaders" Usage="System.Net.Http.HttpClient.DefaultRequestHeaders" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Http.Headers.HttpRequestHeaders</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-200">Pobiera nagłówki, które powinny być wysyłane z każdym żądaniem.</span><span class="sxs-lookup"><span data-stu-id="c29f5-200">Gets the headers which should be sent with each request.</span></span></summary>
        <value><span data-ttu-id="c29f5-201">Nagłówki, które powinny być wysyłane z każdym żądaniem.</span><span class="sxs-lookup"><span data-stu-id="c29f5-201">The headers which should be sent with each request.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-202">Nie trzeba ponownie ustawiać nagłówków ustawionych dla tej właściwości w komunikatach żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-202">Headers set on this property don't need to be set on request messages again.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultRequestVersion">
      <MemberSignature Language="C#" Value="public Version DefaultRequestVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version DefaultRequestVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.DefaultRequestVersion" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultRequestVersion As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Version ^ DefaultRequestVersion { Version ^ get(); void set(Version ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultRequestVersion : Version with get, set" Usage="System.Net.Http.HttpClient.DefaultRequestVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-203">Pobiera lub ustawia domyślną wersję protokołu HTTP używaną w kolejnych żądaniach wykonywanych przez to <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-203">Gets or sets the default HTTP version used on subsequent requests made by this <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></summary>
        <value><span data-ttu-id="c29f5-204">Domyślna wersja do użycia w przypadku wszystkich żądań wykonanych w <see cref="T:System.Net.Http.HttpClient" /> tym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-204">The default version to use for any requests made with this <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
<span data-ttu-id="c29f5-205">`DefaultRequestVersion`jest <xref:System.Net.HttpVersion.Version11?displayProperty=nameWithType> domyślnie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-205">`DefaultRequestVersion` is <xref:System.Net.HttpVersion.Version11?displayProperty=nameWithType> by default.</span></span>

<span data-ttu-id="c29f5-206"><xref:System.Net.Http.HttpClient.GetAsync%2A> <xref:System.Net.Http.HttpClient> <xref:System.Net.Http.HttpClient.SendAsync%2A> <xref:System.Net.Http.HttpClient.GetStringAsync%2A>Właściwość określa domyślną wersję protokołu HTTP, która ma być używana dla wszystkich żądań wysyłanych przy użyciu tego wystąpienia, takich jak wywołania do, lub. `DefaultRequestVersion`</span><span class="sxs-lookup"><span data-stu-id="c29f5-206">The `DefaultRequestVersion` property specifies the default HTTP version to use for any requests sent using this <xref:System.Net.Http.HttpClient> instance, such as calls to <xref:System.Net.Http.HttpClient.GetAsync%2A>, <xref:System.Net.Http.HttpClient.GetStringAsync%2A>, or <xref:System.Net.Http.HttpClient.SendAsync%2A>.</span></span>

<span data-ttu-id="c29f5-207">Właściwość można zmienić, o <xref:System.Net.Http.HttpClient> ile wystąpienie nie rozpoczęło żadnego żądania. `DefaultRequestVersion`</span><span class="sxs-lookup"><span data-stu-id="c29f5-207">The `DefaultRequestVersion` property can be changed as long as the <xref:System.Net.Http.HttpClient> instance has not started any request.</span></span>
 ]]></format>
      </remarks>
      <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-208">W operacji <see langword="DefaultRequestVersion" /> ustawiania ma wartość <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c29f5-208">In a set operation, <see langword="DefaultRequestVersion" /> is <see langword="null" />.</span></span></exception>
      <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-209"><see cref="T:System.Net.Http.HttpClient" /> Wystąpienie już uruchomiło co najmniej jedno żądanie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-209">The <see cref="T:System.Net.Http.HttpClient" /> instance has already started one or more requests.</span></span></exception>
      <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c29f5-210"><see cref="T:System.Net.Http.HttpClient" /> Wystąpienie zostało już usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-210">The <see cref="T:System.Net.Http.HttpClient" /> instance has already been disposed.</span></span></exception>
    </Docs>
    </Member>
    <MemberGroup MemberName="DeleteAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-211">Wyślij żądanie USUŃ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-211">Send a DELETE request to the specified Uri as an asynchronous operation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; DeleteAsync (string requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; DeleteAsync(string requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.DeleteAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteAsync (requestUri As String) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ DeleteAsync(System::String ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.DeleteAsync : string -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.DeleteAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-212">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-212">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-213">Wyślij żądanie USUŃ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-213">Send a DELETE request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-214">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-214">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-215">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-215">This operation will not block.</span></span> <span data-ttu-id="c29f5-216">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-216">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-217"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-217">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-218">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-218">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-219">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-219">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; DeleteAsync (Uri requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; DeleteAsync(class System.Uri requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.DeleteAsync(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteAsync (requestUri As Uri) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ DeleteAsync(Uri ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.DeleteAsync : Uri -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.DeleteAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-220">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-220">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-221">Wyślij żądanie USUŃ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-221">Send a DELETE request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-222">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-222">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-223">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-223">This operation will not block.</span></span> <span data-ttu-id="c29f5-224">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-224">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-225"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-225">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-226">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-226">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-227">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-227">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; DeleteAsync (string requestUri, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; DeleteAsync(string requestUri, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.DeleteAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ DeleteAsync(System::String ^ requestUri, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.DeleteAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.DeleteAsync (requestUri, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-228">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-228">The Uri the request is sent to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-229">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-229">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-230">Wyślij żądanie usunięcia do określonego identyfikatora URI z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-230">Send a DELETE request to the specified Uri with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-231">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-231">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-232">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-232">This operation will not block.</span></span> <span data-ttu-id="c29f5-233">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-233">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-234"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-234">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-235">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-235">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-236">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-236">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; DeleteAsync (Uri requestUri, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; DeleteAsync(class System.Uri requestUri, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.DeleteAsync(System.Uri,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ DeleteAsync(Uri ^ requestUri, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.DeleteAsync : Uri * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.DeleteAsync (requestUri, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-237">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-237">The Uri the request is sent to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-238">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-238">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-239">Wyślij żądanie usunięcia do określonego identyfikatora URI z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-239">Send a DELETE request to the specified Uri with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-240">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-240">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-241">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-241">This operation will not block.</span></span> <span data-ttu-id="c29f5-242">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-242">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-243"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-243">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-244">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-244">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-245">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-245">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="httpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="c29f5-246"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> zwalnia tylko niezarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="c29f5-246"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="c29f5-247">Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Net.Http.HttpClient" /> i opcjonalnie usuwa zarządzane zasoby.</span><span class="sxs-lookup"><span data-stu-id="c29f5-247">Releases the unmanaged resources used by the <see cref="T:System.Net.Http.HttpClient" /> and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-248">Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę.</span><span class="sxs-lookup"><span data-stu-id="c29f5-248">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="c29f5-249">`Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na.</span><span class="sxs-lookup"><span data-stu-id="c29f5-249">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="c29f5-250"><xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.</span><span class="sxs-lookup"><span data-stu-id="c29f5-250"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="c29f5-251">Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Net.Http.HttpClient> których odwołują się te odwołania. `disposing`</span><span class="sxs-lookup"><span data-stu-id="c29f5-251">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Http.HttpClient> references.</span></span> <span data-ttu-id="c29f5-252">Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-252">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 <span data-ttu-id="c29f5-253">Gdy ta metoda jest wywoływana, <xref:System.Net.Http.HttpClient.CancelPendingRequests%2A> Metoda jest wywoływana, aby przerwać wszystkie oczekujące żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-253">When this method is called, the <xref:System.Net.Http.HttpClient.CancelPendingRequests%2A> method is called to abort all pending requests.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-254">Wyślij żądanie POBIERZ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-254">Send a GET request to the specified Uri as an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-255">Operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-255">The operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (string requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(string requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsync (requestUri As String) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(System::String ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : string -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-256">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-256">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-257">Wyślij żądanie POBIERZ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-257">Send a GET request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-258">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-258">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-259">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-259">This operation will not block.</span></span> <span data-ttu-id="c29f5-260">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-260">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-261"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-261">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-262">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-262">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (Uri requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(class System.Uri requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsync (requestUri As Uri) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(Uri ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : Uri -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-263">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-263">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-264">Wyślij żądanie POBIERZ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-264">Send a GET request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-265">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-265">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-266">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-266">This operation will not block.</span></span> <span data-ttu-id="c29f5-267">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-267">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-268"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-268">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-269">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-269">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (string requestUri, System.Net.Http.HttpCompletionOption completionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(string requestUri, valuetype System.Net.Http.HttpCompletionOption completionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsync (requestUri As String, completionOption As HttpCompletionOption) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(System::String ^ requestUri, System::Net::Http::HttpCompletionOption completionOption);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : string * System.Net.Http.HttpCompletionOption -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, completionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-270">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-270">The Uri the request is sent to.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-271">Wartość opcji zakończenia aplikacji HTTP, która wskazuje, kiedy operację należy uznać za zakończoną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-271">An HTTP completion option value that indicates when the operation should be considered completed.</span></span></param>
        <summary><span data-ttu-id="c29f5-272">Wyślij żądanie GET do określonego identyfikatora URI z opcją zakończenia HTTP jako operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-272">Send a GET request to the specified Uri with an HTTP completion option as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-273">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-273">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-274">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-274">This operation will not block.</span></span> <span data-ttu-id="c29f5-275">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony na podstawie `completionOption` parametru po części lub całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-275">The returned <xref:System.Threading.Tasks.Task%601> object will complete based on the `completionOption` parameter after the part or all of the response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-276"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-276">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-277">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-277">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (string requestUri, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(string requestUri, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.String,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(System::String ^ requestUri, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : string * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-278">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-278">The Uri the request is sent to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-279">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-279">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-280">Wyślij żądanie GET do określonego identyfikatora URI z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-280">Send a GET request to the specified Uri with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-281">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-281">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-282">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-282">This operation will not block.</span></span> <span data-ttu-id="c29f5-283">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-283">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-284"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-284">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-285">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-285">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (Uri requestUri, System.Net.Http.HttpCompletionOption completionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(class System.Uri requestUri, valuetype System.Net.Http.HttpCompletionOption completionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsync (requestUri As Uri, completionOption As HttpCompletionOption) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(Uri ^ requestUri, System::Net::Http::HttpCompletionOption completionOption);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : Uri * System.Net.Http.HttpCompletionOption -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, completionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-286">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-286">The Uri the request is sent to.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-287">Wartość opcji zakończenia aplikacji HTTP, która wskazuje, kiedy operację należy uznać za zakończoną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-287">An HTTP completion option value that indicates when the operation should be considered completed.</span></span></param>
        <summary><span data-ttu-id="c29f5-288">Wyślij żądanie GET do określonego identyfikatora URI z opcją zakończenia HTTP jako operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-288">Send a GET request to the specified Uri with an HTTP completion option as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-289">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-289">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-290">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-290">This operation will not block.</span></span> <span data-ttu-id="c29f5-291">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony na podstawie `completionOption` parametru po części lub całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-291">The returned <xref:System.Threading.Tasks.Task%601> object will complete based on the `completionOption` parameter after the part or all of the response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-292"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-292">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-293">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-293">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (Uri requestUri, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(class System.Uri requestUri, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.Uri,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(Uri ^ requestUri, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : Uri * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-294">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-294">The Uri the request is sent to.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-295">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-295">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-296">Wyślij żądanie GET do określonego identyfikatora URI z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-296">Send a GET request to the specified Uri with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-297">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-297">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-298">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-298">This operation will not block.</span></span> <span data-ttu-id="c29f5-299">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-299">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-300"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-300">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-301">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-301">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (string requestUri, System.Net.Http.HttpCompletionOption completionOption, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(string requestUri, valuetype System.Net.Http.HttpCompletionOption completionOption, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.String,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(System::String ^ requestUri, System::Net::Http::HttpCompletionOption completionOption, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : string * System.Net.Http.HttpCompletionOption * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, completionOption, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-302">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-302">The Uri the request is sent to.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-303">Wartość opcji uzupełniania HTTP wskazująca, kiedy operacja powinna zostać uznana za ukończoną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-303">An HTTP  completion option value that indicates when the operation should be considered completed.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-304">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-304">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-305">Wyślij żądanie GET do określonego identyfikatora URI z opcją zakończenia HTTP i tokenem anulowania jako operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-305">Send a GET request to the specified Uri with an HTTP completion option and a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-306">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-306">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-307">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-307">This operation will not block.</span></span> <span data-ttu-id="c29f5-308">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony na podstawie `completionOption` parametru po części lub całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-308">The returned <xref:System.Threading.Tasks.Task%601> object will complete based on the `completionOption` parameter after the part or all of the response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-309"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-309">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-310">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-310">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; GetAsync (Uri requestUri, System.Net.Http.HttpCompletionOption completionOption, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; GetAsync(class System.Uri requestUri, valuetype System.Net.Http.HttpCompletionOption completionOption, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetAsync(System.Uri,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ GetAsync(Uri ^ requestUri, System::Net::Http::HttpCompletionOption completionOption, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.GetAsync : Uri * System.Net.Http.HttpCompletionOption * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.GetAsync (requestUri, completionOption, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-311">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-311">The Uri the request is sent to.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-312">Wartość opcji uzupełniania HTTP wskazująca, kiedy operacja powinna zostać uznana za ukończoną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-312">An HTTP  completion option value that indicates when the operation should be considered completed.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-313">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-313">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-314">Wyślij żądanie GET do określonego identyfikatora URI z opcją zakończenia HTTP i tokenem anulowania jako operacją asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-314">Send a GET request to the specified Uri with an HTTP completion option and a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-315">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-315">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-316">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-316">This operation will not block.</span></span> <span data-ttu-id="c29f5-317">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony na podstawie `completionOption` parametru po części lub całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-317">The returned <xref:System.Threading.Tasks.Task%601> object will complete based on the `completionOption` parameter after the part or all of the response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-318"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-318">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-319">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-319">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetByteArrayAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-320">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako tablicę bajtów w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-320">Send a GET request to the specified Uri and return the response body as a byte array in an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-321">Operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-321">The operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetByteArrayAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;byte[]&gt; GetByteArrayAsync (string requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; GetByteArrayAsync(string requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetByteArrayAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteArrayAsync (requestUri As String) As Task(Of Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;cli::array &lt;System::Byte&gt; ^&gt; ^ GetByteArrayAsync(System::String ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetByteArrayAsync : string -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="httpClient.GetByteArrayAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-322">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-322">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-323">Wysyła żądanie GET do określonego identyfikatora URI i zwraca treść odpowiedzi jako tablicę bajtów w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-323">Sends a GET request to the specified Uri and return the response body as a byte array in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-324">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-324">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-325">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-325">This operation will not block.</span></span> <span data-ttu-id="c29f5-326">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-326">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response body is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-327"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-327">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-328">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-328">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteArrayAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;byte[]&gt; GetByteArrayAsync (Uri requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; GetByteArrayAsync(class System.Uri requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetByteArrayAsync(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteArrayAsync (requestUri As Uri) As Task(Of Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;cli::array &lt;System::Byte&gt; ^&gt; ^ GetByteArrayAsync(Uri ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetByteArrayAsync : Uri -&gt; System.Threading.Tasks.Task&lt;byte[]&gt;" Usage="httpClient.GetByteArrayAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-329">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-329">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-330">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako tablicę bajtów w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-330">Send a GET request to the specified Uri and return the response body as a byte array in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-331">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-331">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-332">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-332">This operation will not block.</span></span> <span data-ttu-id="c29f5-333">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-333">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response body is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-334"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-334">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-335">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-335">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStreamAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-336">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako strumień w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-336">Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-337">Operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-337">The operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStreamAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.IO.Stream&gt; GetStreamAsync (string requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.IO.Stream&gt; GetStreamAsync(string requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetStreamAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStreamAsync (requestUri As String) As Task(Of Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::IO::Stream ^&gt; ^ GetStreamAsync(System::String ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetStreamAsync : string -&gt; System.Threading.Tasks.Task&lt;System.IO.Stream&gt;" Usage="httpClient.GetStreamAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.IO.Stream&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-338">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-338">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-339">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako strumień w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-339">Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-340">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-340">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-341">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-341">This operation will not block.</span></span> <span data-ttu-id="c29f5-342">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu nagłówków odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-342">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the response headers are read.</span></span> <span data-ttu-id="c29f5-343">Ta metoda nie odczytuje ani nie buforuje treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-343">This method does not read nor buffer the response body.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-344"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-344">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-345">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-345">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetStreamAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.IO.Stream&gt; GetStreamAsync (Uri requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.IO.Stream&gt; GetStreamAsync(class System.Uri requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetStreamAsync(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStreamAsync (requestUri As Uri) As Task(Of Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::IO::Stream ^&gt; ^ GetStreamAsync(Uri ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetStreamAsync : Uri -&gt; System.Threading.Tasks.Task&lt;System.IO.Stream&gt;" Usage="httpClient.GetStreamAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.IO.Stream&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-346">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-346">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-347">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako strumień w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-347">Send a GET request to the specified Uri and return the response body as a stream in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-348">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-348">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-349">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-349">This operation will not block.</span></span> <span data-ttu-id="c29f5-350">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu nagłówków odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-350">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the response headers are read.</span></span> <span data-ttu-id="c29f5-351">Ta metoda nie odczytuje ani nie buforuje treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-351">This method does not read nor buffer the response body.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-352"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-352">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-353">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-353">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStringAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-354">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako ciąg w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-354">Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-355">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-355">This operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStringAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;string&gt; GetStringAsync (string requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;string&gt; GetStringAsync(string requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetStringAsync(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringAsync (requestUri As String) As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetStringAsync(System::String ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetStringAsync : string -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="httpClient.GetStringAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-356">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-356">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-357">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako ciąg w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-357">Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-358">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-358">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-359">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-359">This operation will not block.</span></span> <span data-ttu-id="c29f5-360">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-360">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response body is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-361"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-361">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-362">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-362">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetStringAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;string&gt; GetStringAsync (Uri requestUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;string&gt; GetStringAsync(class System.Uri requestUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.GetStringAsync(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetStringAsync (requestUri As Uri) As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetStringAsync(Uri ^ requestUri);" />
      <MemberSignature Language="F#" Value="member this.GetStringAsync : Uri -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="httpClient.GetStringAsync requestUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-363">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-363">The Uri the request is sent to.</span></span></param>
        <summary><span data-ttu-id="c29f5-364">Wyślij żądanie POBIERZ do określonego identyfikatora Uri i zwróć treść odpowiedzi jako ciąg w operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-364">Send a GET request to the specified Uri and return the response body as a string in an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-365">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-365">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-366">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-366">This operation will not block.</span></span> <span data-ttu-id="c29f5-367">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej treści odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-367">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response body is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-368"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-368">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-369">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-369">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseContentBufferSize">
      <MemberSignature Language="C#" Value="public long MaxResponseContentBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaxResponseContentBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.MaxResponseContentBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseContentBufferSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaxResponseContentBufferSize { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseContentBufferSize : int64 with get, set" Usage="System.Net.Http.HttpClient.MaxResponseContentBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-370">Pobiera lub ustawia maksymalną liczbę bajtów do buforowania podczas odczytywania zawartości odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-370">Gets or sets the maximum number of bytes to buffer when reading the response content.</span></span></summary>
        <value><span data-ttu-id="c29f5-371">Maksymalna liczba bajtów do buforowania podczas odczytywania zawartości odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-371">The maximum number of bytes to buffer when reading the response content.</span></span> <span data-ttu-id="c29f5-372">Wartość domyślna tej właściwości to 2 gigabajty.</span><span class="sxs-lookup"><span data-stu-id="c29f5-372">The default value for this property is 2 gigabytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-373">Aplikacja może ustawić niższą <xref:System.Net.Http.HttpClient.MaxResponseContentBufferSize%2A> wartość, aby ograniczyć rozmiar odpowiedzi do buforu podczas odczytywania odpowiedzi.</span><span class="sxs-lookup"><span data-stu-id="c29f5-373">An app can set the <xref:System.Net.Http.HttpClient.MaxResponseContentBufferSize%2A> property to a lower value to limit the size of the response to buffer when reading the response.</span></span> <span data-ttu-id="c29f5-374">Jeśli rozmiar zawartości odpowiedzi jest większy niż <xref:System.Net.Http.HttpClient.MaxResponseContentBufferSize%2A> właściwość, zgłaszany jest wyjątek.</span><span class="sxs-lookup"><span data-stu-id="c29f5-374">If the size of the response content is greater than the  <xref:System.Net.Http.HttpClient.MaxResponseContentBufferSize%2A> property, an exception is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c29f5-375">Określony rozmiar jest mniejszy lub równy zero.</span><span class="sxs-lookup"><span data-stu-id="c29f5-375">The size specified is less than or equal to zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-376">Operacja została już uruchomiona w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-376">An operation has already been started on the current instance.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c29f5-377">Bieżące wystąpienie zostało usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-377">The current instance has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PatchAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PatchAsync (string requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PatchAsync(string requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PatchAsync(System.String,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PatchAsync (requestUri As String, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PatchAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PatchAsync : string * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PatchAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-378">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-378">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-379">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-379">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-380">Wysyła żądanie PATCH do identyfikatora URI wyznaczoną jako ciąg jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-380">Sends a PATCH request to a Uri designated as a string as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-381">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-381">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-382">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-382">This operation will not block.</span></span> <span data-ttu-id="c29f5-383">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-383">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PatchAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PatchAsync (Uri requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PatchAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PatchAsync(System.Uri,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PatchAsync (requestUri As Uri, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PatchAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PatchAsync : Uri * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PatchAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-384">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-384">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-385">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-385">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-386">Wysyła żądanie PATCH jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-386">Sends a PATCH request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-387">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-387">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-388">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-388">This operation will not block.</span></span> <span data-ttu-id="c29f5-389">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-389">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PatchAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PatchAsync (string requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PatchAsync(string requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PatchAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function PatchAsync (requestUri As String, content As HttpContent, cancellationToken as CancellationToken) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PatchAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PatchAsync : string * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PatchAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-390">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-390">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-391">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-391">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-392">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-392">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-393">Wysyła żądanie PATCH z tokenem anulowania do identyfikatora URI reprezentowanego jako ciąg w postaci operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-393">Sends a PATCH request with a cancellation token to a Uri represented as a string as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-394">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-394">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-395">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-395">This operation will not block.</span></span> <span data-ttu-id="c29f5-396">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-396">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PatchAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PatchAsync (Uri requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PatchAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PatchAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function PatchAsync (requestUri As Uri, content As HttpContent, cancellationToken as CancellationToken) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PatchAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PatchAsync : Uri * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PatchAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-397">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-397">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-398">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-398">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-399">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-399">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-400">Wysyła żądanie PATCH z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-400">Sends a PATCH request with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-401">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-401">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-402">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-402">This operation will not block.</span></span> <span data-ttu-id="c29f5-403">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-403">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PostAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-404">Wyślij żądanie WYŚLIJ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-404">Send a POST request to the specified Uri as an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-405">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-405">This operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="PostAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PostAsync (string requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PostAsync(string requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PostAsync(System.String,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PostAsync (requestUri As String, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PostAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PostAsync : string * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PostAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-406">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-406">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-407">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-407">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-408">Wyślij żądanie WYŚLIJ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-408">Send a POST request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-409">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-409">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-410">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-410">This operation will not block.</span></span> <span data-ttu-id="c29f5-411">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-411">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-412"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-412">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-413">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-413">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PostAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PostAsync (Uri requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PostAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PostAsync (requestUri As Uri, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PostAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PostAsync : Uri * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PostAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-414">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-414">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-415">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-415">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-416">Wyślij żądanie WYŚLIJ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-416">Send a POST request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-417">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-417">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-418">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-418">This operation will not block.</span></span> <span data-ttu-id="c29f5-419">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-419">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-420"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-420">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-421">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-421">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PostAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PostAsync (string requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PostAsync(string requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PostAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PostAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PostAsync : string * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PostAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-422">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-422">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-423">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-423">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-424">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-424">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-425">Wyślij żądanie POST z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-425">Send a POST request with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-426">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-426">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-427">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-427">This operation will not block.</span></span> <span data-ttu-id="c29f5-428">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-428">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-429"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-429">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-430">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-430">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PostAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PostAsync (Uri requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PostAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PostAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PostAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PostAsync : Uri * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PostAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-431">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-431">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-432">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-432">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-433">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-433">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-434">Wyślij żądanie POST z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-434">Send a POST request with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-435">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-435">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-436">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-436">This operation will not block.</span></span> <span data-ttu-id="c29f5-437">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-437">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-438"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-438">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-439">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-439">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="PutAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-440">Wyślij żądanie UMIEŚĆ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-440">Send a PUT request to the specified Uri as an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-441">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-441">This operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="PutAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PutAsync (string requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PutAsync(string requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PutAsync(System.String,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PutAsync (requestUri As String, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PutAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PutAsync : string * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PutAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-442">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-442">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-443">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-443">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-444">Wyślij żądanie UMIEŚĆ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-444">Send a PUT request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-445">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-445">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-446">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-446">This operation will not block.</span></span> <span data-ttu-id="c29f5-447">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-447">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-448"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-448">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-449">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-449">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PutAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PutAsync (Uri requestUri, System.Net.Http.HttpContent content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PutAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent)" />
      <MemberSignature Language="VB.NET" Value="Public Function PutAsync (requestUri As Uri, content As HttpContent) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PutAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content);" />
      <MemberSignature Language="F#" Value="member this.PutAsync : Uri * System.Net.Http.HttpContent -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PutAsync (requestUri, content)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-450">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-450">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-451">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-451">The HTTP request content sent to the server.</span></span></param>
        <summary><span data-ttu-id="c29f5-452">Wyślij żądanie UMIEŚĆ do określonego identyfikatora Uri jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-452">Send a PUT request to the specified Uri as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-453">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-453">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-454">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-454">This operation will not block.</span></span> <span data-ttu-id="c29f5-455">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-455">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-456"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-456">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-457">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-457">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PutAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PutAsync (string requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PutAsync(string requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PutAsync(System.String,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PutAsync(System::String ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PutAsync : string * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PutAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.String" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-458">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-458">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-459">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-459">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-460">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-460">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-461">Wyślij żądanie PUT z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-461">Send a PUT request with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-462">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-462">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-463">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-463">This operation will not block.</span></span> <span data-ttu-id="c29f5-464">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-464">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-465"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-465">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-466">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-466">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PutAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; PutAsync (Uri requestUri, System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; PutAsync(class System.Uri requestUri, class System.Net.Http.HttpContent content, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.PutAsync(System.Uri,System.Net.Http.HttpContent,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ PutAsync(Uri ^ requestUri, System::Net::Http::HttpContent ^ content, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.PutAsync : Uri * System.Net.Http.HttpContent * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.PutAsync (requestUri, content, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestUri" Type="System.Uri" />
        <Parameter Name="content" Type="System.Net.Http.HttpContent" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="requestUri"><span data-ttu-id="c29f5-467">Wysłano identyfikator Uri żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-467">The Uri the request is sent to.</span></span></param>
        <param name="content"><span data-ttu-id="c29f5-468">Zawartość żądania HTTP wysyłana do serwera.</span><span class="sxs-lookup"><span data-stu-id="c29f5-468">The HTTP request content sent to the server.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-469">Token odwołania, używany przez inne obiekty lub wątki do otrzymania powiadomienia o anulowaniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-469">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</span></span></param>
        <summary><span data-ttu-id="c29f5-470">Wyślij żądanie PUT z tokenem anulowania jako operacji asynchronicznej.</span><span class="sxs-lookup"><span data-stu-id="c29f5-470">Send a PUT request with a cancellation token as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-471">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-471">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-472">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-472">This operation will not block.</span></span> <span data-ttu-id="c29f5-473">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi (w tym zawartości).</span><span class="sxs-lookup"><span data-stu-id="c29f5-473">The returned <xref:System.Threading.Tasks.Task%601> object will complete after the whole response (including content) is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-474"><paramref name="requestUri" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-474">The <paramref name="requestUri" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-475">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-475">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c29f5-476">Wyślij żądanie HTTP jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-476">Send an HTTP request as an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-477">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-477">This operation will not block.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (request As HttpRequestMessage) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.SendAsync request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="c29f5-478">Komunikat żądania HTTP do wysłania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-478">The HTTP request message to send.</span></span></param>
        <summary><span data-ttu-id="c29f5-479">Wyślij żądanie HTTP jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-479">Send an HTTP request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-480">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-480">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-481">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-481">This operation will not block.</span></span> <span data-ttu-id="c29f5-482">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi z uwzględnieniem zawartości.</span><span class="sxs-lookup"><span data-stu-id="c29f5-482">The returned <xref:System.Threading.Tasks.Task%601> object will complete once the entire response including content is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-483"><paramref name="request" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-483">The <paramref name="request" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-484">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-484">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-485">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-485">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Net.Http.HttpCompletionOption completionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Net.Http.HttpCompletionOption completionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (request As HttpRequestMessage, completionOption As HttpCompletionOption) As Task(Of HttpResponseMessage)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Net::Http::HttpCompletionOption completionOption);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Net.Http.HttpCompletionOption -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.SendAsync (request, completionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="c29f5-486">Komunikat żądania HTTP do wysłania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-486">The HTTP request message to send.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-487">Gdy operacja powinna zostać zakończona (zaraz po otrzymaniu odpowiedzi lub po odczytaniu całej zawartości odpowiedzi).</span><span class="sxs-lookup"><span data-stu-id="c29f5-487">When the operation should complete (as soon as a response is available or after reading the whole response content).</span></span></param>
        <summary><span data-ttu-id="c29f5-488">Wyślij żądanie HTTP jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-488">Send an HTTP request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-489">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-489">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-490">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-490">This operation will not block.</span></span> <span data-ttu-id="c29f5-491">W zależności od wartości `completionOption` parametru zwracany <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony zaraz po otrzymaniu odpowiedzi lub cała odpowiedź obejmująca zawartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-491">Depending on the value of the `completionOption` parameter, the returned <xref:System.Threading.Tasks.Task%601> object will complete as soon as a response is available or the entire response including content is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-492"><paramref name="request" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-492">The <paramref name="request" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-493">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-493">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-494">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-494">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.SendAsync (request, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="c29f5-495">Komunikat żądania HTTP do wysłania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-495">The HTTP request message to send.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-496">Token anulowania do anulowania operacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-496">The cancellation token to cancel operation.</span></span></param>
        <summary><span data-ttu-id="c29f5-497">Wyślij żądanie HTTP jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-497">Send an HTTP request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-498">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-498">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-499">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-499">This operation will not block.</span></span> <span data-ttu-id="c29f5-500">Zwrócony <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony po odczytaniu całej odpowiedzi z uwzględnieniem zawartości.</span><span class="sxs-lookup"><span data-stu-id="c29f5-500">The returned <xref:System.Threading.Tasks.Task%601> object will complete once the entire response including content is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-501"><paramref name="request" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-501">The <paramref name="request" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-502">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-502">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-503">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-503">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt; SendAsync (System.Net.Http.HttpRequestMessage request, System.Net.Http.HttpCompletionOption completionOption, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Http.HttpResponseMessage&gt; SendAsync(class System.Net.Http.HttpRequestMessage request, valuetype System.Net.Http.HttpCompletionOption completionOption, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.HttpClient.SendAsync(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpCompletionOption,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Http::HttpResponseMessage ^&gt; ^ SendAsync(System::Net::Http::HttpRequestMessage ^ request, System::Net::Http::HttpCompletionOption completionOption, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.SendAsync : System.Net.Http.HttpRequestMessage * System.Net.Http.HttpCompletionOption * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;" Usage="httpClient.SendAsync (request, completionOption, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Http.HttpResponseMessage&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Net.Http.HttpRequestMessage" />
        <Parameter Name="completionOption" Type="System.Net.Http.HttpCompletionOption" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="c29f5-504">Komunikat żądania HTTP do wysłania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-504">The HTTP request message to send.</span></span></param>
        <param name="completionOption"><span data-ttu-id="c29f5-505">Gdy operacja powinna zostać zakończona (zaraz po otrzymaniu odpowiedzi lub po odczytaniu całej zawartości odpowiedzi).</span><span class="sxs-lookup"><span data-stu-id="c29f5-505">When the operation should complete (as soon as a response is available or after reading the whole response content).</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="c29f5-506">Token anulowania do anulowania operacji.</span><span class="sxs-lookup"><span data-stu-id="c29f5-506">The cancellation token to cancel operation.</span></span></param>
        <summary><span data-ttu-id="c29f5-507">Wyślij żądanie HTTP jako operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-507">Send an HTTP request as an asynchronous operation.</span></span></summary>
        <returns><span data-ttu-id="c29f5-508">Obiekt zadania reprezentujący operację asynchroniczną.</span><span class="sxs-lookup"><span data-stu-id="c29f5-508">The task object representing the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-509">Ta operacja nie będzie blokować.</span><span class="sxs-lookup"><span data-stu-id="c29f5-509">This operation will not block.</span></span> <span data-ttu-id="c29f5-510">W zależności od wartości `completionOption` parametru zwracany <xref:System.Threading.Tasks.Task%601> obiekt zostanie ukończony zaraz po otrzymaniu odpowiedzi lub cała odpowiedź obejmująca zawartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-510">Depending on the value of the `completionOption` parameter, the returned <xref:System.Threading.Tasks.Task%601> object will complete as soon as a response is available or the entire response including content is read.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c29f5-511"><paramref name="request" /> Ma<see langword="null" />wartość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-511">The <paramref name="request" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-512">Wiadomość żądania została już wysłana przez <see cref="T:System.Net.Http.HttpClient" /> wystąpienie.</span><span class="sxs-lookup"><span data-stu-id="c29f5-512">The request message was already sent by the <see cref="T:System.Net.Http.HttpClient" /> instance.</span></span></exception>
        <exception cref="T:System.Net.Http.HttpRequestException"><span data-ttu-id="c29f5-513">Żądanie nie powiodło się z powodu podstawowego problemu, takiego jak połączenie sieciowe, błąd DNS, sprawdzenie poprawności certyfikatu serwera lub przekroczenie limitu czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-513">The request failed due to an underlying issue such as network connectivity, DNS failure, server certificate validation or timeout.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public TimeSpan Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.HttpClient.Timeout" />
      <MemberSignature Language="VB.NET" Value="Public Property Timeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan Timeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.Timeout : TimeSpan with get, set" Usage="System.Net.Http.HttpClient.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c29f5-514">Pobiera lub ustawia obiekt TimeSpan, który ma czekać przed upływem limitu czasu żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-514">Gets or sets the timespan to wait before the request times out.</span></span></summary>
        <value><span data-ttu-id="c29f5-515">Czas oczekiwania przed upływem limitu czasu żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-515">The timespan to wait before the request times out.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c29f5-516">Wartość domyślna to 100 000 milisekund (100 s).</span><span class="sxs-lookup"><span data-stu-id="c29f5-516">The default value is 100,000 milliseconds (100 seconds).</span></span>  
  
 <span data-ttu-id="c29f5-517">Aby ustawić nieskończony limit czasu, ustaw wartość właściwości na <xref:System.Threading.Timeout.InfiniteTimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="c29f5-517">To set an infinite timeout, set the property value to <xref:System.Threading.Timeout.InfiniteTimeSpan>.</span></span>  
  
 <span data-ttu-id="c29f5-518">Zwracanie lub przekroczenie limitu czasu zapytania systemu nazw domen (DNS) może potrwać do 15 sekund. Jeśli żądanie zawiera nazwę hosta, która wymaga rozwiązania i ma ustawioną <xref:System.Net.Http.HttpClient.Timeout%2A> wartość mniejszą niż 15 sekund, może upłynąć 15 sekund lub więcej <xref:System.Net.WebException> zanim zostanie zgłoszony limit czasu żądania.</span><span class="sxs-lookup"><span data-stu-id="c29f5-518">A Domain Name System (DNS) query may take up to 15 seconds to return or time out. If your request contains a host name that requires resolution and you set <xref:System.Net.Http.HttpClient.Timeout%2A> to a value less than 15 seconds, it may take 15 seconds or more before a <xref:System.Net.WebException> is thrown to indicate a timeout on your request.</span></span>  
  
 <span data-ttu-id="c29f5-519">Ten sam limit czasu będzie stosowany dla wszystkich żądań korzystających z tego <xref:System.Net.Http.HttpClient> wystąpienia.</span><span class="sxs-lookup"><span data-stu-id="c29f5-519">The same timeout will apply for all requests using this <xref:System.Net.Http.HttpClient> instance.</span></span>  <span data-ttu-id="c29f5-520">Można również ustawić różne limity czasu dla poszczególnych żądań przy użyciu <xref:System.Threading.CancellationTokenSource> zadania podrzędnego.</span><span class="sxs-lookup"><span data-stu-id="c29f5-520">You may also set different timeouts for individual requests using a <xref:System.Threading.CancellationTokenSource> on a task.</span></span> <span data-ttu-id="c29f5-521">Należy zauważyć, że będą stosowane tylko krótsze dwa limity czasu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-521">Note that only the shorter of the two timeouts will apply.</span></span>  
  
 ## <a name="example"></a><span data-ttu-id="c29f5-522">Przykład</span><span class="sxs-lookup"><span data-stu-id="c29f5-522">Example</span></span>
 
 <span data-ttu-id="c29f5-523">Poniższy przykład ustawia `Timeout` właściwość.</span><span class="sxs-lookup"><span data-stu-id="c29f5-523">The following example sets the `Timeout` property.</span></span>
  
```csharp
HttpClient httpClient = new HttpClient();
httpClient.Timeout = TimeSpan.FromMinutes(10);
```

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c29f5-524">Określony limit czasu jest mniejszy lub równy zero i nie <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />jest.</span><span class="sxs-lookup"><span data-stu-id="c29f5-524">The timeout specified is less than or equal to zero and is not <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c29f5-525">Operacja została już uruchomiona w bieżącym wystąpieniu.</span><span class="sxs-lookup"><span data-stu-id="c29f5-525">An operation has already been started on the current instance.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="c29f5-526">Bieżące wystąpienie zostało usunięte.</span><span class="sxs-lookup"><span data-stu-id="c29f5-526">The current instance has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>

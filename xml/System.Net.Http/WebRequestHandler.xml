<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="542d6aaeaa10c6517145520d6f88735b9dd3d0c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30558544" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia funkcje specyficzne dla pulpitu nie jest dostępny do aplikacji ze Sklepu Windows lub innych środowisk.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa implementuje obsługi transportu przy użyciu <xref:System.Net.HttpWebRequest> wystąpień do wysyłania żądań HTTP do serwerów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Http.WebRequestHandler" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do potoku żądania z zasobem internetowym.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Jeśli żądanie powinno być potokowe; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> Właściwość wskazująca preferencji dla połączeń w trybie potokowym. Gdy <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> jest `true`, aplikacja zgłasza potokowej połączeń z serwerami, które je obsługują.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, poziom uwierzytelniania i personifikacji używany dla tego żądania.</summary>
        <value>Zwraca <see cref="T:System.Net.Security.AuthenticationLevel" />.  
  
 Bitowe połączenie <see cref="T:System.Net.Security.AuthenticationLevel" /> wartości.  Wartość domyślna to <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku uwierzytelniania wzajemnego klient i serwer przedstawia poświadczenia, aby ustalić jego tożsamość. <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> i <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> wartości są odpowiednie dla uwierzytelniania Kerberos. Uwierzytelnianie Kerberos może być obsługiwany bezpośrednio lub można użyć, jeśli protokół negocjacji zabezpieczeń służy do wybierz protokół zabezpieczeń rzeczywistych. Aby uzyskać więcej informacji o protokołach uwierzytelniania, zobacz [uwierzytelniania internetowego](~/docs/framework/network-programming/internet-authentication.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady pamięci podręcznej dla tego żądania.</summary>
        <value>Zwraca <see cref="T:System.Net.Cache.RequestCachePolicy" />.  
  
 A <see cref="T:System.Net.Cache.RequestCachePolicy" /> obiektu, który definiuje zasady pamięci podręcznej. Wartość domyślna to <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące zasady pamięci podręcznej i obecności żądanego zasobu w pamięci podręcznej określają, czy można pobrać odpowiedzi z pamięci podręcznej. Przy użyciu buforowane odpowiedzi, zazwyczaj zwiększa wydajność aplikacji, ale istnieje ryzyko, że odpowiedź w pamięci podręcznej nie odpowiada odpowiedzi na serwerze.  
  
 Domyślne zasady pamięci podręcznej można określić w pliku konfiguracji w pliku Machine.config lub przez ustawienie <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> właściwości.  
  
 Kopię zasobu jest dodawane tylko do pamięci podręcznej, jeśli w strumieniu odpowiedzi dla zasobu jest pobierany i odczytu do końca strumienia. Aby inne żądanie dla tego samego zasobu można używać kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value>Zwraca <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />.  
  
 Kolekcja certyfikaty zabezpieczeń skojarzony z tym żądaniem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu w milisekundach, aplikacja będzie oczekiwał na 100-kontynuować z serwera przed przekazaniem danych.</summary>
        <value>Zwraca <see cref="T:System.TimeSpan" />.  
  
 Ilość czasu w milisekundach, aplikacja będzie oczekiwał na 100-kontynuować z serwera przed przekazaniem danych. Wartość domyślna to 350 milisekund.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom personifikacji dla bieżącego żądania.</summary>
        <value>Zwraca <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.  
  
 Poziom personifikacji dla żądania. Wartość domyślna to <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji określa, jak serwer może za pomocą poświadczeń klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dopuszczalną długość nagłówków odpowiedzi.</summary>
        <value>Zwraca <see cref="T:System.Int32" />.  
  
 Długość w kilobajtach (1024 bajty), nagłówki odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi zawiera wiersz stanu odpowiedzi i żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na nagłówki odpowiedzi; wartość 0 oznacza, że wszystkie żądania zakończyć się niepowodzeniem.  
  
 Jeśli <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> właściwość nie jest jawnie ustawiona, domyślne wartości <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości.  
  
 Jeśli długość nagłówka odpowiedzi otrzymanych przekracza wartość <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> właściwości, jest zwracany wyjątek podczas uzyskiwania dostępu do odpowiedzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach, gdy żądanie do zapisywania lub odczytywania odpowiedzi z serwera.</summary>
        <value>Zwraca <see cref="T:System.Int32" />.  
  
 Wyrażony w milisekundach czas, zanim limit czasu zapisu lub odczytu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę wywołania zwrotnego można sprawdzić poprawności certyfikatu serwera.</summary>
        <value>Zwraca <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />.  
  
 Metoda wywołania zwrotnego można sprawdzić poprawności certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> jest `null`, certyfikat serwera zostanie zweryfikowana przy użyciu standardowego certyfikatu dobrze znanych urzędów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na udostępnianie szybkiego połączenia z uwierzytelnianiem NTLM.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Aby utrzymać otwarte; uwierzytelnionego połączenia w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna dla tej właściwości to `false`, co powoduje, że bieżące połączenie zostanie zamknięty, zakończenia żądania. Aplikacja musi przechodzić przez sekwencji uwierzytelniania za każdym razem, gdy wystawia nowe żądanie. Jeśli ta właściwość jest ustawiona na `true`, połączenie używane do pobierania odpowiedzi pozostaje otwarty po przeprowadzeniu uwierzytelniania. W takim przypadku żądań innych, że ta właściwość ma wartość `true` może korzystać z połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli została ona uwierzytelniona połączenia dla użytkownika A, użytkownik B mogą ponownie wykorzystać A połączenia; żądanie użytkownika B spełniony jest przeprowadzane przy użyciu poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ponieważ jest możliwe do użycia przez połączenie bez uwierzytelnianego aplikacji, należy upewnić się, że nie administracyjne luki w zabezpieczeniach w systemie, gdy ustawienie dla tej właściwości `true`. Jeśli aplikacja wysyła żądania przez wielu użytkowników (personifikuje wiele kont użytkowników) i opiera się na uwierzytelnianiu w celu ochrony zasobów, nie należy ustawiać tej właściwości `true` chyba że są używane grupy połączeń, zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie ten mechanizm, jeśli Twoje występują problemy z wydajnością i aplikacja jest uruchomiona na serwerze sieci Web przy użyciu zintegrowanego uwierzytelniania systemu Windows.  
  
 Włączenie tego ustawienia otwiera system na zagrożenia bezpieczeństwa. Jeśli ustawisz <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> właściwości `true` podejmij następujące środki ostrożności:  
  
-   Uruchom aplikację w chronionym środowisku w celu uniknięcia połączenia możliwe luki w zabezpieczeniach.  
  
 Jeśli dany serwer zaplecza jako alternatywę można rozważyć wyłączenie uwierzytelniania trwałości. Powoduje to zwiększenie wydajności w mniejszym stopniu, ale jest bezpieczniejsze. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
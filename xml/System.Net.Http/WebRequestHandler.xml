<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fcc25f856413763426701df42edd9e9859611a21" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39797819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zawiera funkcje specyficzne dla pulpitu, które nie jest dostępna do aplikacji Windows Store lub innych środowiskach.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa implementuje obsługi transportu przy użyciu <xref:System.Net.HttpWebRequest> wystąpień do wysyłania żądań HTTP do serwerów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Http.WebRequestHandler" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy potok żądań z zasobem internetowym.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Jeśli żądanie powinno być potokowe; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> właściwości do wskazania preferencji dla połączeń w trybie potokowym. Gdy <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> jest `true`, aplikacja sprawia, że potokowej połączeń z serwerami, które je obsługują.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, poziom uwierzytelniania i personifikacji używane dla tego żądania.</summary>
        <value>Zwraca <see cref="T:System.Net.Security.AuthenticationLevel" />.  
  
Bitowa kombinacja <see cref="T:System.Net.Security.AuthenticationLevel" /> wartości.  Wartość domyślna to <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku uwierzytelniania wzajemnego klient i serwer przedstawiają poświadczeń w celu ustalenia tożsamości. <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> i <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> wartości są istotne dla uwierzytelniania Kerberos. Uwierzytelnianie Kerberos może być obsługiwany bezpośrednio lub mogą być używane, jeśli protokół negocjacji zabezpieczeń jest używany do wybierz protokół zabezpieczeń rzeczywistych. Aby uzyskać więcej informacji na temat protokołów uwierzytelniania, zobacz [uwierzytelnianie internetowe](~/docs/framework/network-programming/internet-authentication.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady pamięci podręcznej dla tego żądania.</summary>
        <value>Zwraca <see cref="T:System.Net.Cache.RequestCachePolicy" />.  
  
A <see cref="T:System.Net.Cache.RequestCachePolicy" /> obiekt, który definiuje zasady pamięci podręcznej. Wartość domyślna to <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące zasady pamięci podręcznej i obecność żądanego zasobu w pamięci podręcznej należy określić, czy można pobrać odpowiedzi z pamięci podręcznej. Zazwyczaj przy użyciu buforowane odpowiedzi zwiększa wydajność aplikacji, ale istnieje ryzyko, że odpowiedzi w pamięci podręcznej nie odpowiada odpowiedzi na serwerze.  
  
 Domyślne zasady pamięci podręcznej można określić w pliku konfiguracji w pliku Machine.config lub poprzez skonfigurowanie <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> właściwości.  
  
 Kopię zasobu jest dodawana do pamięci podręcznej tylko, jeśli w strumieniu odpowiedzi dla zasobu są pobierane i Odczyt do końca strumienia. Dlatego kolejne żądanie dla tego samego zasobu, można użyć kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value>Zwraca <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" />.  
  
Kolekcja certyfikatów zabezpieczeń skojarzony z tym żądaniem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ilość czasu w milisekundach, aplikacja będzie czekać na 100 — Kontynuuj z serwera przed przekazaniem danych.</summary>
        <value>Zwraca <see cref="T:System.TimeSpan" />.  
  
Czas w milisekundach, aplikacja będzie czekać na 100 — Kontynuuj z serwera przed przekazaniem danych. Wartość domyślna to 350 milisekund.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom personifikacji dla bieżącego żądania.</summary>
        <value>Zwraca <see cref="T:System.Security.Principal.TokenImpersonationLevel" />.  
  
Poziom personifikacji dla żądania. Wartość domyślna to <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji decyduje o tym, jak serwer może używać poświadczeń klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dozwoloną długość nagłówków odpowiedzi.</summary>
        <value>Zwraca <see cref="T:System.Int32" />.  
  
Długość w kilobajtach (1024 bajty), nagłówki odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość określonego nagłówka żądania zawiera wiersz stanu odpowiedzi i żadnych znaków kontrolnych dodatkowe, które są odbierane w ramach protokołu HTTP. Wartość-1 oznacza, że limit nie nakłada się na nagłówki odpowiedzi; wartość 0 oznacza, że wszystkie żądania się nie powieść.  
  
 Jeśli <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> właściwość nie została jawnie ustawiona, jego wartość domyślna to wartość <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości.  
  
 Jeśli długość nagłówka odpowiedzi odebrany przekracza wartość <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> właściwości, zgłaszany jest wyjątek podczas uzyskiwania dostępu do odpowiedzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach, zapisywanie żądania lub odczytywania odpowiedzi z serwera.</summary>
        <value>Zwraca <see cref="T:System.Int32" />.  
  
Liczba milisekund, zanim zapisu lub odczytu upłynie limit czasu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia metodę wywołania zwrotnego na potrzeby weryfikacji certyfikatu serwera.</summary>
        <value>Zwraca <see cref="T:System.Net.Security.RemoteCertificateValidationCallback" />.  
  
Metoda wywołania zwrotnego na potrzeby weryfikacji certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> jest `null`, certyfikat serwera zostanie zweryfikowana przy użyciu standardowego certyfikatu dobrze znanych urzędów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy zezwolić na udostępnianie szybkiego połączenia z uwierzytelnianiem NTLM.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />.  
  
 <see langword="true" /> Aby nie zamykaj uwierzytelnionego połączenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna tej właściwości to `false`, co powoduje, że bieżące połączenie zostanie zamknięty, po zakończeniu żądania. Aplikacja musi przejść przez sekwencję uwierzytelniania, za każdym razem, gdy wystawia nowe żądanie. Jeśli ta właściwość jest ustawiona `true`, połączenia służy do pobierania odpowiedzi pozostaje otwarty, po przeprowadzeniu uwierzytelnienia. W tym przypadku żądań innych, które mają tę właściwość ustawioną na `true` mogą korzystać z połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli połączenie uwierzytelnieniu użytkownika, A użytkownik B może ponownie użyć A połączenia; żądanie przez użytkownika B jest spełniony, na podstawie poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ponieważ jest możliwe dla aplikacji, aby korzystać z połączenia bez uwierzytelniane, musisz mieć pewność, że nie administracyjne luk w zabezpieczeniach w systemie podczas ustawiania tej właściwości na `true`. Jeśli Twoja aplikacja przesyła żądania dla wielu użytkowników (personifikuje wiele kont użytkowników) i opiera się na uwierzytelnianie, aby chronić zasoby, nie należy ustawiać tę właściwość na `true` chyba że używasz grup połączeń, zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie tego mechanizmu, jeśli Twoja występują problemy z wydajnością i aplikacja jest uruchomiona na serwerze sieci Web przy użyciu zintegrowanego uwierzytelniania Windows.  
  
 Włączenie tego ustawienia spowoduje otwarcie system na zagrożenia bezpieczeństwa. Jeśli ustawisz <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> właściwość `true` należy wykonać następujące środki ostrożności:  
  
-   Uruchom aplikację w środowisku chronionego, aby zapobiec powstawaniu połączenia możliwe luki w zabezpieczeniach.  
  
 Jeśli dany serwer zaplecza jako alternatywę można rozważyć wyłączenie trwałości uwierzytelniania. Powoduje to zwiększenie wydajności w mniejszym stopniu, ale jest bezpieczniejsze. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod [ http://msdn.microsoft.com/library ](http://msdn.microsoft.com/library).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
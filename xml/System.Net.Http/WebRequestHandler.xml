<Type Name="WebRequestHandler" FullName="System.Net.Http.WebRequestHandler">
  <Metadata><Meta Name="ms.openlocfilehash" Value="312ec839051cc1beaaf53f8fec229fda89127f36" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69114716" /></Metadata><TypeSignature Language="C#" Value="public class WebRequestHandler : System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebRequestHandler extends System.Net.Http.HttpClientHandler" />
  <TypeSignature Language="DocId" Value="T:System.Net.Http.WebRequestHandler" />
  <TypeSignature Language="VB.NET" Value="Public Class WebRequestHandler&#xA;Inherits HttpClientHandler" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebRequestHandler : System::Net::Http::HttpClientHandler" />
  <TypeSignature Language="F#" Value="type WebRequestHandler = class&#xA;    inherit HttpClientHandler" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.Http.HttpClientHandler</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Program udostępnia funkcje specyficzne dla pulpitu, które nie są dostępne dla aplikacji ze sklepu Windows lub innych środowisk.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa implementuje program obsługi transportu przy <xref:System.Net.HttpWebRequest> użyciu wystąpień do wysyłania żądań HTTP do serwerów.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebRequestHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Http.WebRequestHandler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebRequestHandler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Net.Http.WebRequestHandler" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowPipelining">
      <MemberSignature Language="C#" Value="public bool AllowPipelining { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowPipelining" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowPipelining As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowPipelining { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowPipelining : bool with get, set" Usage="System.Net.Http.WebRequestHandler.AllowPipelining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy potoku żądanie do zasobu internetowego.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />wartość.  
  
 <see langword="true" />Jeśli żądanie powinno być potoku; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa właściwości, <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> aby wskazać preferencję połączeń potokowych. Gdy <xref:System.Net.Http.WebRequestHandler.AllowPipelining%2A> jest `true`to aplikacja, tworzy potokowe połączenia z serwerami, które je obsługują.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AuthenticationLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.AuthenticationLevel AuthenticationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.AuthenticationLevel AuthenticationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationLevel As AuthenticationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::AuthenticationLevel AuthenticationLevel { System::Net::Security::AuthenticationLevel get(); void set(System::Net::Security::AuthenticationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationLevel : System.Net.Security.AuthenticationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.AuthenticationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.AuthenticationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą poziom uwierzytelniania i personifikacji używany dla tego żądania.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Net.Security.AuthenticationLevel" /> wartości. Wartość domyślna to <see cref="F:System.Net.Security.AuthenticationLevel.MutualAuthRequested" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W ramach wzajemnego uwierzytelniania zarówno klient, jak i serwer obecne poświadczenia w celu ustalenia tożsamości. Wartości <xref:System.Net.Security.AuthenticationLevel.MutualAuthRequired> i<xref:System.Net.Security.AuthenticationLevel.MutualAuthRequested> są odpowiednie dla uwierzytelniania Kerberos. Uwierzytelnianie Kerberos może być obsługiwane bezpośrednio lub może być używane, jeśli protokół zabezpieczeń Negotiate jest używany do wybierania rzeczywistego protokołu zabezpieczeń. Aby uzyskać więcej informacji na temat protokołów uwierzytelniania, zobacz [Uwierzytelnianie internetowe](~/docs/framework/network-programming/internet-authentication.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CachePolicy">
      <MemberSignature Language="C#" Value="public System.Net.Cache.RequestCachePolicy CachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Cache.RequestCachePolicy CachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePolicy As RequestCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Cache::RequestCachePolicy ^ CachePolicy { System::Net::Cache::RequestCachePolicy ^ get(); void set(System::Net::Cache::RequestCachePolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePolicy : System.Net.Cache.RequestCachePolicy with get, set" Usage="System.Net.Http.WebRequestHandler.CachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zasady pamięci podręcznej dla tego żądania.</summary>
        <value><see cref="T:System.Net.Cache.RequestCachePolicy" /> Obiekt definiujący zasady pamięci podręcznej. Wartość domyślna to <see cref="P:System.Net.WebRequest.DefaultCachePolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżące zasady pamięci podręcznej i obecność żądanego zasobu w pamięci podręcznej określają, czy można pobrać odpowiedź z pamięci podręcznej. Używanie buforowanych odpowiedzi zwykle zwiększa wydajność aplikacji, ale istnieje ryzyko, że odpowiedź w pamięci podręcznej nie jest zgodna z odpowiedzią na serwerze.  
  
 Domyślne zasady pamięci podręcznej można określić w pliku konfiguracyjnym Machine. config lub przez ustawienie <xref:System.Net.HttpWebRequest.DefaultCachePolicy%2A> właściwości.  
  
 Kopia zasobu jest dodawana tylko do pamięci podręcznej, jeśli strumień odpowiedzi dla zasobu jest pobierany i odczytywany na końcu strumienia. Dlatego inne żądanie dotyczące tego samego zasobu może korzystać z kopii w pamięci podręcznej, w zależności od poziomu zasad pamięci podręcznej dla tego żądania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientCertificates As X509CertificateCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ ClientCertificates { System::Security::Cryptography::X509Certificates::X509CertificateCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientCertificates : System.Security.Cryptography.X509Certificates.X509CertificateCollection" Usage="System.Net.Http.WebRequestHandler.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolekcję certyfikatów zabezpieczeń, które są skojarzone z tym żądaniem.</summary>
        <value>Kolekcja certyfikatów zabezpieczeń skojarzonych z tym żądaniem.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ContinueTimeout As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan ContinueTimeout { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.ContinueTimeout : TimeSpan with get, set" Usage="System.Net.Http.WebRequestHandler.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czas (w milisekundach), po upływie którego aplikacja będzie czekać na 100 — Kontynuuj od serwera przed przekazaniem danych.</summary>
        <value>Czas (w milisekundach), po upływie którego aplikacja będzie czekać na 100 — Kontynuuj od serwera przed przekazaniem danych. Wartość domyślna to 350 milisekund.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); void set(System::Security::Principal::TokenImpersonationLevel value); };" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel with get, set" Usage="System.Net.Http.WebRequestHandler.ImpersonationLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia poziom personifikacji dla bieżącego żądania.</summary>
        <value>Poziom personifikacji dla żądania. Wartość domyślna to <see cref="F:System.Security.Principal.TokenImpersonationLevel.Delegation" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poziom personifikacji określa sposób, w jaki serwer może używać poświadczeń klienta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaxResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxResponseHeadersLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxResponseHeadersLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxResponseHeadersLength : int with get, set" Usage="System.Net.Http.WebRequestHandler.MaxResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną dozwoloną długość nagłówków odpowiedzi.</summary>
        <value>Długość nagłówków odpowiedzi wyrażona w kilobajtach (1024 bajtów).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Długość nagłówka odpowiedzi obejmuje wiersz stanu odpowiedzi i wszelkie dodatkowe znaki kontrolne, które są odbierane jako część protokołu HTTP. Wartość-1 oznacza, że w nagłówkach odpowiedzi nie nałożono limitu. wartość 0 oznacza, że wszystkie żądania kończą się niepowodzeniem.  
  
 Jeśli właściwość nie jest jawnie ustawiona, domyślnie przyjmuje wartość <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> właściwości. <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A>  
  
 Jeśli Długość odebranego nagłówka odpowiedzi przekracza wartość <xref:System.Net.Http.WebRequestHandler.MaxResponseHeadersLength%2A> właściwości, zostanie zgłoszony wyjątek podczas uzyskiwania dostępu do odpowiedzi.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadWriteTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReadWriteTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReadWriteTimeout : int with get, set" Usage="System.Net.Http.WebRequestHandler.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia limit czasu w milisekundach podczas zapisywania żądania lub odczytywania odpowiedzi z serwera.</summary>
        <value>Liczba milisekund przed upływem limitu czasu zapisu lub odczytu. Wartość domyślna to 300 000 milisekund (5 minut).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property ServerCertificateValidationCallback As RemoteCertificateValidationCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::RemoteCertificateValidationCallback ^ ServerCertificateValidationCallback { System::Net::Security::RemoteCertificateValidationCallback ^ get(); void set(System::Net::Security::RemoteCertificateValidationCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServerCertificateValidationCallback : System.Net.Security.RemoteCertificateValidationCallback with get, set" Usage="System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia metodę wywołania zwrotnego w celu zweryfikowania certyfikatu serwera.</summary>
        <value>Metoda wywołania zwrotnego służąca do weryfikowania certyfikatu serwera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Http.WebRequestHandler.ServerCertificateValidationCallback%2A> Wtakimprzypadkucertyfikatserwerazostaniesprawdzonyprzyużyciustandardowychdobrze`null`znanych urzędów certyfikacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="VB.NET" Value="Public Property UnsafeAuthenticatedConnectionSharing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UnsafeAuthenticatedConnectionSharing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UnsafeAuthenticatedConnectionSharing : bool with get, set" Usage="System.Net.Http.WebRequestHandler.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Http.WebRequest</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ma być dozwolone udostępnianie połączenia o dużej szybkości przez uwierzytelnianie NTLM.</summary>
        <value>Zwraca <see cref="T:System.Boolean" />wartość.  
  
 <see langword="true" />Aby można było otworzyć uwierzytelnione połączenie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna tej właściwości to `false`, co powoduje zamknięcie bieżącego połączenia po zakończeniu żądania. Aplikacja musi przechodzić przez sekwencję uwierzytelniania za każdym razem, gdy wystawia nowe żądanie. Jeśli ta właściwość jest ustawiona na `true`, połączenie używane do pobrania odpowiedzi pozostaje otwarte po przeprowadzeniu uwierzytelniania. W takim przypadku inne żądania, które mają tę właściwość ustawioną `true` , mogą używać połączenia bez ponownego uwierzytelniania. Innymi słowy, jeśli połączenie zostało uwierzytelnione dla użytkownika A, użytkownik B może ponownie użyć połączenia; żądanie użytkownika B jest spełnione na podstawie poświadczeń użytkownika A.  
  
> [!CAUTION]
>  Ze względu na to, że aplikacja może korzystać z połączenia bez uwierzytelniania, należy się upewnić, że w systemie nie ma żadnych luk w zabezpieczeniach podczas ustawiania tej właściwości `true`na. Jeśli aplikacja wysyła żądania dla wielu użytkowników (personifikuje wiele kont użytkowników) i korzysta z uwierzytelniania w celu ochrony zasobów, nie należy ustawiać tej właściwości `true` , chyba że używasz grup połączeń zgodnie z poniższym opisem.  
  
 Warto rozważyć włączenie tego mechanizmu, jeśli występują problemy z wydajnością, a aplikacja jest uruchomiona na serwerze sieci Web ze zintegrowanym uwierzytelnianiem systemu Windows.  
  
 Włączenie tego ustawienia powoduje otwarcie systemu pod kątem zagrożeń bezpieczeństwa. Jeśli ustawisz właściwość <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> , aby `true` zachować następujące środki ostrożności:  
  
-   Uruchom aplikację w chronionym środowisku, aby uniknąć możliwych luk w zabezpieczeniach.  
  
 Jeśli kontrolujesz serwer zaplecza, możesz rozważyć wyłączenie trwałości uwierzytelniania. Zwiększa to wydajność w mniejszym stopniu, ale jest bezpiecznie. Aby uzyskać więcej informacji, wyszukaj AuthPersistence w bibliotece MSDN pod adresem [http://msdn.microsoft.com/library](https://msdn.microsoft.com/library).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

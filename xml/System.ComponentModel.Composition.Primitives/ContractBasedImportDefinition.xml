<Type Name="ContractBasedImportDefinition" FullName="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8cc3c7c0ef82a155ce73ac57812ebbc462d896b3" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541333" /></Metadata><TypeSignature Language="C#" Value="public class ContractBasedImportDefinition : System.ComponentModel.Composition.Primitives.ImportDefinition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContractBasedImportDefinition extends System.ComponentModel.Composition.Primitives.ImportDefinition" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />
  <TypeSignature Language="VB.NET" Value="Public Class ContractBasedImportDefinition&#xA;Inherits ImportDefinition" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContractBasedImportDefinition : System::ComponentModel::Composition::Primitives::ImportDefinition" />
  <TypeSignature Language="F#" Value="type ContractBasedImportDefinition = class&#xA;    inherit ImportDefinition" />
  <AssemblyInfo>
    <AssemblyName>System.ComponentModel.Composition</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Composition.Primitives.ImportDefinition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje import wymagany przez <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> obiekt, który może określać zarówno nazwę kontraktu, jak i metadane.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ContractBasedImportDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ContractBasedImportDefinition();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## <a name="note-to-inheritors"></a>Uwaga dla dziedziczeń

Typy pochodne wywołujące ten Konstruktor mogą <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.ContractName>opcjonalnie przesłaniać właściwości <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata>, <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.Cardinality> <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity>, <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.IsPrerequisite>, <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.IsRecomposable> , <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy> i.
          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContractBasedImportDefinition (string contractName, string requiredTypeIdentity, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; requiredMetadata, System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, string requiredTypeIdentity, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; requiredMetadata, valuetype System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, valuetype System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Type}},System.ComponentModel.Composition.Primitives.ImportCardinality,System.Boolean,System.Boolean,System.ComponentModel.Composition.CreationPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String, requiredTypeIdentity As String, requiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type)), cardinality As ImportCardinality, isRecomposable As Boolean, isPrerequisite As Boolean, requiredCreationPolicy As CreationPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContractBasedImportDefinition(System::String ^ contractName, System::String ^ requiredTypeIdentity, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ requiredMetadata, System::ComponentModel::Composition::Primitives::ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System::ComponentModel::Composition::CreationPolicy requiredCreationPolicy);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt; * System.ComponentModel.Composition.Primitives.ImportCardinality * bool * bool * System.ComponentModel.Composition.CreationPolicy -&gt; System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" Usage="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition (contractName, requiredTypeIdentity, requiredMetadata, cardinality, isRecomposable, isPrerequisite, requiredCreationPolicy)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" />
        <Parameter Name="requiredTypeIdentity" Type="System.String" />
        <Parameter Name="requiredMetadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;" />
        <Parameter Name="cardinality" Type="System.ComponentModel.Composition.Primitives.ImportCardinality" />
        <Parameter Name="isRecomposable" Type="System.Boolean" />
        <Parameter Name="isPrerequisite" Type="System.Boolean" />
        <Parameter Name="requiredCreationPolicy" Type="System.ComponentModel.Composition.CreationPolicy" />
      </Parameters>
      <Docs>
        <param name="contractName">Nazwa <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> kontraktu obiektu wymaganego przez definicję importu.</param>
        <param name="requiredTypeIdentity">Oczekiwano tożsamości typu eksportu. Użyj metody <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> , aby wygenerować tożsamość typu dla danego typu. Jeśli określony typ nie jest wymagany, użyj <see langword="null" />.</param>
        <param name="requiredMetadata">Kolekcja par klucz/wartość, które zawierają nazwy i typy metadanych wymagane przez definicję importu; lub <see langword="null" /> <see cref="T:System.Collections.Generic.IEnumerable`1" /> , <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> aby ustawić właściwość na pustą kolekcję.</param>
        <param name="cardinality">Jedna z wartości wyliczenia, która wskazuje Kardynalność <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> obiektów wymaganych przez definicję importu.</param>
        <param name="isRecomposable"><see langword="true" />Aby określić, że definicja importu może być spełniona wiele razy w okresie istnienia a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; w przeciwnym <see langword="false" />razie,.</param>
        <param name="isPrerequisite"><see langword="true" />Aby określić, że definicja importu jest wymagana do spełnienia przed <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> rozpoczęciem tworzenia wyeksportowanych obiektów; <see langword="false" />w przeciwnym razie.</param>
        <param name="requiredCreationPolicy">Wartość wskazująca, że importer wymaga określonych zasad tworzenia dla eksportów używanych do zaspokojenia tego importu. Jeśli nie jest wymagana żadna konkretna zasada tworzenia, wartość <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />domyślna to.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> klasy z określoną nazwą kontraktu, wymaganą tożsamością typu, wymaganymi metadanymi, kardynalnością i zasadami tworzenia, a także wskazuje, czy definicja importu została przetworzona, czy wymaganie wstępne.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="contractName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="contractName" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="requiredMetadata" />zawiera element, który jest <see langword="null" />.  
  
—lub— 
 <paramref name="cardinality" />nie jest jedną z <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContractBasedImportDefinition (string contractName, string requiredTypeIdentity, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; requiredMetadata, System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy, System.Collections.Generic.IDictionary&lt;string,object&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string contractName, string requiredTypeIdentity, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; requiredMetadata, valuetype System.ComponentModel.Composition.Primitives.ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, valuetype System.ComponentModel.Composition.CreationPolicy requiredCreationPolicy, class System.Collections.Generic.IDictionary`2&lt;string, object&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Type}},System.ComponentModel.Composition.Primitives.ImportCardinality,System.Boolean,System.Boolean,System.ComponentModel.Composition.CreationPolicy,System.Collections.Generic.IDictionary{System.String,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (contractName As String, requiredTypeIdentity As String, requiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type)), cardinality As ImportCardinality, isRecomposable As Boolean, isPrerequisite As Boolean, requiredCreationPolicy As CreationPolicy, metadata As IDictionary(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContractBasedImportDefinition(System::String ^ contractName, System::String ^ requiredTypeIdentity, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ requiredMetadata, System::ComponentModel::Composition::Primitives::ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, System::ComponentModel::Composition::CreationPolicy requiredCreationPolicy, System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt; * System.ComponentModel.Composition.Primitives.ImportCardinality * bool * bool * System.ComponentModel.Composition.CreationPolicy * System.Collections.Generic.IDictionary&lt;string, obj&gt; -&gt; System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" Usage="new System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition (contractName, requiredTypeIdentity, requiredMetadata, cardinality, isRecomposable, isPrerequisite, requiredCreationPolicy, metadata)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="contractName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredTypeIdentity" Type="System.String" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredMetadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cardinality" Type="System.ComponentModel.Composition.Primitives.ImportCardinality" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isRecomposable" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="isPrerequisite" Type="System.Boolean" Index="5" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="requiredCreationPolicy" Type="System.ComponentModel.Composition.CreationPolicy" Index="6" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;" Index="7" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="contractName">Nazwa <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> kontraktu obiektu wymaganego przez definicję importu.</param>
        <param name="requiredTypeIdentity">Oczekiwano tożsamości typu eksportu. Użyj metody <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> , aby wygenerować tożsamość typu dla danego typu. Jeśli określony typ nie jest wymagany, użyj <see langword="null" />.</param>
        <param name="requiredMetadata">Kolekcja par klucz/wartość, które zawierają nazwy i typy metadanych wymagane przez definicję importu; lub <see langword="null" /> <see cref="T:System.Collections.Generic.IEnumerable`1" /> , <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> aby ustawić właściwość na pustą kolekcję.</param>
        <param name="cardinality">Jedna z wartości wyliczenia, która wskazuje Kardynalność <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> obiektów wymaganych przez definicję importu.</param>
        <param name="isRecomposable"><see langword="true" />Aby określić, że definicja importu może być spełniona wiele razy w okresie istnienia a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; w przeciwnym <see langword="false" />razie,.</param>
        <param name="isPrerequisite"><see langword="true" />Aby określić, że definicja importu jest wymagana do spełnienia przed <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> rozpoczęciem tworzenia wyeksportowanych obiektów; <see langword="false" />w przeciwnym razie.</param>
        <param name="requiredCreationPolicy">Wartość wskazująca, że importer wymaga określonych zasad tworzenia dla eksportów używanych do zaspokojenia tego importu. Jeśli nie jest wymagana żadna konkretna zasada tworzenia, wartość <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />domyślna to.</param>
        <param name="metadata">Metadane skojarzone z tym importem.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> klasy z określoną nazwą kontraktu, wymaganą tożsamością typu, wymaganymi i opcjonalnymi metadanymi, kardynalnością i zasadami tworzenia, a także wskazuje, czy definicja importu jest przetworzona, czy wymaganie wstępne.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="contractName" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="contractName" />jest pustym ciągiem ("").  
  
—lub— 
 <paramref name="requiredMetadata" />zawiera element, który jest <see langword="null" />.  
  
—lub— 
 <paramref name="cardinality" />nie jest jedną z <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="Constraint">
      <MemberSignature Language="C#" Value="public override System.Linq.Expressions.Expression&lt;Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition,bool&gt;&gt; Constraint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Linq.Expressions.Expression`1&lt;class System.Func`2&lt;class System.ComponentModel.Composition.Primitives.ExportDefinition, bool&gt;&gt; Constraint" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.Constraint" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Constraint As Expression(Of Func(Of ExportDefinition, Boolean))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Linq::Expressions::Expression&lt;Func&lt;System::ComponentModel::Composition::Primitives::ExportDefinition ^, bool&gt; ^&gt; ^ Constraint { System::Linq::Expressions::Expression&lt;Func&lt;System::ComponentModel::Composition::Primitives::ExportDefinition ^, bool&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Constraint : System.Linq.Expressions.Expression&lt;Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition, bool&gt;&gt;" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.Constraint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression&lt;System.Func&lt;System.ComponentModel.Composition.Primitives.ExportDefinition,System.Boolean&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wyrażenie określające warunki, które muszą być dopasowane, aby spełniały import opisany przez tę definicję importu.</summary>
        <value>Wyrażenie, które zawiera <see cref="T:System.Func`2" /> obiekt, który definiuje warunki, które muszą być dopasowane <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> , <see cref="T:System.ComponentModel.Composition.Primitives.Export" />aby zostały spełnione przez.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[
Ta właściwość zwraca <xref:System.ComponentModel.Composition.Primitives.ImportDefinition.ContractName>wyrażenie określające warunki na podstawie właściwości <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata>, <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity>, i <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy> . 
                ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstraintSatisfiedBy">
      <MemberSignature Language="C#" Value="public override bool IsConstraintSatisfiedBy (System.ComponentModel.Composition.Primitives.ExportDefinition exportDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsConstraintSatisfiedBy(class System.ComponentModel.Composition.Primitives.ExportDefinition exportDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.IsConstraintSatisfiedBy(System.ComponentModel.Composition.Primitives.ExportDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsConstraintSatisfiedBy(System::ComponentModel::Composition::Primitives::ExportDefinition ^ exportDefinition);" />
      <MemberSignature Language="F#" Value="override this.IsConstraintSatisfiedBy : System.ComponentModel.Composition.Primitives.ExportDefinition -&gt; bool" Usage="contractBasedImportDefinition.IsConstraintSatisfiedBy exportDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exportDefinition" Type="System.ComponentModel.Composition.Primitives.ExportDefinition" />
      </Parameters>
      <Docs>
        <param name="exportDefinition">Definicja eksportu do przetestowania.</param>
        <summary>Zwraca wartość wskazującą, czy ograniczenie reprezentowane przez ten obiekt jest spełnione przez eksport reprezentowany przez daną definicję eksportu.</summary>
        <returns><see langword="true" />Jeśli ograniczenie jest spełnione; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## <a name="note-to-inheritors"></a>Uwaga dla dziedziczeń

Zastąpienia tej metody mogą zapewnić bardziej zoptymalizowane wykonywanie <xref:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.Constraint> właściwości, ale wynik powinien pozostać spójny.
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="exportDefinition" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequiredCreationPolicy">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.Composition.CreationPolicy RequiredCreationPolicy { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.Composition.CreationPolicy RequiredCreationPolicy" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredCreationPolicy As CreationPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::Composition::CreationPolicy RequiredCreationPolicy { System::ComponentModel::Composition::CreationPolicy get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredCreationPolicy : System.ComponentModel.Composition.CreationPolicy" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredCreationPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Composition.CreationPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że importer wymaga określonego <see cref="T:System.ComponentModel.Composition.CreationPolicy" /> dla eksportu używanego do zaspokojenia tego importu.</summary>
        <value>Jedna z następujących wartości: 
 <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />, jeśli importer nie wymaga określonego <see cref="T:System.ComponentModel.Composition.CreationPolicy" />.  
  
 <see cref="F:System.ComponentModel.Composition.CreationPolicy.Shared" />Aby wymagać, aby wszystkie używane eksporty były udostępniane wszystkim importerom w kontenerze.  
  
 <see cref="F:System.ComponentModel.Composition.CreationPolicy.NonShared" />wymaganie, aby wszystkie użyte eksporty nie były udostępniane w kontenerze. W takim przypadku każdy importer otrzymuje oddzielne wystąpienie.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiredMetadata">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,Type&gt;&gt; RequiredMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, class System.Type&gt;&gt; RequiredMetadata" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredMetadata As IEnumerable(Of KeyValuePair(Of String, Type))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ RequiredMetadata { System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, Type ^&gt;&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredMetadata : seq&lt;System.Collections.Generic.KeyValuePair&lt;string, Type&gt;&gt;" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Type&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwy metadanych eksportu wymagane przez definicję importu.</summary>
        <value>Kolekcja <see cref="T:System.String" /> obiektów, które zawierają nazwy <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> metadanych obiektów wymaganych przez <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />. Wartość domyślna to pusta <see cref="T:System.Collections.Generic.IEnumerable`1" /> kolekcja.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastąpienia tej właściwości nigdy nie powinny zwracać `null` lub <xref:System.Collections.Generic.IEnumerable%601> zwracać kolekcji `null`zawierającej element. Jeśli definicja nie zawiera wymaganych metadanych, należy zwrócić pustą <xref:System.Collections.Generic.IEnumerable%601> kolekcję.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequiredTypeIdentity">
      <MemberSignature Language="C#" Value="public virtual string RequiredTypeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RequiredTypeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RequiredTypeIdentity As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ RequiredTypeIdentity { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequiredTypeIdentity : string" Usage="System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredTypeIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera oczekiwany typ eksportu, który jest zgodny z <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />tym.</summary>
        <value>Ciąg, który jest generowany przez wywołanie <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> metody dla typu, którego oczekuje ten import. Jeśli wartość jest <see langword="null" />, ten import nie oczekuje określonego typu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="contractBasedImportDefinition.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ComponentModel.Composition</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący ten <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> obiekt.</summary>
        <returns>Ciąg reprezentujący ten <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> obiekt.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3710b8889c0bd69ce7f7b1f5cee7bca6ea8ec700" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39927188" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <TypeSignature Language="F#" Value="type IsolatedStorageFileStream = class&#xA;    inherit FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Uwidacznia plik w wydzielonej pamięci masowej.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa służy do odczytu, zapisu i tworzenia plików w wydzielonej pamięci masowej.  
  
 Ponieważ klasa rozszerza <xref:System.IO.FileStream>, można użyć wystąpienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> w większości sytuacji gdzie <xref:System.IO.FileStream> w przeciwnym razie mogą być używane, np. w przypadku utworzenia <xref:System.IO.StreamReader> lub <xref:System.IO.StreamWriter>.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
> [!IMPORTANT]
>  Wydzielona pamięć masowa nie jest dostępna dla [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Zamiast tego należy użyć klas danych aplikacji w `Windows.Storage` uwzględnione w przestrzeni nazw [!INCLUDE[wrt](~/includes/wrt-md.md)] interfejsu API, aby przechować lokalne dane i pliki. Aby uzyskać więcej informacji, zobacz [dane aplikacji](http://go.microsoft.com/fwlink/?LinkId=229175) w Centrum deweloperów Windows.  
  
   
  
## Examples  
 Następującej aplikacji konsoli Pokazuje, jak można użyć <xref:System.IO.IsolatedStorage.IsolatedStorageFile> i <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> można zapisać danych do pliku wydzielonej pamięci masowej. Użytkownik jest proszony o Zaloguj się. Jeśli użytkownik jest nowy użytkownik, wiadomości adres URL i adresu URL Sport są rejestrowane jako preferencji w wydzielonej pamięci masowej. Jeśli użytkownik jest użytkownikiem zwracanych, są wyświetlane bieżące preferencje użytkownika. Przykłady kodu, używany w tej przestrzeni nazw są prezentowane w kontekście tej przykładowej aplikacji. Możesz użyć [Storeadm.exe (Isolated Storage — narzędzie)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) narzędzie, aby wyświetlić listę i usuwania plików wydzielonej pamięci masowej, które są tworzone za pomocą tej aplikacji konsoli.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy. Jedynym sposobem, aby otworzyć <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> przy użyciu jednego z jego konstruktorów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu, zapewniając dostęp do pliku określonego przez <paramref name="path" /> w określonym <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Izolowany magazyn, który jest używany, ma zakres tożsamości bieżącego zestawu wykonywanie, a domena aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarty tylko dla okresu istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby określić zakres inny wydzielonej pamięci masowej lub zezwalać na sklep pozostają otwarte, jeśli (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), formularz Konstruktor, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy utworzony nowy plik, istniejące używane i tak dalej.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> jest równa <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z rodzajem elementu <paramref name="access" /> żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Izolowany magazyn, który jest używany, ma zakres tożsamości bieżącego zestawu wykonywanie, a domena aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarty tylko dla okresu istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby określić zakres inny wydzielonej pamięci masowej lub zezwalać na sklep pozostają otwarte, jeśli (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), formularz Konstruktor, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącą używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, a w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określony przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik, istniejące używane i tak dalej.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego konstruktora. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowa kombinacja <see cref="T:System.IO.FileShare" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określony przez trybie współdzielenia <paramref name="share" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Izolowany magazyn, który jest używany, ma zakres tożsamości bieżącego zestawu wykonywanie, a domena aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarty tylko dla okresu istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby określić zakres inny wydzielonej pamięci masowej lub zezwalać na sklep pozostają otwarte, jeśli (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), formularz Konstruktor, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego konstruktora. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" /> w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, a w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określony przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącą używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego konstruktora. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowa kombinacja <see cref="T:System.IO.FileShare" /> wartości.</param>
        <param name="bufferSize">
          <see cref="T:System.IO.FileStream" /> Rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określony przez trybie współdzielenia <paramref name="share" />, za pomocą <paramref name="buffersize" /> określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Izolowany magazyn, który jest używany, ma zakres tożsamości bieżącego zestawu wykonywanie, a domena aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarty tylko dla okresu istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby określić zakres inny wydzielonej pamięci masowej lub zezwalać na sklep pozostają otwarte, jeśli (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), formularz Konstruktor, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącą używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowa kombinacja <see cref="T:System.IO.FileShare" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określony przez trybie współdzielenia <paramref name="share" />i w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określony przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącą używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego konstruktora. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberSignature Language="F#" Value="new System.IO.IsolatedStorage.IsolatedStorageFileStream : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare * int * System.IO.IsolatedStorage.IsolatedStorageFile -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="new System.IO.IsolatedStorage.IsolatedStorageFileStream (path, mode, access, share, bufferSize, isf)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w wydzielonej pamięci masowej.</param>
        <param name="mode">Jedną z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowa kombinacja <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowa kombinacja <see cref="T:System.IO.FileShare" /> wartości</param>
        <param name="bufferSize">
          <see cref="T:System.IO.FileStream" /> Rozmiar buforu.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określony przez trybie współdzielenia <paramref name="share" />, za pomocą <paramref name="buffersize" /> określony i w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określony przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącą używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Gdy kompilujesz zestaw znaków z określonym ustawieniem kultury i pobrać te te same znaki przy użyciu innego ustawienia kultury, znaki mogą nie być interpretowanej i może spowodować zgłoszenie wyjątku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego konstruktora. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do wydzielonej pamięci masowej</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginRead : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginRead (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie w bajtach w <c>buforu</c> jaką ma rozpocząć się odczyt.</param>
        <param name="numBytes">Maksymalna liczba bajtów do odczytania.</param>
        <param name="userCallback">Metoda wywoływana, gdy operacja odczytu asynchroniczną zostanie zakończona. Ten parametr jest opcjonalny.</param>
        <param name="stateObject">Stan odczyt asynchroniczny.</param>
        <summary>Rozpoczyna odczyt asynchroniczny.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odczytać obiekt, który reprezentuje asynchroniczny, który jest nadal prawdopodobnie oczekujące. To <see cref="T:System.IAsyncResult" /> muszą być przekazywane do tego strumienia <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> metodę pozwala ustalić liczbę bajtów zostały odczytane. Można to zrobić przez ten sam kod, który wywołuje <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> lub wywołanie zwrotne przekazane do <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżącą pozycję w strumieniu jest aktualizowana po wykonaniu asynchronicznego odczytu lub zapisu, nie, po zakończeniu operacji We/Wy.  
  
 Należy wywołać <xref:System.IO.Stream.EndRead%2A> z tym <xref:System.IAsyncResult> Aby dowiedzieć się, ile bajtów zostały wczytane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Odczyt asynchroniczny podjęto próbę poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberSignature Language="F#" Value="override this.BeginWrite : byte[] * int * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="isolatedStorageFileStream.BeginWrite (buffer, offset, numBytes, userCallback, stateObject)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do zapisywania danych.</param>
        <param name="offset">Przesunięcie w bajtach w <c>buforu</c> jaką ma rozpocząć się zapis.</param>
        <param name="numBytes">Maksymalna liczba bajtów do zapisania.</param>
        <param name="userCallback">Metoda do wywołania po ukończeniu asynchronicznego zapisu operacji. Ten parametr jest opcjonalny.</param>
        <param name="stateObject">Stan asynchroniczny zapis.</param>
        <summary>Rozpoczyna się asynchronicznego zapisu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Który reprezentuje asynchroniczny zapis prawdopodobnie wciąż oczekuje. To <see cref="T:System.IAsyncResult" /> muszą być przekazywane do tego strumienia <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> metodę, aby upewnić się, że zapisu została zakończona, odpowiednio następnie zwalnia zasoby. Można to zrobić przez ten sam kod, który wywołuje <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> lub wywołanie zwrotne przekazane do <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu jest zapisywalny, z możliwością zapisu na końcu strumienia rozwija strumienia.  
  
 Bieżącą pozycję w strumieniu jest aktualizowana po wykonaniu asynchronicznego odczytu lub zapisu, nie, po zakończeniu operacji We/Wy.  
  
 Należy wywołać <xref:System.IO.Stream.EndWrite%2A> z <xref:System.IAsyncResult> obiekt zwracany przez tę metodę, aby dowiedzieć się, ile bajtów zostały napisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę asynchronicznego zapisu poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRead : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy można odczytać pliku.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt może być odczytany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu może zostać odczytany.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> właściwości jako to sprawdzenie, czy strumień mogą być odczytywane przed wywołaniem <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> lub <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSeek : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą czy wyszukiwanie operacje są obsługiwane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> operacji poszukiwania obsługuje obiektu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> operacji poszukiwania obsługuje obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanWrite : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy można zapisywać do pliku.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt może być napisane; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które mogą być zapisywane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> właściwości jako to sprawdzenie, czy strumień mogą być odczytywane przed wywołaniem <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> lub <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="isolatedStorageFileStream.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="isolatedStorageFileStream.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną <xref:System.IDisposable.Dispose%2A> metody i <xref:System.Object.Finalize%2A> metody. <xref:System.IDisposable.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> metody z `disposing` parametr ma wartość true. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> z `disposing` ustawiony na wartość false.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> odwołania. Ta metoda wywołuje <xref:System.IDisposable.Dispose%2A> metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IDisposable.Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see cref="M:System.IDisposable.Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  Aby uzyskać więcej informacji na temat <see cref="M:System.IDisposable.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndRead : IAsyncResult -&gt; int" Usage="isolatedStorageFileStream.EndRead asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania asynchronicznego.</param>
        <summary>Kończy się oczekiwanie asynchroniczne żądanie odczytu.</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, z zakresu między zero a liczba żądanych bajtów. Strumienie zwróci tylko zero na końcu strumienia. W przeciwnym razie będzie ich blokować do czasu udostępnienia co najmniej jednego bajtu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> obiektu z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>i wywoływać metodę <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> jest jedynym sposobem, aby wiedzieć, ile bajtów zostały odczytane z <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> blokuje, dopóki nie zakończy się operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="override this.EndWrite : IAsyncResult -&gt; unit" Usage="isolatedStorageFileStream.EndWrite asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekiwanie asynchroniczne operacje We/Wy żądanie zakończenia.</param>
        <summary>Kończy się asynchronicznego zapisu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> blokuje, dopóki nie zakończy się operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberSignature Language="F#" Value="override this.Flush : unit -&gt; unit" Usage="isolatedStorageFileStream.Flush " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ buforu może służyć do odczytu lub zapisu, ale nie oba jednocześnie <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> wykonuje dwie funkcje. Najpierw wszelkie dane, które wcześniej zapisane w buforze są kopiowane do pliku i rozmiar buforu jest wyczyszczone. Jeśli drugi <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> jest `true` i dane wcześniej zostały skopiowane z pliku do bufora do odczytu, bieżącą pozycję w pliku zostanie zmniejszony według liczby nieprzeczytane bajtów w buforze. Rozmiar buforu jest następnie czyszczona.  
  
 Użyj <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> przeciążenia metody upewnić się, wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberSignature Language="F#" Value="override this.Flush : bool -&gt; unit" Usage="isolatedStorageFileStream.Flush flushToDisk" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> Aby opróżnić wszystkie bufory plików pośrednich; w przeciwnym razie <see langword="false" />.</param>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku, a także czyści wszystkie bufory plików pośrednich.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, jeśli chcesz upewnić się, wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use IsolatedStorageFileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku dla pliku bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje. Dostęp do tej właściwości nie jest dozwolona w <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu i zgłasza <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />.</summary>
        <value>Dojście do pliku dla pliku, bieżący <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> właściwości.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> Właściwość zawsze generuje wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAsync : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość Boolean wskazującą czy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu otwarto asynchronicznie lub synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt obsługuje asynchronicznego dostępu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczne <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> nie można utworzyć obiektów, w przeciwieństwie do <xref:System.IO.FileStream>. Jednak <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, i <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> metody są obsługiwane w wystąpieniach synchroniczne z niektórych spadku wydajności.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak można użyć <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> właściwości, aby sprawdzić, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> jest synchroniczne. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <value>Długość <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> reprezentuje liczbę bajtów, obecnie w pliku. Nie występuje zgodnie z limitem przydziału wydzielonej pamięci masowej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> właściwości.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Lock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Lock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja początkowa zakresu do zablokowania. Wartość tego parametru musi być równa lub większa od 0 (zero).</param>
        <param name="length">Liczba bajtów do zablokowania.</param>
        <summary>Zapobiega inne procesy z odczytu / zapisu do strumienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blokowanie zakresu strumienia pliku daje wątków blokowania zapewnia wyłączny dostęp do tego zakresu strumienia pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten plik będzie zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Proces uzyskać dostępu do pliku, ponieważ inny proces został zablokowany w części pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int64 with get, set" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <value>Bieżące położenie <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości podczas działania <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> właściwość `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> właściwość do zapisania danych do pliku.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie można ustawić położenie liczbą ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : byte[] * int * int -&gt; int" Usage="isolatedStorageFileStream.Read (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do odczytania.</param>
        <param name="offset">Przesunięcie w buforze, od którego należy rozpocząć pisanie.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Kopiuje bajtów z bieżącej buforowanej <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt jako tablicę.</summary>
        <returns>Całkowita liczba bajtów jest wczytywany <paramref name="buffer" />. Może to być mniejsza niż żądana liczba bajtów, jeśli nie są obecnie dostępne tę liczbę bajtów lub zero, jeśli osiągnięty zostanie koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `buffer` Parametru może być wystąpieniem elementu <xref:System.Buffer> klasy lub tablica z jednym z następujących typów: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32> , <xref:System.UInt64>, <xref:System.Single>, lub <xref:System.Double>. `offset` Parametru zapewnia przesunięcie bajtu w buforze, od której ma rozpocząć się zapis (indeks w buforze) i `count` parametru zapewnia maksymalną liczbę bajtów, które będą odczytywane z tego strumienia. Zwrócona wartość jest rzeczywista liczba odczytanych bajtów lub zero, jeśli osiągnięty zostanie koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżącego położenia obiektu strumienia jest zaawansowany według liczby odczytanych bajtów. Jeśli wystąpi wyjątek, bieżącego położenia obiektu strumienia jest bez zmian.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Traktuje metoda `buffer` parametr jako blok bajtów, niezależnie od jej rzeczywistego typu. Podobnie `offset` i `count` parametry są zawsze podany w bajtach. Aby uzyskać `buffer` parametrów innych niż tablice typu byte, oznacza to, że indeks elementu należy pomnożyć przez wielkość elementu w bajtach, w celu utworzenia poprawnej wartości `offset` lub `count`.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Metoda zwróci wartość zero, tylko wtedy, gdy osiągnięty zostanie koniec strumienia. We wszystkich innych przypadkach <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Jeśli żadne dane nie są dostępne z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu po wywołaniu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, metoda spowoduje zablokowanie, dopóki co najmniej jednego bajtu danych mogą być zwrócone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberSignature Language="F#" Value="override this.ReadByte : unit -&gt; int" Usage="isolatedStorageFileStream.ReadByte " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje jednobajtowych z <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu w wydzielonej pamięci masowej.</summary>
        <returns>8-bitowej nieoznaczonej liczby całkowitej wartość odczytu z pliku wydzielonej pamięci masowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób, w jaki <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> metoda może służyć do odczytywania danych z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeFileHandle : Microsoft.Win32.SafeHandles.SafeFileHandle" Usage="System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> obiekt, który reprezentuje uchwyt pliku systemu operacyjnego dla pliku, bieżący <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> obiekt, który reprezentuje uchwyt pliku systemu operacyjnego dla pliku, bieżący <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> Właściwość nie jest obsługiwana i zawsze generuje <xref:System.IO.IsolatedStorage.IsolatedStorageException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> Właściwość zawsze generuje wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Powiązane wyliczenie: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Akcja zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberSignature Language="F#" Value="override this.Seek : int64 * System.IO.SeekOrigin -&gt; int64" Usage="isolatedStorageFileStream.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Nowe położenie <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</param>
        <param name="origin">Jedną z <see cref="T:System.IO.SeekOrigin" /> wartości.</param>
        <summary>Ustawia bieżącą pozycję <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt z podaną wartością.</summary>
        <returns>Stanowisko w <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiekty obsługują pozycjonowanie przekraczającego długość strumienia, inne spowoduje zgłoszenie wyjątku w tym przypadku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="origin" /> Musi być jednym z <see cref="T:System.IO.SeekOrigin" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberSignature Language="F#" Value="override this.SetLength : int64 -&gt; unit" Usage="isolatedStorageFileStream.SetLength value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Nową długość <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</param>
        <summary>Ustawia długość to <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> określonego obiektu <paramref name="value" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony `value` jest mniejsza niż bieżąca długość <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu strumień został obcięty. Jeśli określony `value` jest większy niż bieżąca długość strumienia, podzielonego strumienia. Jeśli strumień jest rozwinięta, zawartość strumienia między starą a nową długość są niezdefiniowane. Aby można było używać tej metody <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu musi obsługiwać zarówno pisanie i wyszukiwanie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> jest to liczba ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberSignature Language="F#" Value="override this.Unlock : int64 * int64 -&gt; unit" Usage="isolatedStorageFileStream.Unlock (position, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja początkowa zakresu, aby odblokować. Wartość tego parametru musi być równa lub większa od 0 (zero).</param>
        <param name="length">Liczba bajtów do odblokowania.</param>
        <summary>Zezwala na inne procesy dostęp do całości lub części pliku, który wcześniej został zablokowany.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="override this.Write : byte[] * int * int -&gt; unit" Usage="isolatedStorageFileStream.Write (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do zapisania.</param>
        <param name="offset">Przesunięcie bajtów w buforze, od której rozpoczyna się.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Zapisuje bloku bajtów, które mają <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> przy użyciu danych odczytanych z tablicy bajtowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `offset` Parametr zawiera przesunięcie bajtu w `buffer` jaką ma rozpocząć się odczyt i `count` parametr zwraca liczbę bajtów, które będą zapisywane do tego <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Jeśli operacja zapisu zakończy się pomyślnie, bieżącego położenia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu jest zaawansowany, liczba zapisanych bajtów. Jeśli wystąpi wyjątek, bieżącego położenia obiektu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu pozostaje niezmieniony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Próba zapisu przekracza limit przydziału <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberSignature Language="F#" Value="override this.WriteByte : byte -&gt; unit" Usage="isolatedStorageFileStream.WriteByte value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość bajtu zapis do pliku wydzielonej pamięci masowej.</param>
        <summary>Zapisuje do jednego bajtu <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób, w jaki <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> metoda może służyć do odczytywania danych z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Próba zapisu przekracza limit przydziału <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
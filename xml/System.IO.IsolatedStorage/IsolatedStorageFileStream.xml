<Type Name="IsolatedStorageFileStream" FullName="System.IO.IsolatedStorage.IsolatedStorageFileStream">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8eb05ccb12109231f5298b1737311d1a391259c9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30455679" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class IsolatedStorageFileStream : System.IO.FileStream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit IsolatedStorageFileStream extends System.IO.FileStream" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />
  <TypeSignature Language="VB.NET" Value="Public Class IsolatedStorageFileStream&#xA;Inherits FileStream" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFileStream : System::IO::FileStream" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.FileStream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Przedstawia do pliku w magazynie izolowanym.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasa używana do odczytu, zapisu i tworzenia plików w magazynie izolowanym.  
  
 Ponieważ klasa rozszerza <xref:System.IO.FileStream>, można użyć wystąpienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> w większości sytuacji gdzie <xref:System.IO.FileStream> w przeciwnym razie mogą być używane, na przykład w ramach tworzenia <xref:System.IO.StreamReader> lub <xref:System.IO.StreamWriter>.  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niego. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> metody w `try` / `catch` bloku. Do usunięcia ich pośrednio, użyj konstrukcji języka takiego jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu tematu.  
  
> [!IMPORTANT]
>  Izolowany magazyn jest niedostępny dla [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Zamiast tego należy użyć klasy danych aplikacji w `Windows.Storage` obszary nazw dołączane w [!INCLUDE[wrt](~/includes/wrt-md.md)] interfejsu API do przechowywania plików i danych lokalnych. Aby uzyskać więcej informacji, zobacz [danych aplikacji](http://go.microsoft.com/fwlink/?LinkId=229175) w Centrum deweloperów systemu Windows.  
  
   
  
## Examples  
 Następującej aplikacji konsoli Pokazuje, jak używasz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> i <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> można zapisać danych w pliku izolowanego magazynu. Użytkownik jest proszony o zalogować. Jeśli użytkownik jest nowy użytkownik, wiadomości adresu URL i adresu URL aplikacji sportowych są rejestrowane jako osobiste preferencje w magazynie izolowanym. Jeśli użytkownik jest użytkownikiem przekazujących, są wyświetlane bieżące preferencje użytkownika. Przykłady kodu, używany w tej przestrzeni nazw są prezentowane w kontekście tej przykładowej aplikacji. Można użyć [Storeadm.exe (narzędzie magazynu izolowanego)](~/docs/framework/tools/storeadm-exe-isolated-storage-tool.md) narzędzie do listy i usuwania plików izolowanych magazynów, które są tworzone za pomocą tej aplikacji konsoli.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#1)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy. Jedynym sposobem, aby otworzyć <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> przy użyciu jednej z jej konstruktorów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> zapewniające dostęp do pliku określonego przez obiekt <paramref name="path" /> w określonym <paramref name="mode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obejmuje izolowanego magazynu, który jest używany przez bieżący zestaw wykonawczy tożsamości i domeny aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarte tylko w przypadku okres istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Określ zakres magazynu izolowanego innego lub Zezwalaj na sklep mogą pozostawać otwarte (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), użyj formy konstruktora, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy należy utworzyć nowy plik, istniejącego używane i tak dalej.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" /></exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z rodzajem elementu <paramref name="access" /> żądanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obejmuje izolowanego magazynu, który jest używany przez bieżący zestaw wykonawczy tożsamości i domeny aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarte tylko w przypadku okres istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Określ zakres magazynu izolowanego innego lub Zezwalaj na sklep mogą pozostawać otwarte (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), użyj formy konstruktora, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącego używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określonego przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy należy utworzyć nowy plik, istniejącego używane i tak dalej.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego konstruktora. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowe połączenie <see cref="T:System.IO.FileShare" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określona w trybie współdzielenia <paramref name="share" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obejmuje izolowanego magazynu, który jest używany przez bieżący zestaw wykonawczy tożsamości i domeny aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarte tylko w przypadku okres istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Określ zakres magazynu izolowanego innego lub Zezwalaj na sklep mogą pozostawać otwarte (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), użyj formy konstruktora, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego konstruktora. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" /> w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określonego przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącego używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego konstruktora. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowe połączenie <see cref="T:System.IO.FileShare" /> wartości.</param>
        <param name="bufferSize">
          <see cref="T:System.IO.FileStream" /> Rozmiar buforu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określona w trybie współdzielenia <paramref name="share" />, z <paramref name="buffersize" /> określony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obejmuje izolowanego magazynu, który jest używany przez bieżący zestaw wykonawczy tożsamości i domeny aplikacji, w którym jest uruchomiony. Ten magazyn pozostanie otwarte tylko w przypadku okres istnienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Określ zakres magazynu izolowanego innego lub Zezwalaj na sklep mogą pozostawać otwarte (tak wielu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektów, które można otworzyć z niego), użyj formy konstruktora, który akceptuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiektu.  
  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącego używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowe połączenie <see cref="T:System.IO.FileShare" /> wartości.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określona w trybie współdzielenia <paramref name="share" />w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określonego przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącego używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego konstruktora. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IsolatedStorageFileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, class System.IO.IsolatedStorage.IsolatedStorageFile isf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, mode As FileMode, access As FileAccess, share As FileShare, bufferSize As Integer, isf As IsolatedStorageFile)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IsolatedStorageFileStream(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share, int bufferSize, System::IO::IsolatedStorage::IsolatedStorageFile ^ isf);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isf" Type="System.IO.IsolatedStorage.IsolatedStorageFile" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku w magazynie izolowanym.</param>
        <param name="mode">Jeden z <see cref="T:System.IO.FileMode" /> wartości.</param>
        <param name="access">Bitowe połączenie <see cref="T:System.IO.FileAccess" /> wartości.</param>
        <param name="share">Bitowe połączenie <see cref="T:System.IO.FileShare" /> wartości</param>
        <param name="bufferSize">
          <see cref="T:System.IO.FileStream" /> Rozmiar buforu.</param>
        <param name="isf">
          <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> Do otwarcia <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> klasy zapewniające dostęp do pliku określonego przez <paramref name="path" />, w określonym <paramref name="mode" />, z określonego pliku <paramref name="access" />, przy użyciu pliku określona w trybie współdzielenia <paramref name="share" />, z <paramref name="buffersize" /> określona i w kontekście <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> określonego przez <paramref name="isf" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `mode` Parametr wskazuje, czy utworzony nowy plik lub istniejącego używane. `access` Parametr zawiera tylko do odczytu, odczytu/zapisu i tylko do zapisu.  
  
> [!CAUTION]
>  Podczas kompilowania zestawu znaków z danego ustawienia kultury i pobrać te znaki tego samego z inne ustawienie kultury znaki nie mogą być interpretable i może spowodować wyjątek zostanie wygenerowany.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego konstruktora. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#12)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#12)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Jest nieprawidłowo sformułowana.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ma ustawioną wartość <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <paramref name="isf" /> nie ma limit przydziału.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostępu do izolowanego magazynu</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginRead (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginRead(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do wczytania danych.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> pod którym ma rozpocząć się odczyt.</param>
        <param name="numBytes">Maksymalna liczba bajtów do odczytania.</param>
        <param name="userCallback">Metoda wywoływana, gdy operacja odczytu asynchronicznego zostanie ukończona. Ten parametr jest opcjonalny.</param>
        <param name="stateObject">Stan odczyt asynchroniczny.</param>
        <summary>Rozpoczyna odczyt asynchroniczny.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Odczytu obiekt, który reprezentuje asynchroniczną, która jest nadal prawdopodobnie oczekujące. To <see cref="T:System.IAsyncResult" /> muszą być przekazywane do tego strumienia <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" /> metodę, aby określić liczbę bajtów zostały odczytane. Można to zrobić przez ten sam kod, który wywołuje <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> lub wywołanie zwrotne przekazane do <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bieżącą pozycję w strumieniu jest aktualizowany podczas generowania asynchroniczny odczyt lub zapis, nie, po zakończeniu operacji We/Wy.  
  
 Należy wywołać <xref:System.IO.Stream.EndRead%2A> z tym <xref:System.IAsyncResult> Aby dowiedzieć się, odczytano liczbę bajtów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę asynchroniczny odczyt poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] buffer, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function BeginWrite (buffer As Byte(), offset As Integer, numBytes As Integer, userCallback As AsyncCallback, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override IAsyncResult ^ BeginWrite(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int numBytes, AsyncCallback ^ userCallback, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor zapisu danych.</param>
        <param name="offset">Przesunięcie bajtów w <c>buforu</c> pod którym ma rozpocząć się zapis.</param>
        <param name="numBytes">Maksymalna liczba bajtów do zapisania.</param>
        <param name="userCallback">Metoda do wywołania po ukończeniu operacji zapis asynchroniczny. Ten parametr jest opcjonalny.</param>
        <param name="stateObject">Stan zapis asynchroniczny.</param>
        <summary>Rozpoczyna zapis asynchroniczny.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> Reprezentujący zapis asynchroniczny, prawdopodobnie nadal oczekuje. To <see cref="T:System.IAsyncResult" /> muszą być przekazywane do tego strumienia <see cref="M:System.IO.Stream.EndWrite(System.IAsyncResult)" /> metody, aby upewnić się, że zapis jest zakończone, odpowiednio następnie zwalnia zasoby. Można to zrobić przez ten sam kod, który wywołuje <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> lub wywołanie zwrotne przekazane do <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu jest zapisywalny, strumienia rozszerza zapisu na koniec strumienia.  
  
 Bieżącą pozycję w strumieniu jest aktualizowany podczas generowania asynchroniczny odczyt lub zapis, nie, po zakończeniu operacji We/Wy.  
  
 Należy wywołać <xref:System.IO.Stream.EndWrite%2A> z <xref:System.IAsyncResult> obiektu, którego ta metoda zwraca wartość, aby dowiedzieć się, ile bajtów zostały zapisane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Podjęto próbę asynchronicznego zapisu poza końcem pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy można odczytać pliku.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt może zostać odczytany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiekt może zostać odczytany.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak można za pomocą <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanRead%2A> właściwości, jak to sprawdzenie, czy strumień mogą być odczytywane przed wywołaniem <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> lub <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A> metody. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#11)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#11)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanSeek As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSeek { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość Boolean wskazującą czy wyszukiwanie operacje są obsługiwane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu obsługuje operacji szukania; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu obsługuje operacji szukania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość logiczną wskazującą, czy możesz zapisywać do pliku.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt może być zapisany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu mogą być zapisywane.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak można za pomocą <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanWrite%2A> właściwości, jak to sprawdzenie, czy strumień mogą być odczytywane przed wywołaniem <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write%2A> lub <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A> metody. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#13)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#13)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.IDisposable.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. <xref:System.IDisposable.Dispose%2A> wywołuje chronioną metodę <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> metody z `disposing` parametr ma wartość true. <xref:System.Object.Finalize%2A> wywołuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose%2A> z `disposing` ustawiony na wartość false.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> odwołania. Ta metoda wywołuje <xref:System.IDisposable.Dispose%2A> metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IDisposable.Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see cref="M:System.IDisposable.Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Dispose(System.Boolean)" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see cref="M:System.IDisposable.Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function EndRead (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int EndRead(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące żądania asynchronicznego.</param>
        <summary>Kończy się oczekujące żądanie odczytu asynchronicznego.</summary>
        <returns>Liczba odczytanych bajtów ze strumienia, zakresu między zero a liczba żądanych bajtów. Strumienie tylko będzie zwracać zera na koniec strumienia. W przeciwnym razie wartość będzie ich blokować momentu udostępnienia przynajmniej jednego bajtu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> obiekt z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>i wywoływania <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> jest jedynym sposobem, aby wiedzieć, ile bajtów zostały odczytane z <xref:System.IO.Stream>. <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> blokuje dopiero po ukończeniu operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndWrite (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndWrite(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Oczekujące operacje We/Wy żądania asynchronicznego na koniec.</param>
        <summary>Kończy zapis asynchroniczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> musi zostać wywołana tylko raz w każdym <xref:System.IAsyncResult> z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A> blokuje dopiero po ukończeniu operacji We/Wy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Flush">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ bufor mogą zostać użyte dla odczytu lub zapisu, ale nie obie jednocześnie <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%2A> wykonuje dwie funkcje. Najpierw wszystkie dane zapisane wcześniej w buforze jest kopiowana do pliku, a bufor jest wyczyszczone. Drugi, jeśli <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> jest `true` i danych został wcześniej skopiowany z pliku do buforu odczytu, czy bieżące położenie w pliku jest zmniejszany przez liczbę nieprzeczytana bajtów w buforze. Bufor jest następnie wyczyszczone.  
  
 Użyj <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush%28System.Boolean%29> przeciążenie metody, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Flush (flushToDisk As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Flush(bool flushToDisk);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> Aby opróżnić wszystkie bufory pliku pośredniego; w przeciwnym razie <see langword="false" />.</param>
        <summary>Czyści buforów dla tego strumienia i powoduje, że wszystkie buforowane dane są zapisywane w pliku, a także czyści wszystkie bufory pośredniego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, gdy chcesz zapewnić wszystkie buforowane dane w pliku pośredniego buforów są zapisywane na dysku.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public override IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle - once available")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście do pliku dla pliku bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje obiektu. Uzyskiwanie dostępu do tej właściwości nie jest dozwolona na <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu i zwraca <see cref="T:System.IO.IsolatedStorage.IsolatedStorageException" />.</summary>
        <value>Dojście do pliku dla pliku który bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji, zobacz <xref:System.IO.FileStream.Handle%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle%2A> właściwości.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#4)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#4)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Handle" /> Właściwość zawsze generuje ten wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> akcji zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public override bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsAsync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsAsync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość Boolean wskazującą czy <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektów otwarto asynchronicznie lub synchronicznie.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt obsługuje asynchronicznego dostępu; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczne <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> nie można utworzyć obiektów, w przeciwieństwie do <xref:System.IO.FileStream>. Jednak <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead%2A>, <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite%2A>, i <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead%2A> metody są obsługiwane w wystąpieniach synchroniczne, z niektórych spadku wydajności.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak używasz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.IsAsync%2A> właściwość do sprawdzenia, czy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> jest synchroniczne. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.FileStream" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Length As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Length { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <value>Długość <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> przedstawia liczbę bajtów w pliku. Nie ma wpływu na przydziału magazynu izolowanego.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Length%2A> właściwości.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public override void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Lock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Lock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja początkowa zakresu do zablokowania. Wartość tego parametru musi być równa lub większa niż 0 (zero).</param>
        <param name="length">Liczba bajtów do zablokowania.</param>
        <summary>Zapobiega inne procesy Odczyt lub zapis w strumieniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Blokowanie zakresu strumień pliku daje wątki blokowania wyłącznego dostępu procesu do tego zakresu strumienia pliku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
        <exception cref="T:System.ObjectDisposedException">Ten plik będzie zamknięty.</exception>
        <exception cref="T:System.IO.IOException">Proces nie może uzyskać dostępu do pliku, ponieważ inny proces zablokował część pliku.</exception>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Position { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżącą pozycję bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <value>Bieżąca pozycja <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości działa, kiedy <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.CanSeek%2A> jest właściwość `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Position%2A> właściwość do zapisania danych do pliku.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Nie można ustawić pozycji liczbą ujemną.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Byte(), offset As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do odczytania.</param>
        <param name="offset">Przesunięcie w buforze, od której ma rozpocząć się zapis.</param>
        <param name="count">Maksymalna liczba bajtów do odczytania.</param>
        <summary>Kopiuje bajtów z bieżącej buforowanej <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu do tablicy.</summary>
        <returns>Całkowita liczba bajtów odczytanych na <paramref name="buffer" />. Może to być mniejsza niż żądana liczba bajtów wybranej liczby bajtów nie są obecnie dostępne, czy zero, jeśli osiągnięto koniec strumienia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `buffer` Można instancji <xref:System.Buffer> klasy lub tablicą jednego z następujących typów: <xref:System.Byte>, <xref:System.SByte>, <xref:System.Char>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt16>, <xref:System.UInt32> , <xref:System.UInt64>, <xref:System.Single>, lub <xref:System.Double>. `offset` Parametru zapewnia Przesunięcie bajtów w buforze, od której ma rozpocząć się zapis (indeks w buforze) i `count` parametru zapewnia maksymalną liczbę bajtów, które będą odczytywane z tego strumienia. Zwrócona wartość jest rzeczywista liczba bajtów odczytanych lub zero, jeśli zostanie osiągnięty koniec strumienia. Jeśli operacja odczytu zakończy się pomyślnie, bieżącej pozycji strumienia jest zaawansowane przez liczbę bajtów do odczytu. Jeśli wystąpi wyjątek, bieżącej pozycji strumienia jest bez zmian.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Traktuje metody `buffer` parametru jako blok bajtów, niezależnie od jego typu rzeczywistego. Podobnie `offset` i `count` parametry są zawsze określony w bajtach. Aby uzyskać `buffer` parametrów innych niż tablice typu byte, oznacza to, że indeks elementu należy pomnożyć przez element rozmiar w bajtach do utworzenia poprawną wartość dla `offset` lub `count`.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> Metoda zwróci wartość zero, tylko wtedy, gdy zostanie osiągnięty koniec strumienia. We wszystkich innych przypadkach <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A> ma zawsze wartość co najmniej jednego bajtu ze strumienia przed zwróceniem. Jeśli dane są niedostępne z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu po wywołaniu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read%2A>, metoda zablokuje dopóki co najmniej jednego bajtu danych może być zwracany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadByte () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadByte();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odczytuje jednobajtowych z <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu w magazynie izolowanym.</summary>
        <returns>Wartości 8-bitową liczbę całkowitą bez znaku odczytu z pliku magazynu izolowanego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte%2A> metody można użyć do odczytywania danych z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public override Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SafeFileHandle As SafeFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Microsoft::Win32::SafeHandles::SafeFileHandle ^ SafeFileHandle { Microsoft::Win32::SafeHandles::SafeFileHandle ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku który bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje obiektu.</summary>
        <value>A <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> obiekt, który reprezentuje dojście do pliku systemu operacyjnego dla pliku który bieżącego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> hermetyzuje obiektu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle%2A> Właściwość nie jest obsługiwana i zawsze generuje <xref:System.IO.IsolatedStorage.IsolatedStorageException> wyjątku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">
          <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFileStream.SafeFileHandle" /> Właściwość zawsze generuje ten wyjątek.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> akcji zabezpieczeń: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Wymaga pełnego zaufania do bezpośredniego obiektu wywołującego. Ten element członkowski nie może być używany przez częściowo zaufany lub przejrzysty kod.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Seek (offset As Long, origin As SeekOrigin) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override long Seek(long offset, System::IO::SeekOrigin origin);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Nowe położenie <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</param>
        <param name="origin">Jeden z <see cref="T:System.IO.SeekOrigin" /> wartości.</param>
        <summary>Ustawia bieżącą pozycję <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekt z podaną wartością.</summary>
        <returns>Nowa pozycja w <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiekty obsługują pozycjonowanie powyżej długość strumienia, inne spowoduje zgłoszenie wyjątku w takim przypadku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="origin" /> Musi mieć jedną z <see cref="T:System.IO.SeekOrigin" /> wartości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SetLength (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SetLength(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Długość nowego <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</param>
        <summary>Ustawia długość to <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu do określonego <paramref name="value" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli określony `value` jest mniejsza niż bieżąca długość <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiekt strumienia został obcięty. Jeśli określony `value` jest większa niż bieżąca długość strumienia, strumień jest rozwinięta. Jeśli strumień jest rozwinięty, zawartość strumienia między stary i nowy długość jest niezdefiniowany. Aby można było używać tej metody <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu musi obsługiwać zarówno zapisu i wyszukiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="value" /> jest to liczba ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public override void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Unlock (position As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Unlock(long position, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">Pozycja początkowa zakresu do odblokowania. Wartość tego parametru musi być równa lub większa niż 0 (zero).</param>
        <param name="length">Liczba bajtów do odblokowania.</param>
        <summary>Umożliwia dostęp do całości lub części pliku, który wcześniej był zablokowany innych procesów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> lub <paramref name="length" /> jest ujemna.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Write (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Write(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Bufor do zapisu.</param>
        <param name="offset">Przesunięcie bajtów w buforze, od którego ma zostać rozpoczęta.</param>
        <param name="count">Maksymalna liczba bajtów do zapisania.</param>
        <summary>Zapisuje bajty do bloku <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> przy użyciu danych z tablicy bajtów do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `offset` Parametru zapewnia Przesunięcie bajtów w `buffer` w którym ma rozpocząć się odczyt i `count` parametru zapewnia liczba bajtów, które zostaną zapisane do tego <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Jeśli operacja zapisu zakończy się pomyślnie, bieżącego położenia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu jest zaawansowane przez liczba zapisanych bajtów. Jeśli wystąpi wyjątek, bieżącą pozycję <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiekt jest bez zmian.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Próba zapisu przekracza limit przydziału <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteByte (value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteByte(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Wartość bajtu do zapisu w pliku izolowanego magazynu.</param>
        <summary>Zapisuje pojedynczy bajt do <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje sposób <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte%2A> metody można użyć do odczytywania danych z <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu. Zakończenie kontekstu w tym przykładzie, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> omówienie.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#14)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#14)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Próba zapisu przekracza limit przydziału <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiektu.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
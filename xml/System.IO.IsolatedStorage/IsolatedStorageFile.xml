<Type Name="IsolatedStorageFile" FullName="System.IO.IsolatedStorage.IsolatedStorageFile">
  <Metadata><Meta Name="ms.openlocfilehash" Value="17810dab9be13561e8d0eb2f683bf77c59fee541" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52253628" /></Metadata><TypeSignature Language="C#" Value="public sealed class IsolatedStorageFile : System.IO.IsolatedStorage.IsolatedStorage, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit IsolatedStorageFile extends System.IO.IsolatedStorage.IsolatedStorage implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.IsolatedStorage.IsolatedStorageFile" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class IsolatedStorageFile&#xA;Inherits IsolatedStorage&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class IsolatedStorageFile sealed : System::IO::IsolatedStorage::IsolatedStorage, IDisposable" />
  <TypeSignature Language="F#" Value="type IsolatedStorageFile = class&#xA;    inherit IsolatedStorage&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.IsolatedStorage.IsolatedStorage</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obszar wydzielonej pamięci masowej zawierający pliki i katalogi.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten obiekt odnosi się do zakresu określonej wydzielonej pamięci masowej, w której pliki są reprezentowane przez <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> istnieją obiekty. Aplikacje mogą używać wydzielonej pamięci masowej, aby zapisać dane w ich własnych izolowane części systemu plików bez konieczności określania ścieżki określonej w systemie plików. Ponieważ izolowanych magazynów są ograniczone do określonego zestawów, większość kodu zarządzanego nie można uzyskać dostęp do danych kodu (wysoce zaufane zarządzanego kodu i narzędzia administracyjne mogą mieć dostęp do magazynów od innych zestawów). Niezarządzany kod mają dostęp do wszelkich izolowanych magazynów.  
  
 Aby uzyskać więcej informacji, zobacz [wydzielonej pamięci masowej](~/docs/standard/io/isolated-storage.md).  
  
 Ten typ implementuje <xref:System.IDisposable> interfejsu. Po zakończeniu przy użyciu typu bezpośrednio lub pośrednio należy usunąć z niej. Do usuwania tego typu, należy wywołać jej <xref:System.IDisposable.Dispose%2A> method in Class metoda `try` / `catch` bloku. Aby usunąć ją pośrednio, użyj konstrukcją języka pierwszej klasy takiej jak `using` (w języku C#) lub `Using` (w języku Visual Basic). Aby uzyskać więcej informacji, zobacz sekcję "Przy użyciu obiektu który implementuje interfejs IDisposable" w <xref:System.IDisposable> interfejsu.  
  
> [!IMPORTANT]
>  Wydzielona pamięć masowa nie jest dostępna dla [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplikacji. Zamiast tego należy użyć klas danych aplikacji w `Windows.Storage` uwzględnione w przestrzeni nazw [!INCLUDE[wrt](~/includes/wrt-md.md)] interfejsu API, aby przechować lokalne dane i pliki. Aby uzyskać więcej informacji, zobacz [dane aplikacji](https://go.microsoft.com/fwlink/?LinkId=229175) w Centrum deweloperów Windows.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób tworzenia plików i katalogów w izolowanym magazynie. Najpierw pobrać i umieszczane w magazynie, który jest izolowany dla konkretnego użytkownika, domeny i zestawu `isoStore` zmiennej. <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> Następnie wywoływana jest metoda do tworzenia katalogów i dwa wystąpienia <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> klasy Tworzenie plików w katalogach.  
  
 [!code-csharp[Conceptual.IsolatedStorage#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.isolatedstorage/cs/source.cs#1)]
 [!code-vb[Conceptual.IsolatedStorage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.isolatedstorage/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
  </Docs>
  <Members>
    <Member MemberName="AvailableFreeSpace">
      <MemberSignature Language="C#" Value="public override long AvailableFreeSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 AvailableFreeSpace" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.AvailableFreeSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AvailableFreeSpace As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long AvailableFreeSpace { long get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableFreeSpace : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.AvailableFreeSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje ilość wolnego miejsca dostępnego dla wydzielonej pamięci masowej.</summary>
        <value>Dostępne wolne miejsce dla wydzielonej pamięci masowej w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="isolatedStorageFile.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka sklepu poprzednio otwarty za pomocą <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type,System.Type)" />, <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />, lub <see cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Close%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Kopiuje istniejący plik do nowego pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string -&gt; unit" Usage="isolatedStorageFile.CopyFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku do skopiowania.</param>
        <param name="destinationFileName">Nazwa pliku docelowego. Nie może to być katalog lub istniejący plik.</param>
        <summary>Kopiuje istniejący plik do nowego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` i `destinationFileName` należy określić różne nazwy plików. Użyj <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> przeciążenia metody, aby zastąpić istniejący plik.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceFileName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.  
  
—lub— 
 <paramref name="destinationFileName" /> istnieje.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="CopyFile">
      <MemberSignature Language="C#" Value="public void CopyFile (string sourceFileName, string destinationFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyFile(string sourceFileName, string destinationFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyFile (sourceFileName As String, destinationFileName As String, overwrite As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyFile(System::String ^ sourceFileName, System::String ^ destinationFileName, bool overwrite);" />
      <MemberSignature Language="F#" Value="member this.CopyFile : string * string * bool -&gt; unit" Usage="isolatedStorageFile.CopyFile (sourceFileName, destinationFileName, overwrite)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku do skopiowania.</param>
        <param name="destinationFileName">Nazwa pliku docelowego. To nie może być katalogiem.</param>
        <param name="overwrite"><see langword="true" /> Jeśli plik docelowy może zostać zastąpiony; w przeciwnym razie <see langword="false" />.</param>
        <summary>Kopiuje istniejący plik do nowego pliku, a opcjonalnie zastępuje istniejący plik.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` i `destinationFileName` może mieć taką samą nazwę, jeśli `overwrite` jest `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceFileName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.  
  
—lub— 
Wystąpił błąd we/wy.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public void CreateDirectory (string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateDirectory(string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateDirectory (dir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateDirectory(System::String ^ dir);" />
      <MemberSignature Language="F#" Value="member this.CreateDirectory : string -&gt; unit" Usage="isolatedStorageFile.CreateDirectory dir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dir">Ścieżka względna katalogu do utworzenia w zakresie wydzielonej pamięci masowej.</param>
        <summary>Tworzy katalog, w zakresie wydzielonej pamięci masowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utworzono katalog początkowo nie zawiera plików. Jeśli katalog już istnieje, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> metoda zwraca bez tworzenia nowego katalogu. [Porady: tworzenie plików i katalogów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-create-files-and-directories-in-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> — metoda  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#7)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#7)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Bieżący kod nie ma wystarczających uprawnień do tworzenia katalogu wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentNullException">Ścieżka katalogu jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do zakresu wydzielonej pamięci masowej.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="CreateFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateFile (path As String) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ CreateFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.CreateFile : string -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="isolatedStorageFile.CreateFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Względna ścieżka pliku do utworzenia.</param>
        <summary>Tworzy plik w izolowanym magazynie.</summary>
        <returns>Nowy plik wydzielonej pamięci masowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest źle sformułowany.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="CurrentSize">
      <MemberSignature Language="C#" Value="public override ulong CurrentSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 CurrentSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CurrentSize As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::UInt64 CurrentSize { System::UInt64 get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSize : uint64" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("IsolatedStorageFile.CurrentSize has been deprecated because it is not CLS Compliant.  To get the current size use IsolatedStorageFile.UsedSize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący rozmiar magazynu izolowanego.</summary>
        <value>Całkowita liczba bajtów magazynu, która jest obecnie w użyciu w zakresie wydzielonej pamięci masowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przedstawia całkowite użycie wszystkich plików i katalogów w wydzielonej pamięci masowej zakres.  
  
 Bieżący rozmiar nie można dokładnie określić magazynów, które uczestniczą w profilu użytkownika mobilnego. Ponieważ profilów mobilnych są często buforowane na wielu komputerach klienckich, a później zsynchronizowana z serwerem, nie mogą być wymuszane przydziały dla tych magazynów, a bieżący rozmiar nie jest zgłaszany.  
  
 [Porady: przewidywanie warunków limit miejsca w wydzielonej pamięci masowej](~/docs/standard/io/how-to-anticipate-out-of-space-conditions-with-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.CurrentSize%2A> właściwości. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#5)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#5)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest niedostępny. Bieżącego magazynu ma zakres mobilnego lub nie jest otwarty.</exception>
        <exception cref="T:System.ObjectDisposedException">Bieżący rozmiar obiektu jest niezdefiniowane.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteDirectory">
      <MemberSignature Language="C#" Value="public void DeleteDirectory (string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteDirectory(string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteDirectory(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteDirectory (dir As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteDirectory(System::String ^ dir);" />
      <MemberSignature Language="F#" Value="member this.DeleteDirectory : string -&gt; unit" Usage="isolatedStorageFile.DeleteDirectory dir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dir">Ścieżka względna katalogu do usunięcia w zakresie wydzielonej pamięci masowej.</param>
        <summary>Usuwa katalog w zakresie wydzielonej pamięci masowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przed usunięciem katalogu musi być pusty. Usunięto katalog nie mogą być odzyskane po usunięciu.  
  
 [Porady: usuwanie plików i katalogów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-delete-files-and-directories-in-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteDirectory%2A> metody.  
  
   
  
## Examples  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#8)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#8)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można usunąć katalogu.</exception>
        <exception cref="T:System.ArgumentNullException">Ścieżka do katalogu zostało <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do zakresu wydzielonej pamięci masowej.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteFile">
      <MemberSignature Language="C#" Value="public void DeleteFile (string file);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteFile(string file) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteFile (file As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteFile(System::String ^ file);" />
      <MemberSignature Language="F#" Value="member this.DeleteFile : string -&gt; unit" Usage="isolatedStorageFile.DeleteFile file" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="file">Ścieżka względna plik do usunięcia w zakresie wydzielonej pamięci masowej.</param>
        <summary>Usuwa plik w zakresie wydzielonej pamięci masowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można odzyskać usunięty plik, po usunięciu.  
  
 [Porady: usuwanie plików i katalogów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-delete-files-and-directories-in-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile%2A> metodę, aby usunąć wiele plików w wydzielonej pamięci masowej.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#6)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#6)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Plik docelowy jest otwarty lub ścieżka jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">Ścieżka pliku jest <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">Aby uzyskać dostęp do plików w zakresie wydzielonej pamięci masowej.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="DirectoryExists">
      <MemberSignature Language="C#" Value="public bool DirectoryExists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DirectoryExists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.DirectoryExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DirectoryExists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DirectoryExists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.DirectoryExists : string -&gt; bool" Usage="isolatedStorageFile.DirectoryExists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do testowania.</param>
        <summary>Określa, czy określona ścieżka odwołuje się do istniejącego katalogu w izolowanym magazynie.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="path" /> odwołuje się do istniejącego katalogu w izolowanym magazynie, a nie <see langword="null" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="isolatedStorageFile.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `Dispose` po zakończeniu przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile>. `Dispose` Pozostawia metoda <xref:System.IO.IsolatedStorage.IsolatedStorageFile> w stanie uniemożliwiającym jego używanie. Po wywołaniu `Dispose`, trzeba zwolnić wszystkie odwołania do <xref:System.IO.IsolatedStorage.IsolatedStorageFile> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.IO.IsolatedStorage.IsolatedStorageFile> zajmowaną przez wystąpienie.  
  
> [!NOTE]
>  Zawsze wywoływać metodę Dispose, przed zwolnieniem swoje ostatnie odwołanie do <xref:System.IO.IsolatedStorage.IsolatedStorageFile>. W przeciwnym razie zasoby <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> jest przy użyciu nie zostanie zwolniona, aż do wywołania kolekcji wyrzucania elementów <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream> obiektu <xref:System.Object.Finalize%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera plik wydzielonej pamięci masowej, używa go zapisać informacji do strumienia, zamyka plik i następnie używa <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Dispose%2A> metodę, aby zwolnić wszystkie zasoby.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="FileExists">
      <MemberSignature Language="C#" Value="public bool FileExists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool FileExists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.FileExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileExists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool FileExists(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.FileExists : string -&gt; bool" Usage="isolatedStorageFile.FileExists path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka i nazwa pliku do testowania.</param>
        <summary>Określa, czy określona ścieżka odwołuje się do istniejącego pliku w izolowanym magazynie.</summary>
        <returns><see langword="true" /> Jeśli <paramref name="path" /> odwołuje się do istniejącego pliku w izolowanym magazynie, a nie <see langword="null" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~IsolatedStorageFile ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!IsolatedStorageFile ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="isolatedStorageFile.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetCreationTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCreationTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetCreationTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetCreationTime : string -&gt; DateTimeOffset" Usage="isolatedStorageFile.GetCreationTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku lub katalogu, do których chcesz uzyskać informacje o datę i godzinę utworzenia.</param>
        <summary>Zwraca datę i godzinę utworzenia określonego pliku lub katalogu.</summary>
        <returns>Data i godzina utworzenia dla określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik opisanego przez ścieżki nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetDirectoryNames">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wylicza katalogi w katalogu głównym w izolowanym magazynie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetDirectoryNames">
      <MemberSignature Language="C#" Value="public string[] GetDirectoryNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDirectoryNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDirectoryNames();" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryNames : unit -&gt; string[]" Usage="isolatedStorageFile.GetDirectoryNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wylicza katalogi w katalogu głównym w izolowanym magazynie.</summary>
        <returns>Tablica ścieżek względnych katalogów w katalogu głównym w izolowanym magazynie. Tablicę o zerowej długości Określa, że nie istnieją żadne katalogi w katalogu głównym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%28System.String%29?displayProperty=nameWithType> metody za pomocą "*" określona dla wzorca wyszukiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie ma uprawnień do wyliczania katalogów.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie znaleziono co najmniej jeden katalog.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryNames">
      <MemberSignature Language="C#" Value="public string[] GetDirectoryNames (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetDirectoryNames(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDirectoryNames (searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetDirectoryNames(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetDirectoryNames : string -&gt; string[]" Usage="isolatedStorageFile.GetDirectoryNames searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Wzorzec wyszukiwania. Zarówno pojedynczych znaków ("?") i wielu znaków ("*") symbole wieloznaczne są obsługiwane.</param>
        <summary>Wylicza katalogi w zakresie wydzielonej pamięci masowej, które pasują do podanego wzorca.</summary>
        <returns>Tablica ścieżek względnych katalogów w izolowanym magazynie zakres pasujący <paramref name="searchPattern" />. Tablicę o zerowej długości Określa, że nie istnieją żadne katalogi, które odpowiadają.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Symbole wieloznaczne musi być ostatnim elemencie `searchPattern`. Na przykład "directory1 / * itp\*" jest prawidłowy ciąg wyszukiwania, ale "\*itp \* /katalog" nie jest.  
  
 `searchPattern` "Project\Data *" umożliwi się wszystkie podkatalogi projektu rozpoczynający się od danych w zakresie wydzielonej pamięci masowej. `searchPattern` "\*" Spowoduje zwrócenie wszystkich katalogów znajdujących się w folderze głównym. Aby uzyskać pełny opis kryteriów ciągu wyszukiwania, zobacz <xref:System.IO.Directory> klasy.  
  
 Aby uzyskać informacje na temat pobierania nazw plików, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> metody.  
  
 [Porady: znajdowanie istniejących plików i katalogów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-find-existing-files-and-directories-in-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn jest zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Wywołujący nie ma uprawnień do wyliczania katalogów rozpoznana na podstawie <paramref name="searchPattern" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog lub katalogi określone przez <paramref name="searchPattern" /> nie zostaną znalezione.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public static System.Collections.IEnumerator GetEnumerator (System.IO.IsolatedStorage.IsolatedStorageScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IEnumerator GetEnumerator(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnumerator (scope As IsolatedStorageScope) As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IEnumerator ^ GetEnumerator(System::IO::IsolatedStorage::IsolatedStorageScope scope);" />
      <MemberSignature Language="F#" Value="static member GetEnumerator : System.IO.IsolatedStorage.IsolatedStorageScope -&gt; System.Collections.IEnumerator" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator scope" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
      </Parameters>
      <Docs>
        <param name="scope">Reprezentuje <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" /> dla której ma zostać zwrócone izolowanych magazynów. <see langword="User" /> i <see langword="User|Roaming" /> są jedynymi <see langword="IsolatedStorageScope" /> obsługiwane kombinacje.</param>
        <summary>Pobiera moduł wyliczający <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> są przechowywane w zakresie wydzielonej pamięci masowej.</summary>
        <returns>Moduł wyliczający dla <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile" /> są przechowywane w zakresie określonym wydzielonej pamięci masowej.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Porady: Wyliczanie magazynów dla wydzielonej pamięci masowej](~/docs/standard/io/how-to-enumerate-stores-for-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator%2A> metody.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFileNames">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wylicza nazwy plików w folderze głównym w izolowanym magazynie</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFileNames">
      <MemberSignature Language="C#" Value="public string[] GetFileNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetFileNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetFileNames();" />
      <MemberSignature Language="F#" Value="member this.GetFileNames : unit -&gt; string[]" Usage="isolatedStorageFile.GetFileNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wylicza nazwy plików w folderze głównym w izolowanym magazynie.</summary>
        <returns>Tablica ścieżek względnych plików w folderze głównym w izolowanym magazynie.  Tablicę o zerowej długości Określa, że nie istnieją żadne pliki w folderze głównym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%28System.String%29?displayProperty=nameWithType> metody za pomocą "*" określona dla wzorca wyszukiwania.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Nie można ustalić ścieżki plików z katalogu głównego w izolowanym magazynie.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetFileNames">
      <MemberSignature Language="C#" Value="public string[] GetFileNames (string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] GetFileNames(string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFileNames (searchPattern As String) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ GetFileNames(System::String ^ searchPattern);" />
      <MemberSignature Language="F#" Value="member this.GetFileNames : string -&gt; string[]" Usage="isolatedStorageFile.GetFileNames searchPattern" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="searchPattern">Wzorzec wyszukiwania. Zarówno pojedynczych znaków ("?") i wielu znaków ("*") symbole wieloznaczne są obsługiwane.</param>
        <summary>Pobiera nazwy plików które pasują do wzorca wyszukiwania.</summary>
        <returns>Tablica ścieżek względnych plików w wydzielonej pamięci masowej zakres pasujący <paramref name="searchPattern" />. Tablicę o zerowej długości Określa, że nie istnieją żadne pliki, które odpowiadają.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern` "Project\Data * .txt" zapewni, że wszystkie pliki ".txt", począwszy od danych w katalogu projektu w zakresie wydzielonej pamięci masowej. Aby uzyskać pełny opis ciągów wzorzec wyszukiwania, zobacz <xref:System.IO.Directory?displayProperty=nameWithType>.  
  
 Aby uzyskać informacje o sposobach znajdowania nazwy katalogów, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames%2A> metody.  
  
 [Porady: znajdowanie istniejących plików i katalogów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-find-existing-files-and-directories-in-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="searchPattern" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Ścieżka pliku określonego przez <paramref name="searchPattern" /> nie można odnaleźć.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastAccessTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastAccessTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetLastAccessTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetLastAccessTime : string -&gt; DateTimeOffset" Usage="isolatedStorageFile.GetLastAccessTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku lub katalogu, do których chcesz uzyskać ostatniego daty i godziny informacji dotyczących dostępu.</param>
        <summary>Zwraca datę i godzinę określonego pliku lub nastąpił ostatni dostęp do katalogu.</summary>
        <returns>Data i godzina ostatniego udostępnienia określonego pliku lub katalogu. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik opisanego przez `path` nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public DateTimeOffset GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.DateTimeOffset GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastWriteTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastWriteTime (path As String) As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DateTimeOffset GetLastWriteTime(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.GetLastWriteTime : string -&gt; DateTimeOffset" Usage="isolatedStorageFile.GetLastWriteTime path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do pliku lub katalogu, do których chcesz uzyskać ostatniego zapisu daty i godziny informacje.</param>
        <summary>Zwraca datę i godzinę określonego pliku lub katalogu ostatniej zostały zapisane.</summary>
        <returns>Data i godzina, który określony plik lub katalog został ostatnio zapisany. Ta wartość jest wyrażone według czasu lokalnego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli plik opisanego przez `path` nie istnieje, ta metoda zwraca 12:00, a 1 stycznia, 1601 r. N.E. (C.E.) Uniwersalny czas koordynowany (UTC), dostosowane na czas lokalny.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForApplication">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForApplication () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForApplication();" />
      <MemberSignature Language="F#" Value="static member GetMachineStoreForApplication : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zakres maszyny wydzielonej pamięci masowej odpowiadający kod wywołujący tożsamość aplikacji.</summary>
        <returns>Obiekt odpowiadający zakresu wydzielonej pamięci masowej, na podstawie tożsamości aplikacji kod wywołujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie zestawy skojarzone z aplikacją używać tego samego magazynu izolowanego, przy użyciu tej metody.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#18)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#18)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można określić tożsamość aplikacji obiektu wywołującego.  
  
—lub— 
Nie można określić zestaw udzielone uprawnienia dla domeny aplikacji.  
  
—lub— 
Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForAssembly">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForAssembly () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForAssembly();" />
      <MemberSignature Language="F#" Value="static member GetMachineStoreForAssembly : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zakres maszyny wydzielonej pamięci masowej odpowiadający kod wywołujący tożsamości zestawu.</summary>
        <returns>Obiekt odpowiadający zakresu wydzielonej pamięci masowej, na podstawie tożsamości zestawu kodu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego samego zestawu w różnych aplikacjach zawsze używa tego samego magazynu izolowanego, przy użyciu tej metody.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#19)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#19)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#19)]  
  
> [!NOTE]
>  Różne zestawy uruchomionych w tej samej domenie aplikacji zawsze mają różne izolowanych magazynów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetMachineStoreForDomain">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineStoreForDomain () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetMachineStoreForDomain();" />
      <MemberSignature Language="F#" Value="static member GetMachineStoreForDomain : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera zakres maszyny wydzielonej pamięci masowej odpowiadający tożsamość domeny aplikacji i tożsamość zestawu.</summary>
        <returns>Obiekt odpowiadający <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />zgodnie z kombinacją tożsamość domeny aplikacji i tożsamość zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten sam kod zestawu będzie używać różnych magazynów izolowanych, gdy są używane w kontekście innej aplikacji.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#20)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#20)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#20)]  
  
 Różne zestawy uruchomionych w tej samej domenie aplikacji zawsze mają różne izolowanych magazynów.  
  
> [!NOTE]
>  <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału, jeśli domena aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można otworzyć magazynu.  
  
—lub— 
Zestaw określony ma niewystarczające uprawnienia do tworzenia magazynów izolowanych.  
  
—lub— 
Nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetPermission">
      <MemberSignature Language="C#" Value="protected override System.Security.Permissions.IsolatedStoragePermission GetPermission (System.Security.PermissionSet ps);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Security.Permissions.IsolatedStoragePermission GetPermission(class System.Security.PermissionSet ps) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetPermission(System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetPermission (ps As PermissionSet) As IsolatedStoragePermission" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Security::Permissions::IsolatedStoragePermission ^ GetPermission(System::Security::PermissionSet ^ ps);" />
      <MemberSignature Language="F#" Value="override this.GetPermission : System.Security.PermissionSet -&gt; System.Security.Permissions.IsolatedStoragePermission" Usage="isolatedStorageFile.GetPermission ps" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Permissions.IsolatedStoragePermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ps" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="ps">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetStore">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadający danej aplikacji domeny i zestawu dowodów obiektów i zakres wydzielonej pamięci masowej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, object applicationIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, object applicationIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, applicationIdentity As Object) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Object ^ applicationIdentity);" />
      <MemberSignature Language="F#" Value="static member GetStore : System.IO.IsolatedStorage.IsolatedStorageScope * obj -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetStore (scope, applicationIdentity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="applicationIdentity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowe połączenie wartości wyliczenia.</param>
        <param name="applicationIdentity">Obiekt, który zawiera dowodu tożsamości aplikacji.</param>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadający tożsamości danej aplikacji.</summary>
        <returns>Obiekt, który reprezentuje parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli `scope` parametr jest <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Application?displayProperty=nameWithType> i domeny aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metoda zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="applicationIdentity" /> Tożsamości nie został przekazany w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="scope" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość wyliczenia <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, ale nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> dla bieżącej domeny aplikacji zwracany <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, ale nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, ale nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, Type applicationEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Type applicationEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, applicationEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, Type ^ applicationEvidenceType);" />
      <MemberSignature Language="F#" Value="static member GetStore : System.IO.IsolatedStorage.IsolatedStorageScope * Type -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetStore (scope, applicationEvidenceType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="applicationEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowe połączenie wartości wyliczenia.</param>
        <param name="applicationEvidenceType">Obiekt, który zawiera tożsamości aplikacji.</param>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadający zakresu izolacji i obiektu tożsamości aplikacji.</summary>
        <returns>Obiekt, który reprezentuje parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli `scope` parametr jest <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Application> i domeny aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metoda zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="applicationEvidence" /> Tożsamości nie został przekazany w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="scope" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość wyliczenia <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, ale nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> dla bieżącej domeny aplikacji zwracany <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, ale nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, ale nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainIdentity As Object, assemblyIdentity As Object) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Object ^ domainIdentity, System::Object ^ assemblyIdentity);" />
      <MemberSignature Language="F#" Value="static member GetStore : System.IO.IsolatedStorage.IsolatedStorageScope * obj * obj -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetStore (scope, domainIdentity, assemblyIdentity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainIdentity" Type="System.Object" />
        <Parameter Name="assemblyIdentity" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowe połączenie wartości wyliczenia.</param>
        <param name="domainIdentity">Obiekt, który zawiera dowód tożsamość domeny aplikacji.</param>
        <param name="assemblyIdentity">Obiekt, który zawiera dowodów dla tożsamości zestawu kodu.</param>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadającą obiektom dowód domeny i zestawu danej aplikacji.</summary>
        <returns>Obiekt, który reprezentuje parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta forma `GetStore` jest najbardziej użyteczne dla administracyjnej kod, który można otworzyć magazynu, tak jakby innego zestawu. Magazyn zostanie otwarty dowody dostarczone, a nie zawierający obecnie wykonywany zestaw.  
  
> [!NOTE]
>  Jeśli `scope` parametr jest <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> i domeny aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metoda zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentNullException">Ani <paramref name="domainIdentity" /> ani <paramref name="assemblyIdentity" /> został przekazany w. Sprawdza, czy poprawny konstruktora jest używany.  
  
—lub— 
Albo <paramref name="domainIdentity" /> lub <paramref name="assemblyIdentity" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="scope" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość wyliczenia <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, ale nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> dla bieżącej domeny aplikacji zwracany <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, ale nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, ale nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, Type domainEvidenceType, Type assemblyEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Type domainEvidenceType, class System.Type assemblyEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainEvidenceType As Type, assemblyEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, Type ^ domainEvidenceType, Type ^ assemblyEvidenceType);" />
      <MemberSignature Language="F#" Value="static member GetStore : System.IO.IsolatedStorage.IsolatedStorageScope * Type * Type -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetStore (scope, domainEvidenceType, assemblyEvidenceType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainEvidenceType" Type="System.Type" />
        <Parameter Name="assemblyEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowe połączenie wartości wyliczenia.</param>
        <param name="domainEvidenceType">Typ <see cref="T:System.Security.Policy.Evidence" /> można wybierz jedną z listy <see cref="T:System.Security.Policy.Evidence" /> obecnych w domenie aplikacji wywołującej. <see langword="null" /> Umożliwia <see cref="T:System.IO.IsolatedStorage.IsolatedStorage" /> obiektu wybierz dowodów.</param>
        <param name="assemblyEvidenceType">Typ <see cref="T:System.Security.Policy.Evidence" /> można wybierz jedną z listy <see cref="T:System.Security.Policy.Evidence" /> obecnych w domenie aplikacji wywołującej. <see langword="null" /> Umożliwia <see cref="T:System.IO.IsolatedStorage.IsolatedStorage" /> obiektu wybierz dowodów.</param>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadający zakresu wydzielonej pamięci masowej, podane typy dowód domeny i zestaw aplikacji.</summary>
        <returns>Obiekt, który reprezentuje parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to przeciążenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> najprawdopodobniej do wywoływania z kodu aplikacji.  
  
 To przeciążenie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> otwiera dla typów dowody, które są przekazywane w izolowanym magazynie.  
  
> [!NOTE]
>  Jeśli `scope` parametr jest <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> i domeny aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metoda zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#15)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#15)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="scope" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Podano typ dowód brakuje listy dowód zestawu.  
  
—lub— 
Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość wyliczenia <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, ale nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> dla bieżącej domeny aplikacji zwracany <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, ale nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
 <paramref name="scope" /> zawiera <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, ale nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetStore">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetStore (System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Security.Policy.Evidence domainEvidence, Type domainEvidenceType, System.Security.Policy.Evidence assemblyEvidence, Type assemblyEvidenceType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetStore(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope, class System.Security.Policy.Evidence domainEvidence, class System.Type domainEvidenceType, class System.Security.Policy.Evidence assemblyEvidence, class System.Type assemblyEvidenceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Security.Policy.Evidence,System.Type,System.Security.Policy.Evidence,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetStore (scope As IsolatedStorageScope, domainEvidence As Evidence, domainEvidenceType As Type, assemblyEvidence As Evidence, assemblyEvidenceType As Type) As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetStore(System::IO::IsolatedStorage::IsolatedStorageScope scope, System::Security::Policy::Evidence ^ domainEvidence, Type ^ domainEvidenceType, System::Security::Policy::Evidence ^ assemblyEvidence, Type ^ assemblyEvidenceType);" />
      <MemberSignature Language="F#" Value="static member GetStore : System.IO.IsolatedStorage.IsolatedStorageScope * System.Security.Policy.Evidence * Type * System.Security.Policy.Evidence * Type -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetStore (scope, domainEvidence, domainEvidenceType, assemblyEvidence, assemblyEvidenceType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
        <Parameter Name="domainEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="domainEvidenceType" Type="System.Type" />
        <Parameter Name="assemblyEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="assemblyEvidenceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowe połączenie wartości wyliczenia.</param>
        <param name="domainEvidence">Obiekt, który zawiera tożsamość domeny aplikacji.</param>
        <param name="domainEvidenceType">Typ tożsamości z dowodem domeny aplikacji.</param>
        <param name="assemblyEvidence">Obiekt, który zawiera kod tożsamości zestawu.</param>
        <param name="assemblyEvidenceType">Typ tożsamości do wyboru dowód zestawu kodu aplikacji.</param>
        <summary>Uzyskuje wydzielonej pamięci masowej odpowiadający domeny danej aplikacji i obiekty dowód zestawu i typów.</summary>
        <returns>Obiekt, który reprezentuje parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Jeśli `scope` parametr jest <xref:System.IO.IsolatedStorage.IsolatedStorageScope.Domain> i domeny aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>, <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore%2A> metoda zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera magazynu na podstawie dowodów wydawcy.  
  
 [!code-csharp[System.IO.IsolatedStorage.GetStore#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.GetStore/CS/source.cs#1)]
 [!code-vb[System.IO.IsolatedStorage.GetStore#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.GetStore/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="domainEvidence" /> Lub <paramref name="assemblyEvidence" /> tożsamości nie został przekazany w.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="scope" /> Jest nieprawidłowy.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość wyliczenia <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Application" />, ale nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> dla bieżącej domeny aplikacji zwracany <see langword="null" />.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Domain" />, ale nie można określić uprawnienia dla domeny aplikacji.  
  
—lub— 
 <paramref name="scope" /> zawiera wartość <see cref="F:System.IO.IsolatedStorage.IsolatedStorageScope.Assembly" />, ale nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
        <altmember cref="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForApplication">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForApplication () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForApplication();" />
      <MemberSignature Language="F#" Value="static member GetUserStoreForApplication : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje zakresu użytkownika wydzielonej pamięci masowej odpowiadający kod wywołujący tożsamość aplikacji.</summary>
        <returns>Obiekt odpowiadający zakresu wydzielonej pamięci masowej, na podstawie tożsamości zestawu kodu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie zestawy skojarzone z aplikacją używać tego samego magazynu izolowanego, przy użyciu tej metody. Ta metoda może służyć tylko wtedy, gdy tożsamość aplikacji można określić — na przykład, gdy aplikacja zostanie opublikowana przy użyciu wdrażania ClickOnce lub jest aplikacją opartych na technologii Silverlight. Jeśli spróbujesz użyć tej metody poza ClickOnce lub aplikacji opartych na technologii Silverlight, zostanie wyświetlony <xref:System.IO.IsolatedStorage.IsolatedStorageException> wyjątku, ponieważ nie można określić tożsamość aplikacji obiektu wywołującego.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#21)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#21)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#21)]  
  
 W tym kodzie `applicationIdentity` parametr `GetStore(IsolatedStorageScope scope, Object applicationIdentity)` jest `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
Nie można ustalić tożsamość aplikacji obiektu wywołującego, ponieważ <see cref="P:System.AppDomain.ActivationContext" /> właściwości zwróconej <see langword="null" />.  
  
—lub— 
Nie można określić uprawnienia dla domeny aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForAssembly">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForAssembly () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForAssembly();" />
      <MemberSignature Language="F#" Value="static member GetUserStoreForAssembly : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje zakresu użytkownika wydzielonej pamięci masowej odpowiadający kod wywołujący tożsamości zestawu.</summary>
        <returns>Obiekt odpowiadający zakresu wydzielonej pamięci masowej, na podstawie tożsamości zestawu kodu wywołującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego samego zestawu w różnych aplikacjach zawsze używa tego samego magazynu izolowanego, przy użyciu tej metody.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#22)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#22)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#22)]  
  
> [!NOTE]
>  Różne zestawy uruchomionych w tej samej domenie aplikacji zawsze mają różne izolowanych magazynów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
Nie można określić uprawnienia dla zestawu wywołującego.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AssemblyIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForDomain">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForDomain () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForDomain();" />
      <MemberSignature Language="F#" Value="static member GetUserStoreForDomain : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje zakresu użytkownika wydzielonej pamięci masowej odpowiadający tożsamość domeny aplikacji i tożsamość zestawu.</summary>
        <returns>Obiekt odpowiadający <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" />zgodnie z kombinacją tożsamość domeny aplikacji i tożsamość zestawu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten sam kod zestawu będzie używać różnych magazynów izolowanych, gdy są używane w kontekście innej aplikacji.  
  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> jest funkcjonalnie równoważny z następującym kodem:  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/remarks.cpp#23)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/remarks.cs#23)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/remarks.vb#23)]  
  
 Różne zestawy uruchomionych w tej samej domenie aplikacji zawsze mają różne izolowanych magazynów.  
  
> [!NOTE]
>  <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> zwróci <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt nie ma limitu przydziału, jeśli domena aplikacji, w którym jest zainstalowany zestaw nie ma <xref:System.Security.Permissions.IsolatedStorageFilePermission>. Później podejmuje próbę utworzenia <xref:System.IO.IsolatedStorage.IsolatedStorageFile> przy użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFile> obiekt, który nie ma limit przydziału zakończy się niepowodzeniem z <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain%2A> metody. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#10)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#10)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Nie przyznano uprawnienia wystarczające wydzielonej pamięci masowej.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można otworzyć magazynu.  
  
—lub— 
Zestaw określony ma niewystarczające uprawnienia do tworzenia magazynów izolowanych.  
  
—lub— 
Nie można zainicjować z lokalizacją wydzielonej pamięci masowej.  
  
—lub— 
Nie można określić uprawnienia dla domeny aplikacji.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.DomainIsolationByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="GetUserStoreForSite">
      <MemberSignature Language="C#" Value="public static System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForSite" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUserStoreForSite () As IsolatedStorageFile" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::IsolatedStorage::IsolatedStorageFile ^ GetUserStoreForSite();" />
      <MemberSignature Language="F#" Value="static member GetUserStoreForSite : unit -&gt; System.IO.IsolatedStorage.IsolatedStorageFile" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForSite " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFile</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uzyskuje zakresu użytkownika izolowanym magazynie do użytku przez aplikacje w domenie hosta wirtualnego.</summary>
        <returns>Plik wydzielonej pamięci masowej, który odnosi się do zakresu wydzielonej pamięci masowej, na podstawie tożsamości aplikacji kod wywołujący.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko w aplikacjach opartych na technologii Silverlight.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="IncreaseQuotaTo">
      <MemberSignature Language="C#" Value="public override bool IncreaseQuotaTo (long newQuotaSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IncreaseQuotaTo(int64 newQuotaSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IncreaseQuotaTo (newQuotaSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IncreaseQuotaTo(long newQuotaSize);" />
      <MemberSignature Language="F#" Value="override this.IncreaseQuotaTo : int64 -&gt; bool" Usage="isolatedStorageFile.IncreaseQuotaTo newQuotaSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newQuotaSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="newQuotaSize">Żądany rozmiar w bajtach.</param>
        <summary>Umożliwia aplikacji jawne żądanie większy rozmiar przydziału w bajtach.</summary>
        <returns><see langword="true" /> Jeśli nowy limit przydziału zostanie zaakceptowana; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> Metody umożliwia aplikacji jawne żądanie większy rozmiar przydziału w bajtach. Nowy rozmiar przydziału nie może być mniejszy niż bieżący rozmiar przydziału, ponieważ zwiększa tylko przydziału są dozwolone.  
  
 Zawsze, gdy <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> metodą jest wywołany, izolowany magazyn wywołania <xref:System.AppDomainManager.CheckSecuritySettings%2A> metody.  
  
 Możesz zaimplementować decyzji dotyczących zasad, tworząc niestandardowe <xref:System.AppDomainManager> obiekt, który zastępuje <xref:System.AppDomainManager.CheckSecuritySettings%2A> metoda tak, aby obiekt można wykonywać na podstawie decyzji dotyczących zasad <xref:System.IO.IsolatedStorage.IsolatedStorageSecurityState> obiektu.  
  
 W przypadku bez niestandardowych <xref:System.AppDomainManager> obiektu, żądanie zwiększenia limitu przydziału odmowa, ponieważ domyślna implementacja dla <xref:System.AppDomainManager.CheckSecuritySettings%2A> zwraca `false`.  
  
 Aktualnie żaden z hostów w programie .NET Framework zapewnia to dostosowanie, więc <xref:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo%2A> zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="newQuotaSize" /> jest mniejsza niż bieżący rozmiar przydziału.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newQuotaSize" /> jest mniejsza od zera, lub mniejszy niż bieżący rozmiar przydziału.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.NotSupportedException">Bieżący zakres nie jest dla użytkownika aplikacji.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public static bool IsEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy włączono wydzielonej pamięci masowej.</summary>
        <value><see langword="true" /> we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wydzielonej pamięci masowej dla pełnej aplikacji .NET Framework jest zawsze włączona.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override ulong MaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int64 MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MaximumSize As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::UInt64 MaximumSize { System::UInt64 get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : uint64" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("IsolatedStorageFile.MaximumSize has been deprecated because it is not CLS Compliant.  To get the maximum size use IsolatedStorageFile.Quota")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą maksymalną ilość wolnego miejsca dla wydzielonej pamięci masowej w granicach określonych przez limit przydziału.</summary>
        <value>Limit miejsca w wydzielonej pamięci masowej w bajtach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba dostępnych bajtów jest ograniczony przez limit przydziału wydzielonej pamięci masowej, ustawionych przez administratora. Limit przydziału jest skonfigurowany w zasadach zabezpieczeń na podstawie danych, więc ten sam kod może odbierać inny limit przydziału, jeśli zostanie uruchomione z dowodem różne. Na przykład aplikacja jest uruchamiana lokalnie i z udziału w sieci intranet będzie prawdopodobnie otrzymają różne przydziały.  
  
 [Porady: przewidywanie warunków limit miejsca w wydzielonej pamięci masowej](~/docs/standard/io/how-to-anticipate-out-of-space-conditions-with-isolated-storage.md) przykład demonstruje użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize%2A> właściwości. Aby uzyskać pełny kontekst tego przykładu, zobacz <xref:System.IO.IsolatedStorage.IsolatedStorageFile> Przegląd.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#5)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#5)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest niedostępny. <see cref="P:System.IO.IsolatedStorage.IsolatedStorageFile.MaximumSize" /> Nie można ustalić bez dowód od tworzenia zestawu. Nie można określić dowód, podczas tworzenia obiektu.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Wystąpił błąd wydzielonej pamięci masowej.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="MoveDirectory">
      <MemberSignature Language="C#" Value="public void MoveDirectory (string sourceDirectoryName, string destinationDirectoryName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveDirectory(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveDirectory (sourceDirectoryName As String, destinationDirectoryName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveDirectory(System::String ^ sourceDirectoryName, System::String ^ destinationDirectoryName);" />
      <MemberSignature Language="F#" Value="member this.MoveDirectory : string * string -&gt; unit" Usage="isolatedStorageFile.MoveDirectory (sourceDirectoryName, destinationDirectoryName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirectoryName" Type="System.String" />
        <Parameter Name="destinationDirectoryName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirectoryName">Nazwa katalogu, aby przenieść.</param>
        <param name="destinationDirectoryName">Ścieżka do nowej lokalizacji dla <paramref name="sourceDirectoryName" />. Nie może to być ścieżka do istniejącego katalogu.</param>
        <summary>Przenosi określony katalog i jego zawartość do nowej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceFileName` i `destinationFileName` należy określić nazwy innego katalogu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><paramref name="sourceDirectoryName" /> nie istnieje.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.  
  
—lub— 
 <paramref name="destinationDirectoryName" /> już istnieje.  
  
—lub— 
 <paramref name="sourceDirectoryName" /> i <paramref name="destinationDirectoryName" /> można znaleźć w tym samym katalogu.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="MoveFile">
      <MemberSignature Language="C#" Value="public void MoveFile (string sourceFileName, string destinationFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFile(string sourceFileName, string destinationFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveFile(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFile (sourceFileName As String, destinationFileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFile(System::String ^ sourceFileName, System::String ^ destinationFileName);" />
      <MemberSignature Language="F#" Value="member this.MoveFile : string * string -&gt; unit" Usage="isolatedStorageFile.MoveFile (sourceFileName, destinationFileName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">Nazwa pliku, aby przenieść.</param>
        <param name="destinationFileName">Ścieżka do nowej lokalizacji pliku. Jeśli nazwa pliku jest uwzględnione, przeniesiony plik ma tę nazwę.</param>
        <summary>Przenosi określony plik do nowej lokalizacji i opcjonalnie umożliwia określenie nową nazwę pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wyrzuca wyjątku, jeśli `sourceFileName` i `destinationFileName` są takie same.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest ciągiem o zerowej długości, zawiera tylko znak odstępu lub zawiera co najmniej jeden nieprawidłowy znak zdefiniowane przez <see cref="M:System.IO.Path.GetInvalidPathChars" /> metody.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceFileName" /> lub <paramref name="destinationFileName" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="sourceFileName" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Otwiera plik przy użyciu określonego udostępniania i opcje dostępu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string * System.IO.FileMode -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="isolatedStorageFile.OpenFile (path, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w izolowanym magazynie.</param>
        <param name="mode">Jedna z wartości wyliczenia, które określa, jak można otworzyć pliku.</param>
        <summary>Otwiera plik w określonym trybie.</summary>
        <returns>Plik, który jest otwierany w określonym trybie z dostępem do odczytu/zapisu i nie jest udostępniany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest źle sformułowany.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode, access As FileAccess) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string * System.IO.FileMode * System.IO.FileAccess -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="isolatedStorageFile.OpenFile (path, mode, access)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w izolowanym magazynie.</param>
        <param name="mode">Jedna z wartości wyliczenia, które określa, jak można otworzyć pliku.</param>
        <param name="access">Jedna z wartości wyliczenia, które określa, czy plik zostanie otwarty z odczytu, zapisu lub odczytu i zapisu.</param>
        <summary>Otwiera plik w określonym trybie z dostępem do odczytu/zapisu określonego.</summary>
        <returns>Plik jest otwarty w określonym trybie i dostępu, która nie jest udostępniany.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest źle sformułowany.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="F:System.IO.FileMode.Open" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="public System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenFile (path As String, mode As FileMode, access As FileAccess, share As FileShare) As IsolatedStorageFileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::IsolatedStorage::IsolatedStorageFileStream ^ OpenFile(System::String ^ path, System::IO::FileMode mode, System::IO::FileAccess access, System::IO::FileShare share);" />
      <MemberSignature Language="F#" Value="member this.OpenFile : string * System.IO.FileMode * System.IO.FileAccess * System.IO.FileShare -&gt; System.IO.IsolatedStorage.IsolatedStorageFileStream" Usage="isolatedStorageFile.OpenFile (path, mode, access, share)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.IsolatedStorage.IsolatedStorageFileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka względna pliku w izolowanym magazynie.</param>
        <param name="mode">Jedna z wartości wyliczenia, które określa, jak próbę otwarcia lub utworzenia pliku.</param>
        <param name="access">Jedną z wartości wyliczenia, które określa, czy plik zostanie otwarty z odczytu, zapisu lub odczytu i zapisu</param>
        <param name="share">Bitowa kombinacja wartości wyliczenia, które określają typ dostępu do innych <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream" /> obiekty mają do tego pliku.</param>
        <summary>Otwiera plik w określonym trybie dostępu określonego odczytu/zapisu i udostępniania uprawnień.</summary>
        <returns>Plik, który jest otwierany w określonym trybie i dostęp i z określonymi opcjami udostępniania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest równoważne użyciu <xref:System.IO.IsolatedStorage.IsolatedStorageFileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.IO.IsolatedStorage.IsolatedStorageFile%29?displayProperty=nameWithType> konstruktora.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> jest źle sformułowany.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Katalog, w <paramref name="path" /> nie istnieje.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Nie znaleziono pliku i <paramref name="mode" /> ustawiono <see cref="M:System.IO.FileInfo.Open(System.IO.FileMode)" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="Quota">
      <MemberSignature Language="C#" Value="public override long Quota { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Quota" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.Quota" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Quota As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long Quota { long get(); };" />
      <MemberSignature Language="F#" Value="member this.Quota : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.Quota" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą maksymalną ilość wolnego miejsca dla wydzielonej pamięci masowej.</summary>
        <value>Limit miejsca wydzielonej pamięci masowej, w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.  
  
—lub— 
Wydzielona pamięć masowa jest wyłączona.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa zakres wydzielonej pamięci masowej i całą jego zawartość.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Remove();" />
      <MemberSignature Language="F#" Value="override this.Remove : unit -&gt; unit" Usage="isolatedStorageFile.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa zakres wydzielonej pamięci masowej i całą jego zawartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ta metoda usuwa nieodwołalnie cały zakres i wszystkie zawarte katalogów i plików.  
  
 Jeśli katalogi lub plików w magazynie są używane, nie powiedzie się próba usunięcia magazynu i magazyn jest oznaczony do usunięcia. Wszystkie kolejne próby modyfikowanie magazynu throw <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A> metody usuwania plików wydzielonej pamięci masowej, po opróżnienia jego zawartość. [Porady: usuwanie magazynów w wydzielonej pamięci masowej](~/docs/standard/io/how-to-delete-stores-in-isolated-storage.md) przykładzie pokazano również użycie <xref:System.IO.IsolatedStorage.IsolatedStorageFile.Remove%2A> metody.  
  
 [!code-cpp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CPP/source.cpp#16)]
 [!code-csharp[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/CS/source.cs#16)]
 [!code-vb[System.IO.IsolatedStorage.IsolatedStorage#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.IsolatedStorage.IsolatedStorage/VB/source.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można usunąć izolowanym magazynie.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/3947e333-5af6-4601-b2f1-24d4d6129cf3">Porady: usuwanie danych z izolowanego magazynu</related>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static void Remove (System.IO.IsolatedStorage.IsolatedStorageScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remove(valuetype System.IO.IsolatedStorage.IsolatedStorageScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove(System.IO.IsolatedStorage.IsolatedStorageScope)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Remove (scope As IsolatedStorageScope)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Remove(System::IO::IsolatedStorage::IsolatedStorageScope scope);" />
      <MemberSignature Language="F#" Value="static member Remove : System.IO.IsolatedStorage.IsolatedStorageScope -&gt; unit" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.Remove scope" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.IO.IsolatedStorage.IsolatedStorageScope" />
      </Parameters>
      <Docs>
        <param name="scope">Bitowa kombinacja <see cref="T:System.IO.IsolatedStorage.IsolatedStorageScope" /> wartości.</param>
        <summary>Usuwa zakres określony wydzielonej pamięci masowej dla wszystkich tożsamości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ta metoda usuwa nieodwołalnie cały zakres i wszystkie zawarte katalogów i plików.  
  
 Jeśli katalogi lub plików w magazynie są używane, nie powiedzie się próba usunięcia magazynu i magazyn jest oznaczony do usunięcia. Wszystkie kolejne próby modyfikowanie magazynu throw <xref:System.IO.IsolatedStorage.IsolatedStorageException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Nie można usunąć izolowanym magazynie.</exception>
        <permission cref="T:System.Security.Permissions.IsolatedStorageFilePermission">używania wydzielonej pamięci masowej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.IsolatedStorageContainment.AdministerIsolatedStorageByUser" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Po wywołaniu późnego wiązania za pomocą mechanizmów takich jak <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/3947e333-5af6-4601-b2f1-24d4d6129cf3">Porady: usuwanie danych z izolowanego magazynu</related>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
    <Member MemberName="UsedSize">
      <MemberSignature Language="C#" Value="public override long UsedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 UsedSize" />
      <MemberSignature Language="DocId" Value="P:System.IO.IsolatedStorage.IsolatedStorageFile.UsedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property UsedSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long UsedSize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.UsedSize : int64" Usage="System.IO.IsolatedStorage.IsolatedStorageFile.UsedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.IsolatedStorage</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która reprezentuje ilość miejsca, używany do wydzielonej pamięci masowej.</summary>
        <value>Obszar wydzielonej pamięci masowej używanych w bajtach.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Izolowany magazyn został zamknięty.</exception>
        <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException">Usunięto izolowanym magazynie.</exception>
        <exception cref="T:System.ObjectDisposedException">Izolowany magazyn został usunięty.</exception>
        <related type="Article" href="~/docs/standard/io/isolated-storage.md">Izolowany magazyn</related>
      </Docs>
    </Member>
  </Members>
</Type>
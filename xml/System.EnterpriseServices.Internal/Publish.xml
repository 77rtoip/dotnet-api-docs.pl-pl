<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a1832ed11173c47bf8e040d02cf96c9cc35f829" /><Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="10/04/2018" /><Meta Name="ms.locfileid" Value="48598685" /></Metadata><TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publikuje interfejsów COM dla aplikacji z obsługą protokołu SOAP COM +.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish> jest używana wewnętrznie przez program .NET Framework. Nie trzeba z niej korzystać bezpośrednio w kodzie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.EnterpriseServices.Internal.Publish" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL dla głównego serwera poczty.</param>
        <param name="MailBox">Tworzenie skrzynki pocztowej.</param>
        <param name="SmtpName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę serwera Simple Mail Transfer Protocol (SMTP), zawierające skrzynkę pocztową.</param>
        <param name="Domain">Gdy metoda zwróci wartość, ten parametr zawiera domeny serwera SMTP.</param>
        <param name="PhysicalPath">Gdy metoda zwróci wartość, ten parametr zawiera ścieżka systemu plików dla skrzynki pocztowej.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy skrzynki pocztowej aplikacji z obsługą protokołu SOAP modelu COM + pod określonym adresem URL. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są w pełni zaimplementowane; nie powoduje utworzenia skrzynki pocztowej. Zwraca komunikat o błędzie "COM + protokołu SOAP usługi SMTP publikacji nie jest obsługiwana.".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="FullUrl">Pełny adres URL wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy metoda zwróci wartość, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy metoda zwróci wartość, ten parametr zawiera nazwy wirtualnego katalogu głównego.</param>
        <param name="PhysicalPath">Gdy metoda zwróci wartość, ten parametr zawiera ścieżkę do wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy z obsługą protokołu SOAP modelu COM + wirtualny katalog główny aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane jest, <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> można używać zamiast <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.  
  
—lub— 
Obiekt wywołujący nie ma uprawnień dostępu do informacji DNS.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Napotkano błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> jest pusty.  
  
—lub— 
Określonym w schemacie <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="FullUrl" /> zawiera więcej niż dwóch następujących po sobie kreski ułamkowe.  
  
—lub— 
Hasło określone w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla konfiguracji infrastruktury komunikacji zdalnej. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit&#xA;override this.DeleteMailBox : string * string *  -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL dla głównego serwera poczty.</param>
        <param name="MailBox">Usuwanie skrzynki pocztowej.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa z obsługą protokołu SOAP modelu COM + aplikacji skrzynki pocztowej pod określonym adresem URL. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są w pełni zaimplementowane, nie powoduje usunięcia skrzynki pocztowej. Zwraca komunikat o błędzie "COM + protokołu SOAP usługi SMTP publikacji nie jest obsługiwana.".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string *  -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Główny serwer sieci Web.</param>
        <param name="FullUrl">Pełny adres URL wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa z obsługą protokołu SOAP modelu COM + wirtualny katalog główny aplikacji. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> nie jest jeszcze dostępna.  
  
> [!CAUTION]
>  Metoda zwraca wartość obecnie bez błędów, ale wirtualnego katalogu głównego nie jest usuwany.  
  
 Po udostępnieniu funkcji jest zalecaną metodą <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Instaluje zestaw w globalnej pamięci podręcznej.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Usuwa zestaw z globalnej pamięci podręcznej.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.  
  
—lub— 
Obiekt wywołujący nie ma uprawnień do odnajdywania ścieżki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" /> jest pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> Nie można odnaleźć.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit&#xA;override this.GetAssemblyNameForCache : string *  -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ścieżka do pliku który zawiera biblioteki typów.</param>
        <param name="CachePath">Gdy metoda zwróci wartość, ten parametr zawiera nazwę katalogu SoapCache.</param>
        <summary>Zwraca pełną ścieżkę dla podpisanych wygenerowanego zestawu z silną nazwą w katalogu SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla niezarządzanych składników modelu COM + mają zostać opublikowane za pośrednictwem wywołaniem funkcji zdalnych .NET jako punktu końcowego protokołu SOAP serwer proxy musi być generowane, aby udostępnić niezarządzane składniki .NET Framework. Jest to zrobić programowo, wykonując te same kroki Importer biblioteki typów (Tlbimp.exe) [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] narzędzie, które służy do konwertowania niezarządzanych bibliotek typów modelu COM + do zestawów metadanych serwera proxy. Jednak aktywacji klienta za pośrednictwem protokołu SOAP zakończyło się sukcesem, komputerów klienckich i serwerów muszą współużytkować ten sam proxy metadanych podpisany silną nazwą. Z tego powodu podczas generowania zestawu zarządzanego serwera proxy for niezarządzanego składników modelu COM +, klucz silnej nazwy jest również generowane i używany do podpisywania zestawu serwera proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest pusta, zawiera tylko białe lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dostęp do <paramref name="TypeLibPath" /> zostanie odrzucone.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" /> zawiera dwukropek (:) w środku ciągu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">Ustaw <see langword="true" /> można utworzyć katalogu lub <see langword="false" /> Zwróć ścieżkę, ale nie utworzyć katalogu.</param>
        <summary>Zwraca ścieżkę katalogu do przechowywania plików konfiguracji klienta.</summary>
        <returns>Ścieżka do katalogu, który ma zawierać pliki konfiguracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy katalogi "\com\SOAPAssembly\\" w katalogu systemu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <summary>Odzwierciedla za pośrednictwem zestawu i zwraca nazwę typu, który odpowiada identyfikator ProgID.</summary>
        <returns>Nazwa typu, który odpowiada identyfikator ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string *  *  -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">Pełny adres URL wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy metoda zwróci wartość, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy metoda zwróci wartość, ten parametr zawiera nazwy wirtualnego katalogu głównego.</param>
        <summary>Analizuje adres URL i zwraca podstawowy adres URL i fragmenty wirtualnego katalogu głównego.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Napotkano błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do informacji DNS.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" /> jest pusty.  
  
—lub— 
Określonym w schemacie <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="FullUrl" /> zawiera zbyt wiele ukośników.  
  
—lub— 
Hasło określone w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
Nazwa hosta określona w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
Nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku który zawiera biblioteki typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="VRoot">Nazwa wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Podstawowy adres URL zawierający wirtualnego katalogu głównego.</param>
        <param name="Mode">Tryb aktywacji.</param>
        <param name="Transport">Nie używany. Określ <see langword="null" /> dla tego parametru.</param>
        <param name="AssemblyName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy metoda zwróci wartość, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza klienta biblioteki typów, tworzenia pliku konfiguracji na komputerze klienckim.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana przy imporcie serwera proxy klienta można wygenerować pliku konfiguracji usług zdalnych.  
  
 Jeśli `Mode` parametr jest "wellknownobject" lub ciąg pusty (""), przyjmowana jest dobrze znany obiekt; w przeciwnym razie przyjmowana jest aktywacja klienta.  
  
 Zalecane jest, <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> można używać zamiast <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku który zawiera biblioteki typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="strAssemblyName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy metoda zwróci wartość, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza serwera biblioteki typów, dodawanie lub usuwanie wpisów składnik do plików Web.config i Default.disco. Generuje serwer proxy, jeśli to konieczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A> dodaje wpis do pliku odnajdywania i plik web.config dla składników w bibliotece typów, i generuje albo kopiuje serwera proxy do katalogu bin składniki niezarządzane. Jeśli `Operation` równa się "delete", a następnie wpisy składnika zostaną usunięte z plików Web.config i Default.disco.  
  
 Zalecane jest, <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> i <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> można używać zamiast <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException"><paramref name="SrcTlbPath" /> Parametru odwołania scrobj.dll; w związku z tym, publikacja protokołu SOAP składników skryptu nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać możliwość dostępu do kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Rejestruje zestawu dla współdziałania z modelem COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A> używa narzędzie do rejestracji zestawów (Regasm.exe), aby zarejestrować utworzone klasy w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm.exe (narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Zestaw danych wejściowych nie ma silnej nazwy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.  
  
—lub— 
Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> nie zostanie znaleziony, lub rozszerzenie nazwy pliku nie zostanie określony.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami lub nazwę zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> nie <see langword="static" />.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> na danym poziomie hierarchii.  
  
—lub— 
Podpis metody oznaczone <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Aby uzyskać możliwość dostępu do rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">do określania bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Wyrejestrowuje zestaw międzyoperacyjny COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A> używa Regasm.exe wyrejestrować utworzone klasy w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm.exe (narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień do dostępu do kodu niezarządzanego.  
  
—lub— 
Codebase, która nie rozpoczyna się od "file://" został określony bez wymaganych <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" /> nie zostanie znaleziony, lub rozszerzenie nazwy pliku nie zostanie określony.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami lub nazwę zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> nie <see langword="static" />.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> na danym poziomie hierarchii.  
  
—lub— 
Podpis metody oznaczone <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">Aby uzyskać możliwość dostępu do rejestru. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">do określania bieżącego katalogu. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI, który rozpoczyna się od "file://". Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
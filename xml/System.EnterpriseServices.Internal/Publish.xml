<Type Name="Publish" FullName="System.EnterpriseServices.Internal.Publish">
  <Metadata><Meta Name="ms.openlocfilehash" Value="021ea4f3fe93694e754a55f2c3e9233861da1548" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69359023" /></Metadata><TypeSignature Language="C#" Value="public class Publish : System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Publish extends System.Object implements class System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.Publish" />
  <TypeSignature Language="VB.NET" Value="Public Class Publish&#xA;Implements IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public ref class Publish : System::EnterpriseServices::Internal::IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type Publish = class&#xA;    interface IComSoapPublisher" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.EnterpriseServices.Internal.IComSoapPublisher</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eef-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publikuje interfejsy COM dla aplikacji COM+ obsługujących protokół SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish>jest używany wewnętrznie przez .NET Framework. Nie musisz używać go bezpośrednio w kodzie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Publish ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Publish();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.EnterpriseServices.Internal.Publish" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do utworzenia.</param>
        <param name="SmtpName">Gdy ta metoda zwraca, ten parametr zawiera nazwę serwera Simple Mail Transfer Protocol (SMTP) zawierającego skrzynkę pocztową.</param>
        <param name="Domain">Gdy ta metoda zwraca, ten parametr zawiera domenę serwera SMTP.</param>
        <param name="PhysicalPath">Gdy ta metoda zwraca, ten parametr zawiera ścieżkę systemu plików dla skrzynki pocztowej.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy skrzynkę pocztową aplikacji COM+ z obsługą protokołu SOAP pod określonym adresem URL. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie w pełni zaimplementowany; nie tworzy skrzynki pocztowej. Zwraca komunikat o błędzie "publikacja SMTP usług SOAP protokołu COM+ nie jest obsługiwana".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit&#xA;override this.CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="publish.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="FullUrl">Pełny adres URL dla wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy ta metoda zwraca, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy ta metoda zwraca, ten parametr zawiera nazwę wirtualnego katalogu głównego.</param>
        <param name="PhysicalPath">Gdy ta metoda zwraca, ten parametr zawiera ścieżkę pliku dla wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy wirtualny katalog główny aplikacji COM+ z włączonym protokołem SOAP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane <xref:System.EnterpriseServices.Internal.SoapServerVRoot.CreateVirtualRootEx%2A> jest użycie <xref:System.EnterpriseServices.Internal.Publish.CreateVirtualRoot%2A>zamiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
 —lub—  
  
 Obiekt wywołujący nie ma uprawnień dostępu do informacji DNS.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" />jest puste.  
  
—lub— 
Schemat określony w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="FullUrl" />zawiera więcej niż dwa kolejne ukośniki.  
  
—lub— 
Podane <paramref name="FullUrl" /> hasło jest nieprawidłowe.  
  
—lub— 
Określona nazwa hosta <paramref name="FullUrl" /> jest nieprawidłowa.  
  
—lub— 
Nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowa.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Konfiguracja infrastruktury zdalnej. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit&#xA;override this.DeleteMailBox : string * string *  -&gt; unit" Usage="publish.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do usunięcia.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa skrzynkę pocztową aplikacji COM+ z obsługą protokołu SOAP pod określonym adresem URL. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie została w pełni zaimplementowana, nie powoduje usunięcia skrzynki pocztowej. Zwraca komunikat o błędzie "publikacja SMTP usług SOAP protokołu COM+ nie jest obsługiwana".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit&#xA;override this.DeleteVirtualRoot : string * string *  -&gt; unit" Usage="publish.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Główny serwer sieci Web.</param>
        <param name="FullUrl">Pełny adres URL dla wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa wirtualny katalog główny aplikacji COM+ z włączonym protokołem SOAP. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja programu <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> nie jest jeszcze dostępna.  
  
> [!CAUTION]
>  Metoda aktualnie zwraca bez błędu, ale wirtualny katalog główny nie jest usuwany.  
  
 Gdy funkcjonalność zostanie udostępniona, zalecaną metodą będzie <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit&#xA;override this.GacInstall : string -&gt; unit" Usage="publish.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Instaluje zestaw w globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit&#xA;override this.GacRemove : string -&gt; unit" Usage="publish.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Usuwa zestaw z globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
 —lub—  
  
 Obiekt wywołujący nie ma uprawnień do odnajdywania ścieżki.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" />jest puste.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit&#xA;override this.GetAssemblyNameForCache : string *  -&gt; unit" Usage="publish.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ścieżka pliku zawierającego bibliotekę typów.</param>
        <param name="CachePath">Gdy ta metoda zwraca, ten parametr zawiera nazwę katalogu SoapCache.</param>
        <summary>Zwraca pełną ścieżkę do wygenerowanego zestawu o silnej nazwie w katalogu SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby niezarządzany składnik modelu COM był publikowany za pomocą komunikacji zdalnej .NET jako punktu końcowego protokołu SOAP, należy wygenerować serwer proxy, aby udostępnić niezarządzane składniki .NET Framework. Jest to realizowane przez programowe wykonywanie tych samych kroków co Importer biblioteki typów (Tlbimp. exe), [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] narzędzia służącego do konwertowania niezarządzanych bibliotek typów modelu COM+ na zestawy metadanych serwera proxy. W przypadku aktywacji klienta za pośrednictwem protokołu SOAP, jednak komputery klienckie i serwery muszą współdzielić te same podpisane serwery proxy metadanych o silnej nazwie. Z tego powodu, gdy zarządzany zestaw proxy jest generowany dla niezarządzanego składnika modelu COM+, klucz silnej nazwy jest również generowany i używany do podpisywania zestawu proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest pusta, zawiera tylko spacje lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="TypeLibPath" /> Odmowa dostępu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" />zawiera dwukropek (:) w środku ciągu.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania plików. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetClientPhysicalPath">
      <MemberSignature Language="C#" Value="public static string GetClientPhysicalPath (bool CreateDir);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetClientPhysicalPath(bool CreateDir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetClientPhysicalPath (CreateDir As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetClientPhysicalPath(bool CreateDir);" />
      <MemberSignature Language="F#" Value="static member GetClientPhysicalPath : bool -&gt; string" Usage="System.EnterpriseServices.Internal.Publish.GetClientPhysicalPath CreateDir" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="CreateDir" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="CreateDir">Ustaw opcję na, aby utworzyć katalog, <see langword="false" /> lub aby zwrócić ścieżkę, ale nie Utwórz katalogu. <see langword="true" /></param>
        <summary>Zwraca ścieżkę do katalogu do przechowywania plików konfiguracji klienta.</summary>
        <returns>Ścieżka do katalogu zawierającego pliki konfiguracji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tworzy katalogi "\com\SOAPAssembly\\" w katalogu systemowym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string&#xA;override this.GetTypeNameFromProgId : string * string -&gt; string" Usage="publish.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <summary>Odzwierciedla zestaw i zwraca nazwę typu, który odpowiada identyfikatorowi ProgID.</summary>
        <returns>Nazwa typu, która odpowiada identyfikatorowi ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ParseUrl">
      <MemberSignature Language="C#" Value="public static void ParseUrl (string FullUrl, out string BaseUrl, out string VirtualRoot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ParseUrl(string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ParseUrl(System.String,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ParseUrl (FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ParseUrl(System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot);" />
      <MemberSignature Language="F#" Value="static member ParseUrl : string *  *  -&gt; unit" Usage="System.EnterpriseServices.Internal.Publish.ParseUrl (FullUrl, BaseUrl, VirtualRoot)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="FullUrl">Pełny adres URL dla wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy ta metoda zwraca, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy ta metoda zwraca, ten parametr zawiera nazwę wirtualnego katalogu głównego.</param>
        <summary>Analizuje adres URL i zwraca podstawowy adres URL i wirtualne części główne.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie ma uprawnień dostępu do informacji DNS.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" />jest puste.  
  
—lub— 
Schemat określony w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="FullUrl" />zawiera zbyt wiele ukośników.  
  
—lub— 
Podane <paramref name="FullUrl" /> hasło jest nieprawidłowe.  
  
—lub— 
Określona nazwa hosta <paramref name="FullUrl" /> jest nieprawidłowa.  
  
—lub— 
Nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <param name="SrcTlbPath">Ścieżka pliku zawierającego bibliotekę typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="VRoot">Nazwa wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Podstawowy adres URL, który zawiera wirtualny katalog główny.</param>
        <param name="Mode">Tryb aktywacji.</param>
        <param name="Transport">Nie używany. Określ <see langword="null" /> dla tego parametru.</param>
        <param name="AssemblyName">Gdy ta metoda zwraca, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy ta metoda zwraca, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza bibliotekę typów klienta, tworząc plik konfiguracji na komputerze klienckim.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas importowania serwera proxy klienta w celu wygenerowania pliku konfiguracji zdalnej.  
  
 `Mode` Jeśli parametr ma wartość "wellknownobject" lub ciąg pusty (""), zakłada się, że jest dobrze znany obiekt; w przeciwnym razie założono aktywację klienta.  
  
 Zalecane <xref:System.EnterpriseServices.Internal.SoapClientImport.ProcessClientTlbEx%2A> jest użycie <xref:System.EnterpriseServices.Internal.Publish.ProcessClientTlb%2A>zamiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string strAssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; strAssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef strAssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % strAssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit&#xA;override this.ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="publish.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, strAssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="strAssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku, który zawiera bibliotekę typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="strAssemblyName">Gdy ta metoda zwraca, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy ta metoda zwraca, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza bibliotekę typów serwera, dodając lub usuwając wpisy składników do plików Web. config i default. disco. W razie potrzeby generuje serwer proxy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>dodaje wpis do pliku odnajdywania i pliku Web. config dla składników z biblioteki typów, a następnie generuje lub kopiuje serwer proxy do katalogu bin dla niezarządzanych składników. Jeśli `Operation` jest równe "Delete", wpisy składników są usuwane z plików Web. config i default. disco.  
  
 Zaleca się, aby <xref:System.EnterpriseServices.Internal.SoapServerTlb.AddServerTlb%2A> <xref:System.EnterpriseServices.Internal.SoapServerTlb.DeleteServerTlb%2A> były używane zamiast <xref:System.EnterpriseServices.Internal.Publish.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException"><paramref name="SrcTlbPath" /> Parametr, do którego odwołuje się scrobj. dll; w związku z tym publikacja protokołu SOAP składników skryptów nie jest obsługiwana.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">możliwość uzyskania dostępu do kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit&#xA;override this.RegisterAssembly : string -&gt; unit" Usage="publish.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Rejestruje zestaw dla międzyoperacyjności modelu COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.RegisterAssembly%2A>używa narzędzia rejestracji zestawu (Regasm. exe) do zarejestrowania klas do utworzenia w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm. exe (Narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Zestaw wejściowy nie ma silnej nazwy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
—lub— 
Baza kodu, która nie zaczyna się od "file://", została określona bez <see cref="T:System.Net.WebPermission" />wymaganej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie została znaleziona lub nie określono rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwa razy z dwoma różnymi zeznaniami lub nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> symbolem nie <see langword="static" />jest.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona przy użyciu <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> danego poziomu hierarchii.  
  
—lub— 
Podpis metody oznaczonej za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">możliwość uzyskania dostępu do rejestru. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">do określania bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI rozpoczynającego się od ciągu "file://". Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit&#xA;override this.UnRegisterAssembly : string -&gt; unit" Usage="publish.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Wyrejestrowuje zestaw międzyoperacyjny modelu COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EnterpriseServices.Internal.Publish.UnRegisterAssembly%2A>używa programu Regasm. exe do wyrejestrowywania klas do utworzenia w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm. exe (Narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
—lub— 
Baza kodu, która nie zaczyna się od "file://", została określona bez <see cref="T:System.Net.WebPermission" />wymaganej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie została znaleziona lub nie określono rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwa razy z dwoma różnymi zeznaniami lub nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> symbolem nie <see langword="static" />jest.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona przy użyciu <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> danego poziomu hierarchii.  
  
—lub— 
Podpis metody oznaczonej za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
        <permission cref="T:System.Security.Permissions.RegistryPermission">możliwość uzyskania dostępu do rejestru. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">do określania bieżącego katalogu. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.AllAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do odczytywania identyfikatora URI rozpoczynającego się od ciągu "file://". Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">do odczytywania identyfikatora URI, który nie zaczyna się od „file://”.</permission>
      </Docs>
    </Member>
  </Members>
</Type>

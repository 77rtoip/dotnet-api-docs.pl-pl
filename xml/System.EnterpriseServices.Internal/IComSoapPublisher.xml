<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="27108ab5572e3d72aa2b7c6b0d1a777c188569fb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36487513" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type IComSoapPublisher = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publikuje interfejsy modelu COM dla aplikacji z obsługą protokołu SOAP modelu COM +.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja <xref:System.EnterpriseServices.Internal.IComSoapPublisher> jest <xref:System.EnterpriseServices.Internal.Publish>; znaleźć w tym temacie, aby uzyskać szczegóły.  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher> jest używana wewnętrznie przez program .NET Framework. Nie trzeba używać go bezpośrednio w kodzie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Domain" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL dla głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do utworzenia.</param>
        <param name="SmtpName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę serwera Simple Mail Transfer Protocol (SMTP) zawierające skrzynkę pocztową.</param>
        <param name="Domain">Gdy metoda zwróci wartość, ten parametr zawiera domeny serwera SMTP.</param>
        <param name="PhysicalPath">Gdy metoda zwróci wartość, ten parametr zawiera ścieżka systemu plików dla skrzynki pocztowej.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy skrzynkę pocztową aplikacji z obsługą protokołu SOAP modelu COM + pod określonym adresem URL. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są w pełni zaimplementowane; nie tworzy obecnie skrzynki pocztowej. Zwraca komunikat o błędzie "Usług SOAP modelu COM +, publikacja protokołu SMTP nie jest obsługiwane."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String&amp;" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String&amp;" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="FullUrl">Pełny adres URL wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy metoda zwróci wartość, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy metoda zwróci wartość, ten parametr zawiera nazwę wirtualnego katalogu głównego.</param>
        <param name="PhysicalPath">Gdy metoda zwróci wartość, ten parametr zawiera ścieżkę do wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy obsługujące protokół SOAP modelu COM + aplikacji wirtualnego katalogu głównego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane jest <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> można użyć zamiast <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  - lub - obiekt wywołujący nie ma uprawnień dostępu do informacji systemu nazw domen (DNS, Domain Name System).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="FullUrl" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Napotkano błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="FullUrl" /> jest pusty.  - lub - schemat określone w <paramref name="FullUrl" /> jest nieprawidłowy.  - lub - <paramref name="FullUrl" /> zawiera więcej niż dwa ukośniki kolejne.  - lub - hasło określone w <paramref name="FullUrl" /> jest nieprawidłowy.  - lub - nazwa hosta określona w <paramref name="FullUrl" /> jest nieprawidłowy.  - lub - nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL dla głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do usunięcia.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa z obsługą protokołu SOAP modelu COM + aplikacji skrzynki pocztowej pod określonym adresem URL. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie są w pełni zaimplementowane; nie powoduje usunięcia skrzynki pocztowej. Zwraca komunikat o błędzie "Usług SOAP modelu COM +, publikacja protokołu SMTP nie jest obsługiwane."  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Główny serwer sieci Web.</param>
        <param name="FullUrl">Pełny adres URL wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa z obsługą protokołu SOAP modelu COM + aplikacji wirtualnego katalogu głównego. Nie są w pełni zaimplementowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> nie jest jeszcze dostępna.  
  
> [!CAUTION]
>  Metoda zwraca wartość aktualnie bez błędów, ale wirtualnego katalogu głównego nie została usunięta.  
  
 Po udostępnieniu funkcjonalność będzie zalecana metoda <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit" Usage="iComSoapPublisher.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Instaluje zestawu w globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit" Usage="iComSoapPublisher.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Usuwa zestaw z globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="AssemblyPath" /> jest pusty.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> Nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit" Usage="iComSoapPublisher.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ścieżka do pliku, który zawiera biblioteki typów.</param>
        <param name="CachePath">Gdy metoda zwróci wartość, ten parametr zawiera pełną ścieżkę zestawu proxy w katalogu SoapCache.</param>
        <summary>Zwraca pełną ścieżkę dla podpisanych wygenerowanego zestawu z silną nazwą w katalogu SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla niezarządzanego składnik modelu COM + do opublikowania za pośrednictwem funkcji zdalnych .NET jako punktu końcowego protokołu SOAP serwer proxy musi wygenerowanych udostępnić niezarządzane składniki programu .NET Framework. Ma to programowo, wykonując te same kroki jako Importer biblioteki typów (Tlbimp.exe) [!INCLUDE[winsdklong](~/includes/winsdklong-md.md)] narzędzie, które służy do konwertowania niezarządzanych bibliotek typów COM + do zestawów metadanych serwera proxy. Jednak aktywacji klienta za pośrednictwem protokołu SOAP została wykonana pomyślnie, komputerów klienckich i serwerów muszą współużytkować tego samego serwera proxy silną nazwą podpisanych metadanych. Z tego powodu po wygenerowaniu zestawu zarządzanego serwera proxy dla niezarządzanego składnik modelu COM +, klucz silnej nazwy jest również wygenerowany i używany do podpisywania zestawu proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="TypeLibPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest pusta, zawiera tylko białe znaki lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Dostęp do <paramref name="TypeLibPath" /> jest zabroniony.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="TypeLibPath" /> zawiera dwukropek (:) w środku ciągu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string" Usage="iComSoapPublisher.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <summary>Odzwierciedla za pośrednictwem zestawu i zwraca nazwę typu, która odpowiada identyfikator ProgID.</summary>
        <returns>Nazwa typu zgodny identyfikator ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku, który zawiera biblioteki typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="VRoot">Nazwa wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Podstawowy adres URL zawierający wirtualnego katalogu głównego.</param>
        <param name="Mode">Tryb aktywacji.</param>
        <param name="Transport">Nie używany. Określ <see langword="null" /> dla tego parametru.</param>
        <param name="AssemblyName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy metoda zwróci wartość, ten parametr zawiera pełną nazwę typu zestawu.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza klienta biblioteki typów, tworzenia pliku konfiguracji na kliencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy importu serwera proxy klienta można wygenerować pliku konfiguracji usług zdalnych.  
  
 W celu wykonania Jeśli `Mode` parametr ma wartość "wellknownobject" lub ciąg pusty (""), przyjmowana jest dobrze znane obiekty; w przeciwnym razie przyjęto aktywacji klienta.  
  
 Zalecane jest <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> można użyć zamiast <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="TypeName" Type="System.String&amp;" RefType="out" />
        <Parameter Name="Error" Type="System.String&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programowy klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku, który zawiera bibliotekę typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="AssemblyName">Gdy metoda zwróci wartość, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy metoda zwróci wartość, ten parametr zawiera pełną nazwę typu zestawu.</param>
        <param name="Error">Gdy metoda zwróci wartość, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza serwera biblioteki typów, albo dodawanie lub usuwanie składników wpisów w plikach Web.config i Default.disco. Generuje serwer proxy, jeśli to konieczne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generuje wpisy w pliku Web.config i Default.disco dla składników COM +. Generuje serwer proxy, jeśli to konieczne.  
  
 Zalecane jest <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> i <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> można użyć zamiast <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException">
          <paramref name="SrcTlbPath" /> Parametr odwołał się do scrobj.dll; w związku z tym publikacja protokołu SOAP składników skryptu nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Rejestruje zestawu dla modelu COM interop.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> używa narzędzie do rejestrowania zestawów (Regasm.exe) można zarejestrować klasy możliwość utworzenia w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm.exe (narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Wejściowy zestaw nie ma silnej nazwy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  - lub - codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> nie zostanie znaleziony, lub rozszerzenie nazwy pliku nie jest określony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany z dwóch różnych też dowody lub nazwę zestawu przekracza maksymalną długość zdefiniowana w systemie.</exception>
        <exception cref="T:System.InvalidOperationException">Metody oznaczone <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> nie jest <see langword="static" />.  - lub - istnieje więcej niż jednej metody oznaczonej jako <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> na danym poziomie hierarchii.  Podpis metody oznaczonej - lub - <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Wyrejestrowuje zestawu międzyoperacyjnego COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> używa Regasm.exe wyrejestrować możliwość utworzenia klasy w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm.exe (narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  - lub - codebase, który rozpoczyna się od "file://" został określony bez wymaganego <see cref="T:System.Net.WebPermission" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="AssemblyPath" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="AssemblyPath" /> nie zostanie znaleziony, lub rozszerzenie nazwy pliku nie jest określony.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="AssemblyPath" /> nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany z dwóch różnych też dowody lub nazwę zestawu przekracza maksymalną długość zdefiniowane przez system Opera.</exception>
        <exception cref="T:System.InvalidOperationException">Metody oznaczone <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> nie jest <see langword="static" />.  - lub - istnieje więcej niż jednej metody oznaczonej jako <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> na danym poziomie hierarchii.  Podpis metody oznaczonej - lub - <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
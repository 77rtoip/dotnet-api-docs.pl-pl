<Type Name="IComSoapPublisher" FullName="System.EnterpriseServices.Internal.IComSoapPublisher">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6fd0f35d4014167392f0ca0f22aed759a564ae79" /><Meta Name="ms.sourcegitcommit" Value="913829d6e739689126fe74be43a8513d4181fd22" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/20/2019" /><Meta Name="ms.locfileid" Value="69628701" /></Metadata><TypeSignature Language="C#" Value="public interface IComSoapPublisher" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IComSoapPublisher" />
  <TypeSignature Language="DocId" Value="T:System.EnterpriseServices.Internal.IComSoapPublisher" />
  <TypeSignature Language="VB.NET" Value="Public Interface IComSoapPublisher" />
  <TypeSignature Language="C++ CLI" Value="public interface class IComSoapPublisher" />
  <TypeSignature Language="F#" Value="type IComSoapPublisher = interface" />
  <AssemblyInfo>
    <AssemblyName>System.EnterpriseServices</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("d8013eee-730b-45e2-ba24-874b7242c425")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Publikuje interfejsy COM dla aplikacji COM+ obsługujących protokół SOAP.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja programu <xref:System.EnterpriseServices.Internal.IComSoapPublisher> jest; <xref:System.EnterpriseServices.Internal.Publish>zapoznaj się z tym tematem.  
  
 <xref:System.EnterpriseServices.Internal.IComSoapPublisher>jest używany wewnętrznie przez .NET Framework. Nie musisz używać go bezpośrednio w kodzie.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateMailBox">
      <MemberSignature Language="C#" Value="public void CreateMailBox (string RootMailServer, string MailBox, out string SmtpName, out string Domain, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateMailBox(string RootMailServer, string MailBox, [out] string&amp; SmtpName, [out] string&amp; Domain, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateMailBox(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateMailBox (RootMailServer As String, MailBox As String, ByRef SmtpName As String, ByRef Domain As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % SmtpName, [Runtime::InteropServices::Out] System::String ^ % Domain, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateMailBox : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateMailBox (RootMailServer, MailBox, SmtpName, Domain, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(6)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="SmtpName" Type="System.String" RefType="out" />
        <Parameter Name="Domain" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do utworzenia.</param>
        <param name="SmtpName">Gdy ta metoda zwraca, ten parametr zawiera nazwę serwera Simple Mail Transfer Protocol (SMTP) zawierającego skrzynkę pocztową.</param>
        <param name="Domain">Gdy ta metoda zwraca, ten parametr zawiera domenę serwera SMTP.</param>
        <param name="PhysicalPath">Gdy ta metoda zwraca, ten parametr zawiera ścieżkę systemu plików dla skrzynki pocztowej.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy skrzynkę pocztową aplikacji COM+ z obsługą protokołu SOAP pod określonym adresem URL. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie w pełni zaimplementowany; nie tworzy obecnie skrzynki pocztowej. Zwraca komunikat o błędzie "publikacja SMTP usług SOAP protokołu COM+ nie jest obsługiwana".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateVirtualRoot">
      <MemberSignature Language="C#" Value="public void CreateVirtualRoot (string Operation, string FullUrl, out string BaseUrl, out string VirtualRoot, out string PhysicalPath, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CreateVirtualRoot(string Operation, string FullUrl, [out] string&amp; BaseUrl, [out] string&amp; VirtualRoot, [out] string&amp; PhysicalPath, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot(System.String,System.String,System.String@,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateVirtualRoot (Operation As String, FullUrl As String, ByRef BaseUrl As String, ByRef VirtualRoot As String, ByRef PhysicalPath As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateVirtualRoot(System::String ^ Operation, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % BaseUrl, [Runtime::InteropServices::Out] System::String ^ % VirtualRoot, [Runtime::InteropServices::Out] System::String ^ % PhysicalPath, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member CreateVirtualRoot : string * string *  *  *  *  -&gt; unit" Usage="iComSoapPublisher.CreateVirtualRoot (Operation, FullUrl, BaseUrl, VirtualRoot, PhysicalPath, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(4)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" RefType="out" />
        <Parameter Name="VirtualRoot" Type="System.String" RefType="out" />
        <Parameter Name="PhysicalPath" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="FullUrl">Pełny adres URL dla wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Gdy ta metoda zwraca, ten parametr zawiera podstawowy adres URL.</param>
        <param name="VirtualRoot">Gdy ta metoda zwraca, ten parametr zawiera nazwę wirtualnego katalogu głównego.</param>
        <param name="PhysicalPath">Gdy ta metoda zwraca, ten parametr zawiera ścieżkę pliku dla wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Tworzy wirtualny katalog główny aplikacji COM+ z włączonym protokołem SOAP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane <xref:System.EnterpriseServices.Internal.ISoapServerVRoot.CreateVirtualRootEx%2A> jest użycie <xref:System.EnterpriseServices.Internal.IComSoapPublisher.CreateVirtualRoot%2A>zamiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
 —lub—  
  
 Obiekt wywołujący nie ma uprawnień dostępu do informacji o systemie nazw domen (DNS).</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="FullUrl" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Wystąpił błąd podczas rozpoznawania nazwy hosta lokalnego.</exception>
        <exception cref="T:System.UriFormatException"><paramref name="FullUrl" />jest puste.  
  
—lub— 
Schemat określony w <paramref name="FullUrl" /> jest nieprawidłowy.  
  
—lub— 
 <paramref name="FullUrl" />zawiera więcej niż dwa kolejne ukośniki.  
  
—lub— 
Podane <paramref name="FullUrl" /> hasło jest nieprawidłowe.  
  
—lub— 
Określona nazwa hosta <paramref name="FullUrl" /> jest nieprawidłowa.  
  
—lub— 
Nazwa pliku określona w <paramref name="FullUrl" /> jest nieprawidłowa.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteMailBox">
      <MemberSignature Language="C#" Value="public void DeleteMailBox (string RootMailServer, string MailBox, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteMailBox(string RootMailServer, string MailBox, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteMailBox(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteMailBox (RootMailServer As String, MailBox As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteMailBox(System::String ^ RootMailServer, System::String ^ MailBox, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteMailBox : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteMailBox (RootMailServer, MailBox, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(7)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootMailServer" Type="System.String" />
        <Parameter Name="MailBox" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootMailServer">Adres URL głównego serwera poczty.</param>
        <param name="MailBox">Skrzynka pocztowa do usunięcia.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa skrzynkę pocztową aplikacji COM+ z obsługą protokołu SOAP pod określonym adresem URL. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie w pełni zaimplementowany; nie usuwa skrzynki pocztowej. Zwraca komunikat o błędzie "publikacja SMTP usług SOAP protokołu COM+ nie jest obsługiwana".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteVirtualRoot">
      <MemberSignature Language="C#" Value="public void DeleteVirtualRoot (string RootWebServer, string FullUrl, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DeleteVirtualRoot(string RootWebServer, string FullUrl, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.DeleteVirtualRoot(System.String,System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteVirtualRoot (RootWebServer As String, FullUrl As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteVirtualRoot(System::String ^ RootWebServer, System::String ^ FullUrl, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member DeleteVirtualRoot : string * string *  -&gt; unit" Usage="iComSoapPublisher.DeleteVirtualRoot (RootWebServer, FullUrl, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(5)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="RootWebServer" Type="System.String" />
        <Parameter Name="FullUrl" Type="System.String" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="RootWebServer">Główny serwer sieci Web.</param>
        <param name="FullUrl">Pełny adres URL dla wirtualnego katalogu głównego.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Usuwa wirtualny katalog główny aplikacji COM+ z włączonym protokołem SOAP. Nie w pełni zaimplementowany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Funkcja programu <xref:System.EnterpriseServices.Internal.Publish.DeleteVirtualRoot%2A> nie jest jeszcze dostępna.  
  
> [!CAUTION]
>  Metoda aktualnie zwraca bez błędu, ale wirtualny katalog główny nie jest usuwany.  
  
 Gdy funkcjonalność zostanie udostępniona, zalecaną metodą będzie <xref:System.EnterpriseServices.Internal.SoapServerVRoot.DeleteVirtualRootEx%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacInstall">
      <MemberSignature Language="C#" Value="public void GacInstall (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacInstall(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacInstall(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacInstall (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacInstall(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacInstall : string -&gt; unit" Usage="iComSoapPublisher.GacInstall AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(13)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Instaluje zestaw w globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="GacRemove">
      <MemberSignature Language="C#" Value="public void GacRemove (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GacRemove(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GacRemove(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GacRemove (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GacRemove(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member GacRemove : string -&gt; unit" Usage="iComSoapPublisher.GacRemove AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(14)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Usuwa zestaw z globalnej pamięci podręcznej zestawów.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="AssemblyPath" />jest puste.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie znaleziono.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwukrotnie z dwoma różnymi dowodami.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyNameForCache">
      <MemberSignature Language="C#" Value="public void GetAssemblyNameForCache (string TypeLibPath, out string CachePath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetAssemblyNameForCache(string TypeLibPath, [out] string&amp; CachePath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetAssemblyNameForCache(System.String,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetAssemblyNameForCache (TypeLibPath As String, ByRef CachePath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetAssemblyNameForCache(System::String ^ TypeLibPath, [Runtime::InteropServices::Out] System::String ^ % CachePath);" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblyNameForCache : string *  -&gt; unit" Usage="iComSoapPublisher.GetAssemblyNameForCache (TypeLibPath, CachePath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(15)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="TypeLibPath" Type="System.String" />
        <Parameter Name="CachePath" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="TypeLibPath">Ścieżka pliku zawierającego bibliotekę typów.</param>
        <param name="CachePath">Gdy ta metoda zwraca, ten parametr zawiera pełną ścieżkę zestawu proxy w katalogu SoapCache.</param>
        <summary>Zwraca pełną ścieżkę do wygenerowanego zestawu o silnej nazwie w katalogu SoapCache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby niezarządzany składnik modelu COM był publikowany za pomocą komunikacji zdalnej .NET jako punktu końcowego protokołu SOAP, należy wygenerować serwer proxy, aby udostępnić niezarządzane składniki .NET Framework. Jest to realizowane przez programowe wykonywanie tych samych kroków co Importer biblioteki typów (Tlbimp. exe), narzędzia Windows SDK, które służy do konwertowania niezarządzanych bibliotek typów COM+ na zestawy metadanych serwera proxy. W przypadku aktywacji klienta za pośrednictwem protokołu SOAP, jednak komputery klienckie i serwery muszą współdzielić te same podpisane serwery proxy metadanych o silnej nazwie. Z tego powodu, gdy zarządzany zestaw proxy jest generowany dla niezarządzanego składnika modelu COM+, klucz silnej nazwy jest również generowany i używany do podpisywania zestawu proxy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="TypeLibPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący nie posiada wymaganych uprawnień.</exception>
        <exception cref="T:System.ArgumentException">Nazwa pliku jest pusta, zawiera tylko spacje lub zawiera nieprawidłowe znaki.</exception>
        <exception cref="T:System.UnauthorizedAccessException"><paramref name="TypeLibPath" /> Odmowa dostępu.</exception>
        <exception cref="T:System.IO.PathTooLongException">Podana ścieżka, nazwa pliku lub obie przekraczają maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="TypeLibPath" />zawiera dwukropek (:) w środku ciągu.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeNameFromProgId">
      <MemberSignature Language="C#" Value="public string GetTypeNameFromProgId (string AssemblyPath, string ProgId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeNameFromProgId(string AssemblyPath, string ProgId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.GetTypeNameFromProgId(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeNameFromProgId (AssemblyPath As String, ProgId As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTypeNameFromProgId(System::String ^ AssemblyPath, System::String ^ ProgId);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeNameFromProgId : string * string -&gt; string" Usage="iComSoapPublisher.GetTypeNameFromProgId (AssemblyPath, ProgId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(10)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
        <Parameter Name="ProgId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <summary>Odzwierciedla zestaw i zwraca nazwę typu, który odpowiada identyfikatorowi ProgID.</summary>
        <returns>Nazwa typu, która odpowiada identyfikatorowi ProgID.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessClientTlb">
      <MemberSignature Language="C#" Value="public void ProcessClientTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessClientTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string VRoot, string BaseUrl, string Mode, string Transport, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessClientTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, VRoot As String, BaseUrl As String, Mode As String, Transport As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessClientTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ VRoot, System::String ^ BaseUrl, System::String ^ Mode, System::String ^ Transport, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessClientTlb : string * string * string * string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessClientTlb (ProgId, SrcTlbPath, PhysicalPath, VRoot, BaseUrl, Mode, Transport, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(9)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="VRoot" Type="System.String" />
        <Parameter Name="BaseUrl" Type="System.String" />
        <Parameter Name="Mode" Type="System.String" />
        <Parameter Name="Transport" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <param name="SrcTlbPath">Ścieżka pliku zawierającego bibliotekę typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="VRoot">Nazwa wirtualnego katalogu głównego.</param>
        <param name="BaseUrl">Podstawowy adres URL, który zawiera wirtualny katalog główny.</param>
        <param name="Mode">Tryb aktywacji.</param>
        <param name="Transport">Nie używany. Określ <see langword="null" /> dla tego parametru.</param>
        <param name="AssemblyName">Gdy ta metoda zwraca, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy ta metoda zwraca, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza bibliotekę typów klienta, tworząc plik konfiguracji na komputerze klienckim.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas importowania serwera proxy klienta w celu wygenerowania pliku konfiguracji zdalnej.  
  
 W implementacji, jeśli `Mode` parametr ma wartość "wellknownobject" lub pusty ciąg (""), zakłada się, że jest dobrze znany obiekt; w przeciwnym razie założono aktywację klienta.  
  
 Zalecane <xref:System.EnterpriseServices.Internal.ISoapClientImport.ProcessClientTlbEx%2A> jest użycie <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessClientTlb%2A>zamiast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessServerTlb">
      <MemberSignature Language="C#" Value="public void ProcessServerTlb (string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, out string AssemblyName, out string TypeName, out string Error);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessServerTlb(string ProgId, string SrcTlbPath, string PhysicalPath, string Operation, [out] string&amp; AssemblyName, [out] string&amp; TypeName, [out] string&amp; Error) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb(System.String,System.String,System.String,System.String,System.String@,System.String@,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ProcessServerTlb (ProgId As String, SrcTlbPath As String, PhysicalPath As String, Operation As String, ByRef AssemblyName As String, ByRef TypeName As String, ByRef Error As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ProcessServerTlb(System::String ^ ProgId, System::String ^ SrcTlbPath, System::String ^ PhysicalPath, System::String ^ Operation, [Runtime::InteropServices::Out] System::String ^ % AssemblyName, [Runtime::InteropServices::Out] System::String ^ % TypeName, [Runtime::InteropServices::Out] System::String ^ % Error);" />
      <MemberSignature Language="F#" Value="abstract member ProcessServerTlb : string * string * string * string *  *  *  -&gt; unit" Usage="iComSoapPublisher.ProcessServerTlb (ProgId, SrcTlbPath, PhysicalPath, Operation, AssemblyName, TypeName, Error)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="SrcTlbPath" Type="System.String" />
        <Parameter Name="PhysicalPath" Type="System.String" />
        <Parameter Name="Operation" Type="System.String" />
        <Parameter Name="AssemblyName" Type="System.String" RefType="out" />
        <Parameter Name="TypeName" Type="System.String" RefType="out" />
        <Parameter Name="Error" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="ProgId">Identyfikator programistyczny klasy.</param>
        <param name="SrcTlbPath">Ścieżka do pliku, który zawiera bibliotekę typów.</param>
        <param name="PhysicalPath">Katalog aplikacji sieci Web.</param>
        <param name="Operation">Operacja do wykonania.</param>
        <param name="AssemblyName">Gdy ta metoda zwraca, ten parametr zawiera nazwę wyświetlaną zestawu.</param>
        <param name="TypeName">Gdy ta metoda zwraca, ten parametr zawiera w pełni kwalifikowaną nazwę typu zestawu.</param>
        <param name="Error">Gdy ta metoda zwraca, ten parametr zawiera komunikat o błędzie, jeśli wystąpił problem.</param>
        <summary>Przetwarza bibliotekę typów serwera, dodając lub usuwając wpisy składników do plików Web. config i default. disco. W razie potrzeby generuje serwer proxy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Generuje wpisy pliku Web. config i default. disco dla składników modelu COM+. W razie potrzeby generuje serwer proxy.  
  
 Zaleca się, aby <xref:System.EnterpriseServices.Internal.ISoapServerTlb.AddServerTlb%2A> <xref:System.EnterpriseServices.Internal.ISoapServerTlb.DeleteServerTlb%2A> były używane zamiast <xref:System.EnterpriseServices.Internal.IComSoapPublisher.ProcessServerTlb%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.</exception>
        <exception cref="T:System.EnterpriseServices.ServicedComponentException"><paramref name="SrcTlbPath" /> Parametr, do którego odwołuje się scrobj. dll; w związku z tym publikacja protokołu SOAP składników skryptów nie jest obsługiwana.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterAssembly">
      <MemberSignature Language="C#" Value="public void RegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member RegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.RegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(11)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Rejestruje zestaw dla międzyoperacyjności modelu COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja programu <xref:System.EnterpriseServices.Internal.IComSoapPublisher.RegisterAssembly%2A> używa narzędzia rejestracji zestawu (Regasm. exe) do zarejestrowania klas do utworzenia w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm. exe (Narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.EnterpriseServices.RegistrationException">Zestaw wejściowy nie ma silnej nazwy.</exception>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
—lub— 
Baza kodu, która nie zaczyna się od "file://", została określona bez <see cref="T:System.Net.WebPermission" />wymaganej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie została znaleziona lub nie określono rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwa razy z dwoma różnymi zeznaniami lub nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> symbolem nie <see langword="static" />jest.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona przy użyciu <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> danego poziomu hierarchii.  
  
—lub— 
Podpis metody oznaczonej za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnRegisterAssembly">
      <MemberSignature Language="C#" Value="public void UnRegisterAssembly (string AssemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnRegisterAssembly(string AssemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnRegisterAssembly (AssemblyPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnRegisterAssembly(System::String ^ AssemblyPath);" />
      <MemberSignature Language="F#" Value="abstract member UnRegisterAssembly : string -&gt; unit" Usage="iComSoapPublisher.UnRegisterAssembly AssemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.EnterpriseServices</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(12)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AssemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AssemblyPath">Ścieżka systemu plików dla zestawu.</param>
        <summary>Wyrejestrowuje zestaw międzyoperacyjny modelu COM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja programu <xref:System.EnterpriseServices.Internal.IComSoapPublisher.UnRegisterAssembly%2A> używa Regasm. exe do wyrejestrowywania klas do utworzenia w zestawie. Aby uzyskać więcej informacji, zobacz [Regasm. exe (Narzędzie rejestracji zestawów)](~/docs/framework/tools/regasm-exe-assembly-registration-tool.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Obiekt wywołujący w łańcuchu wywołań nie ma uprawnień dostępu do kodu niezarządzanego.  
  
—lub— 
Baza kodu, która nie zaczyna się od "file://", została określona bez <see cref="T:System.Net.WebPermission" />wymaganej.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="AssemblyPath" />jest <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="AssemblyPath" />nie została znaleziona lub nie określono rozszerzenia nazwy pliku.</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="AssemblyPath" />nie jest prawidłowym zestawem.</exception>
        <exception cref="T:System.IO.FileLoadException">Zestaw lub moduł został załadowany dwa razy z dwoma różnymi zeznaniami lub nazwa zestawu przekracza maksymalną długość zdefiniowaną przez system.</exception>
        <exception cref="T:System.InvalidOperationException">Metoda oznaczona <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> symbolem nie <see langword="static" />jest.  
  
—lub— 
Istnieje więcej niż jedna metoda oznaczona przy użyciu <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> danego poziomu hierarchii.  
  
—lub— 
Podpis metody oznaczonej za pomocą <see cref="T:System.Runtime.InteropServices.ComUnregisterFunctionAttribute" /> jest nieprawidłowy.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

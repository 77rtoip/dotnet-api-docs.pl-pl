<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="35c41088e2d1020cd99f7570565c144f44b3e76c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69166705" /></Metadata><TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Odczytuje dane wejściowe XAML i tworzy Graf obiektów przy użyciu domyślnego czytnika XAML WPF i skojarzonego z nim składnika zapisywania obiektów XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody synchroniczne <xref:System.Windows.Markup.XamlReader.Load%2A> są statyczne, ale metody asynchroniczne <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> nie są statyczne i <xref:System.Windows.Markup.XamlReader> wymagają wystąpienia klasy do użycia.  
  
 Dane wyjściowe `Load` metod są pojedynczym obiektem, który reprezentuje obiekt główny utworzonego drzewa obiektów lub Graf obiektu. Wykresy obiektów tworzone przez <xref:System.Windows.Markup.XamlReader> są zwykle dodawane do istniejącego drzewa obiektów aplikacji WPF w czasie wykonywania. W przeciwnym razie nowy Graf obiektu jest traktowany jako odłączony do celów modelu aplikacji WPF. Oznacza to, że nie jest on renderowany i nie można uzyskać do niego dostępu przy użyciu żadnych technik drzewa obiektów, które są stosowane do głównego drzewa obiektów aplikacji WPF (na przykład interfejsów <xref:System.Windows.FrameworkElement.FindName%2A>API <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>,). Aby uzyskać więcej informacji na temat pojęć dotyczących drzewa obiektów, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.Markup.XamlReader>Program obsługuje następujące podstawowe scenariusze:  
  
-   **Klonowanie/fabryka obiektów**: Bez dodatkowych mechanizmów nie można uwzględnić typu referencyjnego w więcej niż jednej pozycji w drzewie obiektów WPF. (Przykłady dodatkowych mechanizmów, które oferują pomoc techniczną do udostępniania lub ponownego użycia w WPF, obejmują obiekty, które <xref:System.Windows.Freezable>są oparte na lub obsługują często obiekty możliwe do współdzielenia, takie jak <xref:System.Windows.Media.Brush> te, do <xref:System.Windows.ResourceDictionary>których odwołuje się element z.) Jednym ze sposobów klonowania obiektu, który znajduje się już w drzewie obiektów, jest serializacja obiektu za <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>pomocą. Następnie można użyć serializowanego ciągu jako danych wejściowych dla wywołania do <xref:System.Windows.Markup.XamlReader.Load%2A>, ze strumieniem lub <xref:System.Xml.XmlReader> jako pośrednikiem.  
  
-   **Konstruowanie obiektów na podstawie informacji just in Time**: Często istnieją inne sposoby uzyskania późnego wiązania lub wprowadzania danych przez użytkownika zmiana stanu istniejących obiektów. Na przykład możesz użyć tej samej wartości, aby ustawić więcej niż jedną właściwość lub użyć powiązania danych. Ale jeśli masz scenariusz, gdzie nawet typ obiektu do utworzenia jest tylko możliwy do ustalenia w czasie wykonywania lub z interakcją użytkownika, tworzenie takiego obiektu przez utworzenie ciągu do <xref:System.Windows.Markup.XamlReader.Load%2A> danych wejściowych jest często przydatną techniką.  
  
-   **Korzystanie z istniejących technik zasobów**: <xref:System.IO.Stream> Typ jest często używany w innych strukturach lub technologiach służących do przesyłania danych lub obiektów między granicami aplikacji lub w podobny sposób. Następnie można użyć <xref:System.IO.Stream> technik do przechowywania lub uzyskiwania danych w formacie XAML, które są używane do tworzenia obiektów w ramach aplikacji.  
  
-   **Naprawione dokumenty:** Aplikacja może ładować lokalne lub pobrane Dokumenty XPS do uwzględnienia w drzewie obiektów aplikacji WPF i interfejsie użytkownika.  
  
> [!NOTE]
>  Ta dokumentacja czasami opisuje Graf obiektu, a nie drzewo obiektów. Ścisła relacja nadrzędny-podrzędny nie zawsze istnieje w relacjach obiektów czasu wykonywania aplikacji WPF w czasie wykonywania, dlatego wykres obiektów jest bardziej szeroko stosowanym terminologią. Jednak ponieważ WPF obejmuje również dwa różne interfejsy API conceptualization drzewa (<xref:System.Windows.LogicalTreeHelper>) <xref:System.Windows.Media.VisualTreeHelper>, drzewo metaphor nadal stosuje się odpowiednio do większości rzeczywistych przypadków w WPF. Z perspektywy języka XAML jest jednak często najlepszym sposobem, aby myśleć o sposobie tworzenia obiektów w języku XAML, ponieważ język XAML nie musi określać metodologii klasy pomocnika, które zwiększają relacje do ponownie strukturę drzewa.  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>Zabezpieczenia dostępu kodu, luźne XAML i XamlReader  
 XAML jest językiem znaczników, który bezpośrednio reprezentuje Tworzenie wystąpienia obiektu i wykonywanie. W związku z tym elementy utworzone w języku XAML mają tę samą możliwość współdziałania z zasobami systemowymi (dostęp do sieci, system plików we/wy) jako równoważny wygenerowany kod.  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]obsługuje strukturę [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]zabezpieczeń. Oznacza to, [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] że zawartość działająca w strefie Internet ma ograniczone uprawnienia wykonywania. "Luźne XAML" (strony nieskompilowanych kodów XAML w czasie ładowania przez przeglądarkę XAML) i [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] są zwykle uruchamiane w tej strefie internetowej i używają tego samego zestawu uprawnień.  Jednak kod XAML załadowany w w pełni zaufanej aplikacji ma taki sam dostęp do zasobów systemowych, jak aplikacja hostingu. Aby uzyskać więcej informacji, zobacz temat informacje o [zabezpieczeniach częściowej relacji zaufania WPF](~/docs/framework/wpf/wpf-partial-trust-security.md).  
  
 Implikacje tych instrukcji dla programu <xref:System.Windows.Markup.XamlReader> polega na tym, że projekt aplikacji musi podejmować decyzje dotyczące zaufania dotyczące języka XAML, który użytkownik chce załadować. Jeśli ładujesz kod XAML, który nie jest zaufany, rozważ zaimplementowanie własnej metody piaskownicy w celu załadowania grafu obiektu.  
  
 <xref:System.Windows.Markup.XamlReader>może być również wywoływana przez częściowy kod zaufania. W takim przypadku do zabezpieczenia dostępu kodu jest stosowana Strefa zabezpieczeń Internet. Jeśli wszystkie elementy w załadowanym języku XAML są nieprawidłowe w strefie zabezpieczeń sieci Internet, zostanie zgłoszony wyjątek analizy XAML. W obszarze XBAP i inne przypadki, które są częściowym zaufaniem na poziomie <xref:System.Windows.Markup.XamlReader> platformy, gdzie jest częścią wykonywania, uzyskuje się takie samo zachowanie wyjątku jak w przypadku jawnych wywołań częściowej relacji zaufania.  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>WPF XAML, czytelnicy XAML/autorzy i przechowywanie wersji języka XAML  
 XAML2009 obejmuje funkcje językowe, takie jak [x:Reference —](~/docs/framework/xaml-services/x-reference-markup-extension.md) i [x:FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md). Możesz użyć podpisów `Load` lub `Parse` do ładowania XAML, który używa tych funkcji. Jednak te funkcje języka nie są obsługiwane w języku XAML, który musi mieć skompilowane adiustacje (na przykład XAML dla akcji tworzenia **strony** w aplikacji WPF lub dowolny kod XAML, który obejmuje zadanie kompilowania znaczników w akcjach kompilacji).  
  
 Typy WPF i technologia WPF, ogólnie rzecz biorąc, zależą od dostępu do wewnętrznych platformy WPF. Na przykład, w jaki sposób WPF implementuje właściwości zależności, opiera się na wewnętrznych technikach do wydajnego wyszukiwania elementów członkowskich typu. Dostęp do tych wewnętrznych funkcji jest włączany przez odczytywanie i zapisywanie interfejsów API w <xref:System.Windows.Markup.XamlWriter> języku <xref:System.Windows.Markup.XamlReader> XAML, <xref:System.Windows.Markup> które znajdują się w i z przestrzeni nazw i zestawu platformie docelowej. Jednak czytniki XAML niższego poziomu i autorzy XAML z zestawu System. XAML (klasy oparte na <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) nie mają dostępu do wewnętrznych platformy WPF. Nie istnieje zależność od system. XAML do żadnego zestawu specyficznego dla platformy WPF. Bez dostępu do wewnętrznych platformy WPF, czytniki system. XAML i autorzy nie mogą poprawnie ładować lub zapisywać wszystkich typów WPF lub typów opartych na typach WPF. W szczególności czytelnicy system. XAML i moduły zapisujące nie rozumieją pojęć, takich jak magazyn właściwości w ramach właściwości zależności WPF, lub wszystkie szczegóły dotyczące sposobu używania przez WPF stylów, słowników zasobów i szablonów. W związku z tym masz możliwość dokonania:  
  
-   Jeśli ładujesz typy WPF i/lub używasz języka XAML w formularzu BAML w dowolny sposób, użyj czytników XAML platformie docelowej i autorów XAML.  
  
-   Jeśli nie korzystasz z żadnych typów WPF lub form BAML języka XAML ani nie korzystasz z innej konkretnej technologii, czytnika XAML lub implementacji składnika zapisywania języka XAML, z powodów specyficznych dla tej struktury, użyj czytników XAML system. XAML i autorów XAML.  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>Implementacja tworzenia kopii zapasowej system. XAML w programie .NET 4  
 <xref:System.Windows.Markup.XamlReader>to przywoływać powierzchnię interfejsu API dla analizatora XAML na poziomie platformy WPF Framework. Ten sam podstawowy parser XAML wykonuje również operacje ładowania i analizowania kodu XAML w czasie wykonywania dla aplikacji [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] WPF przeznaczonych dla i. [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]  
  
 W przypadku określania wartości [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]docelowej zewnętrzny interfejs API jest taki sam, ale części implementacji są oparte [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] na ogólnej implementacji XAML w zestawie System. XAML, co poprawia wiele aspektów technicznych i raportowania analizy języka XAML. Docelowa [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] konieczność obejmuje również system. XAML jako odwołanie, a szczegóły implementacji, takie jak zgłoszone wyjątki mogą pochodzić z typów zdefiniowanych przez system. XAML.  
  
## Examples  
 Poniższy przykład konwertuje <xref:System.Windows.Controls.Button> do ciągu <xref:System.Windows.Markup.XamlWriter> przy użyciu klasy.  Ten ciąg jest następnie ładowany z powrotem do <xref:System.Windows.Controls.Button> metody <xref:System.Windows.Markup.XamlReader> using statycznej <xref:System.Windows.Markup.XamlReader.Load%2A> klasy.  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Markup.XamlReader" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przerywa bieżącą operację ładowania asynchronicznego, jeśli istnieje oczekująca operacja asynchronicznego ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A>jest operacją asynchroniczną; w związku z tym niektóre operacje ładowania mogą wystąpić przed przerwaniem operacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca obiekt, który reprezentuje ustawienia kontekstu schematu WPF <see cref="T:System.Windows.Markup.XamlReader" />dla. <see cref="T:System.Xaml.XamlSchemaContext" /></summary>
        <returns>Obiekt, który reprezentuje ustawienia kontekstu schematu WPF <see cref="T:System.Windows.Markup.XamlReader" />dla. <see cref="T:System.Xaml.XamlSchemaContext" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje dane wejściowe XAML i zwraca katalog główny odpowiedniego drzewa obiektów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">KOD XAML do załadowania w formie strumienia.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca element <see cref="T:System.Object" /> , który jest katalogiem głównym odpowiedniego drzewa obiektów.</summary>
        <returns>Obiekt w katalogu głównym utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje <xref:System.Windows.Controls.Button> <xref:System.IO.MemoryStream> do <xref:System.Windows.Markup.XamlWriter> klasy przy użyciu. Strumień zostaje następnie załadowany z powrotem do <xref:System.Windows.Controls.Button> metody <xref:System.Windows.Markup.XamlReader> using statycznej <xref:System.Windows.Markup.XamlReader.Load%2A> klasy.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="reader">Element <see cref="T:System.Xaml.XamlReader" /> obiektu. Oczekuje się, że zostanie ona zainicjowana przy użyciu wejściowego języka XAML.</param>
        <summary>Odczytuje dane wejściowe XAML za pomocą dostarczonego <see cref="T:System.Xaml.XamlReader" /> i zwraca obiekt, który jest katalogiem głównym odpowiedniego drzewa obiektów.</summary>
        <returns>Obiekt, który jest katalogiem głównym utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mogą to <xref:System.Xaml.XamlReader> być <xref:System.Windows.Baml2006.Baml2006Reader>dane wejściowe. Jest to sposób ładowania BAML w czasie wykonywania lub na potrzeby narzędzia lokalizacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader"><see cref="T:System.Xml.XmlReader" /> , Który już załadował dane wejściowe XAML do załadowania w formularzu XML.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.Xml.XmlReader" /> i zwraca obiekt, który jest elementem głównym odpowiedniego drzewa obiektów.</summary>
        <returns>Obiekt, który jest katalogiem głównym utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje <xref:System.Windows.Controls.Button> do ciągu <xref:System.Windows.Markup.XamlWriter> przy użyciu klasy.  Ten ciąg jest następnie ładowany z powrotem do <xref:System.Windows.Controls.Button> metody <xref:System.Windows.Markup.XamlReader> using statycznej <xref:System.Windows.Markup.XamlReader.Load%2A> klasy.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień zawierający dane wejściowe XAML do załadowania.</param>
        <param name="parserContext">Informacje kontekstowe używane przez parser.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca obiekt, który jest elementem głównym odpowiedniego drzewa obiektów.</summary>
        <returns>Obiekt, który jest katalogiem głównym utworzonego drzewa obiektów.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.  
  
—lub— 
 <paramref name="parserContext" />jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje znaczniki XAML i zwraca obiekt, który odnosi się do elementu głównego określonego znacznika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień zawierający dane wejściowe XAML do załadowania.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca katalog główny odpowiedniego drzewa obiektów.</summary>
        <returns>Obiekt, który jest katalogiem głównym utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczna operacja ładowania XAML najpierw zwraca obiekt, który jest całkowicie obiektem głównym. Asynchronicznie, analizowanie XAML następnie kontynuuje działanie, a wszystkie obiekty podrzędne są wypełniane w katalogu głównym. Jest to w przeciwieństwie do typowego zachowania przetwarzania kodu XAML WPF i interakcji z pojęciami WPF dotyczącymi okresu istnienia obiektu. W typowej interakcji (nieasynchronicznej) wszystkie właściwości obiektu, w tym wszystkie kolekcje podrzędne, są wypełniane przed zwróceniem elementu i zgłoszeniem go jako załadowany. To zachowanie jest równe metodologii tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt, który stanie się dostępny.  
  
 Do niektórych lokalizacji w drzewie obiektów aplikacji WPF można przypisać zwracany obiekt z informacją o tym, że zawartość może być nadal wypełniana i może powodować aktualizacje przyrostowe układu, jeśli cała zawartość jest dostępna jako część interfejsu użytkownika. Z tego powodu typowe jest izolowanie lub Wirtualizacja wszelkich asynchronicznie ładowanych obiektów z XAML i użycie logiki specyficznej dla aplikacji lub stanu aplikacji do powiadamiania, gdy <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwany.  
  
 Aby można było załadować dane wejściowe XAML asynchronicznie, element główny w danych wejściowych XAML musi zawierać atrybut i wartość `x:SynchronousMode="Async"`. <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> Wartość jest traktowana jako uwzględniana wielkość liter. Jeśli katalog główny danych wejściowych XAML nie zawiera `x:SynchronousMode="Async"`, zgłaszany jest wyjątek, a wywołanie jest przetwarzane jako ładowanie synchroniczne (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  
  
 W danej chwili można wykonać tylko jedną asynchroniczną <xref:System.Windows.Markup.XamlReader> operację ładowania na wystąpienie klasy.  Jeśli zostanie podjęta próba wykonania więcej niż jednej operacji asynchronicznej w tym samym <xref:System.Windows.Markup.XamlReader> wystąpieniu <xref:System.InvalidOperationException> klasy a jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wiele operacji ładowania jest oczekujących jednocześnie z tym samym <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Istniejący <see cref="T:System.Xml.XmlReader" /> , który już załadował/odczytał dane wejściowe XAML.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.Xml.XmlReader" /> i zwraca katalog główny odpowiedniego drzewa obiektów.</summary>
        <returns>Katalog główny utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczna operacja ładowania XAML najpierw zwraca obiekt, który jest całkowicie obiektem głównym. Asynchronicznie, analizowanie XAML następnie kontynuuje działanie, a wszystkie obiekty podrzędne są wypełniane w katalogu głównym. Jest to w przeciwieństwie do typowego zachowania przetwarzania kodu XAML WPF i interakcji z pojęciami WPF dotyczącymi okresu istnienia obiektu. W typowej interakcji (nieasynchronicznej) wszystkie właściwości obiektu, w tym wszystkie kolekcje podrzędne, są wypełniane przed zwróceniem elementu i zgłoszeniem go jako załadowany. To zachowanie jest równe metodologii tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt, który stanie się dostępny.  
  
 Do niektórych lokalizacji w drzewie obiektów aplikacji można <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> przypisać zwracany obiekt z informacją o tym, że zawartość może być nadal wypełniana i może powodować aktualizacje przyrostowe układu, jeśli cała zawartość jest udostępniona jako część Interfejsu użytkownika. Z tego powodu typowe jest izolowanie lub Wirtualizacja wszelkich asynchronicznie ładowanych obiektów z XAML i użycie logiki specyficznej dla aplikacji lub stanu aplikacji do powiadamiania, gdy <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwany.  
  
 Aby można było załadować dane wejściowe XAML asynchronicznie, element główny w znaczniku XAML musi zawierać atrybut i wartość `x:SynchronousMode="Async"`. <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> Wartość jest traktowana jako uwzględniana wielkość liter. Jeśli korzeń znacznika XAML nie zawiera `x:SynchronousMode="Async"`, zgłaszany jest żaden wyjątek, a wywołanie jest przetwarzane jako ładowanie synchroniczne (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  
  
 W danej chwili można wykonać tylko jedną asynchroniczną <xref:System.Windows.Markup.XamlReader> operację ładowania na wystąpienie klasy.  Jeśli zostanie podjęta próba wykonania więcej niż jednej operacji asynchronicznej w tym samym <xref:System.Windows.Markup.XamlReader> wystąpieniu <xref:System.InvalidOperationException> klasy a jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wiele operacji ładowania jest wykonywanych współbieżnie <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień zawierający dane wejściowe XAML do załadowania.</param>
        <param name="parserContext">Informacje kontekstowe używane przez parser.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca katalog główny odpowiedniego drzewa obiektów.</summary>
        <returns>Katalog główny utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Asynchroniczna operacja ładowania XAML najpierw zwraca obiekt, który jest całkowicie obiektem głównym. Asynchronicznie, analizowanie XAML następnie kontynuuje działanie, a wszystkie obiekty podrzędne są wypełniane w katalogu głównym. Jest to w przeciwieństwie do typowego zachowania przetwarzania kodu XAML WPF i interakcji z pojęciami WPF dotyczącymi okresu istnienia obiektu. W typowej interakcji (nieasynchronicznej) wszystkie właściwości obiektu, w tym wszystkie kolekcje podrzędne, są wypełniane przed zwróceniem elementu i zgłoszeniem go jako załadowany. To zachowanie jest równe metodologii tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt, który stanie się dostępny.  
  
 Do niektórych lokalizacji w drzewie obiektów aplikacji można przypisać zwracany obiekt z informacją o tym, że zawartość może być nadal wypełniana i może powodować aktualizacje przyrostowe układu, jeśli cała zawartość jest dostępna jako część interfejsu użytkownika. Z tego powodu typowe jest izolowanie lub Wirtualizacja wszelkich asynchronicznie ładowanych obiektów z XAML i użycie logiki specyficznej dla aplikacji lub stanu aplikacji do powiadamiania, gdy <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwany.  
  
 Aby można było załadować znaczniki asynchronicznie, element główny w znaczniku XAML musi zawierać atrybut i wartość `x:SynchronousMode="Async"`. <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> Wartość jest traktowana jako uwzględniana wielkość liter. Jeśli korzeń znacznika XAML nie zawiera `x:SynchronousMode="Async"`, zgłaszany jest żaden wyjątek, a wywołanie jest przetwarzane jako ładowanie synchroniczne (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  
  
 W danej chwili można wykonać tylko jedną asynchroniczną <xref:System.Windows.Markup.XamlReader> operację ładowania na wystąpienie klasy.  Jeśli zostanie podjęta próba wykonania więcej niż jednej operacji asynchronicznej w tym samym <xref:System.Windows.Markup.XamlReader> wystąpieniu <xref:System.InvalidOperationException> klasy a jest generowany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" />jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wiele operacji ładowania jest wykonywanych współbieżnie <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu asynchronicznej operacji ładowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted>jest również uruchamiany w przypadku przerwania asynchronicznej operacji ładowania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje adiustację w określonym ciągu tekstowym i zwraca obiekt, który odnosi się do elementu głównego określonego znacznika.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">Wejściowy kod XAML jako pojedynczy ciąg tekstowy.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym ciągu tekstowym i zwraca obiekt, który odnosi się do elementu głównego określonego znacznika.</summary>
        <returns>Katalog główny utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja jest wywoływana <xref:System.Windows.Markup.XamlReader.Load%2A> wewnętrznie po utworzeniu strumienia z ciągu. Zobacz <xref:System.Windows.Markup.XamlReader.Load%2A> , aby uzyskać dodatkowe informacje, takie jak możliwe wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">Wejściowy kod XAML jako pojedynczy ciąg tekstowy.</param>
        <param name="parserContext">Informacje kontekstowe używane przez parser.</param>
        <summary>Odczytuje adiustację XAML w określonym ciągu tekstowym (przy użyciu określonej <see cref="T:System.Windows.Markup.ParserContext" />) i zwraca obiekt, który odnosi się do elementu głównego określonego znacznika.</summary>
        <returns>Katalog główny utworzonego drzewa obiektów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja jest wywoływana <xref:System.Windows.Markup.XamlReader.Load%2A> wewnętrznie po utworzeniu strumienia z ciągu. Zobacz <xref:System.Windows.Markup.XamlReader.Load%2A> , aby uzyskać dodatkowe informacje, takie jak możliwe wyjątki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

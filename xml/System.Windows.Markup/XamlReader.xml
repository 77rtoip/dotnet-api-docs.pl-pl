<Type Name="XamlReader" FullName="System.Windows.Markup.XamlReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb09b92c85f6899f8f0386e85d5fda59b541d871" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39361144" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XamlReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XamlReader extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.XamlReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XamlReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class XamlReader" />
  <TypeSignature Language="F#" Value="type XamlReader = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Odczytuje dane wejściowe XAML i tworzy grafu obiektów przy użyciu czytnika XAML domyślne WPF i skojarzonego modułu zapisywania obiektu XAML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Synchronicznej <xref:System.Windows.Markup.XamlReader.Load%2A> metody są statyczne, ale asynchroniczną <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> metod nie są statyczne i wymagać wystąpienia <xref:System.Windows.Markup.XamlReader> klasy.  
  
 Dane wyjściowe `Load` metody jest pojedynczy obiekt, który reprezentuje obiekt katalogu głównego drzewa utworzony obiekt lub wykres obiektu. Obiekt wykresów, które są tworzone przez <xref:System.Windows.Markup.XamlReader> zazwyczaj są dodawane do istniejącego drzewa obiektów aplikacji WPF w czasie wykonywania. W przeciwnym razie nowy Graf obiektu jest traktowany jako odłączona na potrzeby modelu aplikacji WPF. Oznacza to, że nie jest renderowana i nie może dotyczyć używanych korzystając z dowolnego z technik drzewa obiektów jako drzewa obiektów głównych aplikacji WPF (na przykład interfejsów API <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>). Aby uzyskać więcej informacji na temat pojęć drzewa obiektów, zobacz [drzewa w WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.Markup.XamlReader> obsługuje następujące podstawowe scenariusze:  
  
-   **Klonowanie obiektów fabryki**: bez dodatkowych mechanizmów typu odwołania ogólnie nie można uwzględnić w więcej niż jedną pozycję drzewa obiektów WPF. (Dodatkowe mechanizmy, które oferują pomoc techniczną dla udostępniania lub ponownego użycia na platformie WPF przykłady obiekty, które są oparte na <xref:System.Windows.Freezable>, lub obsługują powszechnie możliwego do udostępnienia obiektów, takich jak <xref:System.Windows.Media.Brush> , do których istnieją odwołania jako element <xref:System.Windows.ResourceDictionary>.) Jednym ze sposobów, aby sklonować obiekt, który już znajduje się w drzewie obiektów jest serializowanie przy użyciu obiektu <xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType>. Następnie możesz użyć serializacji ciągu jako dane wejściowe do wywołania <xref:System.Windows.Markup.XamlReader.Load%2A>, za pomocą strumienia lub <xref:System.Xml.XmlReader> jako pośrednik.  
  
-   **Konstruowanie obiektów w oparciu o informacje just-in-time**: często są inne sposoby, aby mieć późne powiązania lub dostarczone przez użytkownika dane wejściowe, Zmień stan istniejących obiektów. Na przykład można użyć tę samą wartość można ustawić więcej niż jedną właściwość lub użyj powiązanie danych. Jednak w przypadku scenariusza, w którym nawet typ obiektu do utworzenia jest tylko ustalić w czasie wykonywania lub interakcji z użytkownikiem, następnie utworzenie takiego obiektu, tworząc ciąg dla <xref:System.Windows.Markup.XamlReader.Load%2A> dane wejściowe są często przydatną techniką.  
  
-   **Przy użyciu technik, istniejącego zasobu**: <xref:System.IO.Stream> typ jest używany często w innych platform lub technologii dla transferu danych lub obiektów w granicach aplikacji lub podobnych sytuacji. Następnie można użyć <xref:System.IO.Stream> techniki w celu przechowywania lub uzyskać dane w formacie XAML, który ostatecznie zostanie użyty do utworzenia obiektu jako części aplikacji.  
  
-   **Naprawiono dokumenty:** aplikacji może ładować lokalnych lub pobrane dokumenty XPS do włączenia do drzewa obiektów aplikacji WPF i interfejsu użytkownika.  
  
> [!NOTE]
>  Czasami tej dokumentacji opisano grafu obiektów w przeciwieństwie do drzewa obiektów. Relacji nadrzędny podrzędny strict nie zawsze istnieje w czasie wykonywania relacje obiektów czasu wykonywania aplikacji WPF, więc wykresu obiektu jest powszechnie stosowanych terminologii. Jednak ponieważ WPF obejmuje również dwa inne drzewo conceptualization interfejsy API (<xref:System.Windows.LogicalTreeHelper>, <xref:System.Windows.Media.VisualTreeHelper>) drzewa metaphor nadal obowiązuje ograniczenie odpowiednio do większości przypadków rzeczywistych na platformie WPF. Z punktu widzenia języka XAML, wykres obiektu jest często najlepszym sposobem zastanów się, jak obiekty są tworzone z XAML, ponieważ sam język XAML nie musi określać metodologiach klasy pomocnika, które przenieść relacje więcej w ponownie strukturę drzewa.  
  
## <a name="code-access-security-loose-xaml-and-xamlreader"></a>Zabezpieczenia dostępu kodu, nie będzie XAML i XamlReader  
 XAML jest językiem znaczników, który bezpośrednio reprezentuje tworzenia wystąpienia obiektu, jak i wykonywania. Elementy tworzone w XAML więc ten sam możliwość interakcji z zasobami systemu (na przykład sieci dostępu do pliku systemu We/Wy) jako równoważne, generowany jest kod.  
  
 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] obsługuje [!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)] struktury zabezpieczeń [!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]. Oznacza to, że [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] obniżyła uprawnień Wykonywanie zawartości w strefie internet. "Luźno XAML" (stron XAML Nieskompilowane interpretowany w czasie ładowania przez Podgląd XAML) i [!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)] są zazwyczaj uruchamiane w ramach tej strefy internet i ten sam zestaw uprawnień.  Jednak XAML załadowane w pełni zaufanych aplikacji ma taki sam dostęp do zasobów systemowych, jak hostingu aplikacji. Aby uzyskać więcej informacji, zobacz [WPF częściowego zaufania zabezpieczeń](~/docs/framework/wpf/wpf-partial-trust-security.md).  
  
 Konsekwencje tych instrukcji <xref:System.Windows.Markup.XamlReader> jest, czy projekt aplikacji należy podjęcie decyzji o zaufaniu XAML zdecydować załadować. Jeśli są ładowane XAML, który nie jest zaufany, rozważ zaimplementowanie własne technika piaskownicy jak załadować wynikowy wykres obiektu.  
  
 <xref:System.Windows.Markup.XamlReader> również może być wywoływany przez kod z częściowej relacji zaufania. W tym przypadku strefy zabezpieczeń Internet jest stosowany do zabezpieczenia dostępu kodu. Jeśli dowolne elementy w załadować XAML jest nieprawidłowa dla strefy zabezpieczeń Internet, jest zgłaszany wyjątek analizy XAML. W obszarze XBAP i innych przypadkach, które są częściowej relacji zaufania na poziomie platformy, gdzie <xref:System.Windows.Markup.XamlReader> jest częścią wykonywania, możesz uzyskać takie samo zachowanie wyjątek podobnie jak w przypadku wywołania jawne częściowej relacji zaufania.  
  
## <a name="wpf-xaml-xaml-readerswriters-and-xaml-language-versioning"></a>WPF XAML, XAML czytelnicy/autorzy i przechowywanie wersji języka XAML  
 XAML2009 obejmuje funkcje językowe, takie jak [x: Reference](~/docs/framework/xaml-services/x-reference-markup-extension.md) i [x: FactoryMethod](~/docs/framework/xaml-services/x-factorymethod-directive.md). Możesz użyć sygnatur `Load` lub `Parse` załadować XAML, który używa tych funkcji. Jednak te funkcje językowe nie są obsługiwane dla XAML, który ma zostać skompilowany kod znaczników (takie jak XAML dla **strony** tworzenia akcji w aplikacji WPF lub dowolnym XAML, która obejmuje zadania kompilacji znaczników w akcjach kompilacji).  
  
 Typy WPF i technologii WPF ogólnie rzecz biorąc obsługuje pojęcia, które polegają na dostęp do elementy wewnętrzne WPF. Na przykład Implementowanie właściwości zależności WPF opiera się na wewnętrzny techniki wydajne składowej typu wyszukiwania. Dostęp do tych elementach wewnętrznych jest włączona, XAML, Odczyt i zapis interfejsów API dostarczonych w <xref:System.Windows.Markup.XamlWriter> i <xref:System.Windows.Markup.XamlReader> z <xref:System.Windows.Markup> przestrzeni nazw i PresentationFramework zestawu. Jednak niższego poziomu XAML czytników i składników zapisywania XAML, z zestawu System.Xaml (na podstawie klasy <xref:System.Xaml.XamlReader?displayProperty=nameWithType>, <xref:System.Xaml.XamlWriter?displayProperty=nameWithType>) nie mają dostępu do ustawienia wewnętrzne WPF. Nie ma żadnych zależności z System.Xaml do dowolnego złożenia charakterystyczne dla WPF. Bez dostępu do ustawienia wewnętrzne WPF nie można prawidłowo załadować System.Xaml czytników i składników zapisywania lub Zapisz WPF wszystkich typów, lub na podstawie typów WPF. W szczególności System.Xaml czytników i składników zapisywania niezrozumiały pojęć, takich jak właściwość zależności WPF kopii Magazyn właściwości ani wszystkich szczegółowych informacji o używaniu WPF style, słowniki zasobów i szablony. W związku z tym masz do wyboru, aby:  
  
-   Jeśli są ładowane typy WPF i/lub używasz XAML w formularz BAML w jakikolwiek sposób, przy użyciu czytników PresentationFramework XAML i moduły zapisujące XAML.  
  
-   Jeśli nie opierając się na wszystkie typy WPF i formularz BAML XAML i nie korzystają z czytnika XAML lub implementacji modułu zapisującego XAML innego określonych technologii przyczyn, które są specyficzne dla tej struktury, należy użyć XAML System.Xaml czytników i składników zapisywania XAML.  
  
## <a name="systemxaml-backing-implementation-in-net-4"></a>System.Xaml kopii wdrożenia na platformie .NET 4  
 <xref:System.Windows.Markup.XamlReader> jest wywoływane powierzchnię interfejsu API dla analizatora WPF XAML poziomie struktury. Tego samego podstawowego analizatora XAML oraz wykonuje XAML środowiska wykonawczego, ładowania i analizowania dla aplikacji WPF, których platformą docelową [!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)] i [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)].  
  
 Jeśli [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], zewnętrznego interfejsu API jest taka sama, ale elementy wdrożenia są oparte na [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] ogólne implementacji XAML w zestawie System.Xaml, co zwiększa wiele aspektów technicznych i raportowania analiza kodu XAML. Określanie wartości docelowej [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] zawsze powoduje uwzględnienie System.Xaml jako odwołanie i szczegóły implementacji, takich jak wyjątki zgłaszane mogą pochodzić z System.Xaml zdefiniowanych typów.  
  
## Examples  
 Poniższy przykład konwertuje <xref:System.Windows.Controls.Button> do ciągu za pomocą <xref:System.Windows.Markup.XamlWriter> klasy.  Ten ciąg jest następnie ładowany ponownie <xref:System.Windows.Controls.Button> przy użyciu statycznych <xref:System.Windows.Markup.XamlReader.Load%2A> metody <xref:System.Windows.Markup.XamlReader> klasy.  
  
 [!code-csharp[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[xamlreaderwritersnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Markup.XamlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XamlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XamlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Markup.XamlReader" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelAsync">
      <MemberSignature Language="C#" Value="public void CancelAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.CancelAsync" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelAsync ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelAsync();" />
      <MemberSignature Language="F#" Value="member this.CancelAsync : unit -&gt; unit" Usage="xamlReader.CancelAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bieżąca operacja asynchroniczne ładowanie przerywa, jeśli istnieje oczekująca operacja asynchroniczne ładowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.CancelAsync%2A> jest operacja asynchroniczna; w związku z tym niektóre obciążenia mogą wystąpić, zanim operacja została przerwana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWpfSchemaContext">
      <MemberSignature Language="C#" Value="public static System.Xaml.XamlSchemaContext GetWpfSchemaContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xaml.XamlSchemaContext GetWpfSchemaContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetWpfSchemaContext () As XamlSchemaContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xaml::XamlSchemaContext ^ GetWpfSchemaContext();" />
      <MemberSignature Language="F#" Value="static member GetWpfSchemaContext : unit -&gt; System.Xaml.XamlSchemaContext" Usage="System.Windows.Markup.XamlReader.GetWpfSchemaContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xaml.XamlSchemaContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.Xaml.XamlSchemaContext" /> obiekt, który reprezentuje ustawienia kontekst schematu WPF dla <see cref="T:System.Windows.Markup.XamlReader" />.</summary>
        <returns>A <see cref="T:System.Xaml.XamlSchemaContext" /> obiekt, który reprezentuje ustawienia kontekst schematu WPF dla <see cref="T:System.Windows.Markup.XamlReader" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje dane wejściowe XAML i zwraca odpowiedni drzewa obiektów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">XAML, który można załadować w postaci strumienia.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca <see cref="T:System.Object" /> czyli głównym odpowiedniej drzewa obiektów.</summary>
        <returns>Obiekt katalogu głównego drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład zapisuje <xref:System.Windows.Controls.Button> do <xref:System.IO.MemoryStream> przy użyciu <xref:System.Windows.Markup.XamlWriter> klasy. Strumień jest następnie ładowany ponownie <xref:System.Windows.Controls.Button> przy użyciu statycznych <xref:System.Windows.Markup.XamlReader.Load%2A> metody <xref:System.Windows.Markup.XamlReader> klasy.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xaml.XamlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xaml.XamlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XamlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xaml::XamlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xaml.XamlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xaml.XamlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Element <see cref="T:System.Xaml.XamlReader" /> obiektu. Jest to oczekiwane mogą zostać zainicjowane z danych wejściowych XAML.</param>
        <summary>Odczytuje dane wejściowe XAML przy użyciu podanego <see cref="T:System.Xaml.XamlReader" /> i zwraca obiekt, który jest katalogiem głównym odpowiedniej drzewa obiektów.</summary>
        <returns>Obiekt, który jest elementem głównym drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dane wejściowe <xref:System.Xaml.XamlReader> może być <xref:System.Windows.Baml2006.Baml2006Reader>. Jest to, jak załadować BAML w czasie wykonywania, lub do lokalizacji narzędzia celów.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="static member Load : System.Xml.XmlReader -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">
          <see cref="T:System.Xml.XmlReader" /> , XAML, danych wejściowych w celu załadowania w postaci XML został już załadowany.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.Xml.XmlReader" /> i zwraca obiekt, który jest katalogiem głównym odpowiedniej drzewa obiektów.</summary>
        <returns>Obiekt, który jest elementem głównym drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład konwertuje <xref:System.Windows.Controls.Button> do ciągu za pomocą <xref:System.Windows.Markup.XamlWriter> klasy.  Ten ciąg jest następnie ładowany ponownie <xref:System.Windows.Controls.Button> przy użyciu statycznych <xref:System.Windows.Markup.XamlReader.Load%2A> metody <xref:System.Windows.Markup.XamlReader> klasy.  
  
 [!code-csharp[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/csharp/VS_Snippets_Wpf/XamlReaderWriterSnippets/CSharp/Window1.xaml.cs#xamlreaderloadxmlreader)]
 [!code-vb[XamlReaderWriterSnippets#XamlReaderLoadXmlReader](~/samples/snippets/visualbasic/VS_Snippets_Wpf/XamlReaderWriterSnippets/visualbasic/window1.xaml.vb#xamlreaderloadxmlreader)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static object Load (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Load(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Load(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Load : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Load (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, który zawiera XAML dane wejściowe do załadowania.</param>
        <param name="parserContext">Informacje o kontekście używane przez analizator.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca obiekt, który jest katalogiem głównym odpowiedniej drzewa obiektów.</summary>
        <returns>Obiekt, który jest elementem głównym drzewa utworzony obiekt.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.  
  
—lub— 
 <paramref name="parserContext" /> jest <see langword="null" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadAsync">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje znaczników XAML i zwraca obiekt, który odnosi się w folderze głównym określonego znaczników.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream -&gt; obj" Usage="xamlReader.LoadAsync stream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, zawierający XAML dane wejściowe do załadowania.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca odpowiedni drzewa obiektów.</summary>
        <returns>Obiekt, który jest elementem głównym drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna obciążenia XAML początkowo zwróci obiekt, który jest całkowicie obiektu głównego. Asynchronicznie następnie analiza kodu XAML będzie się powtarzać, a wszystkie jego obiekty podrzędne są wypełnione w katalogu głównym. Jest to w przeciwieństwie do typowych XAML WPF, takich jak przetwarzanie zachowanie i wchodzi w interakcję z WPF pojęcia dotyczące okresu istnienia obiektu. Interakcja typowe (innych niż async) wszystkich właściwości obiektu, w tym wszystkie kolekcje podrzędne są wypełnione przed zwróceniem elementu i zgłoszenie go jako załadowane. To zachowanie jest równa metodologia od dołu do góry tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt staną się dostępne.  
  
 Zazwyczaj przypisywanej zwróconego obiektu lokalizacji drzewa obiektów aplikacji środowiska WPF, ze świadomością, że zawartość może nadal być wypełnianie i może spowodować aktualizacje przyrostowe układu, jeśli całą jego zawartość jest uwidaczniana jako części interfejsu użytkownika. Z tego powodu typowe, aby wyizolować, czy też zwirtualizować je wszystkie obiekty asynchronicznie załadowane z XAML i powiadom mnie, kiedy za pomocą logikę specyficzną dla aplikacji lub stan aplikacji jest <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwane.  
  
 Aby <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> załadować XAML wejściowych asynchronicznie, element główny XAML danych wejściowych musi zawierać atrybut i wartości `x:SynchronousMode="Async"`. Wartość jest traktowana jako wielkość liter. Jeśli główny wejściowych XAML nie zawiera `x:SynchronousMode="Async"`, jest zgłaszany żaden wyjątek, i wywołanie jest przetwarzany jako synchroniczna obciążenia (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29>).  
  
 Tylko jedna operacja asynchroniczne ładowanie każdego wystąpienia <xref:System.Windows.Markup.XamlReader> klasy mogą być wykonywane jednocześnie.  Jeśli próba zostanie podjęta na to samo wystąpienie elementu więcej niż jedna operacja asynchroniczna <xref:System.Windows.Markup.XamlReader> klasy <xref:System.InvalidOperationException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Trwa wiele operacji obciążenia wątkom takie same <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadAsync (reader As XmlReader) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::Xml::XmlReader ^ reader);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.Xml.XmlReader -&gt; obj" Usage="xamlReader.LoadAsync reader" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">Istniejące <see cref="T:System.Xml.XmlReader" /> , został już załadowany/Odczyt danych wejściowych XAML.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.Xml.XmlReader" /> i zwraca odpowiedni drzewa obiektów.</summary>
        <returns>Katalog główny drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna obciążenia XAML początkowo zwróci obiekt, który jest całkowicie obiektu głównego. Asynchronicznie następnie analiza kodu XAML będzie się powtarzać, a wszystkie jego obiekty podrzędne są wypełnione w katalogu głównym. Jest to w przeciwieństwie do typowych XAML WPF, takich jak przetwarzanie zachowanie i wchodzi w interakcję z WPF pojęcia dotyczące okresu istnienia obiektu. Interakcja typowe (innych niż async) wszystkich właściwości obiektu, w tym wszystkie kolekcje podrzędne są wypełnione przed zwróceniem elementu i zgłoszenie go jako załadowane. To zachowanie jest równa metodologia od dołu do góry tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt staną się dostępne.  
  
 Zwykle będzie przypisać obiekt zwrócony z <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> do określonej lokalizacji drzewa obiektów aplikacji ze świadomością, że zawartość może nadal być wypełnianie i może spowodować aktualizacje przyrostowe układu, jeśli całą jego zawartość jest widoczna jako część INTERFEJS UŻYTKOWNIKA. Z tego powodu typowe, aby wyizolować, czy też zwirtualizować je wszystkie obiekty asynchronicznie załadowane z XAML i powiadom mnie, kiedy za pomocą logikę specyficzną dla aplikacji lub stan aplikacji jest <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwane.  
  
 Aby <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> załadować XAML wejściowych asynchronicznie, element główny w znaczniku XAML musi zawierać atrybut i wartości `x:SynchronousMode="Async"`. Wartość jest traktowana jako wielkość liter. Jeśli główny znaczników XAML nie zawiera `x:SynchronousMode="Async"`, jest zgłaszany żaden wyjątek, i wywołanie zamiast tego jest przetwarzany jako synchroniczna obciążenia (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29>).  
  
 Tylko jedna operacja asynchroniczne ładowanie każdego wystąpienia <xref:System.Windows.Markup.XamlReader> klasy mogą być wykonywane jednocześnie.  Jeśli próba zostanie podjęta na to samo wystąpienie elementu więcej niż jedna operacja asynchroniczna <xref:System.Windows.Markup.XamlReader> klasy <xref:System.InvalidOperationException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="reader" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wiele operacji obciążenia są wykonywane równocześnie takie same <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadAsync">
      <MemberSignature Language="C#" Value="public object LoadAsync (System.IO.Stream stream, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object LoadAsync(class System.IO.Stream stream, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ LoadAsync(System::IO::Stream ^ stream, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="member this.LoadAsync : System.IO.Stream * System.Windows.Markup.ParserContext -&gt; obj" Usage="xamlReader.LoadAsync (stream, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień, zawierający XAML dane wejściowe do załadowania.</param>
        <param name="parserContext">Informacje o kontekście używane przez analizator.</param>
        <summary>Odczytuje dane wejściowe XAML w określonym <see cref="T:System.IO.Stream" /> i zwraca odpowiedni drzewa obiektów.</summary>
        <returns>Katalog główny drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operacja asynchroniczna obciążenia XAML początkowo zwróci obiekt, który jest całkowicie obiektu głównego. Asynchronicznie następnie analiza kodu XAML będzie się powtarzać, a wszystkie jego obiekty podrzędne są wypełnione w katalogu głównym. Jest to w przeciwieństwie do typowych XAML WPF, takich jak przetwarzanie zachowanie i wchodzi w interakcję z WPF pojęcia dotyczące okresu istnienia obiektu. Interakcja typowe (innych niż async) wszystkich właściwości obiektu, w tym wszystkie kolekcje podrzędne są wypełnione przed zwróceniem elementu i zgłoszenie go jako załadowane. To zachowanie jest równa metodologia od dołu do góry tworzenia drzewa, w którym obiektem głównym jest ostatni obiekt staną się dostępne.  
  
 Zazwyczaj przypisywanej zwróconego obiektu lokalizacji drzewa obiektów aplikacji, ze świadomością, że zawartość może nadal być wypełnianie i może spowodować aktualizacje przyrostowe układu, jeśli całą jego zawartość jest uwidaczniana jako części interfejsu użytkownika. Z tego powodu typowe, aby wyizolować, czy też zwirtualizować je wszystkie obiekty asynchronicznie załadowane z XAML i powiadom mnie, kiedy za pomocą logikę specyficzną dla aplikacji lub stan aplikacji jest <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest obsługiwane.  
  
 Aby <xref:System.Windows.Markup.XamlReader.LoadAsync%2A> załadować znaczników asynchronicznie, element główny w znaczniku XAML musi zawierać atrybut i wartości `x:SynchronousMode="Async"`. Wartość jest traktowana jako wielkość liter. Jeśli główny znaczników XAML nie zawiera `x:SynchronousMode="Async"`, jest zgłaszany żaden wyjątek, i wywołanie jest przetwarzany jako synchroniczna obciążenia (zobacz <xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29>).  
  
 Tylko jedna operacja asynchroniczne ładowanie każdego wystąpienia <xref:System.Windows.Markup.XamlReader> klasy mogą być wykonywane jednocześnie.  Jeśli próba zostanie podjęta na to samo wystąpienie elementu więcej niż jedna operacja asynchroniczna <xref:System.Windows.Markup.XamlReader> klasy <xref:System.InvalidOperationException> zgłaszany.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Wiele operacji obciążenia są wykonywane równocześnie takie same <see cref="T:System.Windows.Markup.XamlReader" />.</exception>
        <altmember cref="T:System.Windows.Markup.XamlWriter" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AsyncCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AsyncCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Markup.XamlReader.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Event LoadCompleted As AsyncCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AsyncCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " Usage="member this.LoadCompleted : System.ComponentModel.AsyncCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AsyncCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji asynchronicznej obciążenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlReader.LoadCompleted> jest także zgłaszane w przypadku operacji asynchronicznych obciążenia przerywa.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.AsyncCompletedEventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odczytuje znaczników w określonym ciągu i zwraca obiekt, który odnosi się w folderze głównym określonego znaczników.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (xamlText As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse xamlText" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xamlText">Dane wejściowe XAML jako jeden ciąg tekstowy.</param>
        <summary>Odczytuje dane wejściowe XAML w ciągu określony tekst i zwraca obiekt, który odnosi się w folderze głównym określonego znaczników.</summary>
        <returns>Katalog główny drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja wywołuje <xref:System.Windows.Markup.XamlReader.Load%2A> wewnętrznie po tworzenia strumienia z ciągu. Zobacz <xref:System.Windows.Markup.XamlReader.Load%2A> Aby uzyskać dodatkowe informacje, takie jak możliwych wyjątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (string xamlText, System.Windows.Markup.ParserContext parserContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(string xamlText, class System.Windows.Markup.ParserContext parserContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Parse(System::String ^ xamlText, System::Windows::Markup::ParserContext ^ parserContext);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Windows.Markup.ParserContext -&gt; obj" Usage="System.Windows.Markup.XamlReader.Parse (xamlText, parserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xamlText" Type="System.String" />
        <Parameter Name="parserContext" Type="System.Windows.Markup.ParserContext" />
      </Parameters>
      <Docs>
        <param name="xamlText">Dane wejściowe XAML jako jeden ciąg tekstowy.</param>
        <param name="parserContext">Informacje o kontekście używane przez analizator.</param>
        <summary>Odczytuje znaczników XAML w ciągu określonego tekstu (przy użyciu określonego <see cref="T:System.Windows.Markup.ParserContext" />) i zwraca obiekt, który odpowiada w folderze głównym określonego znaczników.</summary>
        <returns>Katalog główny drzewa utworzony obiekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implementacja wywołuje <xref:System.Windows.Markup.XamlReader.Load%2A> wewnętrznie po tworzenia strumienia z ciągu. Zobacz <xref:System.Windows.Markup.XamlReader.Load%2A> Aby uzyskać dodatkowe informacje, takie jak możliwych wyjątków.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
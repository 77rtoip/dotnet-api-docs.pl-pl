<Type Name="DependsOnAttribute" FullName="System.Windows.Markup.DependsOnAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9cc8359e6b8b119c606483f2b145d91b25694032" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36502858" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependsOnAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependsOnAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.DependsOnAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependsOnAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependsOnAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type DependsOnAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Method | System.AttributeTargets.Property, AllowMultiple=true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wskazuje, że właściwość oparte na atrybutach jest zależny od wartości właściwości innego.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Markup.XamlWriter.Save%2A> Metoda <xref:System.Windows.Markup.XamlWriter> przetworzy przed przetworzeniem właściwość ten atrybut zostanie ustawiony na określonej właściwości.  
  
 `name` Wartość stosowane do tego atrybutu musi być prosta nazwa niekwalifikowana w ten sam typ właściwości. Dołączone właściwości nie można określić jako zależne.  
  
 Po zastosowaniu tego atrybutu, należy uważać, aby uniknąć zależności cykliczne.  Zależności cykliczne wykryciu tylko po zapisaniu wszystkich właściwości w cyklu i nawet to zachowanie jest niejednoznaczny.  
  
 Stosowanie tego atrybutu do definicji właściwości zapewnia najpierw przetworzony zależne właściwości na piśmie obiektu języka XAML. Jest ona częścią ogólne reguły znaczników XAML, które zostały zastosowane do utworzonego obiektu wartości atrybutów powinno być możliwe do przetworzenia w dowolnej kolejności. Sposoby użycia <xref:System.Windows.Markup.DependsOnAttribute> Określ wyjątkowych przypadkach właściwości na typy, których określonej kolejności analizowania musi występować do utworzenia prawidłowego obiektu.  
  
 Ta klasa były dostępne w programie WPF określonego zestawu WindowsBase w poprzednich wersjach programu .NET Framework. W [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.DependsOnAttribute> znajduje się w zestawie System.Xaml. Aby uzyskać więcej informacji, zobacz [typy migrowane z WPF do System.Xaml](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
## <a name="wpf-usage-notes"></a>Uwagi dotyczące użycia WPF  
 <xref:System.Windows.Setter.Value%2A> Właściwość <xref:System.Windows.Setter> klasy jest przykładem właściwości na platformie WPF gdzie <xref:System.Windows.Markup.DependsOnAttribute> atrybut jest stosowany.  <xref:System.Windows.Setter.Value%2A> zależy od <xref:System.Windows.Setter.Property%2A> i <xref:System.Windows.Setter.TargetName%2A> przetwarzana najpierw, w przeciwnym razie nie istnieje sposób wiedzieć, jakiego typu powinien zostać utworzony dla przypadków konwertera wartości.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Xaml.XamlMember.DependsOn" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependsOnAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.DependsOnAttribute.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependsOnAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Windows.Markup.DependsOnAttribute : string -&gt; System.Windows.Markup.DependsOnAttribute" Usage="new System.Windows.Markup.DependsOnAttribute name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Właściwość właściwości skojarzone z tym <see cref="T:System.Windows.Markup.DependsOnAttribute" /> zależy.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Markup.DependsOnAttribute" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.Markup.DependsOnAttribute.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę właściwości powiązanych zadeklarowany w tym <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Nazwa właściwości powiązanych.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeId">
      <MemberSignature Language="C#" Value="public override object TypeId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object TypeId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Markup.DependsOnAttribute.TypeId" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TypeId As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ TypeId { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeId : obj" Usage="System.Windows.Markup.DependsOnAttribute.TypeId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator dla tego <see cref="T:System.Windows.Markup.DependsOnAttribute" />.</summary>
        <value>Unikatowy identyfikator.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to wartość wygenerowaną używającej zachowanie zastąpienie w celu umożliwienia wielu atrybutów o tej samej <xref:System.Windows.Markup.DependsOnAttribute.Name%2A> ma zostać zastosowany. Tak długo, jak zależności nie są cykliczne lub w inny sposób niejednoznaczny, wielu <xref:System.Windows.Markup.DependsOnAttribute> odwołania do tej samej nazwie właściwości są obsługiwane.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
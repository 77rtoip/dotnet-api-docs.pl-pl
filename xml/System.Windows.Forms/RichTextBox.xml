<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="56342548e09ef6d2bbd22d95b336427f7001474e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69181490" /></Metadata><TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kontrolkę pola tekstu sformatowanego systemu Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przy użyciu <xref:System.Windows.Forms.RichTextBox> kontrolki użytkownik może wprowadzać i edytować tekst. Formant oferuje również bardziej zaawansowane funkcje formatowania niż kontrolka standardowa <xref:System.Windows.Forms.TextBox> . Tekst może być przypisywany bezpośrednio do formantu lub można go załadować z formatu tekstu sformatowanego (RTF) lub zwykłego pliku tekstowego. Tekst w kontrolce może mieć przypisany znak i formatowanie akapitu.  
  
 <xref:System.Windows.Forms.RichTextBox> Formant zawiera wiele właściwości, których można użyć do zastosowania formatowania do dowolnej części tekstu w formancie. Aby zmienić formatowanie tekstu, należy najpierw go zaznaczyć. Tylko do zaznaczonego tekstu może być przypisany znak i formatowanie akapitu. Po wprowadzeniu ustawienia do wybranej sekcji tekstu, cały tekst wprowadzony po zaznaczeniu jest również sformatowany przy użyciu tych samych ustawień, dopóki nie zostanie wprowadzona zmiana ustawienia lub zostanie wybrana inna sekcja dokumentu formantu. <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> Właściwość umożliwia pogrubienie tekstu lub kursywę. Można także użyć tej właściwości, aby zmienić rozmiar i krój tekstu. <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> Właściwość pozwala zmienić kolor tekstu. Aby utworzyć listę punktowaną, można użyć <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> właściwości. Możesz również dopasować formatowanie akapitu <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, ustawiając właściwości, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>i. <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A>  
  
 <xref:System.Windows.Forms.RichTextBox> Kontrolka udostępnia metody, które zapewniają funkcje umożliwiające otwieranie i zapisywanie plików. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Metoda pozwala załadować istniejący plik tekstowy w formacie RTF lub ASCII do kontrolki. Możesz również załadować dane ze strumienia danych, który został już otwarty. <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Umożliwia zapisanie pliku w formacie RTF lub tekstu ASCII. Podobnie jak w przypadku <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody,możnarównieżużyćmetodydozapisywaniawotwartymstrumieniudanych.<xref:System.Windows.Forms.RichTextBox.LoadFile%2A> <xref:System.Windows.Forms.RichTextBox> Kontrolka udostępnia również funkcje do znajdowania ciągów tekstu. <xref:System.Windows.Forms.RichTextBox.Find%2A> Metoda jest przeciążona, aby znaleźć oba ciągi tekstu, jak również określone znaki w tekście kontrolki.  
  
 Można również zainicjować <xref:System.Windows.Forms.RichTextBox> kontrolę w danych przechowywanych w pamięci. Na przykład można zainicjować <xref:System.Windows.Forms.RichTextBox.Rtf%2A> właściwość na ciąg, który zawiera tekst do wyświetlenia, włącznie z kodami RTF, które określają sposób formatowania tekstu.  
  
 Jeśli tekst w kontrolce zawiera linki, takie jak link do witryny sieci Web, można użyć <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> właściwości, aby wyświetlić link odpowiednio do tekstu kontrolki. Następnie można obsłużyć <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzenie, aby wykonać zadania skojarzone z linkiem. <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> Właściwość umożliwia ochronę tekstu w formancie przed manipulacją przez użytkownika. Za pomocą chronionego tekstu w kontrolce można obsłużyć <xref:System.Windows.Forms.RichTextBox.Protected> zdarzenie, aby określić, kiedy użytkownik próbuje zmodyfikować chroniony tekst, i ostrzega użytkownika o tym, że tekst jest chroniony, lub udostępnić użytkownikowi standardowy sposób manipulowania chronionym tekstem.  
  
 Aplikacje, które już <xref:System.Windows.Forms.TextBox> używają kontrolek, można łatwo dostosować do korzystania <xref:System.Windows.Forms.RichTextBox> z kontrolek. Jednak kontrolka nie ma tego samego ograniczenia <xref:System.Windows.Forms.TextBox> pojemności 64 KB w formancie. <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.RichTextBox> Jest zazwyczaj używany do udostępniania tekstu i funkcji wyświetlania, podobnie jak w przypadku aplikacji do przetwarzania tekstów, takich jak Microsoft Word.  
  
> [!NOTE]
>  Metoda nie działa <xref:System.Windows.Forms.Control.KeyPress> ze zdarzeniami ani <xref:System.Windows.Forms.Control.TextChanged>. <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType>  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.RichTextBox> kontrolkę ładującą plik RTF do kontrolki i wyszukuje pierwsze wystąpienie słowa "text". Następnie kod zmienia styl czcionki, rozmiar czcionki i kolor czcionki zaznaczonego tekstu i zapisuje zmiany z powrotem do oryginalnego pliku. Przykładowy kod zostaje zakończyny przez dodanie kontrolki <xref:System.Windows.Forms.Form>do jej. Ten przykład wymaga, aby Metoda utworzona w przykładowym kodzie została dodana do <xref:System.Windows.Forms.Form> klasy i wywołana z konstruktora formularza. Przykład wymaga również, aby plik RTF został utworzony w katalogu głównym dysku C zawierającego wyraz "text".  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.RichTextBox" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> właściwość kontrolki jest ustawiona na `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.RichTextBox> kontrolkę ładującą plik RTF do kontrolki i wyszukuje pierwsze wystąpienie słowa "text". Następnie kod zmienia styl czcionki, rozmiar czcionki i kolor czcionki zaznaczonego tekstu i zapisuje zmiany z powrotem do oryginalnego pliku. Przykładowy kod zostaje zakończyny przez dodanie kontrolki <xref:System.Windows.Forms.Form>do jej. Ten przykład wymaga, aby Metoda utworzona w przykładowym kodzie została dodana do <xref:System.Windows.Forms.Form> klasy i wywołana z konstruktora formularza. Przykład wymaga również, aby plik RTF został utworzony w katalogu głównym dysku C zawierającego wyraz "text".  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kontrolka będzie umożliwiała wykonywanie operacji przeciągania i upuszczania.</summary>
        <value><see langword="true" />Jeśli przeciąganie i upuszczanie jest włączone w formancie; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wykonywania operacji przeciągania i upuszczania za pomocą <xref:System.Windows.Forms.ListBox> kontrolki, która zawiera elementy do porzucenia <xref:System.Windows.Forms.RichTextBox> do kontrolki. Konstruktor formularza ustawia <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> właściwość na `true` , aby umożliwić <xref:System.Windows.Forms.RichTextBox>wykonywanie operacji przeciągania i upuszczania w. W przykładzie używa <xref:System.Windows.Forms.Control.MouseDown> się zdarzenia, <xref:System.Windows.Forms.ListBox> aby rozpocząć operację <xref:System.Windows.Forms.Control.DoDragDrop%2A> przeciągania przez wywołanie metody. W przykładzie używa <xref:System.Windows.Forms.Control.DragEnter> się zdarzenia, aby określić, czy element, który jest przeciągany do elementu, <xref:System.Windows.Forms.RichTextBox> jest prawidłowym typem danych. Zdarzenie wykonuje rzeczywiste upuszczenie przeciąganego elementu <xref:System.Windows.Forms.RichTextBox> do kontrolki w <xref:System.Windows.Forms.RichTextBox>bieżącej lokalizacji kursora w obrębie. <xref:System.Windows.Forms.Control.DragDrop> Ten przykład wymaga, aby <xref:System.Windows.Forms.Control.DragDrop> zdarzenia <xref:System.Windows.Forms.Control.DragEnter> i były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest istotna dla tej klasy.</summary>
        <value><see langword="true" />Jeśli ta funkcja jest włączona; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest włączone automatyczne zaznaczanie wyrazów.</summary>
        <value><see langword="true" />Jeśli włączono automatyczne zaznaczanie słów; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true`, wybranie dowolnej części tekstu w kontrolce spowoduje zaznaczenie całego wyrazu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć <xref:System.Windows.Forms.RichTextBox> powiększenie, które powiększa się w tekście, automatycznie zaznacza słowa w tekście kontrolki, gdy słowo jest podwójnie kliknięte i ma margines po prawej stronie obszaru klienckiego kontrolki. Jeśli kontrolka ma małą szerokość, przy użyciu tego kodu <xref:System.Windows.Forms.RichTextBox> utworzysz każdy znak tekstu w osobnym wierszu. <xref:System.Windows.Forms.RichTextBox> W tej pionowej pozycji wyświetlania kliknięcie dowolnej części słowa spowoduje zaznaczenie wszystkich znaków wyrazu, niezależnie od tego, czy tekst jest wyświetlany pionowo. Ten przykład wymaga, aby był formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę o nazwie. `richTextBox1`  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest istotna dla tej klasy.</summary>
        <value>Obraz tła wyświetlany w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest istotna dla tej klasy.</summary>
        <value>Układ obrazu tła wyświetlanego w formancie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wcięcia używane w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce, gdy styl punktora zostanie zastosowany do tekstu.</summary>
        <value>Liczba pikseli wstawionych w postaci wcięcia po wypunktowaniu. Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby zastosować styl punktora do akapitu tekstu, ustaw <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> właściwość na `true` , a następnie ustaw <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> właściwość na liczbę pikseli, w których powinien być wcięty tekst. Styl punktora zostanie zastosowany do akapitu z określoną ilością wcięć po wyliczeniu. Ta właściwość ma wpływ tylko na bieżący akapit wewnątrz tekstu kontrolki i aktualnie wybranego punktora na liście punktowanych elementów. Aby zastosować inny poziom wcięcia do całej listy punktowanej, przed ustawieniem <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> właściwości należy wybrać cały tekst elementów punktowanych.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> kodu demonstruje <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, jak używać właściwości z właściwościami <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, i <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> , aby utworzyć listę punktowaną w <xref:System.Windows.Forms.RichTextBox> kontrolce. Ten przykład wymaga, aby <xref:System.Windows.Forms.RichTextBox> kontrolka `richTextBox1` o nazwie została utworzona w formularzu.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podane wcięcie jest mniejsze od zera.</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Jedna z <see cref="T:System.Windows.Forms.DataFormats.Format" /> wartości.</param>
        <summary>Określa, czy można wklejać informacje ze schowka w określonym formacie danych.</summary>
        <returns><see langword="true" />Jeśli można wkleić dane ze schowka w określonym formacie danych; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć tej metody, aby określić, czy bieżąca zawartość schowka znajduje się w określonym formacie danych schowka przed umożliwieniem użytkownikowi wklejenia informacji do <xref:System.Windows.Forms.RichTextBox> kontrolki. Na przykład można utworzyć procedurę obsługi zdarzeń dla <xref:System.Windows.Forms.MenuItem.Popup> zdarzenia polecenia <xref:System.Windows.Forms.MenuItem> Wklej i użyć tej metody do określenia, czy wklejanie <xref:System.Windows.Forms.MenuItem> ma być włączone na podstawie typu danych w Schowku.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.RichTextBox.Paste%2A> metody do wklejenia mapy bitowej <xref:System.Windows.Forms.RichTextBox> do kontrolki. Po otwarciu mapy bitowej z pliku, przykład używa <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> metody do kopiowania mapy bitowej do Schowka systemu Windows. Na koniec przykład <xref:System.Drawing.Bitmap> Pobiera format dla obiektu, <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> używa metody do sprawdzenia, czy format można wkleić do <xref:System.Windows.Forms.RichTextBox> kontrolki, a następnie używa <xref:System.Windows.Forms.RichTextBox.Paste%2A> metody, aby wkleić dane.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy istnieją akcje, które wystąpiły w <see cref="T:System.Windows.Forms.RichTextBox" /> ramach którego można ponownie zastosować.</summary>
        <value><see langword="true" />Jeśli istnieją operacje, które zostały cofnięte, można je ponownie zastosować do zawartości kontrolki; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można określić, czy Ostatnia operacja cofnięta w ramach <xref:System.Windows.Forms.RichTextBox> można ponownie zastosować <xref:System.Windows.Forms.RichTextBox.Redo%2A> przy użyciu metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> właściwości <xref:System.Windows.Forms.RichTextBox.Redo%2A> i <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> i metody w celu ograniczenia operacji wykonaj ponownie do dowolnej akcji poza usunięciem tekstu. Ten przykład wymaga, aby masz formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę oraz że operacja w ramach programu <xref:System.Windows.Forms.RichTextBox> została wykonana i cofnięta przed wykonaniem kodu w tym przykładzie.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniany jest rozmiar zawartości w formancie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.ContentsResized> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.ContentsResized> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymagane parametry tworzenia podczas tworzenia uchwytu sterującego.</summary>
        <value>A <see cref="T:System.Windows.Forms.CreateParams" /> , który zawiera wymagane parametry tworzenia podczas tworzenia uchwytu do kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt <see langword="IRichEditOleCallback" />zgodny z obsługą rozbudowanych operacji wywołania zwrotnego.</summary>
        <returns>Obiekt, który implementuje <see langword="IRichEditOleCallback" /> interfejs.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Można zastąpić tę metodę w klasie pochodnej, aby umożliwić dostęp do podstawowych funkcji edycji. W przypadku zastąpienia tej metody wszystkie zdarzenia przeciągania i upuszczania nie będą zgłaszane. W związku z tym należy zapewnić własne wsparcie dla operacji przeciągania i upuszczania. Aby uzyskać więcej informacji o <see langword="IRichEditOleCallback" /> interfejsie, zobacz dokumentację zestawu SDK platformy http://msdn.microsoft.compod adresem.</para></block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny rozmiar kontrolki.</summary>
        <value><see cref="T:System.Drawing.Size" /> Wartość.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, <see cref="T:System.Windows.Forms.RichTextBox" /> czy program automatycznie sformatuje adres URL (Uniform Resource Locator), gdy jest on wpisywany do kontrolki.</summary>
        <value><see langword="true" />Jeśli program automatycznie sformatuje adresy URL, które są wpisane do kontrolki jako łącze; <see langword="false" />w przeciwnym razie. <see cref="T:System.Windows.Forms.RichTextBox" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona na `true`, każdy tekst wprowadzony do kontrolki, która jest określana <xref:System.Windows.Forms.RichTextBox> przez adres URL, jest automatycznie formatowany jako link. Można utworzyć procedurę obsługi zdarzeń dla <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzenia, aby obsłużyć wszystkie linki kliknięte w formancie. Ten, który jest dostarczany do programu obsługi zdarzeń <xref:System.Windows.Forms.RichTextBox.LinkClicked> dla zdarzenia zawiera dane, które umożliwiają określenie, który Link został kliknięty w kontrolce w celu przetworzenia łącza. <xref:System.Windows.Forms.LinkClickedEventArgs>  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera procedurę obsługi zdarzeń dla <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzenia. Program obsługi zdarzeń tworzy łącze w dokumencie <xref:System.Windows.Forms.RichTextBox> kontrolki i uruchamia wystąpienie domyślnej przeglądarki ( <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> przy użyciu metody), wyświetlając stronę klikniętego łącza. Ten przykład wymaga, aby program obsługi zdarzeń był połączony ze <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzeniem <xref:System.Windows.Forms.RichTextBox>dla.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po dwukrotnym kliknięciu <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki przez użytkownika.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik ukończy przeciąganie i upuszczanie</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przeciągnięciu obiektu w granice formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.DragEnter> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.DragEnter> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt zostanie przeciągnięty poza granice formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy. Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt zostanie przeciągnięty na granicach formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy. Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap">A <see cref="T:System.Drawing.Bitmap" />.</param>
        <param name="targetBounds">A <see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Ta metoda nie jest odpowiednia dla tej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość, która umożliwia wykonywanie operacji przeciągania i upuszczania na tekst, obrazy i inne dane.</summary>
        <value><see langword="true" />Aby włączyć operacje przeciągania i upuszczania; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wyszukuje tekst w zawartości <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tablica znaków do wyszukania.</param>
        <summary>Przeszukuje tekst <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki pierwszego wystąpienia znaku z listy znaków.</summary>
        <returns>Lokalizacja w kontrolce, w której znaleziono znaki wyszukiwania, lub-1, jeśli nie odnaleziono znaków wyszukiwania lub w <paramref name="char" /> parametrze został określony pusty zestaw znaków wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody poszukuje pierwszego wystąpienia znaku z listy znaków określonych `characterSet` w parametrze i zwraca lokalizację znaku. Na przykład można przekazać tablicę znaków zawierającą znak "Q". Jeśli kontrolka zawierała tekst "Quick Brown Fox", <xref:System.Windows.Forms.RichTextBox.Find%2A> Metoda zwróci wartość czterech. Wielkie litery i małe litery są uznawane za różne wartości w wyszukiwaniu.  
  
 Jeśli właściwość zwraca wartość ujemną, wyszukiwane znaki nie zostały odnalezione w zawartości formantu. Za pomocą tej metody można wyszukać grupę znaków w kontrolce. Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody wymaga, aby cały dokument zawarty w kontrolce był przeszukiwany dla znaków. Jeśli zostanie znaleziony znak z listy znaków podany w `characterSet` parametrze metody, wartość zwracana przez tę metodę jest indeksem od zera położenia znaku w kontrolce. Spacja jest traktowana jako znak przez metodę podczas określania lokalizacji znaku.  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje zawartość a <xref:System.Windows.Forms.RichTextBox> dla znaków, które są przesyłane do metody `text` z parametru. Jeśli zawartość `text` tablicy znajduje się <xref:System.Windows.Forms.RichTextBox>w, metoda zwraca indeks znalezionej wartości; w przeciwnym razie zwraca-1. Przykład wymaga, aby ta metoda została <xref:System.Windows.Forms.Form> umieszczona w klasie a, która <xref:System.Windows.Forms.RichTextBox> zawiera kontrolkę o `richTextBox1` nazwie i <xref:System.Windows.Forms.Button> kontrolkę o `button1`nazwie, która jest połączona `Click` z programem obsługi zdarzeń zdefiniowanym w przykład.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, który ma zostać zlokalizowany w formancie.</param>
        <summary>Przeszukuje tekst w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce ciągu.</summary>
        <returns>Lokalizacja w kontrolce, w której znaleziono tekst wyszukiwania lub-1, jeśli ciąg wyszukiwania nie został znaleziony lub w <paramref name="str" /> parametrze określono pusty ciąg wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje tekst określony `str` w parametrze i zwraca lokalizację pierwszego znaku w kontrolce. <xref:System.Windows.Forms.RichTextBox.Find%2A> Jeśli właściwość zwraca wartość ujemną, wyszukiwany ciąg tekstowy nie został odnaleziony w zawartości kontrolki. Za pomocą tej metody można utworzyć funkcje wyszukiwania, które mogą być udostępniane użytkownikowi formantu. Możesz również użyć tej metody, aby wyszukać tekst, który ma zostać zastąpiony określonym formatem. Na przykład, jeśli użytkownik wprowadził daty do kontrolki, można użyć <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby wyszukać wszystkie daty w dokumencie i zastąpić je odpowiednim formatem przed <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> użyciem metody formantu.  
  
> [!NOTE]
>  Metody akceptujące jako parametr nie mogą znaleźć tekstu zawartego w więcej niż jednym <xref:System.Windows.Forms.RichTextBox>wierszu tekstu w. `string` <xref:System.Windows.Forms.RichTextBox.Find%2A> Wykonanie takiego wyszukiwania zwróci wartość ujemną (-1).  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje całą zawartość a <xref:System.Windows.Forms.RichTextBox> dla pierwszego wystąpienia ciągu wyszukiwania przekazaną do parametru Text metody. Jeśli ciąg wyszukiwania zostanie znaleziony w <xref:System.Windows.Forms.RichTextBox>, metoda zwraca `true` wartość i podświetla tekst wyszukiwania, w przeciwnym razie zwraca `false`. Przykład wymaga, aby ta metoda została umieszczona w klasie a <xref:System.Windows.Forms.Form> , która <xref:System.Windows.Forms.RichTextBox> zawiera nazwę `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tablica znaków do wyszukania.</param>
        <param name="start">Lokalizacja wewnątrz tekstu kontrolki, w której należy rozpocząć wyszukiwanie.</param>
        <summary>Wyszukuje tekst <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki w określonym punkcie początkowym dla pierwszego wystąpienia znaku z listy znaków.</summary>
        <returns>Lokalizacja w kontrolce, w której znajdują się znaki wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody poszukuje pierwszego wystąpienia znaku z listy znaków określonych `characterSet` w parametrze i zwraca lokalizację znaku. Na przykład można przekazać tablicę znaków zawierającą znak "Q". Jeśli kontrolka zawierała tekst "Quick Brown Fox", <xref:System.Windows.Forms.RichTextBox.Find%2A> Metoda zwróci wartość czterech. Wielkie litery i małe litery są uznawane za różne wartości w wyszukiwaniu.  
  
 Jeśli właściwość zwraca wartość ujemną, wyszukiwane znaki nie zostały odnalezione w zawartości formantu. Za pomocą tej metody można wyszukać grupę znaków w kontrolce. Jeśli zostanie znaleziony znak z listy znaków podany w `characterSet` parametrze metody, wartość zwracana przez tę metodę jest indeksem od zera położenia znaku w kontrolce. Spacja jest traktowana jako znak przez metodę podczas określania lokalizacji znaku.  
  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody umożliwia wyszukanie zestawu znaków z określonej pozycji początkowej w tekście kontrolki przez określenie wartości `start` parametru. Wartość zerowa wskazuje, że wyszukiwanie powinno zacząć się od początku dokumentu kontrolki. Możesz użyć tej wersji <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby zawęzić kryteria wyszukiwania, aby uniknąć tego, że tekst, który już znasz, nie zawiera określonych znaków wyszukiwanych lub nie jest istotny w wyszukiwaniu.  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje zawartość a <xref:System.Windows.Forms.RichTextBox> dla znaków, które są przesyłane do metody `text` z parametru. Wyszukiwanie rozpoczyna się od lokalizacji w <xref:System.Windows.Forms.RichTextBox> określonym `start` przez parametr `FindMyText` metody. Jeśli zawartość tablicy tekstu znajduje się w <xref:System.Windows.Forms.RichTextBox>, metoda zwraca indeks znalezionej wartości; w przeciwnym razie zwraca-1. Przykład wymaga, aby ta metoda została <xref:System.Windows.Forms.Form> umieszczona w klasie a, która <xref:System.Windows.Forms.RichTextBox> zawiera kontrolkę o `richTextBox1` nazwie i <xref:System.Windows.Forms.Button> kontrolkę `button1` o nazwie, która jest <xref:System.Windows.Forms.Control.Click> połączona z programem obsługi zdarzeń zdefiniowanym w przyklad.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, który ma zostać zlokalizowany w formancie.</param>
        <param name="options">Bitowa kombinacja <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> wartości.</param>
        <summary>Przeszukuje tekst w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce w poszukiwaniu ciągu z określonymi opcjami stosowanymi do wyszukiwania.</summary>
        <returns>Lokalizacja w kontrolce, w której znaleziono tekst wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje tekst określony `str` w parametrze i zwraca lokalizację pierwszego znaku w kontrolce. <xref:System.Windows.Forms.RichTextBox.Find%2A> Jeśli właściwość zwraca wartość ujemną, wyszukiwany ciąg tekstowy nie został odnaleziony w zawartości kontrolki. Za pomocą tej metody można utworzyć funkcje wyszukiwania, które mogą być udostępniane użytkownikowi formantu. Możesz również użyć tej metody, aby wyszukać tekst, który ma zostać zastąpiony określonym formatem. Na przykład, jeśli użytkownik wprowadził daty do kontrolki, można użyć <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby wyszukać wszystkie daty w dokumencie i zastąpić je odpowiednim formatem przed <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> użyciem metody formantu.  
  
 Za pomocą tej wersji <xref:System.Windows.Forms.RichTextBox.Find%2A> metody można określić opcje, które umożliwiają rozwijanie lub Zawężanie wyszukiwania. Można określić opcje, które umożliwiają dopasowanie wielkości liter w wyrazie wyszukiwania lub wyszukiwanie całych wyrazów zamiast częściowych wyrazów. Określając `RichTextBoxFinds.Reverse` Wyliczenie`options` w parametrze, można wyszukać tekst od dołu dokumentu na górze zamiast domyślnej metody wyszukiwania Góra do dołu.  
  
> [!NOTE]
>  Metody akceptujące jako parametr nie mogą znaleźć tekstu zawartego w więcej niż jednym <xref:System.Windows.Forms.RichTextBox>wierszu tekstu w. `string` <xref:System.Windows.Forms.RichTextBox.Find%2A> Wykonanie takiego wyszukiwania zwróci wartość ujemną (-1).  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje całą zawartość a <xref:System.Windows.Forms.RichTextBox> dla pierwszego wystąpienia ciągu wyszukiwania przekazaną do parametru Text metody. Jeśli ciąg wyszukiwania zostanie znaleziony w <xref:System.Windows.Forms.RichTextBox>, metoda zwraca `true` wartość i podświetla tekst; w przeciwnym razie zwraca `false`. W tym przykładzie określono również opcje wyszukiwania odpowiadające wielkości liter określonego ciągu wyszukiwania. Przykład wymaga, aby ta metoda została umieszczona w klasie a <xref:System.Windows.Forms.Form> , która <xref:System.Windows.Forms.RichTextBox> zawiera nazwę `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Tablica znaków do wyszukania.</param>
        <param name="start">Lokalizacja wewnątrz tekstu kontrolki, w której należy rozpocząć wyszukiwanie.</param>
        <param name="end">Lokalizacja w tekście kontrolki, w której chcesz zakończyć wyszukiwanie.</param>
        <summary>Przeszukuje zakres tekstu w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce pierwszego wystąpienia znaku z listy znaków.</summary>
        <returns>Lokalizacja w kontrolce, w której znajdują się znaki wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody poszukuje pierwszego wystąpienia znaku z listy znaków określonych `characterSet` w parametrze i zwraca lokalizację znaku. Na przykład można przekazać tablicę znaków zawierającą znak "Q". Jeśli kontrolka zawierała tekst "Quick Brown Fox", <xref:System.Windows.Forms.RichTextBox.Find%2A> Metoda zwróci wartość czterech. Wielkie litery i małe litery są uznawane za różne wartości w wyszukiwaniu.  
  
 Jeśli właściwość zwraca wartość ujemną, wyszukiwane znaki nie zostały odnalezione w zawartości formantu. Za pomocą tej metody można wyszukać grupę znaków w kontrolce. Jeśli zostanie znaleziony znak z listy znaków podany w `characterSet` parametrze metody, wartość zwracana przez tę metodę jest indeksem od zera pozycji znaku w kontrolce. Spacja jest traktowana jako znak przez metodę podczas określania lokalizacji znaku.  
  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody umożliwia wyszukanie zestawu znaków na podstawie zakresu tekstu w kontrolce, określając wartość `start` parametrów i `end` . Wartość zero dla `start` parametru wskazuje, że wyszukiwanie powinno zacząć się od początku dokumentu kontrolki. Wartość-1 `end` parametru wskazuje, że wyszukiwanie powinno kończyć się na końcu tekstu w kontrolce. Możesz użyć tej wersji <xref:System.Windows.Forms.RichTextBox.Find%2A> metody do zawężenia wyszukiwania do określonego zakresu tekstu w kontrolce, aby uniknąć przeszukiwania obszarów dokumentu, które nie są istotne dla potrzeb aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="characterSet" />ma wartość null.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="start" />jest mniejsza niż 0 lub większa niż długość tekstu w kontrolce.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, który ma zostać zlokalizowany w formancie.</param>
        <param name="start">Lokalizacja wewnątrz tekstu kontrolki, w której należy rozpocząć wyszukiwanie.</param>
        <param name="options">Bitowa kombinacja <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> wartości.</param>
        <summary>Przeszukuje tekst w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce w poszukiwaniu ciągu w określonej lokalizacji w kontrolce i z określonymi opcjami dotyczącymi wyszukiwania.</summary>
        <returns>Lokalizacja w kontrolce, w której znaleziono tekst wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje tekst określony `str` w parametrze i zwraca lokalizację pierwszego znaku ciągu wyszukiwania w formancie. <xref:System.Windows.Forms.RichTextBox.Find%2A> Jeśli właściwość zwraca wartość ujemną, wyszukiwany ciąg tekstowy nie został odnaleziony w zawartości kontrolki. Za pomocą tej metody można utworzyć funkcje wyszukiwania, które mogą być udostępniane użytkownikowi formantu. Możesz również użyć tej metody, aby wyszukać tekst, który ma zostać zastąpiony określonym formatem. Na przykład, jeśli użytkownik wprowadził daty do kontrolki, można użyć <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby wyszukać wszystkie daty w dokumencie i zastąpić je odpowiednim formatem przed <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> użyciem metody formantu.  
  
 Za pomocą tej wersji <xref:System.Windows.Forms.RichTextBox.Find%2A> metody można określić opcje, które umożliwiają rozwijanie lub Zawężanie wyszukiwania. Można określić opcje, które umożliwiają dopasowanie wielkości liter w wyrazie wyszukiwania lub wyszukiwanie całych wyrazów zamiast częściowych wyrazów. Określając `RichTextBoxFinds.Reverse` Wyliczenie`options` w parametrze, można wyszukać tekst od dołu dokumentu na górze zamiast domyślnej metody wyszukiwania Góra do dołu. Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody umożliwia również zawężenie wyszukiwania tekstu, wybierając określoną pozycję początkową wewnątrz tekstu kontrolki. Ta funkcja umożliwia uniknięcie tekstu, który mógł już zostać przeszukany lub gdzie określony szukany tekst nie istnieje. Gdy wartość jest określona `options` w parametrze `start` , wartość parametru wskazuje położenie, w którym zakończy się wyszukiwanie wsteczne, ponieważ wyszukiwanie rozpocznie się w dolnej części dokumentu w przypadku korzystania z tej wersji `RichTextBoxFinds.Reverse` <xref:System.Windows.Forms.RichTextBox.Find%2A> Metoda.  
  
> [!NOTE]
>  Metody akceptujące jako parametr nie mogą znaleźć tekstu zawartego w więcej niż jednym <xref:System.Windows.Forms.RichTextBox>wierszu tekstu w. `string` <xref:System.Windows.Forms.RichTextBox.Find%2A> Wykonanie takiego wyszukiwania zwróci wartość ujemną (-1).  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje całą zawartość a <xref:System.Windows.Forms.RichTextBox> dla pierwszego wystąpienia ciągu wyszukiwania przekazaną do parametru Text metody. Początkowa lokalizacja wyszukiwania jest określana przez parametr Start metody. Jeśli ciąg wyszukiwania znajduje się w <xref:System.Windows.Forms.RichTextBox>, metoda zwraca lokalizację indeksu pierwszego znaku znalezionego tekstu i podświetla znaleziony tekst; w przeciwnym razie zwraca wartość-1. W tym przykładzie określono również opcje wyszukiwania odpowiadające wielkości liter określonego ciągu wyszukiwania. Przykład wymaga, aby ta metoda została umieszczona w klasie a <xref:System.Windows.Forms.Form> , która <xref:System.Windows.Forms.RichTextBox> zawiera nazwę `richTextBox1`. Tego przykładu można użyć do wykonania typu "Znajdź następny" operacji. Po znalezieniu wystąpienia tekstu wyszukiwania można znaleźć inne wystąpienia tekstu, zmieniając wartość `start` parametru, aby wyszukać w lokalizacji poza pozycją bieżącego dopasowania.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Tekst, który ma zostać zlokalizowany w formancie.</param>
        <param name="start">Lokalizacja wewnątrz tekstu kontrolki, w której należy rozpocząć wyszukiwanie.</param>
        <param name="end">Lokalizacja w tekście kontrolki, w której chcesz zakończyć wyszukiwanie. Ta wartość musi być równa wartości ujemnej (-1) lub większej lub równej <paramref name="start" /> parametrowi.</param>
        <param name="options">Bitowa kombinacja <see cref="T:System.Windows.Forms.RichTextBoxFinds" /> wartości.</param>
        <summary>Przeszukuje tekst w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce pod kątem ciągu w obrębie zakresu tekstu w kontrolce oraz z określonymi opcjami stosowanymi do wyszukiwania.</summary>
        <returns>Lokalizacja w kontrolce, w której znaleziono tekst wyszukiwania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wyszukuje tekst określony `str` w parametrze i zwraca lokalizację pierwszego znaku ciągu wyszukiwania w formancie. <xref:System.Windows.Forms.RichTextBox.Find%2A> Jeśli właściwość zwraca wartość ujemną, wyszukiwany ciąg tekstowy nie został odnaleziony w zawartości kontrolki. Za pomocą tej metody można utworzyć funkcje wyszukiwania, które mogą być udostępniane użytkownikowi formantu. Możesz również użyć tej metody, aby wyszukać tekst, który ma zostać zastąpiony określonym formatem. Na przykład, jeśli użytkownik wprowadził daty do kontrolki, można użyć <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby wyszukać wszystkie daty w dokumencie i zastąpić je odpowiednim formatem przed <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> użyciem metody formantu.  
  
 Za pomocą tej wersji <xref:System.Windows.Forms.RichTextBox.Find%2A> metody można określić opcje, które umożliwiają rozwijanie lub Zawężanie wyszukiwania. Można określić opcje, które umożliwiają dopasowanie wielkości liter w wyrazie wyszukiwania lub wyszukiwanie całych wyrazów zamiast częściowych wyrazów. Określając `RichTextBoxFinds.Reverse` Wyliczenie`options` w parametrze, można wyszukać tekst od dołu dokumentu na górze zamiast domyślnej metody wyszukiwania Góra do dołu. Ta wersja <xref:System.Windows.Forms.RichTextBox.Find%2A> metody umożliwia również zawężenie wyszukiwania tekstu, zaznaczając konkretną pozycję początkową i końcową wewnątrz tekstu kontrolki. Ta funkcja umożliwia ograniczenie zakresu wyszukiwania do określonej sekcji tekstu formantu. Jeśli wartość ujemna (-1) jest przypisana do `end` parametru, Metoda zostanie przeszukana do końca tekstu <xref:System.Windows.Forms.RichTextBox> w wyszukiwaniach zwykłych. W przypadku wyszukiwania wstecznego wartość ujemna jedna (-1) przypisana do `end` parametru wskazuje, że tekst będzie przeszukiwany od końca tekstu (dół) do pozycji zdefiniowanej przez `start` parametr. Gdy parametry `end` i są podane tak samo, że cały formant jest przeszukiwany pod kątem normalnego wyszukiwania. `start` W przypadku wyszukiwania wstecznego cała kontrolka jest przeszukiwana, ale wyszukiwanie rozpoczyna się w dolnej części dokumentu i wyszukuje na początku dokumentu.  
  
> [!NOTE]
>  Metody akceptujące jako parametr nie mogą znaleźć tekstu zawartego w więcej niż jednym <xref:System.Windows.Forms.RichTextBox>wierszu tekstu w. `string` <xref:System.Windows.Forms.RichTextBox.Find%2A> Wykonanie takiego wyszukiwania zwróci wartość ujemną (-1).  
  
   
  
## Examples  
 Poniższy przykład kodu przeszukuje sekcję tekstu w <xref:System.Windows.Forms.RichTextBox> dla pierwszego wystąpienia ciągu wyszukiwania przekazaną `searchText` do parametru metody. Zakres wyszukiwania tekstu w kontrolce jest określany przez `searchStart` parametry i `searchEnd` metody. Jeśli ciąg wyszukiwania znajduje się w <xref:System.Windows.Forms.RichTextBox>, metoda zwraca lokalizację indeksu pierwszego znaku znalezionego tekstu i podświetla znaleziony tekst; w przeciwnym razie zwraca wartość-1. W przykładzie zastosowano `options` również parametr <xref:System.Windows.Forms.RichTextBox.Find%2A> metody, aby określić, że znaleziony tekst powinien być zgodny z wielkością liter ciągu wyszukiwania. Przykład wymaga, aby ta metoda została umieszczona w klasie a <xref:System.Windows.Forms.Form> , która <xref:System.Windows.Forms.RichTextBox> zawiera kontrolkę o `richTextBox1`nazwie. Po znalezieniu pierwszego wystąpienia ciągu wyszukiwania można użyć tego przykładu, aby znaleźć inne wystąpienia w tekście.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> Parametr został<see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość <paramref name="start" /> parametru była mniejsza od zera.

—lub— 
Parametr był krótszy niż <paramref name="start" />parametr. <paramref name="end" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę tekstu wyświetlanego przez kontrolkę.</summary>
        <value><see cref="T:System.Drawing.Font" /> Do zastosowania do tekstu wyświetlanego przez kontrolkę. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultFont" /> właściwości.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu formantu.</summary>
        <value><see cref="T:System.Drawing.Color" /> Reprezentujący kolor pierwszego planu formantu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharFromPosition">
      <MemberSignature Language="C#" Value="public char GetCharFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char GetCharFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharFromPosition (pt As Point) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; char GetCharFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetCharFromPosition : System.Drawing.Point -&gt; char" Usage="richTextBox.GetCharFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="pt">Lokalizacja do przeszukania.</param>
        <summary>Pobiera znak najbliższy określonej lokalizacji.</summary>
        <returns>Znak w określonej lokalizacji.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Lokalizacja do przeszukania.</param>
        <summary>Pobiera indeks znaku znajdującego się najbliżej określonej lokalizacji.</summary>
        <returns>Indeks znakowy liczony od zera w określonej lokalizacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zwraca indeks znaku, który znajduje się najbliżej pozycji określonej w `pt` parametrze. Indeks znaku jest indeksem tekstu w kontrolce, w tym spacjami. Za pomocą tej metody można określić, gdzie w tekście użytkownik ma wskaźnik myszy, przekazując Współrzędne myszy do tej metody. Może to być przydatne, jeśli chcesz wykonywać zadania, gdy użytkownik umieści wskaźnik myszy nad słowem w tekście kontrolki.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> użycia metody <xref:System.Windows.Forms.RichTextBox.Find%2A> z metodą w celu wyszukania określonego ciągu w <xref:System.Windows.Forms.RichTextBox> kontrolce i wyświetlenia indeksu znaków, <xref:System.Windows.Forms.RichTextBox> gdzie znaleziony ciąg znajduje się w kontroli. Przykład wyszukuje wyraz "brązowy" w zawartości kontrolki i zwraca pozycję indeksu znaku, gdzie znaleziono ciąg wyszukiwania. W tym przykładzie jest wymagane posiadanie formularza zawierającego <xref:System.Windows.Forms.RichTextBox> kontrolkę o nazwie `richTextBox1` , która zawiera tekst. Wymaga również, aby kod w przykładzie był połączony ze <xref:System.Windows.Forms.Control.MouseDown> zdarzeniem. <xref:System.Windows.Forms.RichTextBox>  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Pozycja indeksu znaków do przeszukania.</param>
        <summary>Pobiera numer wiersza z podanej pozycji znaku w tekście <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki.</summary>
        <returns>Numer wiersza (liczony od zera), w którym znajduje się indeks znaków.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia określenie numeru wiersza w oparciu o indeks znaków określony w `index` parametrze metody. Pierwszy wiersz tekstu w kontrolce zwraca wartość zero. <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> Metoda zwraca numer linii fizycznej, w której znajduje się indeksowany znak w kontrolce. Na przykład, jeśli część pierwszej logicznej linii tekstu w kontrolce jest zawijana do następnego wiersza, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> Metoda zwraca wartość 1, jeśli znak w określonym indeksie znaków został opakowany do drugiego wiersza fizycznego. Jeśli <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> jest ustawiona na `false`, żadna część wiersza nie jest zawijana do następnego, a metoda zwraca wartość 0 dla określonego indeksu znaków. Za pomocą tej metody można określić, w którym wierszu znajduje się określony indeks znaków. Na przykład po wywołaniu <xref:System.Windows.Forms.RichTextBox.Find%2A> metody w celu wyszukania tekstu można uzyskać indeks znaku, w którym znajdują się wyniki wyszukiwania. Możesz wywołać tę metodę z indeksem znaku zwracanym przez <xref:System.Windows.Forms.RichTextBox.Find%2A> metodę, aby określić, który wiersz został znaleziony.  
  
 W niektórych przypadkach nie <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> zgłasza wyjątku, `index` gdy parametr jest nieprawidłową wartością. Na przykład:  
  
-   Jeśli parametr ma <xref:System.Int32.MinValue> wartość lub-1, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> zwraca 0. `index`  
  
-   <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> `Lines.Length-1` <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> Jeśli parametr jest długością tekstu lub <xref:System.Int32.MaxValue>, zwraca numer ostatniego wiersza tekstu, który nie musi być taki sam jak w zależności od wartości właściwości. `index`  
  
 W takich przypadkach Sprawdź poprawność danych wejściowych <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>przed wywołaniem.  
  
> [!NOTE]
>  Jeśli indeks znaków określony w `index` parametrze wykracza poza dostępną liczbę wierszy zawartych w kontrolce, zwracany jest ostatni numer wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> metody. Aby uruchomić przykład, wklej następujący kod w postaci <xref:System.Windows.Forms.RichTextBox> zawierającej kontrolkę o nazwie `RichTextBox1`, przycisk o nazwie `Button1` i dwa pola tekstowe o nazwach `TextBox2` `TextBox1` i. Gdy jest uruchomiony ten przykład, wprowadź ciąg wyszukiwania w `TextBox2` i kliknij przycisk, aby uzyskać wyniki wyszukiwania.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks znaku, dla którego ma zostać pobrana lokalizacja.</param>
        <summary>Pobiera lokalizację w kontrolce pod określonym indeksem znaku.</summary>
        <returns>Lokalizacja określonego znaku.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pozwala określić, gdzie w kontrolce znajduje się określony indeks znaków. Tej metody można użyć do takich zadań jak wyświetlanie elementów menu skrótów lub pomocy dla wyrazu w kontrolce. Jeśli na przykład chcesz wyświetlić menu opcji dla użytkownika, gdy użytkownik kliknie prawym przyciskiem myszy słowo w kontrolce, możesz użyć tej metody, aby określić położenie wyrazu w celu prawidłowego wyświetlenia <xref:System.Windows.Forms.ContextMenu> kontrolki.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje podczas operacji przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie poziomy pasek przewijania formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.HScroll> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.HScroll> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przełącza metody wejściowe w wersji azjatyckiej systemu operacyjnego Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.ImeChange> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.ImeChange> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą <see cref="T:System.Windows.Forms.RichTextBox" /> ustawienia dla edytora IME (Input Method Editor) i języka azjatyckiego.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie link w tekście kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia, aby przetworzyć łącze, które zostało kliknięte w formancie. Korzystając z informacji dostarczonych do programu obsługi zdarzeń, można określić, który Link został kliknięty w dokumencie.  
  
> [!IMPORTANT]
>  Domyślnie łącza są wyświetlane jako tekst i nie są klikane. Aby można je było klikać, <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> ustaw właściwość `true`na.  
  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera procedurę obsługi zdarzeń dla <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzenia. Program obsługi zdarzeń tworzy łącze w dokumencie <xref:System.Windows.Forms.RichTextBox> kontrolki i uruchamia wystąpienie domyślnej przeglądarki ( <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> przy użyciu metody), wyświetlając stronę klikniętego łącza. Ten przykład wymaga, aby program obsługi zdarzeń był połączony ze <xref:System.Windows.Forms.RichTextBox.LinkClicked> zdarzeniem <xref:System.Windows.Forms.RichTextBox>dla.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ładuje zawartość pliku do <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i lokalizacja pliku do załadowania do kontrolki.</param>
        <summary>Ładuje tekst sformatowany (RTF) lub standardowy plik tekstowy ASCII do <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ładowania pliku przy użyciu <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody zawartość załadowanego pliku zastępuje całą zawartość <xref:System.Windows.Forms.RichTextBox> formantu. Spowoduje to zmianę wartości <xref:System.Windows.Forms.TextBoxBase.Text%2A> właściwości i. <xref:System.Windows.Forms.RichTextBox.Rtf%2A> Tej metody można użyć do załadowania utworzonego wcześniej tekstu lub dokumentu RTF do kontrolki do manipulowania. Jeśli chcesz zapisać plik, możesz użyć <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody.  
  
> [!NOTE]
>  W tej wersji <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody, jeśli ładowany plik nie jest dokumentem RTF, wystąpi wyjątek. Aby załadować inny typ pliku, taki jak plik tekstowy ASCII, użyj innych wersji tej metody, które akceptują wartość z <xref:System.Windows.Forms.RichTextBoxStreamType> wyliczenia jako parametr.  
  
> [!NOTE]
>  Metoda nie otworzy pliku, dopóki nie zostanie utworzone dojście <xref:System.Windows.Forms.RichTextBox>dla elementu. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Upewnij się, że dojście kontrolki zostało utworzone przed <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> wywołaniem metody.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera plik RTF do <xref:System.Windows.Forms.RichTextBox> kontrolki. W przykładzie używa <xref:System.Windows.Forms.OpenFileDialog> klasy do wyświetlania okna dialogowego, aby zażądać pliku od użytkownika. Następnie kod ładuje plik z założeniem, że jest to plik dokumentu RTF. Jeśli plik nie jest, przykładowy kod zgłosi wyjątek. Ten przykład wymaga, aby kod został umieszczony w <xref:System.Windows.Forms.Form> klasie, która <xref:System.Windows.Forms.RichTextBox> ma kontrolkę o `richTextBox1`nazwie.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas ładowania pliku do kontrolki.</exception>
        <exception cref="T:System.ArgumentException">Ładowany plik nie jest dokumentem RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do otwierania pliku. Skojarzone Wyliczenie: <see langword="Read" /> Wartość .<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Strumień danych do załadowania <see cref="T:System.Windows.Forms.RichTextBox" /> do kontrolki.</param>
        <param name="fileType">Jedna z <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> wartości.</param>
        <summary>Ładuje zawartość istniejącego strumienia danych do <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody służy do <xref:System.Windows.Forms.RichTextBox> ładowania danych z istniejącego strumienia danych. Dane, które są ładowane do formantu, zastępują całą zawartość <xref:System.Windows.Forms.RichTextBox> formantu. Spowoduje to zmianę wartości <xref:System.Windows.Forms.TextBoxBase.Text%2A> właściwości i. <xref:System.Windows.Forms.RichTextBox.Rtf%2A> Za pomocą tej metody można załadować plik, który został wcześniej otwarty w strumieniu danych w formancie do manipulowania. Jeśli chcesz zapisać zawartość formantu z powrotem w strumieniu, możesz użyć <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody, która <xref:System.IO.Stream> akceptuje obiekt jako parametr.  
  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody umożliwia również określenie typu danych ładowanych do kontrolki. Ta funkcja umożliwia korzystanie ze strumieni danych, które zawierają dane inne niż dokumenty Rich Text Format (RTF) do kontrolki.  
  
> [!NOTE]
>  Metoda nie otworzy pliku, dopóki nie zostanie utworzone dojście <xref:System.Windows.Forms.RichTextBox>dla elementu. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Upewnij się, że dojście kontrolki zostało utworzone przed <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> wywołaniem metody.  
  
   
  
## Examples  
 W poniższym przykładowym kodzie zaprezentowano użycie metod <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> i <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> ze strumieniami. Pokazano także użycie elementów członkowskich <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType> i <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>.  
  
 Jest to kompletny przykład, gotowy do uruchomienia przez skopiowanie do projektu.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas ładowania pliku do kontrolki.</exception>
        <exception cref="T:System.ArgumentException">Ładowany plik nie jest dokumentem RTF.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i lokalizacja pliku do załadowania do kontrolki.</param>
        <param name="fileType">Jedna z <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> wartości.</param>
        <summary>Ładuje określony typ pliku do <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ładowania pliku przy użyciu <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody zawartość załadowanego pliku zastępuje całą zawartość <xref:System.Windows.Forms.RichTextBox> formantu. Spowoduje to zmianę wartości <xref:System.Windows.Forms.TextBoxBase.Text%2A> właściwości i. <xref:System.Windows.Forms.RichTextBox.Rtf%2A> Tej metody można użyć do załadowania utworzonego wcześniej dokumentu tekstu lub tekstu sformatowanego (RTF) do kontrolki do manipulowania. Jeśli chcesz zapisać plik, możesz użyć <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody.  
  
 Możesz użyć tej wersji <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody, aby określić typ pliku do załadowania pliku. Ta funkcja umożliwia ładowanie plików innych niż dokumenty RTF do kontrolki.  
  
> [!NOTE]
>  Metoda nie otworzy pliku, dopóki nie zostanie utworzone dojście <xref:System.Windows.Forms.RichTextBox>dla elementu. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Upewnij się, że dojście kontrolki zostało utworzone przed <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> wywołaniem metody.  
  
   
  
## Examples  
 Poniższy przykład kodu otwiera plik tekstowy w <xref:System.Windows.Forms.RichTextBox> kontrolce. W przykładzie używa <xref:System.Windows.Forms.OpenFileDialog> klasy do wyświetlania okna dialogowego, aby zażądać pliku od użytkownika. Następnie kod ładuje ten plik do <xref:System.Windows.Forms.RichTextBox> kontrolki. W przykładzie użyto tej wersji <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> metody, aby określić, że plik zostanie otwarty jako plik tekstowy ASCII zamiast standardowego formatu tekstu sformatowanego. Ten przykład wymaga, aby kod został umieszczony w <xref:System.Windows.Forms.Form> klasie, która <xref:System.Windows.Forms.RichTextBox> ma kontrolkę o `richTextBox1`nazwie.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas ładowania pliku do kontrolki.</exception>
        <exception cref="T:System.ArgumentException">Ładowany plik nie jest dokumentem RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do otwierania pliku. Skojarzone Wyliczenie: <see langword="Read" /> Wartość .<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną liczbę znaków, którą użytkownik może wpisać lub wkleić do kontrolki pola tekstowego tekstu sformatowanego.</summary>
        <value>Liczba znaków, które można wprowadzić do kontrolki. Wartość domyślna to <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość ma wartość 0, Maksymalna długość tekstu, którą można wprowadzić w kontrolce, wynosi 64 KB znaków. Ta właściwość jest zwykle używana, <xref:System.Windows.Forms.RichTextBox> gdy jest używany do wyświetlania pojedynczego wiersza tekstu w formacie tekstu sformatowanego (RTF). Za pomocą tej właściwości można ograniczyć długość tekstu wprowadzonego w kontrolce dla wartości, takich jak kody pocztowe i numery telefonów, lub ograniczyć długość tekstu wprowadzanego, gdy dane mają być wprowadzane w bazie danych. Można ograniczyć tekst wprowadzony w formancie do maksymalnej długości odpowiedniego pola w bazie danych.  
  
> [!NOTE]
>  W kodzie, można ustawić wartość <xref:System.Windows.Forms.TextBoxBase.Text%2A> właściwości na wartość, która ma długość większą niż wartość określona <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> przez właściwość. Ta właściwość ma wpływ tylko na tekst wprowadzony w kontrolce w czasie wykonywania.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć właściwości, <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> aby określić, czy tekst przypisany <xref:System.Windows.Forms.RichTextBox> do kontrolki jest większy niż wartość <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> przypisana do właściwości. Jeśli tekst nie jest większy, w przykładzie zostanie użyta <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> właściwość do przypisania tekstu do kontrolki. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza i że metoda w przykładzie jest wywoływana z tekstem dostarczonym do parametru, który ma zostać wklejony do kontrolki. Przykład wymaga również, <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> aby właściwość została ustawiona na wartość, aby ograniczyć wprowadzanie tekstu <xref:System.Windows.Forms.RichTextBox>do.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość przypisana do właściwości jest mniejsza niż 0.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest to formant wielowierszowy <see cref="T:System.Windows.Forms.RichTextBox" /> .</summary>
        <value><see langword="true" />Jeśli formant jest formantem wielowierszowym <see cref="T:System.Windows.Forms.RichTextBox" /> ; w przeciwnym razie,. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.HScroll" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.ImeChange" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.LinkClickedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.Protected" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected override void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnTextChanged : EventArgs -&gt; unit" Usage="richTextBox.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="e">Obiekt, który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.RichTextBox.VScroll" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Format schowka, w którym dane mają być pobierane ze schowka.</param>
        <summary>Wkleja zawartość schowka w określonym formacie Schowka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można wkleić dane ze schowka do kontrolki. Ta wersja <xref:System.Windows.Forms.RichTextBox.Paste%2A> metody różni się <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> od metody, ponieważ umożliwia wklejenie tylko tekstu w określonym formacie Schowka. Możesz użyć metody, <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> aby określić, czy dane w schowku są w określonym formacie Schowka. Następnie można wywołać tę wersję <xref:System.Windows.Forms.RichTextBox.Paste%2A> metody, aby upewnić się, że operacja wklejania zostanie wykonana z odpowiednim formatem danych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.RichTextBox.Paste%2A> metody do wklejenia mapy bitowej <xref:System.Windows.Forms.RichTextBox> do kontrolki. Po otwarciu mapy bitowej z pliku, przykład używa <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> metody do kopiowania mapy bitowej do Schowka systemu Windows. Na koniec przykład pobiera format dla <xref:System.Drawing.Bitmap> obiektu, sprawdza, czy format można wkleić <xref:System.Windows.Forms.RichTextBox> do <xref:System.Windows.Forms.RichTextBox.Paste%2A> kontrolki i używa metody do wklejenia danych.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">do odczytu ze schowka. Skojarzone Wyliczenie: <see langword="AllClipboard" /> <see cref="T:System.Security.Permissions.UIPermissionClipboard" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="m">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat okna do przetworzenia.</param>
        <param name="keyData">Jedna z <see cref="T:System.Windows.Forms.Keys" /> wartości reprezentujących klucz do przetworzenia.</param>
        <summary>Przetwarza klucz polecenia.</summary>
        <returns><see langword="true" />Jeśli znak został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik próbuje zmodyfikować chroniony tekst w kontrolce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia w aplikacjach, aby określić, kiedy użytkownik próbuje zmodyfikować tekst oznaczony jako chroniony w formancie. Procedura obsługi zdarzeń może być używana do powiadamiania użytkownika o tym, że tekst, który użytkownik próbuje zmodyfikować, jest chroniony lub aby wyświetlić okno dialogowe, które umożliwia użytkownikowi wprowadzenie odpowiednich zmian do tekstu. Na przykład, Jeśli chroniony obszar jest datą, można wyświetlić okno dialogowe, które umożliwia użytkownikowi wybranie daty, którą można następnie zastosować do tekstu kontrolki.  
  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.Protected> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.Protected> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To zdarzenie nie jest istotne dla tej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie stosuje ostatnią operację, która została cofnięta w kontrolce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Następnie można użyć <xref:System.Windows.Forms.RichTextBox.Redo%2A> metody do ponownego zastosowania ostatniej operacji cofania do kontrolki. <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> Metoda pozwala określić, czy Ostatnia operacja, która została cofnięta, może zostać ponownie zastosowana do kontrolki.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> właściwości <xref:System.Windows.Forms.RichTextBox.Redo%2A> i <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> i metody w celu ograniczenia operacji wykonaj ponownie do dowolnej akcji poza usunięciem tekstu. Ten przykład wymaga, aby masz formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę oraz że operacja w ramach programu <xref:System.Windows.Forms.RichTextBox> została wykonana i cofnięta przed wykonaniem kodu w tym przykładzie.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę akcji, którą można ponownie zastosować do kontrolki, gdy <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> wywoływana jest metoda.</summary>
        <value>Ciąg, który reprezentuje nazwę akcji, która zostanie wykonana w przypadku wywołania <see cref="M:System.Windows.Forms.RichTextBox.Redo" /> metody.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość zwraca pusty ciąg (""), nie jest dostępna żadna operacja do ponownego zastosowania do kontrolki. Za pomocą tej metody można określić ostatnią akcję cofniętą w <xref:System.Windows.Forms.RichTextBox> kontrolce, którą można następnie ponownie zastosować do kontrolki, gdy wywołanie <xref:System.Windows.Forms.RichTextBox.Redo%2A> metody zostanie wykonane. Można określić, czy istnieją operacje, które mają być ponownie zastosowane do formantu przy użyciu <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> właściwości <xref:System.Windows.Forms.RichTextBox.Redo%2A> i <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> i metody w celu ograniczenia operacji wykonaj ponownie do dowolnej akcji poza usunięciem tekstu. Ten przykład wymaga, aby masz formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę oraz że operacja w ramach programu <xref:System.Windows.Forms.RichTextBox> została wykonana i cofnięta przed wykonaniem kodu w tym przykładzie.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest odpowiednia dla tej klasy.</summary>
        <value><see langword="true" />Jeśli klawisze skrótów są włączone; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar pojedynczego wiersza tekstu w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce.</summary>
        <value>Rozmiar pojedynczego wiersza tekstu w kontrolce (w pikselach). Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy w kontrolce wprowadzono wartość większą od zera, niewidoczny margines jest umieszczany w kontrolce o określonej liczbie pikseli od lewej strony kontrolki. Wszelkie wprowadzone teksty wykraczające poza ten margines są umieszczane w następnym wierszu tekstu w kontrolce. Ta właściwość ma wpływ na cały tekst wprowadzony w kontrolce, a także dodatkowy tekst wprowadzony w kontrolce po ustawieniu właściwości. Za pomocą tej właściwości można określić maksymalną szerokość linii dla całego tekstu wprowadzonego w <xref:System.Windows.Forms.RichTextBox> kontrolce.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć <xref:System.Windows.Forms.RichTextBox> powiększenie, które powiększa się w tekście, automatycznie zaznacza słowa w tekście kontrolki, gdy słowo jest podwójnie kliknięte i ma margines po prawej stronie obszaru klienckiego kontrolki. Jeśli kontrolka ma małą szerokość, przy użyciu tego kodu <xref:System.Windows.Forms.RichTextBox> utworzysz każdy znak tekstu w osobnym wierszu. <xref:System.Windows.Forms.RichTextBox> W tej pionowej pozycji wyświetlania kliknięcie dowolnej części słowa spowoduje zaznaczenie wszystkich znaków wyrazu, niezależnie od tego, czy tekst jest wyświetlany pionowo. Ten przykład wymaga, aby był formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę o nazwie. `richTextBox1`  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona wartość była mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki, w tym wszystkie kody tekstu sformatowanego (RTF).</summary>
        <value>Tekst kontrolki w formacie RTF.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do umieszczania tekstu sformatowanego RTF w kontrolce do wyświetlania lub do wyodrębnienia tekstu formantu z określonym formatowaniem RTF zdefiniowanym w tekście kontrolki. Ta właściwość jest zazwyczaj używana podczas przypisywania tekstu RTF z innego źródła RTF, takiego jak Microsoft Word lub Windows WordPad, do kontrolki.  
  
 Jeśli zmienisz <xref:System.Windows.Forms.Control.RightToLeft%2A> właściwość w czasie wykonywania, zachowywany jest tylko nieprzetworzony tekst bez formatowania.  
  
 W przypadku kodów RTF Zobacz sekcję specyfikacja formatu tekstu sformatowanego (RTF), wersja 1,6 "w bibliotece MSDN pod adresem http://msdn.microsoft.com/library.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zapisuje zawartość <see cref="T:System.Windows.Forms.RichTextBox" /> do pliku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i lokalizacja pliku do zapisania.</param>
        <summary>Zapisuje zawartość <see cref="T:System.Windows.Forms.RichTextBox" /> pliku w formacie tekstu sformatowanego (RTF).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Metoda umożliwia zapisanie całej zawartości formantu do pliku RTF, który może być używany przez inne programy, takie jak programy Microsoft Word i Windows WordPad. Jeśli nazwa pliku, który jest przekazywany do `path` parametru już istnieje w określonym katalogu, plik zostanie nadpisany bez powiadomienia. Możesz użyć metody, <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> aby załadować zawartość pliku <xref:System.Windows.Forms.RichTextBox>do.  
  
> [!NOTE]
>  Aby zapisać zawartość formantu w innym formacie pliku, takim jak tekst ASCII, użyj innych wersji tej metody, które akceptują wartość z <xref:System.Windows.Forms.RichTextBoxStreamType> wyliczenia jako parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu zapisuje zawartość <xref:System.Windows.Forms.RichTextBox> kontrolki do pliku RTF. W przykładzie używa <xref:System.Windows.Forms.SaveFileDialog> klasy do wyświetlania okna dialogowego do żądania od użytkownika, ścieżki i nazwy pliku do zapisania. Następnie kod zapisuje plik z założeniem, że zawartość jest w formacie tekstu sformatowanego. Jeśli plik już istnieje, zostanie automatycznie nadpisany. Ten przykład wymaga, aby kod został umieszczony w <xref:System.Windows.Forms.Form> klasie, która <xref:System.Windows.Forms.RichTextBox> ma kontrolkę o `richTextBox1`nazwie.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas zapisywania zawartości kontrolki do pliku.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Strumień danych zawierający plik do zapisania.</param>
        <param name="fileType">Jedna z <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> wartości.</param>
        <summary>Zapisuje zawartość <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki w otwartym strumieniu danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody umożliwia zapisanie całej zawartości formantu do strumienia danych, który jest już otwarty. Strumień danych może następnie zapisać informacje w pliku. Możesz użyć metody, <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> aby załadować zawartość pliku <xref:System.Windows.Forms.RichTextBox>do.  
  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody umożliwia również określenie formatu danych informacji, które zostaną wysłane <xref:System.IO.Stream> do obiektu.  
  
   
  
## Examples  
 W poniższym przykładowym kodzie zaprezentowano użycie metod <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> i <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> ze strumieniami. Pokazano także użycie elementów członkowskich <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType> i <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType>.  
  
 Jest to kompletny przykład, gotowy do uruchomienia przez skopiowanie do projektu.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">W <paramref name="fileType" /> parametrze określono nieprawidłowy typ pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas zapisywania zawartości kontrolki do pliku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do tworzenia lub modyfikowania pliku. Skojarzone Wyliczenie: <see langword="Write" /> Wartość .<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Nazwa i lokalizacja pliku do zapisania.</param>
        <param name="fileType">Jedna z <see cref="T:System.Windows.Forms.RichTextBoxStreamType" /> wartości.</param>
        <summary>Zapisuje zawartość <see cref="T:System.Windows.Forms.RichTextBox" /> do określonego typu pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Metoda umożliwia zapisanie całej zawartości formantu do pliku RTF, który może być używany przez inne programy, takie jak programy Microsoft Word i Windows WordPad. Jeśli nazwa pliku, który jest przekazywany do `path` parametru już istnieje w określonym katalogu, plik zostanie nadpisany bez powiadomienia. Możesz użyć metody, <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> aby załadować zawartość pliku <xref:System.Windows.Forms.RichTextBox>do.  
  
 Ta wersja <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody pozwala określić typ pliku, do którego ma zostać zapisana zawartość formantu. Za pomocą tej funkcji można upewnić się, że plik jest zapisany w odpowiednim formacie, na podstawie zawartości kontrolki. Jeśli na przykład dokument nie zawiera różnic w stylu czcionki ani kolorowanie, można zapisać plik jako plik tekstowy ASCII, ustawiając `fileType` parametr na. `RichTextBoxStreamType.PlainText`  
  
   
  
## Examples  
 Poniższy przykład kodu zapisuje zawartość <xref:System.Windows.Forms.RichTextBox> do pliku tekstowego ASCII. W przykładzie używa <xref:System.Windows.Forms.SaveFileDialog> klasy do wyświetlania okna dialogowego, aby zażądać ścieżki i nazwy pliku od użytkownika. Następnie kod zapisuje zawartość kontrolki do tego pliku. W przykładzie użyto tej wersji <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> metody, aby określić, że plik powinien być zapisany jako plik tekstowy ASCII zamiast standardowego formatu tekstu sformatowanego. Ten przykład wymaga, aby kod został umieszczony w <xref:System.Windows.Forms.Form> klasie, która <xref:System.Windows.Forms.RichTextBox> ma kontrolkę o `richTextBox1`nazwie.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">W <paramref name="fileType" /> parametrze określono nieprawidłowy typ pliku.</exception>
        <exception cref="T:System.IO.IOException">Wystąpił błąd podczas zapisywania zawartości kontrolki do pliku.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">do tworzenia lub modyfikowania pliku. Skojarzone Wyliczenie: <see langword="Write" /> Wartość .<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ pasków przewijania do wyświetlenia w <see cref="T:System.Windows.Forms.RichTextBox" /> formancie.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> wartości. Wartość domyślna to <see langword="RichTextBoxScrollBars.Both" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia przechodzenie w poziomie i w pionie pionowych pasków przewijania <xref:System.Windows.Forms.RichTextBox> do użytkownika kontrolki, aby umożliwić przewijanie tekstu w kontrolce, która jest poza wymiarem fizycznym formantu. Można także użyć tej właściwości, aby usunąć paski przewijania z formantu, aby ograniczyć przewijanie zawartości formantu.  
  
> [!NOTE]
>  Poziome paski przewijania nie będą wyświetlane, jeśli <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> jest `true`, niezależnie <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> od wartości właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określona wartość nie jest zdefiniowana w <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" /> wyliczeniu.</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst sformatowany w formacie tekstu sformatowanego (RTF) w kontrolce.</summary>
        <value>Zaznaczony tekst RTF w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia uzyskanie zaznaczonego tekstu w kontrolce, w tym kodów formatowania RTF. Ta właściwość umożliwia skopiowanie tekstu z kontrolki, zakończenie z formatowaniem i wklejenie tekstu w innych aplikacjach, które akceptują tekst sformatowany RTF, takich jak Microsoft Word i Windows WordPad. Aby uzyskać zaznaczony tekst bez kodów formatowania RTF, użyj <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> właściwości.  
  
 Jeśli żaden tekst nie jest zaznaczony, tekst określony w tej właściwości zostanie wstawiony w punkcie wstawiania. Jeśli tekst jest zaznaczony, każdy tekst przypisany do tej właściwości zastępuje zaznaczony tekst.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zaznaczony tekst w obrębie <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Ciąg, który reprezentuje zaznaczony tekst w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> kodu demonstruje <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, jak używać właściwości z właściwościami, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>i <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> , aby utworzyć listę punktowaną w <xref:System.Windows.Forms.RichTextBox> kontrolce. Ten przykład wymaga, aby <xref:System.Windows.Forms.RichTextBox> kontrolka `richTextBox1` o nazwie została utworzona w formularzu.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wyrównanie, które ma zostać zastosowane do bieżącego zaznaczenia lub punktu wstawiania.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie wybrano żadnego akapitu w kontrolce, ustawienie tej właściwości stosuje ustawienie wyrównania do akapitu, w którym pojawia się punkt wstawiania, a także do akapitów utworzonych po akapicie, który ma ustawienie właściwości wyrównania. Na przykład, jeśli w <xref:System.Windows.Forms.RichTextBox> kontrolce znajdują się dwa akapity, a punkt wstawiania znajduje się w drugim akapicie. Jeśli ustawisz <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> właściwość na `HorizontalAlignment.Center`, akapit w punkcie wstawiania będzie wyorodkowany w kontrolce. Po utworzeniu akapitu trzeciego po drugim akapicie jest on również wyrównany do środka kontrolki.  
  
 Jeśli zaznaczenie zostanie wykonane w formancie, gdy właściwość jest ustawiona, wszystkie zaznaczone akapity są wyrównane na podstawie tego ustawienia właściwości. Ta właściwość służy do wyrównywania akapitów w dokumencie tworzonym w <xref:System.Windows.Forms.RichTextBox>. Na przykład jeśli chcesz, aby wszystkie akapity dokumentu były wyśrodkowane, możesz zaznaczyć wszystkie akapity w kontrolce i ustawić <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> właściwość na. `HorizontalAlignment.Center`  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A>zwraca `SelectionAlignment.Left` , gdy zaznaczenie tekstu zawiera wiele akapitów z wyrównaniem mieszanym.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wyrównywania tekstu w elemencie <xref:System.Windows.Forms.RichTextBox>. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określona wartość nie jest jedną z wartości zdefiniowanych w <see cref="T:System.Windows.Forms.HorizontalAlignment" /> klasie.</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tekstu, gdy tekst jest zaznaczony w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce.</summary>
        <value>Reprezentujący kolor tekstu, gdy tekst jest zaznaczony. <see cref="T:System.Drawing.Color" /> Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> , aby uzyskać lub ustawić kolor zaznaczonego tekstu <xref:System.Windows.Forms.RichTextBox>w. Jeśli żaden tekst nie jest obecnie zaznaczony, <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> właściwość ma zastosowanie do bieżącej pozycji karetki. Znaki wprowadzane z tego położenia mają określony <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy styl punktora jest stosowany do bieżącego zaznaczenia lub punktu wstawiania.</summary>
        <value><see langword="true" />Jeśli bieżące zaznaczenie lub punkt wstawiania ma zastosowany styl punktora; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli tekst nie jest zaznaczony, styl punktora jest stosowany do bieżącego punktu wstawiania i do wszystkich akapitów, które użytkownik wprowadza po punkcie wstawiania. Styl punktora jest stosowany do tekstu kontrolki do momentu przesunięcia punktu wstawiania lub naciśnięcia klawisza ENTER w pustym elemencie punktora.  
  
 Jeśli tekst jest zaznaczony w kontrolce, gdy ta właściwość jest ustawiona, wszystkie akapity w zaznaczonym tekście są konwertowane na elementy punktowane na liście punktowanej. Ta właściwość służy do tworzenia list punktowanych w dokumentach tworzonych w <xref:System.Windows.Forms.RichTextBox> formancie.  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> Właściwość umożliwia określenie wielkości wcięcia, która ma zostać zastosowana między punktorem a tekstem elementu punktowanego.  
  
   
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> kodu demonstruje <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, jak używać właściwości z właściwościami, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>i <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> , aby utworzyć listę punktowaną w <xref:System.Windows.Forms.RichTextBox> kontrolce. Ten przykład wymaga, aby <xref:System.Windows.Forms.RichTextBox> kontrolka `richTextBox1` o nazwie została utworzona w formularzu.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie zaznaczenia tekstu w kontrolce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia, aby określić, kiedy użytkownik zmienił wybór tekstu w formancie. Procedura obsługi zdarzeń dla tego zdarzenia może służyć do zachowania tekstu wybranego do momentu ukończenia zadania przez użytkownika w aplikacji.  
  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.SelectionChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.SelectionChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy tekst w formancie ma być wyświetlany w linii bazowej, jako indeks górny, czy jako indeks dolny poniżej linii bazowej.</summary>
        <value>Liczba, która określa Przesunięcie znaku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości musi należeć do zakresu od-2000 do 2000.  
  
 Jeśli ta właściwość ma wartość zero, tekst jest wyświetlany w linii bazowej. Jeśli jest to liczba dodatnia, liczba określa liczbę pikseli, przez którą ma zostać podniesiony wybór tekstu powyżej linii bazowej. Jeśli jest to liczba ujemna, ta liczba określa liczbę pikseli, przez które ma być uruchamiany indeks tekstu. Za pomocą tej właściwości można określić tekst jako indeks górny lub dolny.  
  
 Jeśli nie wybrano żadnego tekstu, przesunięcie jest stosowane do bieżącego punktu wstawiania i do całego tekstu, który użytkownik wpisze po punkcie wstawiania. Przesunięcie znaku ma zastosowanie do momentu zmiany właściwości na inną wartość lub do momentu przeniesienia punktu wstawiania do innej sekcji w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Za pomocą tej właściwości można utworzyć indeks górny i dolny dla takich aplikacji jako wyrażenia matematyczne.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak określić indeks górny i dolny w obrębie <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> przy użyciu właściwości. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określona wartość jest mniejsza niż-2000 lub większa niż 2000.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tekstu bieżącego zaznaczenia tekstu lub punktu wstawiania.</summary>
        <value><see cref="T:System.Drawing.Color" /> Reprezentuje kolor, który ma zostać zastosowany do bieżącego zaznaczenia tekstu lub do tekstu wprowadzonego po punkcie wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dla bieżącego zaznaczenia tekstu określono więcej niż jeden kolor, ta właściwość zwraca `Color.Empty`. Jeśli nie wybrano żadnego tekstu, kolor tekstu określony w tej właściwości jest stosowany do bieżącego punktu wstawiania i do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie kolor tekstu stosuje się do momentu zmiany właściwości na inny kolor lub do momentu przeniesienia punktu wstawiania do innej sekcji w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Ta właściwość służy do zmiany koloru tekstu w <xref:System.Windows.Forms.RichTextBox>.  
  
 Aby tekst był pogrubiony w formancie, użyj <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> właściwości, aby przypisać nową czcionkę, która ma określony styl czcionki pogrubionej.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Windows.Forms.ColorDialog> dla użytkownika, aby określić kolor bieżącego zaznaczonego tekstu lub tekst wprowadzony po bieżącym punkcie wstawiania <xref:System.Windows.Forms.RichTextBox> w kontrolce. Ten przykład wymaga, aby metoda zdefiniowana w przykładzie została dodana do <xref:System.Windows.Forms.Form> klasy, która <xref:System.Windows.Forms.RichTextBox> zawiera kontrolkę o nazwie `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę bieżącego wyboru tekstu lub punktu wstawiania.</summary>
        <value>Reprezentujący czcionkę, która ma zostać zastosowana do bieżącego zaznaczenia tekstu lub do tekstu wprowadzonego po punkcie wstawiania. <see cref="T:System.Drawing.Font" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli dla bieżącego zaznaczenia tekstu określono więcej niż jedną czcionkę, ta właściwość jest `null`. Jeśli nie wybrano żadnego tekstu, czcionka określona w tej właściwości jest stosowana do bieżącego punktu wstawiania i do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie czcionki stosuje się do momentu zmiany właściwości na inną czcionkę lub do momentu, gdy punkt wstawiania zostanie przeniesiony do innej sekcji w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Ta właściwość służy do zmiany stylu czcionki tekstu w <xref:System.Windows.Forms.RichTextBox>. Tekst w formancie może być pogrubiony, pisany kursywą i podkreślony. Możesz również zmienić rozmiar tekstu i czcionkę zastosowana do tekstu.  
  
 Aby zmienić kolor tekstu w kontrolce, użyj <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia bieżące ustawienie stylu pogrubienia czcionki dla zaznaczonego tekstu lub tekstu wprowadzonego po punkcie wstawiania w <xref:System.Windows.Forms.RichTextBox> kontrolce. Ten przykład wymaga, aby kod został zawarty w metodzie w <xref:System.Windows.Forms.Form>. Przykład wymaga <xref:System.Windows.Forms.RichTextBox>również, aby nazwa `richTextBox1`, <xref:System.Windows.Forms.Form>została dodana do.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odległość między lewą krawędzią pierwszego wiersza tekstu w wybranym akapicie a lewą krawędzią kolejnych wierszy w tym samym akapicie.</summary>
        <value>Odległość, w pikselach, dla wcięcia wysunięcie stosowanego do bieżącego zaznaczenia tekstu lub punktu wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie wybrano żadnego tekstu, wysunięcie jest stosowane do akapitu, w którym pojawia się punkt wstawiania, oraz do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie wysunięcie jest stosowane do momentu zmiany właściwości na inną wartość lub do momentu przeniesienia punktu wstawiania do innego akapitu w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Możesz użyć tej właściwości, aby zastosować wysunięcie do akapitów.  
  
 Aby ustawić wcięcie pierwszego wiersza zaznaczenia akapitu, użyj <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak określić wysunięcie <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> przy użyciu właściwości. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia długość wcięcia wiersza, w którym rozpocznie się wybór, w pikselach.</summary>
        <value>Bieżąca odległość (w pikselach) wcięcia zastosowane po lewej stronie bieżącego zaznaczenia tekstu lub punktu wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie wybrano żadnego tekstu, ustawienie wcięcia jest stosowane do akapitu, w którym pojawia się punkt wstawiania, oraz do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie wcięcia stosuje się do momentu zmiany właściwości na inną wartość lub do momentu przeniesienia punktu wstawiania do innego akapitu w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Za pomocą tej właściwości można wciąć akapity zawarte w dokumencie <xref:System.Windows.Forms.RichTextBox>. Tej właściwości można użyć w połączeniu z programem, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> aby utworzyć akapity wyświetlane w akapitach.  
  
 Aby utworzyć wysunięcie dla akapitów w kontrolce, użyj <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób określania wcięcia tekstu w obrębie <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> właściwości przy użyciu. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia liczbę znaków wybranych w formancie.</summary>
        <value>Liczba znaków wybranych w polu tekstowym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można określić, czy dowolne znaki są aktualnie zaznaczone w formancie pola tekstowego przed wykonaniem operacji na zaznaczonym tekście. Można także użyć tej właściwości do określenia łącznej liczby znaków (w tym spacji), które są wybierane podczas wykonywania jednoznakowych zadań `for` w pętli.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć właściwości, <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> aby określić, czy tekst jest zaznaczony <xref:System.Windows.Forms.RichTextBox>w obrębie. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza. Przykład wymaga również, aby `richTextBox1` zawierał tekst zaznaczony w kontrolce.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy bieżący wybór tekstu jest chroniony.</summary>
        <value><see langword="true" />Jeśli bieżące zaznaczenie nie pozwala na wprowadzanie zmian w jego zawartości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie wybrano żadnego tekstu, ustawienie ochrony jest stosowane do akapitu, w którym pojawia się punkt wstawiania, oraz do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie ochrona stosuje się do momentu zmiany właściwości na inną wartość lub do momentu przeniesienia punktu wstawiania do innego akapitu w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Tej właściwości można użyć, aby uniemożliwić użytkownikowi modyfikowanie sekcji tekstu w formancie.  
  
 Jeśli ta właściwość jest ustawiona na `true` <xref:System.Windows.Forms.RichTextBox.Protected> , zdarzenie jest zgłaszane, gdy użytkownik próbuje zmienić bieżący wybór tekstu.  
  
> [!NOTE]
>  Ta właściwość `true` zwróci wartość tylko wtedy, gdy cały wybór w formancie zawiera zawartość chronioną.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób określania chronionego tekstu w obrębie <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> przy użyciu właściwości. Ten przykład wymaga <xref:System.Windows.Forms.RichTextBox> , aby kontrolka o `richTextBox1`nazwie została dodana do formularza i że <xref:System.Windows.Forms.RichTextBox> kontrolka ma do niej dodany tekst zawierający słowo "RichTextBox".  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Odległość (w pikselach) między prawą krawędzią <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolki a prawą krawędzią tekstu, który jest zaznaczony lub dodany w bieżącym punkcie wstawiania.</summary>
        <value>Obszar wcięcia (w pikselach) po prawej stronie bieżącego zaznaczenia lub punktu wstawiania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nie wybrano żadnego tekstu, ustawienie wcięcia jest stosowane do akapitu, w którym pojawia się punkt wstawiania, oraz do całego tekstu, który jest wpisywany do kontrolki po punkcie wstawiania. Ustawienie wcięcia stosuje się do momentu zmiany właściwości na inną wartość lub do momentu przeniesienia punktu wstawiania do innego akapitu w kontrolce.  
  
 Jeśli tekst jest zaznaczony wewnątrz kontrolki, zaznaczony tekst i dowolny tekst wprowadzony po zaznaczeniu tekstu będą mieć zastosowana wartość tej właściwości. Za pomocą tej właściwości można wciąć akapity zawarte w dokumencie <xref:System.Windows.Forms.RichTextBox>. Tej właściwości można użyć w połączeniu z programem, <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> aby utworzyć akapity wyświetlane w akapitach.  
  
 Aby utworzyć wysunięcie dla akapitów w kontrolce, użyj <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć prawy margines <xref:System.Windows.Forms.RichTextBox> przy <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> użyciu właściwości. Przykład wymaga, aby masz formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę o nazwie `richTextBox1`i że przykładowy kod jest wywoływany ze zdarzenia w obrębie klasy formularza.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bezwzględne położenie tabulatora w <see cref="T:System.Windows.Forms.RichTextBox" /> kontrolce.</summary>
        <value>Tablica, w której każdy element członkowski Określa przesunięcie tabulatora (w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia uzyskanie tablicy zawierającej odstępy dla każdej karty w bieżącym zaznaczeniu tekstu w <xref:System.Windows.Forms.RichTextBox> formancie. Tej właściwości można następnie użyć do dostosowania rozmiaru każdej karty w obrębie zaznaczenia tekstu. Na przykład jeśli chcesz dostosować obszar tabulacji w dokumencie, możesz wybrać cały dokument i uzyskać listę spacji tabulacji przy użyciu <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> właściwości. Następnie można dostosować je do nowych wartości i przypisać je ponownie do tej właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Tablica ma więcej niż maksymalną liczbę elementów 32.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ zaznaczenia wewnątrz kontrolki.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można określić typ danych, które są aktualnie zaznaczone w kontrolce w celu zapewnienia prawidłowej obsługi zaznaczenia podczas wykonywania zadań w obrębie formantu w bieżącym zaznaczeniu. Właściwość może reprezentować dowolną kombinację wartości z <xref:System.Windows.Forms.RichTextBoxSelectionTypes> wyliczenia reprezentującą wiele typów obiektów w bieżącym zaznaczeniu.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, <see cref="T:System.Windows.Forms.RichTextBox" />czy w elemencie zostanie wyświetlony margines zaznaczenia.</summary>
        <value><see langword="true" />Jeśli margines zaznaczenia jest włączony w formancie; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można umożliwić użytkownikowi łatwe zaznaczanie wierszy tekstu w <xref:System.Windows.Forms.RichTextBox>. Margines zaznaczenia zostanie dodany po lewej stronie <xref:System.Windows.Forms.RichTextBox>. Ten margines ułatwia użytkownikowi wybranie tekstu rozpoczynającego się po lewej stronie kontrolki. Użytkownik może kliknąć na marginesie zaznaczenia, aby zaznaczyć pojedynczy wiersz tekstu, lub kliknąć dwukrotnie, aby zaznaczyć cały akapit, w którym znajduje się podwójna linia.  
  
> [!NOTE]
>  `RichTextBoxScrollBars.Horizontal` <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> `true`Jeśli właściwość jest ustawiona na, ustawienie właściwości na, `RichTextBoxScrollBars.Vertical`lub `RichTextBoxScrollBars.Both` nie spowoduje wyświetlenia pasków przewijania. <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> Aby wyświetlić paski przewijania, gdy <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> właściwość jest ustawiona na `true`, ustaw <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> właściwość na `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`lub `RichTextBoxScrollBars.ForcedBoth`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący tekst w polu tekstu sformatowanego.</summary>
        <value>Tekst wyświetlany w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyświetlić wiele wierszy tekstu w <xref:System.Windows.Forms.RichTextBox>, <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> ustaw właściwość na `true`. Aby odczytać lub ustawić tekst wielowierszowego pola tekstowego, użyj <xref:System.Windows.Forms.TextBoxBase.Lines%2A> właściwości. Właściwość nie zwraca żadnych informacji o formatowaniu zastosowanym do zawartości <xref:System.Windows.Forms.RichTextBox>. <xref:System.Windows.Forms.RichTextBox.Text%2A> Aby uzyskać kody formatowania tekstu sformatowanego (RTF), użyj <xref:System.Windows.Forms.RichTextBox.Rtf%2A> właściwości. Ilość tekstu, którą można wprowadzić w <xref:System.Windows.Forms.RichTextBox> kontrolce, jest ograniczona tylko przez dostępną ilość pamięci systemowej.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość tekstu w kontrolce.</summary>
        <value>Liczba znaków zawartych w tekście kontrolki.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę akcji, którą można cofnąć w kontrolce, gdy <see cref="M:System.Windows.Forms.TextBoxBase.Undo" /> Metoda jest wywoływana.</summary>
        <value>Nazwa tekstowa akcji, którą można cofnąć.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia określenie ostatniej akcji, która została wykonana w obrębie formantu, który można cofnąć. Za pomocą tej właściwości można ograniczyć operacje dostępne do cofnięcia przez użytkownika formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie pionowe paski przewijania formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o sposobie obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.RichTextBox.VScroll> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.RichTextBox> o nazwie. `RichTextBox1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.RichTextBox.VScroll> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Obiekt komunikatu systemu Windows.</param>
        <summary>Przetwarza wiadomości systemu Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący poziom <see cref="T:System.Windows.Forms.RichTextBox" />powiększenia.</summary>
        <value>Współczynnik, za pomocą którego zawartość kontrolki jest powiększona.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości może należeć do zakresu od 1/64 (0,015625) do 64,0, nie włącznie. Wartość 1,0 wskazuje, że powiększenie nie jest stosowane do kontrolki. Funkcja zoom działa optymalnie, gdy dokument zawiera czcionki TrueType. Gdy czcionka, która nie jest TrueType, jest używana w dokumencie kontrolki, <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> właściwość będzie używać najbliższej wartości liczbowej. Można użyć tej właściwości, aby umożliwić użytkownikowi <xref:System.Windows.Forms.RichTextBox> kontrolce powiększanie do sekcji dokumentacji, które są zbyt małe, aby wyświetlić lub zaskraplać widok, aby umożliwić wyświetlanie większej liczby dokumentów na ekranie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak utworzyć <xref:System.Windows.Forms.RichTextBox> powiększenie, które powiększa się w tekście, automatycznie zaznacza słowa w tekście kontrolki, gdy słowo jest podwójnie kliknięte i ma margines po prawej stronie obszaru klienckiego kontrolki. Jeśli kontrolka ma małą szerokość, przy użyciu tego kodu <xref:System.Windows.Forms.RichTextBox> utworzysz każdy znak tekstu w osobnym wierszu. <xref:System.Windows.Forms.RichTextBox> W tej pionowej pozycji wyświetlania kliknięcie dowolnej części słowa spowoduje zaznaczenie wszystkich znaków wyrazu, niezależnie od tego, czy tekst jest wyświetlany pionowo. Ten przykład wymaga, aby był formularz, który zawiera <xref:System.Windows.Forms.RichTextBox> kontrolkę o nazwie. `richTextBox1`  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Określony współczynnik powiększenia nie mieści się w dozwolonym zakresie.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

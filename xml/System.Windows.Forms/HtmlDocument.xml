<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="de61a40d29466f5571748e067903d4dbe58bd524" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36521315" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <TypeSignature Language="F#" Value="type HtmlDocument = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia dostęp programistyczny najwyższego poziomu w dokumencie HTML obsługiwanych przez <see cref="T:System.Windows.Forms.WebBrowser" /> formantu.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> udostępnia otokę zarządzanego obiektu dokumentu programu Internet Explorer, znanej także jako HTML modelu DOM (Document Object). Uzyskać wystąpienia <xref:System.Windows.Forms.HtmlDocument> za pośrednictwem <xref:System.Windows.Forms.WebBrowser.Document%2A> właściwość <xref:System.Windows.Forms.WebBrowser> formantu.  
  
 Tagi HTML wewnątrz dokumentu HTML może być zagnieżdżone wewnątrz siebie. <xref:System.Windows.Forms.HtmlDocument> w związku z tym reprezentuje drzewa dokumentu, którego elementy podrzędne są wystąpieniami elementu <xref:System.Windows.Forms.HtmlElement> klasy. Poniższy przykład kodu pokazuje prostego pliku HTML.  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 W tym przykładzie <xref:System.Windows.Forms.HtmlDocument> reprezentuje cały dokument wewnątrz `HTML` tagów. `BODY`, `DIV`, `FORM` i `SPAN` tagi są reprezentowane przez poszczególne <xref:System.Windows.Forms.HtmlElement> obiektów.  
  
 Istnieje kilka sposobów, można uzyskać dostępu do elementów w tym drzewie. Użyj <xref:System.Windows.Forms.HtmlDocument.Body%2A> właściwości, aby uzyskać dostęp do `BODY` znacznika i wszystkie jego elementy podrzędne. <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> Właściwość <xref:System.Windows.Forms.HtmlElement> dla elementu na stronę HTML, który ma fokus wprowadzania użytkownika. Wszystkie elementy na stronie HTML może mieć nazwę; <xref:System.Windows.Forms.HtmlDocument.All%2A> kolekcji zapewnia dostęp do każdego <xref:System.Windows.Forms.HtmlElement> jako indeks za pomocą jego nazwy. <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> Zwraca <xref:System.Windows.Forms.HtmlElementCollection> wszystkich <xref:System.Windows.Forms.HtmlElement> obiekty z danego nazwa tagu HTML, takie jak `DIV` lub `TABLE`. <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> Zwraca pojedynczą <xref:System.Windows.Forms.HtmlElement> odpowiadający Unikatowy identyfikator, który podasz. <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> Zwraca <xref:System.Windows.Forms.HtmlElement> znajdującymi się na ekranie we współrzędnych wskaźnika myszy dostarczony.  
  
 Można również użyć <xref:System.Windows.Forms.HtmlDocument.Forms%2A> i <xref:System.Windows.Forms.HtmlDocument.Images%2A> kolekcji do iterowania po elementach użytkownika reprezentuje dane wejściowe formularzy i grafiki, odpowiednio.  
  
 <xref:System.Windows.Forms.HtmlDocument> jest oparta na niezarządzanych interfejsy implementowane przez Internet Explorer DHTML DOM: `IHTMLDocument`, `IHTMLDocument2`, `IHTMLDocument3`, i `IHTMLDocument4`. Tylko najczęściej używane właściwości i metody w tych niezarządzane interfejsy są udostępniane przez <xref:System.Windows.Forms.HtmlDocument>. Można uzyskać dostępu do innych właściwości i metody bezpośrednio za pomocą <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> właściwości, które można rzutować na żądany interfejs niezarządzanego wskaźnika.  
  
 Dokument HTML może zawierać ramek, które są różne windows wewnątrz <xref:System.Windows.Forms.WebBrowser> formantu. Każdej ramce własnej strony HTML. <xref:System.Windows.Forms.HtmlWindow.Frames%2A> Kolekcji jest dostępna za pośrednictwem <xref:System.Windows.Forms.HtmlDocument.Window%2A> właściwości. Można także użyć <xref:System.Windows.Forms.HtmlDocument.Window%2A> właściwość, aby zmienić rozmiar wyświetlanych strony, przewiń dokument o lub wyświetlić alerty i wyświetla monit dla użytkownika.  
  
 <xref:System.Windows.Forms.HtmlDocument> przedstawia najbardziej typowe zdarzenia, która może obsłużyć odnośnie do hostowania stron HTML. W przypadku zdarzeń nie są udostępniane bezpośrednio przez interfejs, można dodać obsługi dla zdarzenia za pomocą <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A>.  
  
 Można znaleźć w plikach HTML `SCRIPT` tagi, które hermetyzują kod napisany w jednym języku wykonywanie aktywnych skryptów, takich jak JScript i VBScript. <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Metoda zapewnia wykonanie właściwości i metody zdefiniowane w `SCRIPT` tagu.  
  
> [!NOTE]
>  Podczas gdy większość właściwości, metod i zdarzeń na <xref:System.Windows.Forms.HtmlDocument> zostały zachowane te same nazwy mają one na niezarządzanych DOM niektórych zostały zmienione w celu zachowania spójności z [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje dane z bazy danych Northwind, aby utworzyć `HTML TABLE` dynamicznie przy użyciu <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Najpierw metoda również jest używana do dodawania komórek (`TD` elementy) do wierszy (`TR` elementy), można dodać wiersze do tabeli, a następnie i na koniec można dołączyć tabeli do końca bieżącego dokumentu. Przykład kodu wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`. Kod powinna być wywoływana po załadowaniu dokumentu.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Udostępnia <see cref="T:System.Windows.Forms.HtmlElement" /> który aktualnie ma fokus wprowadzania użytkownika.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Który aktualnie ma fokus wprowadzania użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy dokument ma fokus, ale żaden element dokumentu nie będzie miał fokus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwraca element odpowiadający `<BODY>` tagu.  
  
 Jeśli dokument nie ma fokus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwraca `null`.  
  
 Jeśli bieżący element z fokusem wprowadzania jest komórki (`TD`) w formacie HTML `TABLE` tagu <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwróci element, który zawiera `TABLE` elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Drawing.Color" /> hiperłącza po kliknięciu przez użytkownika.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> Dla aktywnych łączy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łącze jest aktywne, gdy użytkownik jest kliknięcie jej. Zmień tę właściwość, aby zmienić kolor łącza przed nawigacji.  
  
 <xref:System.Drawing.Color> Wpisz [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` nie odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie elementu <see cref="T:System.Windows.Forms.HtmlElementCollection" />, który przechowuje wszystkie <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów dla dokumentu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> Wszystkich elementów w dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.All%2A> Kolekcji zapewnia dostęp losowy do dowolnego elementu w dokumencie HTML, niezależnie od jej położenie w drzewie dokumentu. Umożliwia ona dostęp do dowolnego elementu w dokumencie HTML, nazwa, identyfikator lub indeksu. Użytkownik może również przejść przez wszystkie elementy w dokumencie.  
  
 Niektóre elementy, takie jak `HEAD` i `TITLE`, nigdy nie będą mieć nazwy skojarzonych z nimi. Wszystkie inne elementy będą mieć nazwy tylko wtedy, gdy autor pliku HTML przypisaniu ich. Można uzyskać dostępu do elementów bez nazwy według Identyfikatora lub indeksu.  
  
 Nie można dodać elementów bezpośrednio do <xref:System.Windows.Forms.HtmlDocument.All%2A> kolekcji, ponieważ wszystkie elementy w kodzie HTML pliku poza `HTML` tag musi zawierać element nadrzędny. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody lub <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość <xref:System.Windows.Forms.HtmlElement> Dodawanie nowych elementów do drzewa.  
  
   
  
## Examples  
 Poniższy przykład kodu iterację wszystkich elementów w dokumencie i zestawy `Enabled=True`, włączanie elementów, które może być wyłączony domyślnie, aby zapobiec dane wejściowe użytkownika podczas ładowania dokumentu. Przykład kodu wymaga, aby aplikacja zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Zarządzany kod obsługujący zdarzenia.</param>
        <summary>Dodaje program obsługi zdarzeń dla nazwanego zdarzenia modelu DOM kodu HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy dołączyć zdarzenia do dokumentu lub jednego ze swoich obiektów aż do zakończenia ładowania dokumentu. Najwcześniejsza powinny wywoływać tej metody jest <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenie <xref:System.Windows.Forms.WebBrowser> formantu.  
  
 Ta metoda umożliwia dołączyć obsługi do niezarządzanego zdarzenia modelu DOM nie jest udostępniany przez <xref:System.Windows.Forms.HtmlDocument>. Aby uzyskać więcej informacji o dostępnych niezarządzane zdarzeń modelu DOM, zobacz [podczas uzyskiwania dostępu do nieujawnionych elementów w modelu obiektów zarządzanych dokumentów HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) i interfejsy IHTMLDocument: [IHTMLDocument](http://go.microsoft.com/fwlink/?LinkId=104882), [IHTMLDocument2](http://go.microsoft.com/fwlink/?LinkId=104884), [IHTMLDocument3](http://go.microsoft.com/fwlink/?LinkId=104886), [IHTMLDocument4](http://go.microsoft.com/fwlink/?LinkId=104887), [IHTMLDocument5](http://go.microsoft.com/fwlink/?LinkId=104888).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła dokumentu HTML.</summary>
        <value>
          <see cref="T:System.Drawing.Color" /> Tła dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> zostanie wyświetlony innych elementów zajmuje obszar tego ekranu.  
  
 <xref:System.Drawing.Color> Wpisz [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` nie odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Body : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElement" /> dla <c>treści</c> tagu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Obiekt do <c>treści</c> tagu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dokument HTML jest podzielony na dwie główne części:  
  
-   `HEAD`, które zawiera tytuł dokumentu, wszelkie dokumentu metadanych, i `SCRIPT` elementy.  
  
-   `BODY`, który zawiera wszystkie elementy związane z wyświetlanymi wygląd dokumentu.  
  
 Nie ma odpowiednika `Head` właściwość <xref:System.Windows.Forms.HtmlDocument>. Aby uzyskać `HEAD` elementu, użyj <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową `DIV` elementu i dołącza go do dolnej części w dokumencie przy użyciu <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie w dowolnym miejscu w dokumencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykrywa kliknięcie dokumentu, wyszukuje element i używa <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> do Dopasuj element w górnej części strony sieci Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik żąda, aby wyświetlić menu kontekstowe dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie jeśli kliknij prawym przyciskiem myszy dokumentu lub elementu w dokumencie, wyświetli określonego menu kontekstowe domyślne do elementu. Użyj tego zdarzenia, aby anulować wyświetlanie menu kontekstowego i wyświetlić własny.  
  
   
  
## Examples  
 Poniższy kod przykładowy przechwytywania <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> zdarzeń i używa go do wyświetlenia <xref:System.Windows.Forms.ContextMenuStrip>.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cookie : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pliki cookie HTTP skojarzone z tym dokumentem.</summary>
        <value>A <see cref="T:System.String" /> zawierającego listę plików cookie, każdy plik cookie oddzielone średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Właściwość <xref:System.Windows.Forms.HtmlDocument> udostępnia wszystkie pliki cookie, ustaw dla strony sieci Web.  
  
 A *pliku cookie* jest pary nazwa/wartość dowolnego skojarzone z daną stronę sieci Web. Deweloperzy sieci Web pliki cookie służą do śledzenia w przypadku użytkowników, odwiedź stronę lub wróć do witryny sieci Web. Plik cookie składa się z wielu części, smutek pliku cookie, które określają następujące czynności:  
  
-   Zestawu dokumentów, którego dotyczy pliku cookie; domena i ścieżkę.  
  
-   Nazwa i wartość pliku cookie.  
  
-   Data wygaśnięcia pliku cookie.  
  
-   Określa, czy plik cookie mogą być wysyłane tylko za pomocą bezpiecznego połączenia.  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Właściwość może zawierać wiele plików cookie.  
  
 Można używać tylko <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> właściwości można ustawić jednego pliku cookie naraz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.CreateElement elementTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">Nazwa elementu HTML do utworzenia.</param>
        <summary>Tworzy nową <see langword="HtmlElement" /> HTML określony typ znacznika.</summary>
        <returns>Nowy element typu określonego tagu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` może być jedna z obsługiwanych tagów HTML w programie Internet Explorer, z wyjątkiem `FRAME` lub `IFRAME`.  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> Zwraca element niedołączonej bieżące drzewo dokumentu. Aby dodać element do dokumentu, użyj <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> lub <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody.  
  
 Ta metoda nie wpłynie stan kodu źródłowego istniejący dokument, korzystając z <xref:System.Windows.Forms.WebBrowser> formantu **Wyświetl źródło** polecenia menu kontekstowego lub <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> i <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> właściwości <xref:System.Windows.Forms.WebBrowser> formant.  
  
 Podczas tworzenia nowych elementów z <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>, nie można ustawić niektórych właściwości, takich jak `Name`. W przypadkach, w którym należy ustawić atrybut Name, przypisz je jako HTML w celu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość innego obiektu w dokumencie.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje dane z bazy danych Northwind do utworzenia kodu HTML tabeli, używając <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Najpierw metoda również jest używana do dodawania komórek (`TD` elementy) do wierszy (`TR` elementy), można dodać wiersze do tabeli, a następnie i na koniec można dołączyć tabeli do końca bieżącego dokumentu. Przykład kodu wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultEncoding : string" Usage="System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie, używany domyślnie do bieżącego dokumentu.</summary>
        <value>
          <see cref="T:System.String" /> Reprezentujący kodowania, że przeglądarka używa po stronie wyświetlane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym kodowaniem jest kodowanie, będzie próbował użyć podczas ładowania strony do zarządzanego kodu HTML modelu DOM (Document Object). Ten typ kodowania pochodzi z programu Internet Explorer **kodowanie** ustawienia, lub z `META` znacznika osadzonego wewnątrz strony.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które chcesz zaprzestać obsługi.</param>
        <param name="eventHandler">Zarządzany kod obsługujący zdarzenia.</param>
        <summary>Usuwa program obsługi zdarzeń z nazwanym zdarzeń w modelu DOM. HTML</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg opisujący domeny tego dokumentu, ze względów bezpieczeństwa.</summary>
        <value>Nieprawidłowa domena.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie dwie strony sieci Web w różnych ramek nie będą mogli dostęp do siebie nawzajem zawartości przy użyciu skryptu; nawet www.microsoft.com i msdn.microsoft.com w tym wystąpieniu traktowane jako różnych domenach. Aby włączyć wykonywania skryptów dla stron z tej samej domeny najwyższego poziomu, można przypisać nową wartość do <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwości. W poprzednich przykładzie adres URL, ustawienie <xref:System.Windows.Forms.HtmlDocument.Domain%2A> do witryny microsoft.com umożliwiałyby obie strony do komunikowania się ze sobą.  
  
 Ciągi przypisane do <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwość musi być prawidłową domen najwyższego poziomu. W poprzednim przykładzie adres URL, można ustawić <xref:System.Windows.Forms.HtmlDocument.Domain%2A> do witryny microsoft.com, ale nie do .com, który umożliwia dowolnej strony w Internecie, aby skrypt zawartość strony.  
  
 Nie można użyć <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwości, aby włączyć wykonywania skryptów dla stron dostęp za pomocą dwóch różnych protokołów. Jeśli jednej ramki na stronie pochodzi z serwera sieci Web (protokół http://) oraz innego pochodzą z protokołu system (file://), nie będą oni mogli do komunikowania się ze sobą, niezależnie od wartości <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument <c>domeny</c> właściwość musi być prawidłową nazwę domeny za pomocą Konwencji systemu nazw domen (DNS, Domain Name System).</exception>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomDocument : obj" Usage="System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskaźnik interfejsu niezarządzane dla <see cref="T:System.Windows.Forms.HtmlDocument" />.</summary>
        <value>
          <see cref="T:System.Object" /> Reprezentujący <c>IDispatch</c> wskaźnik do dokumentu niezarządzane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> jest otokę dla Internet Explorer modelu DOM (Document Object), który jest zapisywany w modelu COM. Jeśli potrzebujesz dostępu do nieujawnionych właściwości lub metody podstawowej interfejsy modelu COM, takich jak `IHTMLDocument2`, można użyć tego obiektu na zapytania dla nich.  
  
 Aby użyć niezarządzane interfejsy, należy zaimportować biblioteki MSHTML (mshtml.dll) do aplikacji. Jednak możesz również wykonać nieujawnionych właściwości i metody, przy użyciu `IDispatch::Invoke` metody.  
  
   
  
## Examples  
 Poniższy kod przykładowy rzutowania <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> do `IHTMLDocument2` wskaźnik i wyświetla wartość `lastModified` właściwość, która informuje, gdy właściciel dokumentu ostatniej aktualizacji swoją zawartość. Przykład kodu wymaga <xref:System.Windows.Forms.Button> w formularzu o nazwie `Button6`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> uprawnienia. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie znaków dla tego dokumentu.</summary>
        <value>
          <see cref="T:System.String" /> Reprezentujący bieżący kodowania znaków.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlDocument.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do przetestowania.</param>
        <summary>Testy obiekt do porównania z bieżącym obiektem.</summary>
        <returns>
          <see langword="true" /> Jeśli obiekty są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ExecCommand : string * bool * obj -&gt; unit" Usage="htmlDocument.ExecCommand (command, showUI, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">Nazwa polecenia do wykonania.</param>
        <param name="showUI">Czy mają być wyświetlane okna dialogowe specyficzne dla polecenia lub pola komunikatów dla użytkownika.</param>
        <param name="value">Wartość do przypisania, za pomocą polecenia. Nie dotyczy wszystkich poleceń.</param>
        <summary>Wykonuje określone polecenie względem dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> zawiera dużą tablicę poleceń, dla których dostępne są żadnych metod narażone na <xref:System.Windows.Forms.HtmlDocument>. Przy użyciu <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> można wstawić nowych elementów HTML, wybierz i formatowanie tekstu i wyczyść wszystkie buforowane poświadczenia uwierzytelniania. Aby uzyskać pełną listę poleceń, zobacz [identyfikatory poleceń](http://go.microsoft.com/fwlink/?LinkId=198814).  
  
> [!NOTE]
>  Niektórych poleceń, takich jak kopiowanie, mieć zwracanych wartości. W bieżąca implementacja <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A>, nie można uzyskać wartość zwrotna z wywołania. Aby uzyskać zwracanych wartości, użyj odpowiedniej metody niezarządzanego na <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> zamiast tego odwołania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlDocument.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia fokus wprowadzania użytkownika w bieżącym dokumencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Windows.Forms.HtmlDocument.Focus%2A> ustawi fokus na <xref:System.Windows.Forms.WebBrowser> kontroli, jeśli formant aktualnie ma fokus. Jeśli dokument znajduje się wewnątrz `FRAME`, ta metoda umieści fokus na tej `FRAME` w `FRAMESET`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> uprawnienia, aby ustawić fokus na formularzu. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.UIPermissionWindow" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.HtmlDocument.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dokument ma fokus wprowadzania użytkownika.</summary>
        <value>
          <see langword="true" /> Jeśli dokument ma fokus; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed zamknięciem dokumentu otrzymuje fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.Focusing> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.Focusing> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tekstu dla dokumentu.</summary>
        <value>Kolor tekstu w dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> <xref:System.Drawing.Color> Wpisz [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` nie odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Forms : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Forms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich <c> &lt;formularza&gt; </c> elementów w dokumencie.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> z <c> &lt;formularza&gt; </c> elementów w dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dokument HTML może mieć co najmniej jeden `FORM` elementy z pól wejściowych do przesyłania danych z powrotem do serwera.  
  
 Programowo można przesłać `FORM` , uzyskując jego <xref:System.Windows.Forms.HtmlElement> i wywoływania jego `Submit` przy użyciu metody <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> metody.  
  
 Aby dodać nowy `FORM` do dokumentu, możesz utworzyć nową `FORM` tagu jako ciąg znaków i przypisz go do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości elementu wcześniej dodane do modelu DOM HTML; lub użyć <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody, ustaw jej właściwości, za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, i dodaj go jako element podrzędny istniejących przy użyciu elementu <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje wszystkie `Form` elementy w sieci Web i usuwa wszystkie dane wejściowe użytkownika, ustawienie formularze wartości domyślnych.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetElementById : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Atrybut ID elementu do pobrania.</param>
        <summary>Pobiera jeden <see cref="T:System.Windows.Forms.HtmlElement" /> przy użyciu elementu <c>identyfikator</c> atrybut jako klucz wyszukiwania.</summary>
        <returns>Zwraca pierwszy obiekt o takim samym <c>identyfikator</c> atrybut określona wartość lub <see langword="null" /> Jeśli <paramref name="id" /> nie można odnaleźć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli istnieje wiele elementów w dokumencie o tej samej wartości Identyfikatora <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> zwróci pierwsza z nich znalezione.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera nazwane `TABLE` z dokumentu, liczy w górę liczbę wierszy i wyświetla wyniki na stronie sieci Web. Przykład kodu wymaga <xref:System.Windows.Forms.WebBrowser> formantu w projekcie o nazwie `WebBrowser1`, i że załadowano strony sieci Web z `TABLE` których `ID` atrybut jest `Table1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromPoint : System.Drawing.Point -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementFromPoint point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">X, y pozycji elementu na ekranie względem lewego górnego narożnika dokumentu.</param>
        <summary>Pobiera element HTML, znajduje się na współrzędne określonego klienta.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElement" /> w lokalizacji określonej ekranu w dokumencie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> używa współrzędne klienta, w których lewego górnego rogu dokumentu jest przypisywana wartość (0,0). Współrzędne klienta dla bieżącej pozycji kursora można uzyskać za pomocą <xref:System.Windows.Forms.HtmlWindow.Position%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wykrywa kliknięcie dokumentu, wyszukuje element i używa <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> do Dopasuj element w górnej części strony sieci Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlDocument.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nazwa tagu HTML <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty, które ma zostać pobrane.</param>
        <summary>Pobiera kolekcję elementów z określonego tagu HTML.</summary>
        <returns>Kolekcję elementów, których nazwa tagu jest równa <paramref name="tagName" /> argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Strony HTML często używają `META` tag do osadzenia dowolnych informacji dotyczących dokumentu. Poniższy przykład kodu HTML pobiera wszystkie `META` znajdzie tagów w dokumencie HTML `META` tag o nazwie `Description`i wyświetla dla użytkownika. Przykład kodu wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlDocument.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tego obiektu.</summary>
        <returns>
          <see cref="T:System.Int32" /> Reprezentujący skrót tego obiektu w pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Images : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Images" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkie tagi obrazu w dokumencie.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów, dla każdego znacznika IMG w dokumencie. Elementy są zwracane z kolekcji w kolejności źródeł.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> Zwraca kolekcję <xref:System.Windows.Forms.HtmlElement> obiektów. Aby dostęp do atrybutów, takich jak `ALT` i `SRC`, które nie są bezpośrednio widoczne przez <xref:System.Windows.Forms.HtmlElement>, użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> metody.  
  
 Aby dodać nowy obraz do dokumentu, albo utwórz nową `IMG` tagu jako ciąg znaków i przypisz go do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości elementu wcześniej dodane do modelu DOM HTML; lub użyj <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody, ustaw jej właściwości, za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>i dodaj go jako element podrzędny istniejących przy użyciu elementu <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 W poniższym przykładzie kodu `ALT` atrybutu wszystkich obrazów w dokumencie i ustawia domyślne `ALT` atrybut, jeśli wartość nie jest już ustawiony.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga załadowano następującą stronę sieci Web.  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="htmlDocument.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa metody skryptu do wywołania.</param>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowy typ obiektu zwracanego przez <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> będą się różnić. Wywoływana funkcja wykonywanie aktywnych skryptów zwraca dane skalarne, takie jak ciąg lub liczba całkowita, będzie zwracaną jako ciąg. Jeśli zmienna zwraca obiekt opartych na skryptach, takich jak obiekt utworzony przy użyciu języka JScript lub języka VBScript `new` operatora, będzie typu `Object`. (Można wykonywać wywołania na takie obiekty, wywołując <xref:System.Object.GetType%2A> i przy użyciu <xref:System.Type.InvokeMember%2A>.) Jeśli element HTML DOM, takich jak zwraca `DIV` lub `TABLE`, będzie on typu `Object`; Jeśli dodano odwołanie projektu do MSHTML. Biblioteki DLL, jednak będzie można rzutować na jego określonego typu modelu DOM niezarządzane.  
  
 Może wywołać dowolną funkcję w języku wykonywanie aktywnych skryptów zainstalowany na komputerze użytkownika, w tym JScript i VBScript.  
  
 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Wykona nic, jeśli użytkownik jawnie wyłączył wykonywanie skryptu w programie Internet Explorer lub nie zezwala na to bieżącej konfiguracji zabezpieczeń dla strony sieci Web.  
  
   
  
## Examples  
 Poniższy przykład kodu wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga <xref:System.Windows.Forms.WebBrowser> w aplikacji o nazwie `WebBrowser1`, i że załadowano następującą stronę sieci Web.  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="htmlDocument.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa metody skryptu do wywołania.</param>
        <param name="args">Argumenty do przekazania do metody skryptu.</param>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowy typ obiektu zwracanego przez <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> będą się różnić. Wywoływana funkcja wykonywanie aktywnych skryptów zwraca dane skalarne, takie jak ciąg lub liczba całkowita, będzie zwracaną jako ciąg. Jeśli zmienna zwraca obiekt opartych na skryptach, takich jak obiekt utworzony przy użyciu języka JScript lub języka VBScript `new` operatora, będzie typu `Object`. (Można wykonywać wywołania na takie obiekty, wywołując <xref:System.Object.GetType%2A> i przy użyciu <xref:System.Type.InvokeMember%2A>.) Jeśli element HTML DOM, takich jak zwraca `DIV` lub `TABLE`, będzie on typu `Object`; Jeśli dodano odwołanie projektu do MSHTML. Biblioteki DLL, jednak będzie można rzutować na jego określonego typu modelu DOM niezarządzane.  
  
 Może wywołać dowolną funkcję w języku wykonywanie aktywnych skryptów zainstalowana na komputerze użytkownika, w tym JScript i VBScript.  
  
 Ta metoda będzie wykonywać nic, jeśli użytkownik jawnie wyłączył wykonywanie skryptu w programie Internet Explorer lub nie zezwala na to bieżącej konfiguracji zabezpieczeń dla strony sieci Web.  
  
   
  
## Examples  
 Poniższy przykład kodu wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga <xref:System.Windows.Forms.WebBrowser> w aplikacji o nazwie `WebBrowser1`, i że załadowano następującą stronę sieci Web.  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor hiperłącza.</summary>
        <value>Kolor hiperłącza w bieżącym dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> Wpisz [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` nie odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Links : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Links" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę wszystkich hiperłączy w tym dokumencie HTML.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> z <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta kolekcja będzie zawierać wszystkie linki utworzone za pomocą `A`, `LINK`, i `AREA` tagów HTML.  
  
 <xref:System.Windows.Forms.HtmlElement> Obiektów zawartych w tej kolekcji Hermetyzowanie niezarządzanej `IHTMLLinkElement` interfejsu. Aby uzyskać dostęp do właściwości interfejsu źródłowego bezpiecznie, użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy fokus jest pozostawienie formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.LosingFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.LosingFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie lewego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.MouseDown> Zdarzenie występuje przed <xref:System.Windows.Forms.HtmlDocument.Click> zdarzeń.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy jest już umieszczony nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy jest przesuwany nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseMove> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseMove> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy jest przesuwany nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni lewego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie do porównania.</param>
        <param name="right">Drugie wystąpienie do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Windows.Forms.HtmlDocument" /> wystąpienia reprezentują tę samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli określone wystąpienia są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="System.Windows.Forms.HtmlDocument.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie do porównania.</param>
        <param name="right">Drugie wystąpienie do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Windows.Forms.HtmlDocument" /> wystąpień nie reprezentują tę samą wartość.</summary>
        <returns>
          <see langword="true" /> Jeśli określone wystąpienia nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : bool -&gt; System.Windows.Forms.HtmlDocument" Usage="htmlDocument.OpenNew replaceInHistory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">Określa, czy nowe okno nawigacji należy zastąpić poprzedniego elementu w historii nawigacji modelu DOM.</param>
        <summary>Pobiera nową <see cref="T:System.Windows.Forms.HtmlDocument" /> do użycia z <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" /> metody.</summary>
        <returns>Nowy dokument do zapisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> usunie poprzednie załadowanego dokumentu, w tym wszystkie skojarzone stan, na przykład zmienne. Nie spowoduje zdarzenia nawigacji w <xref:System.Windows.Forms.WebBrowser> do wywołania.  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> zawsze tworzy nowy dokument w bieżącym oknie. Aby otworzyć dokument w nowym oknie, użyj <xref:System.Windows.Forms.HtmlWindow.Open%2A> metoda <xref:System.Windows.Forms.HtmlWindow> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu przygotowuje modelu DOM do zapisu i zapisuje nowego dokumentu przy użyciu <xref:System.Windows.Forms.HtmlDocument.Write%2A> metody.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool with get, set" Usage="System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia kierunek tekstu w bieżącym dokumencie.</summary>
        <value>
          <see langword="true" /> Jeśli renderuje tekst od prawej do lewej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> nie będzie miał wartości, chyba że został on ustawiony jawnie, albo w kodzie HTML.  
  
 W odróżnieniu od <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> właściwości formantów formularzy systemu Windows, <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> na zarządzany HTML DOM nie wpłynie na kierunek tekstu alfabetu łacińskiego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nawigacja do innej strony sieci Web jest zatrzymany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ładowania strony sieci Web zostanie zatrzymanie, jeśli kod program wywołuje <xref:System.Windows.Forms.WebBrowser.Stop%2A> metody <xref:System.Windows.Forms.WebBrowser> formantu. Nie powoduje niepowodzenia nawigacji spowodowany awarią sieci lub nieprawidłowo witryn sieci Web <xref:System.Windows.Forms.HtmlDocument.Stop> występuje.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu resetuje paska stanu w aplikacji formularzy systemu Windows podczas `Stop` wystąpiło zdarzenie. Przykład kodu wymaga <xref:System.Windows.Forms.StatusBar> formantu o nazwie `StatusBar1` w aplikacji.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość tekstu <c> &lt;tytuł&gt; </c> tag w bieżącym dokumencie HTML.</summary>
        <value>Tytuł bieżącego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlDocument.Title%2A> właściwość do identyfikacji dokumentu za zrozumiałą nazwę.  
  
 Zmiany w tej właściwości będzie również dotyczyła w <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> właściwość <xref:System.Windows.Forms.WebBrowser> formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy hiperłącze HTML do bieżącego dokumentu przy użyciu adresu URL dokumentu jako lokalizacji łącza i tytuł dokumentu jako tekst łącza. Przykład kodu wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlDocument.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL opisujące lokalizacji tego dokumentu.</summary>
        <value>A <see cref="T:System.Uri" /> reprezentujący adres URL tego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest tylko do odczytu. Aby przejść do nowego dokumentu, należy użyć <xref:System.Windows.Forms.WebBrowser.Url%2A> właściwość <xref:System.Windows.Forms.WebBrowser> formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.VisitedLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor łączy do stron HTML, które użytkownik ma już odwiedzać.</summary>
        <value>Kolor odwiedzonego łącza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Color` Wpisz [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` nie odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Window : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlDocument.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlWindow" /> skojarzony z tym dokumentem.</summary>
        <value>W oknie tego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie dokumenty HTML mają obiektu HTML DOM okno, który może służyć do modyfikowania rozmiaru ekranu dokumentu i otworzyć nowe okno, a także uzyskiwać dostęp do innych ważnych obiektów, takich jak <xref:System.Windows.Forms.HtmlHistory>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="htmlDocument.Write text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst HTML, który można zapisać do dokumentu.</param>
        <summary>Zapisuje nową stronę HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie wywołania <xref:System.Windows.Forms.HtmlDocument.Write%2A> powinien być poprzedzony wywołanie <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A>, która spowoduje wyczyszczenie bieżący dokument i wszystkie jego zmienne. Wywołaniami <xref:System.Windows.Forms.HtmlDocument.Write%2A> utworzy nowy dokument HTML w jego miejscu. Aby zmienić określonej części dokumentu, należy uzyskać odpowiednie <xref:System.Windows.Forms.HtmlElement> i ustawić jej <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości.  
  
 Zaleca się zapis całego prawidłowy HTML dokumentu za pomocą <xref:System.Windows.Forms.HtmlDocument.Write%2A> metody, w tym `HTML` i `BODY` tagów. Jednak jeśli piszesz tylko elementów HTML modelu DOM (Document Object) będzie dostarczać te elementy są dla Ciebie.  
  
   
  
## Examples  
 Poniższy przykład kodu zostanie otwarty nowy <xref:System.Windows.Forms.HtmlDocument> i zapisuje w pliku HTML.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>
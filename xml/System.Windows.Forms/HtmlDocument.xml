<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b55668d15b5ed2a45ed27c9ae49ab197052bf9f0" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53491951" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <TypeSignature Language="F#" Value="type HtmlDocument = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia najwyższego poziomu programistyczny dostęp do dokumentu HTML pracujących <see cref="T:System.Windows.Forms.WebBrowser" /> kontroli.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> udostępnia zarządzanych otoka wokół obiektu dokumentu programu Internet Explorer, znany także jako HTML Document Object Model (DOM). Uzyskaj wystąpienia <xref:System.Windows.Forms.HtmlDocument> za pośrednictwem <xref:System.Windows.Forms.WebBrowser.Document%2A> właściwość <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
 Tagi HTML w dokumencie HTML może być zagnieżdżone wewnątrz siebie nawzajem. <xref:System.Windows.Forms.HtmlDocument> ten sposób reprezentuje drzewo dokumentu, którego elementy podrzędne są wystąpieniami programu <xref:System.Windows.Forms.HtmlElement> klasy. Poniższy przykład kodu pokazuje prosty plik HTML.  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 W tym przykładzie <xref:System.Windows.Forms.HtmlDocument> reprezentuje cały dokument wewnątrz `HTML` tagów. `BODY`, `DIV`, `FORM` i `SPAN` znaczniki są reprezentowane przez osobę <xref:System.Windows.Forms.HtmlElement> obiektów.  
  
 Istnieje kilka sposobów, które są dostępne elementy tego drzewa. Użyj <xref:System.Windows.Forms.HtmlDocument.Body%2A> właściwości w celu uzyskania dostępu do `BODY` tag i wszystkie jego elementy podrzędne. <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> Właściwość umożliwia <xref:System.Windows.Forms.HtmlElement> dla elementu na stronie HTML, który ma fokus wprowadzania użytkownika. Wszystkie elementy w ramach strony HTML może mieć nazwę; <xref:System.Windows.Forms.HtmlDocument.All%2A> kolekcji zapewnia dostęp do każdego <xref:System.Windows.Forms.HtmlElement> indeksu przy użyciu jego nazwy. <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> zwróci <xref:System.Windows.Forms.HtmlElementCollection> wszystkich <xref:System.Windows.Forms.HtmlElement> obiektów z danego nazwa tagu HTML, takich jak `DIV` lub `TABLE`. <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> Zwraca pojedynczą <xref:System.Windows.Forms.HtmlElement> odpowiadający Unikatowy identyfikator, który podasz. <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> zwróci <xref:System.Windows.Forms.HtmlElement> znajdującymi się na ekranie na współrzędne wskaźnika myszy podane.  
  
 Można również użyć <xref:System.Windows.Forms.HtmlDocument.Forms%2A> i <xref:System.Windows.Forms.HtmlDocument.Images%2A> kolekcji do iterowania po elementach użytkownik reprezentują dane wejściowe formularzy i grafiki, odpowiednio.  
  
 <xref:System.Windows.Forms.HtmlDocument> opiera się na niezarządzanych interfejsów implementowanych przez program Internet Explorer DHTML DOM: `IHTMLDocument`, `IHTMLDocument2`, `IHTMLDocument3`, i `IHTMLDocument4`. Tylko najczęściej używane właściwości i metody na te niezarządzane interfejsy są udostępniane przez <xref:System.Windows.Forms.HtmlDocument>. Dostęp wszystkich innych właściwości i metod bezpośrednio przy użyciu <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> właściwość, która może być rzutowany na wskaźnik żądanego interfejsu niezarządzanych.  
  
 Dokument HTML może zawierać ramki, które są różne windows wewnątrz <xref:System.Windows.Forms.WebBrowser> kontroli. Każdej ramce wyświetla własną stronę HTML. <xref:System.Windows.Forms.HtmlWindow.Frames%2A> Kolekcji jest dostępna za pośrednictwem <xref:System.Windows.Forms.HtmlDocument.Window%2A> właściwości. Można także użyć <xref:System.Windows.Forms.HtmlDocument.Window%2A> właściwości, aby zmienić rozmiar wyświetlanych strony, przewiń dokument o lub wyświetlania alertów i wyświetli monit dla użytkownika.  
  
 <xref:System.Windows.Forms.HtmlDocument> przedstawia najbardziej typowe zdarzenia, czego można oczekiwać do obsługi w przypadku hostowania stron HTML. W przypadku zdarzeń nie są udostępniane bezpośrednio przez interfejs, możesz dodać program obsługi zdarzeń za pomocą <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A>.  
  
 Pliki HTML może zawierać `SCRIPT` tagi, które hermetyzują kodu napisanego w jednym z języków wykonywanie aktywnych skryptów, takich jak JScript lub skrypt VBScript. <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Metoda bazuje na potrzeby wykonywania właściwości i metody zdefiniowane w `SCRIPT` tagu.  
  
> [!NOTE]
>  Podczas gdy większość właściwości, metod i zdarzeń na <xref:System.Windows.Forms.HtmlDocument> ma przechowywane takich samych nazwach, ponieważ mają one na niezarządzanych modelu DOM, niektóre zostały zmienione w celu zachowania spójności z [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu używa danych z bazy danych Northwind do utworzenia `HTML TABLE` dynamicznie przy użyciu <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Najpierw metoda również jest używana do dodawania komórek (`TD` elementy) do wierszy (`TR` elementy), można dodać wiersze do tabeli, a następnie a na koniec do dołączenia w tabeli na koniec bieżącego dokumentu. Przykład kodu wymaga, że Twoja aplikacja ma <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`. Kod powinien zostać wywołany po załadowaniu dokumentu.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://developer.mozilla.org/en-US/docs/Web/API/Document">dokument — interfejsy API sieci Web</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">Interfejs IHTMLDocument2</related>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActiveElement : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Udostępnia <see cref="T:System.Windows.Forms.HtmlElement" /> który aktualnie ma fokus wprowadzania użytkownika.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /> Który aktualnie ma fokus wprowadzania użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy dokument ma fokus, ale żaden element dokumentu nie będzie miał fokus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwraca element odpowiadający `<BODY>` tagu.  
  
 Jeśli dokument nie ma fokus, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwraca `null`.  
  
 Jeśli bieżący element z fokusem wprowadzania jest komórki (`TD`) w kodzie HTML `TABLE` tagu <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> zwróci element, który zawiera `TABLE` elementu.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752581(v=vs.85)">activeElement właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ActiveLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Drawing.Color" /> hiperłącza po kliknięciu przez użytkownika.</summary>
        <value><see cref="T:System.Drawing.Color" /> Dla aktywnych łączy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Łącze jest aktywne, gdy użytkownik jest kliknięcie na nim. Należy zmienić tę właściwość, aby zmienić kolor łącza przed nawigacji.  
  
 <xref:System.Drawing.Color> Wpisać [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752564.aspx">alinkColor właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wystąpienie elementu <see cref="T:System.Windows.Forms.HtmlElementCollection" />, która przechowuje wszystkie <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów do dokumentu.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElementCollection" /> Wszystkich elementów w dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.All%2A> Kolekcji zapewnia dostęp losowy do dowolnego elementu w dokumencie HTML, niezależnie od jego pozycja w drzewie dokumentu. Umożliwia dostęp do dowolnego elementu w dokumencie HTML, nazwa, identyfikator lub indeksu. Użytkownik może również iteracji wszystkich elementów w dokumencie.  
  
 Niektóre elementy, takie jak `HEAD` i `TITLE`, nigdy nie będzie miała nazw skojarzonych z nimi. Wszystkie inne elementy będą mieć nazwy, tylko wtedy, gdy przypisaną Autor pliku HTML. Można uzyskać dostęp do elementów bez nazwy według Identyfikatora lub indeksu.  
  
 Nie można dodać bezpośrednio do elementów <xref:System.Windows.Forms.HtmlDocument.All%2A> kolekcji, ponieważ wszystkie elementy w kodzie HTML plik poza `HTML` tag musi zawierać element nadrzędny. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody lub <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość <xref:System.Windows.Forms.HtmlElement> Dodawanie nowych elementów do drzewa.  
  
   
  
## Examples  
 Poniższy kod wykonuje iterację przez wszystkie elementy w dokumencie i zestawach `Enabled=True`, umożliwiając żadnych elementów, które może być wyłączone domyślnie, aby zapobiec dane wejściowe użytkownika podczas ładowania dokumentu. Przykład kodu wymaga, że aplikacja zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752582.aspx">wszystkie właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Kodu zarządzanego, który obsługuje zdarzenie.</param>
        <summary>Dodaje program obsługi zdarzeń dla zdarzenia HTML DOM nazwanego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie należy dołączać zdarzenie w dokumencie lub jednego ze swoich obiektów, dopóki nie zakończy się dokument ładowania. Jest najwcześniejsza powinna wywołać tę metodę w <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenia <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
 Ta metoda umożliwia dołączanie obsługi do niezarządzanego zdarzenia DOM nie jest udostępniany przez <xref:System.Windows.Forms.HtmlDocument>. Aby uzyskać więcej informacji na temat dostępnych niezarządzanych zdarzenia DOM, zobacz [uzyskiwania dostępu do nieujawnionych elementów w zarządzanych HTML Document Object Model](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) i interfejsy IHTMLDocument: [IHTMLDocument](https://go.microsoft.com/fwlink/?LinkId=104882), [IHTMLDocument2](https://go.microsoft.com/fwlink/?LinkId=104884), [IHTMLDocument3](https://go.microsoft.com/fwlink/?LinkId=104886), [IHTMLDocument4](https://go.microsoft.com/fwlink/?LinkId=104887), [IHTMLDocument5](https://go.microsoft.com/fwlink/?LinkId=104888).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752535.aspx">attachEvent — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła dokumentu HTML.</summary>
        <value><see cref="T:System.Drawing.Color" /> Tła dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> zostanie wyświetlony element nie zajmuje ten obszar ekranu.  
  
 <xref:System.Drawing.Color> Wpisać [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752565.aspx">kolor tła właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Body : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlDocument.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElement" /> dla <c>treści</c> tagu.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /> Dla obiektu <c>treści</c> tagu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dokument HTML jest podzielony na dwie główne części:  
  
-   `HEAD`, który zawiera element title dokumentu, dowolnego dokumentu metadanych, i `SCRIPT` elementów.  
  
-   `BODY`, który zawiera wszystkie elementy związane z wyświetlanymi na ekranie wygląd dokumentu.  
  
 Nie ma odpowiednika `Head` właściwość <xref:System.Windows.Forms.HtmlDocument>. Aby uzyskać `HEAD` elementu, użyj <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową `DIV` elementu i dołącza je do dolnej części dokumentu, za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752585.aspx">treści właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie w dowolnym miejscu w dokumencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykrywa kliknięć w dokumencie, umożliwia znalezienie elementem i używa <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> Aby wyrównać element z górnej części strony sieci Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752611.aspx">OnClick zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.ContextMenuShowing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zażąda, aby wyświetlić menu kontekstowe dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie jeśli kliknij prawym przyciskiem myszy dokumentu lub elementu w dokumencie, jego wyświetli określonego menu kontekstowe domyślne do elementu. To zdarzenie służy do anulowania wyświetlanie menu kontekstowe i wyświetlić własny.  
  
   
  
## Examples  
 Poniższy kod przykładowy przechwytywania <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> zdarzeń i używa go do wyświetlenia <xref:System.Windows.Forms.ContextMenuStrip>.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536914.aspx">oncontextmenu zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cookie : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pliki cookie protokołu HTTP, skojarzone z tym dokumentem.</summary>
        <value>A <see cref="T:System.String" /> zawierającego listę plików cookie, każdy plik cookie oddzielone średnikami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Właściwość <xref:System.Windows.Forms.HtmlDocument> uwidacznia wszystkie pliki cookie, ustaw dla strony sieci Web.  
  
 A *plik cookie* jest pary nazwa/wartość dowolnego skojarzone z daną stronę sieci Web. Deweloperzy sieci Web używanie plików cookie do śledzenia, gdy użytkownicy w odwiedzić lub wróć do witryny sieci Web. Plik cookie składa się z wielu części, smutek plików cookie, które określają następujące czynności:  
  
-   Zestaw dokumentów, którego plik cookie dotyczy; domena i ścieżki.  
  
-   Nazwa i wartość pliku cookie.  
  
-   Data wygaśnięcia pliku cookie.  
  
-   Czy plik cookie może go wysłać tylko przy użyciu bezpiecznego połączenia.  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Właściwość może zawierać wiele plików cookie.  
  
 Można używać tylko <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> właściwość umożliwiająca ustawienie jednego pliku cookie naraz.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752569.aspx">Właściwości pliku cookie</related>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberSignature Language="F#" Value="member this.CreateElement : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.CreateElement elementTag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">Nazwa elementu HTML do utworzenia.</param>
        <summary>Tworzy nową <see langword="HtmlElement" /> HTML określony typ znacznika.</summary>
        <returns>Nowy element typu określonego tagu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` może być jedna z obsługiwanych tagów HTML w przeglądarce Internet Explorer, z wyjątkiem `FRAME` lub `IFRAME`.  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> Zwraca element niedołączone bieżące drzewo dokumentu. Aby dodać element do dokumentu, należy użyć <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> lub <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody.  
  
 Ta metoda nie wpłynie stanu istniejącego dokumentu kodu źródłowego, gdy używasz <xref:System.Windows.Forms.WebBrowser> kontrolki **Wyświetl źródło** polecenia menu kontekstowego lub <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> i <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> właściwości <xref:System.Windows.Forms.WebBrowser> formant.  
  
 Podczas tworzenia nowych elementów z <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>, nie można ustawić niektóre właściwości, takie jak `Name`. W przypadkach, w którym należy ustawić atrybut Name, należy przypisać je jako HTML w celu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość innego obiektu w dokumencie.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje dane z bazy danych Northwind do utworzenia kodu HTML tabeli, używając <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Najpierw metoda również jest używana do dodawania komórek (`TD` elementy) do wierszy (`TR` elementy), można dodać wiersze do tabeli, a następnie a na koniec do dołączenia w tabeli na koniec bieżącego dokumentu. Przykład kodu wymaga, że Twoja aplikacja ma <xref:System.Windows.Forms.WebBrowser> formant nazywany `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752570.aspx">createElement — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultEncoding : string" Usage="System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kodowanie, używany domyślnie dla bieżącego dokumentu.</summary>
        <value><see cref="T:System.String" /> Reprezentujące kodowania, że przeglądarka używa po stronie wyświetlane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym kodowaniem jest kodowanie, którego zarządzanych HTML Document Object Model (DOM) zostanie podjęta próba wykorzystania podczas wczytywania strony. To kodowanie pochodzi z programu Internet Explorer **kodowanie** ustawienia, lub z `META` znacznika osadzonego na stronie.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms537500.aspx">Rozpoznawania zestawu znaków</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms533714.aspx">defaultCharset właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlDocument.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia mają zaprzestania obsługi.</param>
        <param name="eventHandler">Kodu zarządzanego, który obsługuje zdarzenie.</param>
        <summary>Usuwa procedurę obsługi zdarzeń z nazwanego zdarzenia w formacie HTML DOM.</summary>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752539.aspx">detachEvent — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Domain : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg opisujący domeny tego dokumentu, ze względów bezpieczeństwa.</summary>
        <value>Prawidłową domenę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie dwie strony sieci Web w różnych ramek mają zablokowaną możliwość uzyskiwania dostępu do siebie nawzajem zawartości przy użyciu skryptu; nawet www.microsoft.com i msdn.microsoft.com w tym wypadku traktowane jako różne domeny. Aby włączyć wykonywania skryptów dla stron z tej samej domeny najwyższego poziomu, można przypisać nową wartość do <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwości. W przypadku poprzedniej adresu URL przykładu ustawienie <xref:System.Windows.Forms.HtmlDocument.Domain%2A> do witryny microsoft.com pozwoliłoby obie strony komunikować się ze sobą.  
  
 Ciągi przypisane do <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwość musi być prawidłową domen najwyższego poziomu. W poprzednim przykładzie adres URL, możesz ustawić <xref:System.Windows.Forms.HtmlDocument.Domain%2A> do witryny microsoft.com, ale nie na .com, który umożliwiłby dowolnej strony w Internecie, aby zawartość strony skryptu.  
  
 Nie można użyć <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwością pozwalającą włączyć wykonywania skryptów dla stron, uzyskiwać dostęp za pomocą dwóch różnych protokołów. Jeśli jedną klatkę na stronie pochodzi z serwera sieci Web (protokół http://), a inny pochodzi z pliku protokół systemu (file://), nie będą w stanie komunikować się ze sobą bez względu na wartość <xref:System.Windows.Forms.HtmlDocument.Domain%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Argument <c>domeny</c> właściwość musi być prawidłową nazwą domeny za pomocą Konwencji systemu nazw domen (DNS, Domain Name System).</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752575.aspx">Właściwości domeny</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms533028.aspx">Dotyczące wykonywania skryptów i zabezpieczeń</related>
        <related type="Article" href="https://msdn.microsoft.com/library/ms535250.aspx">Obiekt w ramce</related>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomDocument : obj" Usage="System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskaźnik interfejsu niezarządzane w tym <see cref="T:System.Windows.Forms.HtmlDocument" />.</summary>
        <value><see cref="T:System.Object" /> Reprezentujący <c>IDispatch</c> wskaźnik do dokumentu niezarządzanych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> jest otoką dla Internet Explorer modelu DOM (Document Object), które są zapisywane w modelu COM. Jeśli potrzebujesz dostępu do nieujawnionych właściwości lub metody na podstawowych interfejsów COM, takich jak `IHTMLDocument2`, można użyć tego obiektu, aby wykonać zapytanie dla nich.  
  
 Aby użyć niezarządzane interfejsy, należy zaimportować biblioteki MSHTML (mshtml.dll) do aplikacji. Jednak można również wykonać nieujawnionych właściwości i metod za pomocą `IDispatch::Invoke` metody.  
  
   
  
## Examples  
 Poniższy kod przykładowy rzutowania <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> do `IHTMLDocument2` wskaźnika i wyświetla wartość `lastModified` właściwość, która informuje, kiedy właściciel dokumentu miejsce ostatnia aktualizacja jego zawartość. Przykład kodu wymaga, że masz <xref:System.Windows.Forms.Button> w formularzu o nazwie `Button6`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Aby uzyskać <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> uprawnień. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa752574(v=vs.85)">Interfejs IHTMLDocument2</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=128638">Dokumentacja MSHTML</related>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kodowanie znaków dla tego dokumentu.</summary>
        <value><see cref="T:System.String" /> Reprezentujący bieżącego kodowania znaków.</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms537500.aspx">Rozpoznawania zestawu znaków</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752566.aspx">zestaw znaków właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlDocument.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do przetestowania.</param>
        <summary>Sprawdza obiekt do porównania w odniesieniu do bieżącego obiektu.</summary>
        <returns><see langword="true" /> Jeśli obiekty są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.ExecCommand : string * bool * obj -&gt; unit" Usage="htmlDocument.ExecCommand (command, showUI, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">Nazwa polecenia do wykonania.</param>
        <param name="showUI">Czy ma być wyświetlane okna dialogowe specyficzne dla polecenia lub okien komunikatów dla użytkownika.</param>
        <param name="value">Wartość do przypisania, za pomocą polecenia. Nie ma zastosowania dla wszystkich poleceń.</param>
        <summary>Wykonuje określone polecenie przed dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> udostępnia dużą tablicę poleceń, na którym są żadnych metod udostępnianych na <xref:System.Windows.Forms.HtmlDocument>. Za pomocą <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> można wstawić nowych elementów HTML, wybrać i formatować tekst i wyczyść wszystkie buforowane poświadczenia uwierzytelniania. Aby uzyskać pełną listę poleceń, zobacz [identyfikatory poleceń](https://go.microsoft.com/fwlink/?LinkId=198814).  
  
> [!NOTE]
>  Niektórych poleceń, takich jak kopiowanie, mają wartości zwracanej. W bieżącej implementacji <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A>, nie można uzyskać wartość zwracaną z wywołania. Aby pobrać wartości zwracane, użyj odpowiedniej metody niezarządzanego na <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> zamiast tego odwołania.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536419.aspx">execCommand — metoda</related>
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=198814">Identyfikatory poleceń</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlDocument.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia fokus wprowadzania użytkownika w bieżącym dokumencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Windows.Forms.HtmlDocument.Focus%2A> ustawi fokus na <xref:System.Windows.Forms.WebBrowser> kontroli, jeśli kontrolka obecnie nie ma fokusu. Jeśli dokument znajduje się wewnątrz `FRAME`, ta metoda umieści skoncentrować się na tym `FRAME` w ramach `FRAMESET`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> uprawnienia, aby ustawić fokus na formularzu. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.UIPermissionWindow" /></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752527.aspx">fokus — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.HtmlDocument.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dokument ma fokus wprowadzania użytkownika.</summary>
        <value><see langword="true" /> Jeśli dokument ma fokus; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim otrzymuje fokus do dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.Focusing> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.Focusing> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752520.aspx">onfocusin zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tekstu dla dokumentu.</summary>
        <value>Kolor tekstu w dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> <xref:System.Drawing.Color> Wpisać [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752580.aspx">fgColor właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Forms : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Forms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkich <c>&lt;formularza&gt;</c> elementów w dokumencie.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElementCollection" /> z <c>&lt;formularza&gt;</c> elementów w obrębie dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dokument HTML może mieć co najmniej jeden `FORM` elementów za pomocą pól wejściowych na przesyłanie danych z powrotem do serwera.  
  
 Programowe można przesłać `FORM` , uzyskując jego <xref:System.Windows.Forms.HtmlElement> i wywoływania jego `Submit` przy użyciu metody <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> metody.  
  
 Aby dodać nowy `FORM` do dokumentu, możesz utworzyć nową `FORM` otaguj jako ciąg i przypisz ją do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość elementu wcześniej dodane do modelu DOM HTML; możesz też <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody, ustaw jego właściwości, za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, i dodaj go jako element podrzędny istniejącego elementu za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 Poniższy kod wykonuje iterację przez wszystkie `Form` elementy w sieci Web strony i czyści wszystkie dane wejściowe użytkownika, ustawienie formularze wartości domyślnych.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752591.aspx">Formularze właściwości</related>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752432.aspx">Interfejs IHTMLFormElement</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberSignature Language="F#" Value="member this.GetElementById : string -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementById id" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Atrybut ID elementu do pobrania.</param>
        <summary>Pobiera pojedynczy <see cref="T:System.Windows.Forms.HtmlElement" /> przy użyciu elementu <c>identyfikator</c> atrybutu jako klucza wyszukiwania.</summary>
        <returns>Zwraca pierwszy obiekt o takiej samej <c>identyfikator</c> atrybutu z określoną wartością lub <see langword="null" /> Jeśli <paramref name="id" /> nie można odnaleźć.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wielu elementów w dokumencie o tej samej wartości Identyfikatora <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> zwróci znajdzie pierwszy z nich.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera nazwane `TABLE` z dokumentu, liczy w górę liczbę wierszy i wyświetla wyniki na stronie sieci Web. Przykład kodu wymaga, że masz <xref:System.Windows.Forms.WebBrowser> formantu w projekcie o nazwie `WebBrowser1`, i załadowano stronę sieci Web za pomocą `TABLE` którego `ID` atrybut jest `Table1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752543.aspx">getElementById — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberSignature Language="F#" Value="member this.GetElementFromPoint : System.Drawing.Point -&gt; System.Windows.Forms.HtmlElement" Usage="htmlDocument.GetElementFromPoint point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">X, y pozycji elementu na ekranie względem lewego górnego rogu dokumencie.</param>
        <summary>Pobiera element HTML, znajduje się na współrzędnych określonego klienta.</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlElement" /> w lokalizacji określonej ekranu w dokumencie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> używa współrzędne klienta, w których lewego górnego rogu dokumencie jest przypisywana wartość (0,0). Współrzędne klienta dla bieżącej pozycji kursora można uzyskać za pomocą <xref:System.Windows.Forms.HtmlWindow.Position%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu wykrywa kliknięć w dokumencie, umożliwia znalezienie elementem i używa <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> Aby wyrównać element z górnej części strony sieci Web.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752576.aspx">elementFromPoint — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlDocument.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nazwa tagu HTML <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty mają zostać pobrane.</param>
        <summary>Pobiera kolekcję elementów z określonego tagu HTML.</summary>
        <returns>Kolekcja elementów, które nazwa tagu jest równa <paramref name="tagName" /> argumentu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Strony HTML często używają `META` tag, aby osadzić dowolnych informacji o dokumencie. Poniższy przykład kodu HTML, pobiera wszystkie `META` znajdzie tagów w dokumencie HTML `META` tag o nazwie `Description`i wyświetla dla użytkownika. Przykład kodu wymaga, że Twoja aplikacja ma <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752545.aspx">getElementsByTagName — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlDocument.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla tego obiektu.</summary>
        <returns><see cref="T:System.Int32" /> Reprezentująca wartość skrótu tego obiektu w pamięci.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Images : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Images" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję wszystkie tagi obrazu w dokumencie.</summary>
        <value>Kolekcja <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów, po jednym dla każdego znacznika IMG w dokumencie. Elementy są zwracane z kolekcji w kolejności źródła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> Zwraca kolekcję <xref:System.Windows.Forms.HtmlElement> obiektów. Do dostępu do atrybutów, takich jak `ALT` i `SRC`, które nie są bezpośrednio widoczne przez <xref:System.Windows.Forms.HtmlElement>, użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> metody.  
  
 Aby dodać nowy obraz do dokumentu, albo utworzyć nową `IMG` otaguj jako ciąg i przypisz ją do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość elementu wcześniej dodane do modelu DOM HTML; lub użyj <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody, ustaw jego właściwości, za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>i dodaj go jako element podrzędny istniejącego elementu za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy `ALT` atrybutu wszystkich obrazów w dokumencie i ustawia domyślne `ALT` atrybutu, jeśli wartość nie jest już ustawiona.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752593.aspx">obrazy właściwości</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga załadowano następującej stronie sieci Web.  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string -&gt; obj" Usage="htmlDocument.InvokeScript scriptName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa metody skryptu do wywołania.</param>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowym typem obiektu zwróconego przez <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> będą się różnić. Wywołana funkcja wykonywanie aktywnych skryptów zwraca dane skalarne, takie jak ciąg lub liczba całkowita, będzie zwracaną jako ciąg. Jeśli zostanie zwrócona obiektów opartych na skryptach, takie jak obiekt, który został utworzony za pomocą języka JScript lub języka VBScript `new` operator będzie typu `Object`. (W tych obiektach może wykonywać wywołania przez wywołanie metody <xref:System.Object.GetType%2A> i przy użyciu <xref:System.Type.InvokeMember%2A>.) Jeśli funkcja zwraca wartość elementu HTML DOM, takich jak `DIV` lub `TABLE`, będzie mieć typ `Object`; po dodaniu odwołania projektu do MSHTML. Biblioteki DLL, jednak będzie można rzutować do jego określonego typu modelu DOM niezarządzanych.  
  
 Może wywołać dowolną funkcję napisane w dowolnym języku wykonywanie aktywnych skryptów zainstalowany na komputerze użytkownika, w tym JScript i VBScript.  
  
 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Wykona nothing, jeśli użytkownik jawnie wyłączył wykonywanie skryptu w programie Internet Explorer lub bieżącą konfigurację zabezpieczeń dla strony sieci Web nie zezwala.  
  
   
  
## Examples  
 Poniższy kod wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga, że masz <xref:System.Windows.Forms.WebBrowser> w aplikacji o nazwie `WebBrowser1`, i załadowano następującej stronie sieci Web.  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.InvokeScript : string * obj[] -&gt; obj" Usage="htmlDocument.InvokeScript (scriptName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">Nazwa metody skryptu do wywołania.</param>
        <param name="args">Argumenty do przekazania do metody skryptu.</param>
        <summary>Wykonuje funkcję wykonywanie aktywnych skryptów zdefiniowane na stronie HTML.</summary>
        <returns>Obiekt zwrócony przez wywołanie wykonywanie aktywnych skryptów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podstawowym typem obiektu zwróconego przez <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> będą się różnić. Wywołana funkcja wykonywanie aktywnych skryptów zwraca dane skalarne, takie jak ciąg lub liczba całkowita, będzie zwracaną jako ciąg. Jeśli zostanie zwrócona obiektów opartych na skryptach, takie jak obiekt, który został utworzony za pomocą języka JScript lub języka VBScript `new` operator będzie typu `Object`. (W tych obiektach może wykonywać wywołania przez wywołanie metody <xref:System.Object.GetType%2A> i przy użyciu <xref:System.Type.InvokeMember%2A>.) Jeśli funkcja zwraca wartość elementu HTML DOM, takich jak `DIV` lub `TABLE`, będzie mieć typ `Object`; po dodaniu odwołania projektu do MSHTML. Biblioteki DLL, jednak będzie można rzutować do jego określonego typu modelu DOM niezarządzanych.  
  
 Może wywołać dowolną funkcję napisane w dowolnym języku wykonywanie aktywnych skryptów zainstalowany na komputerze użytkownika, w tym JScript i VBScript.  
  
 Ta metoda będzie wykonywać nothing, jeśli użytkownik jawnie wyłączył wykonywanie skryptu w programie Internet Explorer lub bieżącą konfigurację zabezpieczeń dla strony sieci Web nie zezwala.  
  
   
  
## Examples  
 Poniższy kod wykonuje zawartość skryptu na stronie sieci Web. Przykład kodu wymaga, że masz <xref:System.Windows.Forms.WebBrowser> w aplikacji o nazwie `WebBrowser1`, i załadowano następującej stronie sieci Web.  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor hiperłącza.</summary>
        <value>Kolor dla hiperlinków w bieżącym dokumencie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> Wpisać [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752608.aspx">linkColor właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Links : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlDocument.Links" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę wszystkich hiperłącza znajdującego się w tym dokumencie HTML.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElementCollection" /> z <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta kolekcja będzie zawierać wszystkie łącza utworzone za pomocą `A`, `LINK`, i `AREA` tagów HTML.  
  
 <xref:System.Windows.Forms.HtmlElement> Obiektów zawartych w tej kolekcji hermetyzowania niezarządzanych `IHTMLLinkElement` interfejsu. Aby uzyskać dostęp do właściwości interfejsu bazowego bezpieczne, użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> metody.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752595.aspx">Właściwości łącza</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy fokus jest pozostawienie formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.LosingFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.LosingFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752521.aspx">onfocusout zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie przycisk myszy po lewej stronie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.MouseDown> Zdarzenie występuje przed <xref:System.Windows.Forms.HtmlDocument.Click> zdarzeń.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752619.aspx">onMouseDown zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy nie jest już po umieszczeniu wskaźnika nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/ms536948.aspx">onmouseout zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy jest przesuwany nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseMove> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseMove> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752620.aspx">OnMouseMove — zdarzenie</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy jest przesuwany nad dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752622.aspx">onMouseOver zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni przycisk myszy po lewej stronie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlDocument.MouseUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlDocument> o nazwie `HtmlDocument1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlDocument.MouseUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752623.aspx">onMouseUp zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie do porównania.</param>
        <param name="right">Drugie wystąpienie do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Windows.Forms.HtmlDocument" /> wystąpienia reprezentują tę samą wartość.</summary>
        <returns><see langword="true" /> Jeśli określone wystąpienia są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlDocument * System.Windows.Forms.HtmlDocument -&gt; bool" Usage="System.Windows.Forms.HtmlDocument.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Pierwsze wystąpienie do porównania.</param>
        <param name="right">Drugie wystąpienie do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy określony <see cref="T:System.Windows.Forms.HtmlDocument" /> wystąpień nie reprezentują tę samą wartość.</summary>
        <returns><see langword="true" /> Jeśli określone wystąpienia nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberSignature Language="F#" Value="member this.OpenNew : bool -&gt; System.Windows.Forms.HtmlDocument" Usage="htmlDocument.OpenNew replaceInHistory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">Czy nawigacji w nowym oknie powinny zastąpić poprzedni element w historii nawigacji elementu DOM.</param>
        <summary>Pobiera nową <see cref="T:System.Windows.Forms.HtmlDocument" /> za pomocą <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" /> metody.</summary>
        <returns>Nowy dokument do zapisu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> Spowoduje to wyczyszczenie poprzedni dokument załadowane, w tym wszystkie skojarzone stanu, takie jak zmienne. Nie spowoduje zdarzeń nawigacji w <xref:System.Windows.Forms.WebBrowser> zgłoszenie.  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> zawsze tworzy nowy dokument w bieżącym oknie. Aby otworzyć dokument w nowym oknie, należy użyć <xref:System.Windows.Forms.HtmlWindow.Open%2A> metody <xref:System.Windows.Forms.HtmlWindow> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu przygotowuje modelu DOM, do pisania i zapisuje nowego dokumentu przy użyciu <xref:System.Windows.Forms.HtmlDocument.Write%2A> metody.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752628.aspx">Open — metoda</related>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : bool with get, set" Usage="System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia kierunek tekstu w bieżącym dokumencie.</summary>
        <value><see langword="true" /> Jeśli tekst, który powoduje wyświetlenie od prawej do lewej; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> nie będziesz mieć dowolną wartość, o ile nie została ustawiona w sposób jawny, w kodzie lub w formacie HTML.  
  
 W odróżnieniu od <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> właściwości kontrolek formularzy Windows <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> na zarządzany HTML DOM nie ma wpływu na kierunek tekstu alfabetu łacińskiego.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752540.aspx">dir właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Stop : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy nawigacja do innej strony sieci Web jest zatrzymywana.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ładowanie strony sieci Web zostanie zatrzymany, jeśli kod program wywołuje <xref:System.Windows.Forms.WebBrowser.Stop%2A> metody <xref:System.Windows.Forms.WebBrowser> kontroli. Nie spowoduje niepowodzenia nawigacji spowodowany awarią sieci lub nieprawidłowo działający witryn sieci Web <xref:System.Windows.Forms.HtmlDocument.Stop> wystąpienia.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu resetuje paska stanu w aplikacji Windows Forms przy `Stop` wystąpiło zdarzenie. Przykład kodu wymaga, że masz <xref:System.Windows.Forms.StatusBar> formantu o nazwie `StatusBar1` w aplikacji.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752561.aspx">onstop zdarzeń</related>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Title : string with get, set" Usage="System.Windows.Forms.HtmlDocument.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość tekstowa elementu <c>&lt;tytuł&gt;</c> tagu w bieżącym dokumencie HTML.</summary>
        <value>Tytuł bieżącego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlDocument.Title%2A> właściwość do identyfikacji dokumentu za zrozumiałą nazwę.  
  
 Również odzwierciedlają zmiany tej właściwości w <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> właściwość <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy hiperłącze HTML do bieżącego dokumentu przy użyciu adresu URL dokumentu jako lokalizacja linku i tytuł dokumentu jako tekst łącza. Przykład kodu wymaga, że Twoja aplikacja ma <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Url : Uri" Usage="System.Windows.Forms.HtmlDocument.Url" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera adres URL opisujący lokalizację tego dokumentu.</summary>
        <value>A <see cref="T:System.Uri" /> reprezentujący adres URL tego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość jest tylko do odczytu. Aby przejść do nowego dokumentu, należy użyć <xref:System.Windows.Forms.WebBrowser.Url%2A> właściwość <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.VisitedLinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor łączy do stron HTML, które użytkownik ma już odwiedzać.</summary>
        <value>Kolor odwiedzonych odnośników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Color` Wpisać [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] obsługuje `Alpha` wartość, ale HTML DOM nie. W związku z tym `Alpha` odniesie żadnego skutku, gdy jest przypisany do tej właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <related type="Article" href="https://msdn.microsoft.com/library/aa752638.aspx">vlinkColor właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Window : System.Windows.Forms.HtmlWindow" Usage="System.Windows.Forms.HtmlDocument.Window" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlWindow" /> skojarzone z tym dokumentem.</summary>
        <value>Okno dla tego dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie dokumenty w formacie HTML mają obiektu modelu DOM HTML o nazwie to okno, który może służyć do modyfikowania rozmiaru dokumentu, a następnie otwórz nowy systemu windows, a także uzyskiwać dostęp do innych ważnych obiektów, takich jak <xref:System.Windows.Forms.HtmlHistory>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/aa752599.aspx">parentWindow właściwości</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberSignature Language="F#" Value="member this.Write : string -&gt; unit" Usage="htmlDocument.Write text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst HTML, który można zapisać do dokumentu.</param>
        <summary>Zapisuje strony HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie wywołania do <xref:System.Windows.Forms.HtmlDocument.Write%2A> powinien być poprzedzony wywołanie <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A>, która spowoduje wyczyszczenie bieżącym dokumentem i wszystkich jego zmiennych. Wywołania względem <xref:System.Windows.Forms.HtmlDocument.Write%2A> utworzy nowy dokument HTML w tym miejscu. Aby zmienić określonych części dokumentu, uzyskaj odpowiednie <xref:System.Windows.Forms.HtmlElement> i ustaw jego <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości.  
  
 Zalecane jest, zapis całego prawidłowe HTML dokumentu za pomocą <xref:System.Windows.Forms.HtmlDocument.Write%2A> metody, w tym `HTML` i `BODY` tagów. Jednak pisania tylko elementy HTML Document Object Model (DOM) będzie podać te elementy dla Ciebie.  
  
   
  
## Examples  
 Poniższy kod zostanie otwarty nowy <xref:System.Windows.Forms.HtmlDocument> i zapisuje je w nowym pliku HTML.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
        <related type="Article" href="https://msdn.microsoft.com/library/default.asp?url=/workshop/browser/mshtml/reference/ifaces/document2/write.asp">Write — Metoda</related>
      </Docs>
    </Member>
  </Members>
</Type>
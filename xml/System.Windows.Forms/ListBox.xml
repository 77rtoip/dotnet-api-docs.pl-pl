<Type Name="ListBox" FullName="System.Windows.Forms.ListBox">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cb337792f9d7a64fdc5532004c5039484ef9f625" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69185394" /></Metadata><TypeSignature Language="C#" Value="public class ListBox : System.Windows.Forms.ListControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ListBox extends System.Windows.Forms.ListControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.ListBox" />
  <TypeSignature Language="VB.NET" Value="Public Class ListBox&#xA;Inherits ListControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class ListBox : System::Windows::Forms::ListControl" />
  <TypeSignature Language="F#" Value="type ListBox = class&#xA;    inherit ListControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ListControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.DefaultBindingProperty("SelectedValue")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("SelectedIndexChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Items")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ListBoxDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje kontrolkę Windows, aby wyświetlić listę elementów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox> Kontrolka umożliwia wyświetlenie listy elementów dla użytkownika, które użytkownik może wybrać, klikając pozycję. Kontrolka może udostępniać pojedyncze lub wielokrotne zaznaczenia <xref:System.Windows.Forms.ListBox.SelectionMode%2A> przy użyciu właściwości. <xref:System.Windows.Forms.ListBox> <xref:System.Windows.Forms.ListBox> UdostępniarównieżwłaściwośćumożliwiającąWyświetlanieelementówwkolumnachzamiastprostej<xref:System.Windows.Forms.ListBox.MultiColumn%2A> pionowej listy elementów. Dzięki temu kontrolka może wyświetlać więcej widocznych elementów i użytkownik nie musi już przewijać do elementu.  
  
 Zwykle system Windows obsługuje zadanie rysowania elementów do wyświetlenia w <xref:System.Windows.Forms.ListBox>. Możesz użyć <xref:System.Windows.Forms.ListBox.DrawMode%2A> właściwości i <xref:System.Windows.Forms.ListBox.MeasureItem> obsłużyć zdarzenia i <xref:System.Windows.Forms.ListBox.DrawItem> , aby można było przesłonić automatyczne rysowanie, które system Windows udostępnia i samodzielnie rysuje elementy. Za pomocą kontrolek rysowanych <xref:System.Windows.Forms.ListBox> przez właściciela można wyświetlać elementy o zmiennej wysokości, obrazy lub inne kolory lub czcionki dla tekstu każdego elementu na liście. Właściwość, <xref:System.Windows.Forms.ListBox.GetItemHeight%2A>, a<xref:System.Windows.Forms.ListBox.GetItemRectangle%2A> także pomoc dotycząca rysowania własnych elementów. <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A>  
  
 Oprócz funkcji wyświetlania i wyboru program <xref:System.Windows.Forms.ListBox> udostępnia również funkcje, które umożliwiają efektywne Dodawanie elementów <xref:System.Windows.Forms.ListBox> do i znajdowanie tekstu w obrębie elementów listy. Metody <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> <xref:System.Windows.Forms.ListBox> i <xref:System.Windows.Forms.ListBox.EndUpdate%2A> umożliwiają dodanie dużej liczby elementów do bez kontrolki, która jest odświeżana za każdym razem, gdy element zostanie dodany do listy. Metody <xref:System.Windows.Forms.ListBox.FindString%2A> i<xref:System.Windows.Forms.ListBox.FindStringExact%2A> umożliwiają wyszukiwanie elementu na liście zawierającej określony ciąg wyszukiwania.  
  
 Właściwości <xref:System.Windows.Forms.ListBox.Items%2A> <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedItems%2A>i zapewniajądostępdotrzechkolekcji,któresąużywaneprzez.<xref:System.Windows.Forms.ListBox.SelectedIndices%2A> W poniższej tabeli opisano trzy kolekcje używane przez <xref:System.Windows.Forms.ListBox> program i ich użycie w ramach formantu.  
  
|Klasa kolekcji|Użyj w ramach<xref:System.Windows.Forms.ListBox>|  
|----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Windows.Forms.ListBox.ObjectCollection>|Zawiera wszystkie elementy zawarte w <xref:System.Windows.Forms.ListBox> kontrolce.|  
|<xref:System.Windows.Forms.ListBox.SelectedObjectCollection>|Zawiera kolekcję wybranych elementów, która jest podzbiorem elementów zawartych w <xref:System.Windows.Forms.ListBox> kontrolce.|  
|<xref:System.Windows.Forms.ListBox.SelectedIndexCollection>|Zawiera kolekcję wybranych indeksów, która jest podzbiorem indeksów <xref:System.Windows.Forms.ListBox.ObjectCollection>. Te indeksy określają wybrane elementy.|  
  
 Poniższe trzy przykłady przedstawiają trzy kolekcje indeksowane obsługiwane przez <xref:System.Windows.Forms.ListBox> klasę.  
  
 W poniższej tabeli przedstawiono przykład sposobu <xref:System.Windows.Forms.ListBox.ObjectCollection> przechowywania elementów <xref:System.Windows.Forms.ListBox> programu oraz ich stanu zaznaczania w ramach przykładu <xref:System.Windows.Forms.ListBox>.  
  
|Indeks|Element|Stan zaznaczenia w polu listy|  
|-----------|----------|----------------------------------------|  
|0|Obiekt1|Niezaznaczone|  
|1|Obiekt2|Wybrane|  
|2|object3|Niezaznaczone|  
|3|object4|Wybrane|  
|4|object5|Wybrane|  
  
 W oparciu o <xref:System.Windows.Forms.ListBox.ObjectCollection> pokazane w poprzedniej tabeli, w tej tabeli przedstawiono <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> sposób wyświetlania.  
  
|Indeks|Element|  
|-----------|----------|  
|0|Obiekt2|  
|1|object4|  
|2|object5|  
  
 W oparciu o <xref:System.Windows.Forms.ListBox.ObjectCollection> pokazane w poprzedniej tabeli, w tej tabeli przedstawiono <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> sposób wyświetlania.  
  
|Indeks|Indeks elementu|  
|-----------|-------------------|  
|0|1|  
|1|3|  
|2|4|  
  
 Metoda klasy umożliwia dodawanie elementów do <xref:System.Windows.Forms.ListBox>. <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> <xref:System.Windows.Forms.ListBox.ObjectCollection> Metoda może akceptować dowolny obiekt podczas dodawania elementu członkowskiego <xref:System.Windows.Forms.ListBox>do. <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> Gdy obiekt jest dodawany do <xref:System.Windows.Forms.ListBox>, formant używa tekstu zdefiniowanego <xref:System.Object.ToString%2A> w metodzie obiektu, chyba że nazwa elementu członkowskiego w <xref:System.Windows.Forms.ListControl.DisplayMember%2A> obiekcie jest określona we właściwości. Oprócz dodawania elementów przy <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> użyciu metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy można <xref:System.Windows.Forms.ListControl.DataSource%2A> również dodawać elementy <xref:System.Windows.Forms.ListControl> przy użyciu właściwości klasy.  
  
> [!NOTE]
>  Jeśli masz <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ComboBox>, lub <xref:System.Windows.Forms.CheckedListBox> w podstawowym formularzu systemu Windows i chcesz zmodyfikować kolekcje ciągów tych formantów w pochodnym formularzu systemu Windows, kolekcje ciągów tych kontrolek w podstawowym formularzu systemu Windows muszą być puste. Jeśli kolekcje ciągów nie są puste, stają się one tylko do odczytu, gdy pochodny jest inny formularz systemu Windows.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć <xref:System.Windows.Forms.ListBox> kontrolkę wyświetlającą wiele elementów w kolumnach i na liście kontrolki można wybrać więcej niż jeden element. Kod dla przykładu <xref:System.Windows.Forms.ListBox> dodaje 50 elementów do <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy, a następnie <xref:System.Windows.Forms.ListBox.SetSelected%2A> wybiera trzy elementy z listy przy użyciu metody. Następnie kod <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> wyświetla wartości z kolekcji, <xref:System.Windows.Forms.ListBox.SelectedItems%2A> przez właściwość <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> i <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>, za pośrednictwem właściwości. Ten przykład wymaga, aby kod znajdował się w i został wywołany przez <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ListBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ListBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.ListBox" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć <xref:System.Windows.Forms.ListBox> kontrolkę wyświetlającą wiele elementów w kolumnach i na liście kontrolki można wybrać więcej niż jeden element. Kod dla przykładu <xref:System.Windows.Forms.ListBox> dodaje 50 elementów do <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy, a następnie <xref:System.Windows.Forms.ListBox.SetSelected%2A> wybiera trzy elementy z listy przy użyciu metody. Następnie kod <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> wyświetla wartości z kolekcji, <xref:System.Windows.Forms.ListBox.SelectedItems%2A> przez właściwość <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> i <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>, za pośrednictwem właściwości. Ten przykład wymaga, aby kod znajdował się w i został wywołany przez <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemsCore">
      <MemberSignature Language="C#" Value="protected virtual void AddItemsCore (object[] value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddItemsCore(object[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.AddItemsCore(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub AddItemsCore (value As Object())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void AddItemsCore(cli::array &lt;System::Object ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="abstract member AddItemsCore : obj[] -&gt; unit&#xA;override this.AddItemsCore : obj[] -&gt; unit" Usage="listBox.AddItemsCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  There is no replacement.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="value">Tablica obiektów.</param>
        <summary>Ten element członkowski jest przestarzały i nie ma żadnych zastąpień.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowSelection">
      <MemberSignature Language="C#" Value="protected override bool AllowSelection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.AllowSelection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property AllowSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool AllowSelection { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowSelection : bool" Usage="System.Windows.Forms.ListBox.AllowSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obecnie <see cref="T:System.Windows.Forms.ListBox" /> zezwala na wybór elementów listy.</summary>
        <value><see langword="true" />Jeśli <see cref="T:System.Windows.Forms.SelectionMode" /> <see langword="false" />nie <see cref="F:System.Windows.Forms.SelectionMode.None" />jest; w przeciwnym razie,.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.ListBox.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła formantu.</summary>
        <value><see cref="T:System.Drawing.Color" /> Reprezentujący kolor tła kontrolki. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> właściwości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.ListBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest istotna dla tej klasy.</summary>
        <value>Obraz tła formularza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.ListBox.BackgroundImage" /> gdy właściwość etykiety zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.ListBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia układ obrazu tła dla elementu <see cref="T:System.Windows.Forms.ListBox" /> zdefiniowanego <see cref="T:System.Windows.Forms.ImageLayout" /> w wyliczeniu.</summary>
        <value>Jedna z wartości <see cref="T:System.Windows.Forms.ImageLayout" />. Wartości to <see langword="Center" />, <see langword="None" />, <see langword="Stretch" /> ,lub<see langword="Zoom" />. <see langword="Tile" /> <see langword="Center" />jest wartością domyślną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określona wartość wyliczenia nie istnieje.</exception>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.ListBox.BackgroundImageLayout" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdate">
      <MemberSignature Language="C#" Value="public void BeginUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.BeginUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginUpdate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginUpdate();" />
      <MemberSignature Language="F#" Value="member this.BeginUpdate : unit -&gt; unit" Usage="listBox.BeginUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Utrzymuje wydajność, <see cref="T:System.Windows.Forms.ListBox" /> gdy elementy są dodawane do jednej naraz, uniemożliwiając rysowania kontrolki <see cref="M:System.Windows.Forms.ListBox.EndUpdate" /> do momentu wywołania metody.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox> Preferowanym sposobem dodawania wielu elementów do programu jest <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> użycie metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy (za pomocą <xref:System.Windows.Forms.ListBox.Items%2A> właściwości <xref:System.Windows.Forms.ListBox>). Dzięki temu można dodać tablicę elementów do listy w ramach jednej operacji. Jeśli jednak chcesz dodać <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> elementy pojedynczo przy użyciu metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> , możesz użyć metody, aby zapobiec odświeżeniu formantu za każdym razem, <xref:System.Windows.Forms.ListBox> gdy element zostanie dodany do listy. Po zakończeniu zadania dodawania elementów do listy Wywołaj <xref:System.Windows.Forms.ListBox.EndUpdate%2A> metodę, aby <xref:System.Windows.Forms.ListBox> umożliwić odświeżenie. W ten sposób Dodawanie elementów może uniemożliwić migotanie rysowania <xref:System.Windows.Forms.ListBox> po dodaniu dużej liczby elementów do listy.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> metod i <xref:System.Windows.Forms.ListBox.EndUpdate%2A> podczas <xref:System.Windows.Forms.ListBox>dodawania 5000 elementów do. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie <xref:System.Windows.Forms.Form> została dodana do a i że ta metoda jest umieszczana w formularzu i wywoływana z niej.  
  
 [!code-cpp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.EndUpdate" />
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.ListBox.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ obramowania rysowany wokół <see cref="T:System.Windows.Forms.ListBox" />elementu.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.BorderStyle" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.BorderStyle.Fixed3D" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Wartość nie jest jedną z <see cref="T:System.Windows.Forms.BorderStyle" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="ClearSelected">
      <MemberSignature Language="C#" Value="public void ClearSelected ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearSelected() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ClearSelected" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearSelected ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearSelected();" />
      <MemberSignature Language="F#" Value="member this.ClearSelected : unit -&gt; unit" Usage="listBox.ClearSelected " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje zaznaczenie wszystkich elementów w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody jest równoznaczne z ustawieniem <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> właściwości na wartość ujemną (-1). Za pomocą tej metody można szybko usunąć zaznaczenie wszystkich elementów na liście.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób używania <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> właściwości <xref:System.Windows.Forms.ListBox.TopIndex%2A> z właściwością do przenoszenia aktualnie wybranego elementu do góry listy elementów w obszarze <xref:System.Windows.Forms.ListBox>wyświetlania. W przykładzie przedstawiono dalsze instrukcje usuwania elementów przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> klasy oraz sposób czyszczenia <xref:System.Windows.Forms.ListBox.ClearSelected%2A> wszystkich elementów przy użyciu metody. Kod najpierw przenosi aktualnie zaznaczony element w <xref:System.Windows.Forms.ListBox> górę na początku listy. Następnie kod usuwa wszystkie elementy przed aktualnie wybranym elementem i czyści wszystkie zaznaczenia w <xref:System.Windows.Forms.ListBox>. Ten przykład wymaga, aby <xref:System.Windows.Forms.ListBox> element zawierający elementy został dodany do formularza i że <xref:System.Windows.Forms.ListBox>w.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="T:System.Windows.Forms.ListBox" /> gdy formant zostanie kliknięty.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnWidth">
      <MemberSignature Language="C#" Value="public int ColumnWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ColumnWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ColumnWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ColumnWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnWidth : int with get, set" Usage="System.Windows.Forms.ListBox.ColumnWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość kolumn w wielokolumnowej <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Szerokość (w pikselach) każdej kolumny w kontrolce. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ustawisz wartość na zero (0), do każdej kolumny zostanie przypisana Domyślna szerokość. Jeśli jest to wielokolumnowa <xref:System.Windows.Forms.ListBox>, ta właściwość zwraca bieżącą szerokość każdej kolumny na liście. <xref:System.Windows.Forms.ListBox> Tej właściwości można użyć, aby upewnić się, że każda kolumna w <xref:System.Windows.Forms.ListBox> wielokolumnowym może prawidłowo wyświetlić swoje elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje prostą dwie kolumny <xref:System.Windows.Forms.ListBox>.  
  
 [!code-csharp[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Do właściwości jest przypisana wartość mniejsza od zera.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="listBox.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy obiekt ułatwień dostępu dla tej kontrolki.</summary>
        <returns>Obiekt dostępności dla tej kontrolki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateItemCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ListBox.ObjectCollection CreateItemCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.ListBox/ObjectCollection CreateItemCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.CreateItemCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateItemCollection () As ListBox.ObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::ListBox::ObjectCollection ^ CreateItemCollection();" />
      <MemberSignature Language="F#" Value="abstract member CreateItemCollection : unit -&gt; System.Windows.Forms.ListBox.ObjectCollection&#xA;override this.CreateItemCollection : unit -&gt; System.Windows.Forms.ListBox.ObjectCollection" Usage="listBox.CreateItemCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+ObjectCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie kolekcji elementów.</summary>
        <returns><see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> Reprezentujący nową kolekcję elementów.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Można zastąpić tę wartość w klasach pochodnych, aby udostępnić inną kolekcję do przechowywania elementów.</para></block>
        <altmember cref="T:System.Windows.Forms.ListBox.ObjectCollection" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.ListBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymagane parametry tworzenia podczas tworzenia uchwytu sterującego.</summary>
        <value>A <see cref="T:System.Windows.Forms.CreateParams" /> , który zawiera wymagane parametry tworzenia podczas tworzenia uchwytu do kontrolki.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obsługi kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomTabOffsets">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.IntegerCollection CustomTabOffsets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/IntegerCollection CustomTabOffsets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.CustomTabOffsets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CustomTabOffsets As ListBox.IntegerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::IntegerCollection ^ CustomTabOffsets { System::Windows::Forms::ListBox::IntegerCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomTabOffsets : System.Windows.Forms.ListBox.IntegerCollection" Usage="System.Windows.Forms.ListBox.CustomTabOffsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+IntegerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera szerokość kart między elementami w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Kolekcja liczb całkowitych reprezentujących szerokości tabulacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tablica liczb całkowitych zawiera spacje w kolejności rosnącej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItemHeight">
      <MemberSignature Language="C#" Value="public const int DefaultItemHeight = 13;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 DefaultItemHeight = (13)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ListBox.DefaultItemHeight" />
      <MemberSignature Language="VB.NET" Value="Public Const DefaultItemHeight As Integer  = 13" />
      <MemberSignature Language="C++ CLI" Value="public: int DefaultItemHeight = 13;" />
      <MemberSignature Language="F#" Value="val mutable DefaultItemHeight : int" Usage="System.Windows.Forms.ListBox.DefaultItemHeight" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>13</MemberValue>
      <Docs>
        <summary>Określa domyślną wysokość elementu dla właściciela <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.ListBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny rozmiar kontrolki.</summary>
        <value>Wartość domyślna <see cref="T:System.Drawing.Size" /> formantu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wizualnego aspektu rysowanych <see cref="T:System.Windows.Forms.ListBox" /> zmian przez właściciela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest używane przez właściciela <xref:System.Windows.Forms.ListBox>. Zdarzenie jest wywoływane tylko wtedy, <xref:System.Windows.Forms.ListBox.DrawMode%2A> gdy właściwość jest ustawiona na `DrawMode.OwnerDrawFixed` lub. `DrawMode.OwnerDrawVariable` To zdarzenie służy do wykonywania zadań wymaganych do rysowania elementów w <xref:System.Windows.Forms.ListBox>. Jeśli masz element o zmiennej wielkości (gdy <xref:System.Windows.Forms.ListBox.DrawMode%2A> właściwość jest ustawiona na `DrawMode.OwnerDrawVariable`), przed <xref:System.Windows.Forms.ListBox.MeasureItem> rysowaniem elementu zdarzenie jest zgłaszane. Można utworzyć procedurę obsługi zdarzeń dla <xref:System.Windows.Forms.ListBox.MeasureItem> zdarzenia, aby określić rozmiar elementu, który ma być rysowany w programie obsługi zdarzeń <xref:System.Windows.Forms.ListBox.DrawItem> dla zdarzenia.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia elementów rysowanych <xref:System.Windows.Forms.ListBox> przez właściciela. Kod używa <xref:System.Windows.Forms.ListBox.DrawMode%2A> właściwości, aby określić, że rysowane elementy są stałym rozmiarem <xref:System.Windows.Forms.ListBox.DrawItem> i zdarzeniem do przeprowadzenia rysowania każdego elementu w <xref:System.Windows.Forms.ListBox>. Przykładowy kod używa właściwości i metod <xref:System.Windows.Forms.DrawItemEventArgs> klasy przekazaną jako parametr do programu obsługi zdarzeń, aby rysować elementy. Ten przykład wymaga, <xref:System.Windows.Forms.ListBox> aby wywołany `listBox1` formant został dodany do formularza i że <xref:System.Windows.Forms.ListBox.DrawItem> zdarzenie jest obsługiwane przez program obsługi zdarzeń zdefiniowany w przykładowym kodzie. Przykład wymaga również, aby elementy zostały dodane do <xref:System.Windows.Forms.ListBox> z tekstem "Apple", "pomarańczowa" i "śliwe" w tej kolejności.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawMode">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DrawMode DrawMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DrawMode DrawMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.DrawMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DrawMode As DrawMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DrawMode DrawMode { System::Windows::Forms::DrawMode get(); void set(System::Windows::Forms::DrawMode value); };" />
      <MemberSignature Language="F#" Value="member this.DrawMode : System.Windows.Forms.DrawMode with get, set" Usage="System.Windows.Forms.ListBox.DrawMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb rysowania dla kontrolki.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.DrawMode" /> wartości reprezentujących tryb rysowania elementów formantu. Wartość domyślna to <see langword="DrawMode.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia elementów rysowanych <xref:System.Windows.Forms.ListBox> przez właściciela. Kod używa <xref:System.Windows.Forms.ListBox.DrawMode%2A> właściwości, aby określić, że rysowane elementy są stałym rozmiarem <xref:System.Windows.Forms.ListBox.DrawItem> i zdarzeniem do przeprowadzenia rysowania każdego elementu w <xref:System.Windows.Forms.ListBox>. Przykładowy kod używa właściwości i metod <xref:System.Windows.Forms.DrawItemEventArgs> klasy przekazaną jako parametr do programu obsługi zdarzeń, aby rysować elementy. Ten przykład wymaga, <xref:System.Windows.Forms.ListBox> aby wywołany `listBox1` formant został dodany do formularza i że <xref:System.Windows.Forms.ListBox.DrawItem> zdarzenie jest obsługiwane przez program obsługi zdarzeń zdefiniowany w przykładowym kodzie. Przykład wymaga również, aby elementy zostały dodane do <xref:System.Windows.Forms.ListBox> z tekstem "Apple", "pomarańczowa" i "śliwe" w tej kolejności.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Wartość przypisana do właściwości nie jest elementem członkowskim <see cref="T:System.Windows.Forms.DrawMode" /> wyliczenia.</exception>
        <exception cref="T:System.ArgumentException">Kolumna wielokolumnowa <see cref="T:System.Windows.Forms.ListBox" /> nie może mieć wysokości o zmiennej wielkości.</exception>
        <altmember cref="T:System.Windows.Forms.DrawMode" />
        <altmember cref="E:System.Windows.Forms.ListBox.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="EndUpdate">
      <MemberSignature Language="C#" Value="public void EndUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.EndUpdate" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndUpdate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndUpdate();" />
      <MemberSignature Language="F#" Value="member this.EndUpdate : unit -&gt; unit" Usage="listBox.EndUpdate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia malowanie <see cref="T:System.Windows.Forms.ListBox" /> kontrolki po zakończeniu rysowania <see cref="M:System.Windows.Forms.ListBox.BeginUpdate" /> przez metodę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox> Preferowanym sposobem dodawania elementów do elementu jest <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> użycie metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy (za pomocą <xref:System.Windows.Forms.ListBox.Items%2A> właściwości <xref:System.Windows.Forms.ListBox>). Dzięki temu można dodać do listy tablicę elementów. Jeśli jednak chcesz dodać <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> elementy pojedynczo przy użyciu metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> , możesz użyć metody, aby zapobiec odświeżeniu formantu za każdym razem, <xref:System.Windows.Forms.ListBox> gdy element zostanie dodany do listy. Po zakończeniu zadania dodawania elementów do listy Wywołaj <xref:System.Windows.Forms.ListBox.EndUpdate%2A> metodę, aby <xref:System.Windows.Forms.ListBox> umożliwić odświeżenie. W ten sposób Dodawanie elementów może uniemożliwić migotanie rysowania <xref:System.Windows.Forms.ListBox> po dodaniu dużej liczby elementów do listy.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.ListBox.BeginUpdate%2A> metod i <xref:System.Windows.Forms.ListBox.EndUpdate%2A> podczas <xref:System.Windows.Forms.ListBox>dodawania 5000 elementów do. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie <xref:System.Windows.Forms.Form> została dodana do a i że ta metoda jest umieszczana w formularzu i wywoływana z niej.  
  
 [!code-cpp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox.BeginUpdate Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox.BeginUpdate Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.BeginUpdate" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindString">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który rozpoczyna się od określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindString">
      <MemberSignature Language="C#" Value="public int FindString (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindString(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindString (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindString(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.FindString : string -&gt; int" Usage="listBox.FindString s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do wyszukania.</param>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który rozpoczyna się od określonego ciągu.</summary>
        <returns>Indeks (liczony od zera) pierwszego elementu znaleziony; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu wykonywanym przez tę metodę nie jest rozróżniana wielkość liter. Wyszukiwanie szuka wyrazów, które częściowo pasują do określonego parametru `s`ciągu wyszukiwania. Tej metody można użyć do wyszukania pierwszego elementu, który pasuje do określonego ciągu. Następnie można wykonać zadania, takie jak usunięcie elementu, który zawiera tekst wyszukiwania, przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> metody lub zmiany tekstu elementu. Po znalezieniu określonego tekstu, jeśli chcesz wyszukać inne wystąpienia tekstu w programie <xref:System.Windows.Forms.ListBox>, możesz użyć wersji <xref:System.Windows.Forms.ListBox.FindString%2A> metody, która zawiera parametr służący do określania początkowego indeksu w ramach <xref:System.Windows.Forms.ListBox>. Jeśli chcesz wykonać wyszukiwanie dokładnego dopasowania wyrazu zamiast częściowego dopasowania, użyj <xref:System.Windows.Forms.ListBox.FindStringExact%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.ListBox.FindString%2A> metody do wyszukiwania pierwszego wystąpienia ciągu <xref:System.Windows.Forms.ListBox>w. Jeśli nie znaleziono żadnych elementów pasujących do ciągu <xref:System.Windows.Forms.ListBox.FindString%2A> wyszukiwania zwraca wartość-1, a przykład <xref:System.Windows.Forms.MessageBox>wyświetla. Jeśli zostanie znaleziony element pasujący do tekstu wyszukiwania, w przykładzie zostanie użyta <xref:System.Windows.Forms.ListBox.SetSelected%2A> metoda wybierania elementu <xref:System.Windows.Forms.ListBox>w.  
  
 [!code-cpp[ListBox.FindString2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString2/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString2/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość <paramref name="s" /> parametru jest mniejsza niż-1 lub większa lub równa liczbie elementów.</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindString">
      <MemberSignature Language="C#" Value="public int FindString (string s, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindString(string s, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindString(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindString (s As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindString(System::String ^ s, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.FindString : string * int -&gt; int" Usage="listBox.FindString (s, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do wyszukania.</param>
        <param name="startIndex">Indeks (liczony od zera) elementu przed pierwszym elementem do przeszukania. Ustaw negatywną wartość (-1), aby wyszukać od początku formantu.</param>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który rozpoczyna się od określonego ciągu. Wyszukiwanie rozpoczyna się na określonym indeksie początkowym.</summary>
        <returns>Indeks (liczony od zera) pierwszego elementu znaleziony; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu wykonywanym przez tę metodę nie jest rozróżniana wielkość liter. Wyszukiwanie szuka wyrazów, które częściowo pasują do określonego parametru `s`ciągu wyszukiwania. Tej metody można użyć do wyszukania pierwszego elementu, który pasuje do określonego ciągu na określonym indeksie początkowym na liście elementów dla <xref:System.Windows.Forms.ListBox>. Następnie można wykonać zadania, takie jak usunięcie elementu, który zawiera tekst wyszukiwania, przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> metody lub zmiany tekstu elementu. Ta metoda jest zwykle używana po wywołaniu wywołania przy użyciu wersji tej metody, która nie określa początkowego indeksu. Po znalezieniu początkowego elementu na liście Ta metoda jest zwykle używana do znajdowania dalszych wystąpień tekstu wyszukiwania przez określenie pozycji indeksu w `startIndex` parametrze elementu po pierwszym znalezionym wystąpieniu tekstu wyszukiwania. Jeśli chcesz wykonać wyszukiwanie dokładnego dopasowania wyrazu zamiast częściowego dopasowania, użyj <xref:System.Windows.Forms.ListBox.FindStringExact%2A> metody.  
  
> [!NOTE]
>  Gdy wyszukiwanie osiągnie dolny koniec <xref:System.Windows.Forms.ListBox>, kontynuuje wyszukiwanie od góry <xref:System.Windows.Forms.ListBox> z powrotem do elementu określonego przez `startIndex` parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.ListBox.FindString%2A> metody do wyszukiwania wszystkich wystąpień tekstu wyszukiwania w elementach. <xref:System.Windows.Forms.ListBox> W przykładzie stosowana jest wersja <xref:System.Windows.Forms.ListBox.FindString%2A> metody, która pozwala określić początkowy indeks wyszukiwania, z którego ma być ciągłego wyszukiwania wszystkich elementów <xref:System.Windows.Forms.ListBox>w. W przykładzie pokazano również, jak ustalić, <xref:System.Windows.Forms.ListBox.FindString%2A> Kiedy metoda rozpoczyna wyszukiwanie od góry listy po osiągnięciu dolnej części listy elementów, aby zapobiec przeszukiwaniu cyklicznemu. Po znalezieniu elementów w programie <xref:System.Windows.Forms.ListBox>są one wybierane <xref:System.Windows.Forms.ListBox.SetSelected%2A> przy użyciu metody.  
  
 [!code-cpp[ListBox.FindString#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru jest mniejsza od zera lub większa lub równa wartości <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> właściwości <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> klasy. <paramref name="startIndex" /></exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindStringExact">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który dokładnie pasuje do określonego ciągu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindStringExact">
      <MemberSignature Language="C#" Value="public int FindStringExact (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindStringExact(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindStringExact(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindStringExact (s As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindStringExact(System::String ^ s);" />
      <MemberSignature Language="F#" Value="member this.FindStringExact : string -&gt; int" Usage="listBox.FindStringExact s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do wyszukania.</param>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który dokładnie pasuje do określonego ciągu.</summary>
        <returns>Indeks (liczony od zera) pierwszego elementu znaleziony; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu wykonywanym przez tę metodę nie jest rozróżniana wielkość liter. Wyszukiwanie szuka dokładnego dopasowania do słów określonych w parametrze `s`wyszukiwania ciągu. Tej metody można użyć do wyszukania pierwszego elementu, który pasuje do określonego ciągu. Następnie można wykonać zadania, takie jak usunięcie elementu, który zawiera tekst wyszukiwania, przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> metody lub zmiany tekstu elementu. Po znalezieniu określonego tekstu, jeśli chcesz wyszukać inne wystąpienia tekstu w programie <xref:System.Windows.Forms.ListBox>, możesz użyć wersji <xref:System.Windows.Forms.ListBox.FindStringExact%2A> metody, która zawiera parametr służący do określania początkowego indeksu w ramach <xref:System.Windows.Forms.ListBox>. Jeśli chcesz wykonać częściowe wyszukiwanie słów zamiast dokładnego dopasowania słów, użyj <xref:System.Windows.Forms.ListBox.FindString%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.FindStringExact%2A?displayProperty=nameWithType> metody do <xref:System.Windows.Forms.ListBox> przeszukiwania kontrolki dla elementu, który dokładnie pasuje do określonego ciągu. Jeśli nie znaleziono żadnych elementów pasujących do ciągu wyszukiwania, <xref:System.Windows.Forms.ListBox.FindStringExact%2A> zwraca wartość-1, a przykład <xref:System.Windows.Forms.MessageBox>wyświetla. Jeśli zostanie znaleziony element pasujący do tekstu wyszukiwania, w przykładzie zostanie użyta <xref:System.Windows.Forms.ListBox.SetSelected%2A> metoda wybierania elementu <xref:System.Windows.Forms.ListBox>w.  
  
 [!code-cpp[ListBox.FindStringExact#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindStringExact/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindStringExact#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindStringExact/CS/form1.cs#1)]
 [!code-vb[ListBox.FindStringExact#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindStringExact/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ListBox.FindString(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindStringExact">
      <MemberSignature Language="C#" Value="public int FindStringExact (string s, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindStringExact(string s, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.FindStringExact(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindStringExact (s As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int FindStringExact(System::String ^ s, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.FindStringExact : string * int -&gt; int" Usage="listBox.FindStringExact (s, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">Tekst do wyszukania.</param>
        <param name="startIndex">Indeks (liczony od zera) elementu przed pierwszym elementem do przeszukania. Ustaw negatywną wartość (-1), aby wyszukać od początku formantu.</param>
        <summary>Znajduje pierwszy element w <see cref="T:System.Windows.Forms.ListBox" /> , który dokładnie pasuje do określonego ciągu. Wyszukiwanie rozpoczyna się na określonym indeksie początkowym.</summary>
        <returns>Indeks (liczony od zera) pierwszego elementu znaleziony; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W wyszukiwaniu wykonywanym przez tę metodę nie jest rozróżniana wielkość liter. Wyszukiwanie szuka słów, które dokładnie pasują do określonego parametru `s`ciągu wyszukiwania. Tej metody można użyć do wyszukania pierwszego elementu, który pasuje do określonego ciągu na określonym indeksie początkowym na liście elementów dla <xref:System.Windows.Forms.ListBox>. Następnie można wykonać zadania, takie jak usunięcie elementu zawierającego szukany tekst przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.Remove%2A> metody lub zmianę tekstu elementu. Ta metoda jest zwykle używana po wywołaniu wywołania przy użyciu wersji tej metody, która nie określa początkowego indeksu. Po znalezieniu początkowego elementu na liście Ta metoda jest zwykle używana do znajdowania dalszych wystąpień tekstu wyszukiwania przez określenie pozycji indeksu w `startIndex` parametrze elementu po pierwszym znalezionym wystąpieniu tekstu wyszukiwania. Jeśli chcesz wykonać wyszukiwanie częściowe słowa zamiast dokładnego dopasowania słowa, użyj <xref:System.Windows.Forms.ListBox.FindString%2A> metody.  
  
> [!NOTE]
>  Gdy wyszukiwanie osiągnie dolny koniec <xref:System.Windows.Forms.ListBox>, kontynuuje wyszukiwanie od góry <xref:System.Windows.Forms.ListBox> z powrotem do elementu określonego przez `startIndex` parametr.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.FindStringExact%2A> metody do wyszukania wszystkich elementów <xref:System.Windows.Forms.ListBox> w, które dokładnie pasują do określonego wyszukiwanego tekstu. W przykładzie stosowana jest wersja <xref:System.Windows.Forms.ListBox.FindStringExact%2A> metody, która pozwala określić początkowy indeks wyszukiwania, z którego ma być ciągłego wyszukiwania wszystkich elementów <xref:System.Windows.Forms.ListBox>w. W przykładzie pokazano również, jak ustalić, <xref:System.Windows.Forms.ListBox.FindStringExact%2A> Kiedy metoda rozpoczyna wyszukiwanie od góry listy po osiągnięciu dolnej części listy elementów, aby zapobiec wyszukiwaniu cyklicznemu. Po znalezieniu elementów w programie <xref:System.Windows.Forms.ListBox>są one wybierane <xref:System.Windows.Forms.ListBox.SetSelected%2A> przy użyciu metody.  
  
 [!code-cpp[ListBox.FindStringExact2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindStringExact2/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindStringExact2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindStringExact2/CS/form1.cs#1)]
 [!code-vb[ListBox.FindStringExact2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindStringExact2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru jest mniejsza od zera lub większa lub równa wartości <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> właściwości <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> klasy. <paramref name="startIndex" /></exception>
        <altmember cref="M:System.Windows.Forms.ListBox.FindString(System.String)" />
        <altmember cref="M:System.Windows.Forms.ListBox.ObjectCollection.Contains(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.ListBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę tekstu wyświetlanego przez kontrolkę.</summary>
        <value><see cref="T:System.Drawing.Font" /> Do zastosowania do tekstu wyświetlanego przez kontrolkę. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultFont" /> właściwości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.ListBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu formantu.</summary>
        <value>Pierwszy plan <see cref="T:System.Drawing.Color" /> formantu. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> właściwości.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemHeight">
      <MemberSignature Language="C#" Value="public int GetItemHeight (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetItemHeight(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetItemHeight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemHeight (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetItemHeight(int index);" />
      <MemberSignature Language="F#" Value="member this.GetItemHeight : int -&gt; int" Usage="listBox.GetItemHeight index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu, dla którego ma zostać zwrócona wysokość.</param>
        <summary>Zwraca wysokość elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <returns>Wysokość, w pikselach, określonego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość nie jest ustawiona na `DrawMode.OwnerDrawVariable`, wartość parametru indeksu jest ignorowana, ponieważ wszystkie elementy w standardzie <xref:System.Windows.Forms.ListBox> mają ten sam rozmiar. <xref:System.Windows.Forms.ListBox.DrawMode%2A> Tej właściwości można użyć podczas korzystania przez właściciela <xref:System.Windows.Forms.ListBox> w celu określenia rozmiaru dowolnego elementu <xref:System.Windows.Forms.ListBox>w.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określona wartość <paramref name="index" /> parametru jest mniejsza od zera lub większa od liczby elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetItemRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetItemRectangle (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetItemRectangle(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetItemRectangle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemRectangle (index As Integer) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetItemRectangle(int index);" />
      <MemberSignature Language="F#" Value="member this.GetItemRectangle : int -&gt; System.Drawing.Rectangle" Usage="listBox.GetItemRectangle index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu, którego prostokąt ograniczający ma zostać zwrócony.</param>
        <summary>Zwraca prostokąt powiązany dla elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <returns><see cref="T:System.Drawing.Rectangle" /> Reprezentujący prostokąt powiązany dla określonego elementu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element określony w `index` parametrze nie jest widoczny, prostokąt zwracany przez tę metodę będzie spoza widocznej części formantu. Tej metody można użyć do określenia rozmiaru i pozycji elementu na liście. Aby uzyskać wysokość elementu, szczególnie właściciela elementu listy o zmiennej wysokości, można użyć <xref:System.Windows.Forms.ListBox.GetItemHeight%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru jest mniejsza od zera lub większa lub równa wartości <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> właściwości <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> klasy. <paramref name="index" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="listBox.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">Element <see cref="T:System.Drawing.Rectangle" /> określający obszar, dla którego mają zostać pobrane granice wyświetlania.</param>
        <param name="factor">Wysokość i szerokość granic formantu.</param>
        <param name="specified">Jedna z wartości <see cref="T:System.Windows.Forms.BoundsSpecified" /> , która określa granice formantu do użycia podczas definiowania jego rozmiaru i położenia.</param>
        <summary>Pobiera granice, w których <see cref="T:System.Windows.Forms.ListBox" /> jest skalowany.</summary>
        <returns><see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice, w których kontrolka jest skalowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox> Klasa<xref:System.Windows.Forms.Control.GetScaledBounds%2A?displayProperty=nameWithType> przesłania metodę, aby upewnić się, że żądana wysokość jest skalowana, a nie z bieżącą wysokością.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSelected">
      <MemberSignature Language="C#" Value="public bool GetSelected (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetSelected(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.GetSelected(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSelected (index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetSelected(int index);" />
      <MemberSignature Language="F#" Value="member this.GetSelected : int -&gt; bool" Usage="listBox.GetSelected index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu, który określa, czy jest wybrany.</param>
        <summary>Zwraca wartość wskazującą, czy wybrany element jest zaznaczony.</summary>
        <returns><see langword="true" />Jeśli określony element jest aktualnie wybrany w <see cref="T:System.Windows.Forms.ListBox" />; w przeciwnym razie,. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej metody można szybko określić, czy wybrany element jest zaznaczony. Ta metoda jest przydatna, gdy należy wykonać konkretną operację, gdy wybrano określony element w wielokrotnym wyborze <xref:System.Windows.Forms.ListBox> .  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.GetSelected%2A> metody w celu ustalenia, które elementy w, <xref:System.Windows.Forms.ListBox> są zaznaczone, aby wybrać elementy, które nie są wybrane i usunąć zaznaczenie wybranych elementów. W przykładzie pokazano również, jak <xref:System.Windows.Forms.ListBox.SelectionMode%2A> użyć właściwości, aby <xref:System.Windows.Forms.ListBox> włączyć więcej niż jeden <xref:System.Windows.Forms.ListBox.Sorted%2A> wybrany element i używa właściwości, <xref:System.Windows.Forms.ListBox> aby zademonstrować sposób sortowania elementów w automatycznie. Ten przykład <xref:System.Windows.Forms.ListBox>wymaga, aby do formularza `listBox1`został dodany, nazwany, i że `InitializeMyListBox` Metoda <xref:System.Windows.Forms.Form.Load> zdefiniowana w przykładzie jest wywoływana ze zdarzenia formularza.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość parametru jest mniejsza od zera lub większa lub równa wartości <see cref="P:System.Windows.Forms.ListBox.ObjectCollection.Count" /> właściwości <see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> klasy. <paramref name="index" /></exception>
      </Docs>
    </Member>
    <Member MemberName="HorizontalExtent">
      <MemberSignature Language="C#" Value="public int HorizontalExtent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HorizontalExtent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.HorizontalExtent" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalExtent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HorizontalExtent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalExtent : int with get, set" Usage="System.Windows.Forms.ListBox.HorizontalExtent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość, za pomocą której <see cref="T:System.Windows.Forms.ListBox" /> można przewijać poziomy pasek przewijania.</summary>
        <value>Szerokość w pikselach, którą poziomy pasek przewijania może przewijać kontrolkę. Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość tylko raportuje przydatną wartość, <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> Jeśli właściwość jest ustawiona `true`na. Jeśli szerokość <xref:System.Windows.Forms.ListBox> jest mniejsza niż wartość tej właściwości, poziomy pasek przewijania <xref:System.Windows.Forms.ListBox>w poziomie przewija elementy w. Jeśli szerokość <xref:System.Windows.Forms.ListBox> jest równa lub większa od tej wartości, poziomy pasek przewijania jest ukryty. Wartość tej właściwości nie jest aktualizowana dynamicznie przez <xref:System.Windows.Forms.ListBox>. Ta właściwość jest przydatna, gdy elementy <xref:System.Windows.Forms.ListBox> są rysowane przez właściciela. Na przykład, jeśli elementy <xref:System.Windows.Forms.ListBox> , które są rysowane przez właściciela są 200 pikseli szerokości, ale o <xref:System.Windows.Forms.ListBox> szerokości do <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> 60 pikseli, właściwość musi być ustawiona na 200, aby przewijać prawą krawędź elementów do widocznego regionu formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> właściwości i <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> do wyświetlania poziomego paska przewijania, który pokazuje <xref:System.Windows.Forms.ListBox> cały tekst elementu w formancie. W przykładzie użyta <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> jest również właściwość, aby upewnić się, że elementy nie są częściowo wyświetlane ze <xref:System.Windows.Forms.ListBox> względu na rozmiar kontrolki. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalScrollbar">
      <MemberSignature Language="C#" Value="public bool HorizontalScrollbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HorizontalScrollbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalScrollbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HorizontalScrollbar { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalScrollbar : bool with get, set" Usage="System.Windows.Forms.ListBox.HorizontalScrollbar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy w formancie jest wyświetlany poziomy pasek przewijania.</summary>
        <value><see langword="true" />Aby wyświetlić poziomy pasek przewijania w kontrolce; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość określa, <xref:System.Windows.Forms.ListBox> czy powinien być wyświetlany poziomy pasek przewijania, gdy <xref:System.Windows.Forms.ListBox> szerokość elementów w obrębie wykracza poza prawą krawędź formantu. <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> Gdy ta właściwość jest ustawiona na `true`, pasek przewijania jest automatycznie wyświetlany na podstawie szerokości elementów <xref:System.Windows.Forms.ListBox>w. Jeśli jest rysowany <xref:System.Windows.Forms.ListBox>przez właściciela, aby prawidłowo wyświetlić poziomy pasek przewijania <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> , należy ustawić właściwość. <xref:System.Windows.Forms.ListBox>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> właściwości i <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> do wyświetlania poziomego paska przewijania, który pokazuje <xref:System.Windows.Forms.ListBox> cały tekst elementu w formancie. W przykładzie użyta <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> jest również właściwość, aby upewnić się, że elementy nie są częściowo wyświetlane ze <xref:System.Windows.Forms.ListBox> względu na rozmiar kontrolki. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalExtent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexFromPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca indeks (liczony od zera) elementu na określonych współrzędnych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexFromPoint">
      <MemberSignature Language="C#" Value="public int IndexFromPoint (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexFromPoint(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.IndexFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexFromPoint (p As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexFromPoint(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.IndexFromPoint : System.Drawing.Point -&gt; int" Usage="listBox.IndexFromPoint p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p"><see cref="T:System.Drawing.Point" /> Obiekt zawierający współrzędne używane do uzyskania indeksu elementu.</param>
        <summary>Zwraca indeks (liczony od zera) elementu na określonych współrzędnych.</summary>
        <returns>Indeks (liczony od zera) elementu znaleziony na określonych współrzędnych; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia określenie, który element znajduje się w określonej lokalizacji w formancie. Za pomocą tej metody można określić, który element na liście jest wybierany, gdy użytkownik kliknie <xref:System.Windows.Forms.ListBox>prawym przyciskiem myszy. Lokalizację kursora można określić i przekazywać do `p` parametru <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> metody, aby określić, który element został kliknięty prawym przyciskiem myszy. Następnie można wyświetlić menu skrótów dla użytkownika, aby udostępnić zadania i funkcje na podstawie określonego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wykonywania operacji przeciągania i upuszczania za pomocą <xref:System.Windows.Forms.ListBox> kontrolki, która zawiera elementy do porzucenia <xref:System.Windows.Forms.RichTextBox> do kontrolki. Konstruktor formularza ustawia <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> właściwość na `true` , aby umożliwić <xref:System.Windows.Forms.RichTextBox>wykonywanie operacji przeciągania i upuszczania w. W przykładzie używa <xref:System.Windows.Forms.Control.MouseDown> się zdarzenia, <xref:System.Windows.Forms.ListBox> aby rozpocząć operację <xref:System.Windows.Forms.Control.DoDragDrop%2A> przeciągania przez wywołanie metody. W przykładzie używa <xref:System.Windows.Forms.Control.DragEnter> się zdarzenia, aby określić, czy element, który jest przeciągany do elementu, <xref:System.Windows.Forms.RichTextBox> jest prawidłowym typem danych. Zdarzenie wykonuje rzeczywiste upuszczenie przeciąganego elementu <xref:System.Windows.Forms.RichTextBox> do kontrolki w <xref:System.Windows.Forms.RichTextBox>bieżącej lokalizacji kursora w obrębie. <xref:System.Windows.Forms.Control.DragDrop> Ten przykład wymaga, aby <xref:System.Windows.Forms.Control.DragDrop> zdarzenia <xref:System.Windows.Forms.Control.DragEnter> i były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexFromPoint">
      <MemberSignature Language="C#" Value="public int IndexFromPoint (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexFromPoint(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.IndexFromPoint(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexFromPoint (x As Integer, y As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexFromPoint(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.IndexFromPoint : int * int -&gt; int" Usage="listBox.IndexFromPoint (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Współrzędna x lokalizacji do przeszukania.</param>
        <param name="y">Współrzędna y lokalizacji do przeszukania.</param>
        <summary>Zwraca indeks (liczony od zera) elementu na określonych współrzędnych.</summary>
        <returns>Indeks (liczony od zera) elementu znaleziony na określonych współrzędnych; zwraca <see langword="ListBox.NoMatches" /> wartość, jeśli nie znaleziono żadnego dopasowania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia określenie, który element znajduje się w określonej lokalizacji w formancie. Za pomocą tej metody można określić, który element na liście jest wybierany, gdy użytkownik kliknie <xref:System.Windows.Forms.ListBox>prawym przyciskiem myszy. Lokalizację kursora można określić i przesłać do `x` parametrów <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> i `y` metody, aby określić, który element użytkownik kliknie prawym przyciskiem myszy. Następnie można wyświetlić menu skrótów dla użytkownika, aby udostępnić zadania i funkcje na podstawie określonego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób wykonywania operacji przeciągania i upuszczania za pomocą <xref:System.Windows.Forms.ListBox> kontrolki, która zawiera elementy do porzucenia <xref:System.Windows.Forms.RichTextBox> do kontrolki. Konstruktor formularza ustawia <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> właściwość na `true` , aby umożliwić <xref:System.Windows.Forms.RichTextBox>wykonywanie operacji przeciągania i upuszczania w. W przykładzie używa <xref:System.Windows.Forms.Control.MouseDown> się zdarzenia, <xref:System.Windows.Forms.ListBox> aby rozpocząć operację <xref:System.Windows.Forms.Control.DoDragDrop%2A> przeciągania przez wywołanie metody. W przykładzie używa <xref:System.Windows.Forms.Control.DragEnter> się zdarzenia, aby określić, czy element, który jest przeciągany do elementu, <xref:System.Windows.Forms.RichTextBox> jest prawidłowym typem danych. Zdarzenie wykonuje rzeczywiste upuszczenie przeciąganego elementu <xref:System.Windows.Forms.RichTextBox> do kontrolki w <xref:System.Windows.Forms.RichTextBox>bieżącej lokalizacji kursora w obrębie. <xref:System.Windows.Forms.Control.DragDrop> Ten przykład wymaga, aby <xref:System.Windows.Forms.Control.DragDrop> zdarzenia <xref:System.Windows.Forms.Control.DragEnter> i były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IntegralHeight">
      <MemberSignature Language="C#" Value="public bool IntegralHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IntegralHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.IntegralHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property IntegralHeight As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IntegralHeight { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IntegralHeight : bool with get, set" Usage="System.Windows.Forms.ListBox.IntegralHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant powinien zmienić rozmiar, aby uniknąć wyświetlania częściowych elementów.</summary>
        <value><see langword="true" />Jeśli formant zmienia rozmiar, tak aby nie wyświetlał częściowych elementów; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość jest ustawiona na `true`, formant automatycznie zmienia rozmiar, aby upewnić się, że element nie jest częściowo wyświetlany. Jeśli chcesz zachować oryginalny rozmiar <xref:System.Windows.Forms.ListBox> w oparciu o wymagania dotyczące miejsca w formularzu, ustaw tę właściwość na. `false`  
  
 <xref:System.Windows.Forms.ListBox> Domyślnie<xref:System.Windows.Forms.CheckedListBox> i rozmiary są takie, aby pokazywały tylko całe elementy. Jeśli chcesz <xref:System.Windows.Forms.ListBox> <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> , aby całkowicie wypełnić obszar zadokowany, ustaw wartość na `false`. <xref:System.Windows.Forms.CheckedListBox> Powoduje to całkowite wypełnienie obszaru przez formant, ale ostatni element nie jest w pełni wyświetlany.  
  
 <xref:System.Windows.Forms.ListBox> Jeśli nie zawiera żadnych elementów, ta właściwość nie ma żadnego skutku.  
  
> [!NOTE]
>  Wysokość całkowity jest oparta na wysokości <xref:System.Windows.Forms.ListBox>, a nie na wysokości obszaru klienta. W związku z tym <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> , gdy właściwość jest ustawiona `true`, elementy można nadal pokazać częściowo, jeśli są wyświetlane paski przewijania.  
  
> [!NOTE]
>  Jeśli właściwość jest ustawiona na `DrawMode.OwnerDrawVariable`, ta właściwość nie ma żadnego skutku. <xref:System.Windows.Forms.ListBox.DrawMode%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> właściwości i <xref:System.Windows.Forms.ListBox.HorizontalExtent%2A> do wyświetlania poziomego paska przewijania, który pokazuje <xref:System.Windows.Forms.ListBox> cały tekst elementu w formancie. W przykładzie użyta <xref:System.Windows.Forms.ListBox.IntegralHeight%2A> jest również właściwość, aby upewnić się, że elementy nie są częściowo wyświetlane ze <xref:System.Windows.Forms.ListBox> względu na rozmiar kontrolki. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[ListView.HorizontalExtent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListView.HorizontalExtent/CPP/form1.cpp#1)]
 [!code-csharp[ListView.HorizontalExtent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListView.HorizontalExtent/CS/form1.cs#1)]
 [!code-vb[ListView.HorizontalExtent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListView.HorizontalExtent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ItemHeight">
      <MemberSignature Language="C#" Value="public virtual int ItemHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ItemHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ItemHeight" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ItemHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int ItemHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ItemHeight : int with get, set" Usage="System.Windows.Forms.ListBox.ItemHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(13)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Wysokość elementu w formancie (w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest ustawiona na `DrawMode.OwnerDrawFixed`, wszystkie elementy mają taką samą wysokość. <xref:System.Windows.Forms.ListBox.DrawMode%2A> Gdy właściwość jest ustawiona na `DrawMode.OwnerDrawVariable`, <xref:System.Windows.Forms.ListBox.ItemHeight%2A> Właściwość określa wysokość każdego elementu dodanego do <xref:System.Windows.Forms.ListBox>. <xref:System.Windows.Forms.ListBox.DrawMode%2A> Ponieważ każdy element na liście rysowania przez właściciela może mieć inną wysokość, można użyć <xref:System.Windows.Forms.ListBox.GetItemHeight%2A> metody, aby uzyskać wysokość określonego elementu <xref:System.Windows.Forms.ListBox>w. W przypadku użycia <xref:System.Windows.Forms.ListBox.ItemHeight%2A> właściwości zelementamiozmiennejwysokościtawłaściwośćzwracawysokośćpierwszegoelementuwkontrolce.<xref:System.Windows.Forms.ListBox>  
  
 Maksymalna wysokość <xref:System.Windows.Forms.ListBox> elementu to 255 pikseli.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:System.Windows.Forms.ListBox.ItemHeight" /> Właściwość została ustawiona na wartość mniejszą niż 0 lub więcej niż 255 pikseli.</exception>
        <altmember cref="M:System.Windows.Forms.ListBox.GetItemHeight(System.Int32)" />
        <altmember cref="P:System.Windows.Forms.ListBox.DrawMode" />
        <altmember cref="E:System.Windows.Forms.ListBox.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.ObjectCollection Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/ObjectCollection Items" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ListBox.ObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::ObjectCollection ^ Items { System::Windows::Forms::ListBox::ObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Windows.Forms.ListBox.ObjectCollection" Usage="System.Windows.Forms.ListBox.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ListControlStringCollectionEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+ObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera elementy <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox.ObjectCollection" /> Reprezentuje elementy <see cref="T:System.Windows.Forms.ListBox" />w.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia uzyskanie odwołania do listy elementów, które są obecnie przechowywane w <xref:System.Windows.Forms.ListBox>. Za pomocą tego odwołania można dodawać elementy, usuwać elementy i uzyskiwać liczbę elementów w kolekcji. Aby uzyskać więcej informacji o zadaniach, które można wykonać za pomocą kolekcji elementów, zobacz <xref:System.Windows.Forms.ListBox.ObjectCollection> tematy dotyczące klas.  
  
 Można również manipulować elementami a <xref:System.Windows.Forms.ListBox> za <xref:System.Windows.Forms.ListControl.DataSource%2A> pomocą właściwości. Jeśli <xref:System.Windows.Forms.ListControl.DataSource%2A> używasz właściwości, aby dodać elementy do elementu <xref:System.Windows.Forms.ListBox>, można <xref:System.Windows.Forms.ListBox> wyświetlić <xref:System.Windows.Forms.ListBox.Items%2A> elementy w użyciu właściwości, ale nie można dodawać <xref:System.Windows.Forms.ListBox.ObjectCollection>ani usuwać elementów z listy przy użyciu metod.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć <xref:System.Windows.Forms.ListBox> kontrolkę wyświetlającą wiele elementów w kolumnach i na liście kontrolki można wybrać więcej niż jeden element. Kod dla przykładu <xref:System.Windows.Forms.ListBox> dodaje 50 elementów do <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy, a następnie <xref:System.Windows.Forms.ListBox.SetSelected%2A> wybiera trzy elementy z listy przy użyciu metody. Następnie kod <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> wyświetla wartości z kolekcji ( <xref:System.Windows.Forms.ListBox.SelectedItems%2A> przez właściwość) <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> i <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> (przez właściwość). Ten przykład wymaga, aby kod znajdował się w i został wywołany przez <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ListBox.ObjectCollection" />
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy tworzony <see cref="T:System.Windows.Forms.ListBox" /> jest utworzony przez właściciela i są określane rozmiary elementów listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia, aby określić rozmiar elementu, który zostanie narysowany w <xref:System.Windows.Forms.ListBox.DrawItem> zdarzeniu. Zdarzenie jest wywoływane tylko wtedy, <xref:System.Windows.Forms.ListBox.DrawMode%2A> gdy właściwość jest ustawiona na. <xref:System.Windows.Forms.DrawMode.OwnerDrawVariable>  
  
 Maksymalna prawidłowa wysokość <xref:System.Windows.Forms.ListBox> elementu to 255 pikseli. <xref:System.Windows.Forms.MeasureItemEventArgs.ItemHeight%2A> Ustawienie właściwości <xref:System.Windows.Forms.MeasureItemEventArgs> na wartość większą niż 255 podczas obsługi tego zdarzenia może dać nieoczekiwane wyniki.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje właściciela <xref:System.Windows.Forms.ListBox> przez <xref:System.Windows.Forms.ListBox.DrawMode%2A> ustawienie <xref:System.Windows.Forms.ListBox.DrawItem> właściwości na <xref:System.Windows.Forms.DrawMode.OwnerDrawVariable> i obsługę zdarzeń i <xref:System.Windows.Forms.ListBox.MeasureItem> . Przedstawiono w <xref:System.Windows.Forms.ListBox.BorderStyle%2A> nim również ustawienia i <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> właściwości oraz przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> metody.  
  
 Aby uruchomić ten przykład, wklej go w postaci pustej, która importuje <xref:System.Drawing> przestrzeń nazw <xref:System.Windows.Forms> i przestrzeń nazw. Wywołanie `InitializeOwnerDrawnListBox` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń.  
  
 [!code-cpp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.ItemHeight" />
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie <see cref="T:System.Windows.Forms.ListBox" /> formant ze wskaźnikiem myszy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiColumn">
      <MemberSignature Language="C#" Value="public bool MultiColumn { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MultiColumn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.MultiColumn" />
      <MemberSignature Language="VB.NET" Value="Public Property MultiColumn As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MultiColumn { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MultiColumn : bool with get, set" Usage="System.Windows.Forms.ListBox.MultiColumn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, <see cref="T:System.Windows.Forms.ListBox" /> czy obsługuje wiele kolumn.</summary>
        <value><see langword="true" />Jeśli obsługuje wiele kolumn; w <see langword="false" />przeciwnym razie. <see cref="T:System.Windows.Forms.ListBox" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele kolumn <xref:System.Windows.Forms.ListBox> umieszcza elementy na tyle kolumn, ile jest potrzebnych do niepotrzebnego przewijania w pionie. Użytkownik może użyć klawiatury, aby przejść do kolumn, które nie są obecnie widoczne. Ustaw właściwość na `true` , aby wyświetlić poziomy pasek przewijania, który umożliwia użytkownikowi przewijanie do kolumn, które nie są aktualnie wyświetlane w widocznym regionie <xref:System.Windows.Forms.ListBox>. <xref:System.Windows.Forms.ListBox.HorizontalScrollbar%2A> Wartość <xref:System.Windows.Forms.ListBox.ColumnWidth%2A> właściwości określa szerokość każdej kolumny.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje prostą dwie kolumny <xref:System.Windows.Forms.ListBox>.  
  
 [!code-csharp[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBox.MultiColumn#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBox.MultiColumn/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kolumna wielokolumnowa <see cref="T:System.Windows.Forms.ListBox" /> nie może mieć wysokości o zmiennej wielkości.</exception>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
        <altmember cref="P:System.Windows.Forms.ListBox.ColumnWidth" />
      </Docs>
    </Member>
    <Member MemberName="NoMatches">
      <MemberSignature Language="C#" Value="public const int NoMatches = -1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 NoMatches = (-1)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.ListBox.NoMatches" />
      <MemberSignature Language="VB.NET" Value="Public Const NoMatches As Integer  = -1" />
      <MemberSignature Language="C++ CLI" Value="public: int NoMatches = -1;" />
      <MemberSignature Language="F#" Value="val mutable NoMatches : int" Usage="System.Windows.Forms.ListBox.NoMatches" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>-1</MemberValue>
      <Docs>
        <summary>Określa, że podczas wyszukiwania nie znaleziono żadnych dopasowań.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta stała jest zwracana przez <xref:System.Windows.Forms.ListBox.FindString%2A>metody, <xref:System.Windows.Forms.ListBox.FindStringExact%2A>i <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A> , gdy w wyszukiwaniu nie znaleziono pasujących wartości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected override void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="listBox.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.UICuesEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ChangeUICues" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected override void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="listBox.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.DataSourceChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayMemberChanged">
      <MemberSignature Language="C#" Value="protected override void OnDisplayMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDisplayMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDisplayMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDisplayMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDisplayMemberChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnDisplayMemberChanged : EventArgs -&gt; unit" Usage="listBox.OnDisplayMemberChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.DisplayMemberChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="listBox.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.DrawItemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListBox.DrawItem" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.ListBox.OnDrawItem%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób tworzenia elementów rysowanych <xref:System.Windows.Forms.ListBox> przez właściciela. Kod używa <xref:System.Windows.Forms.ListBox.DrawMode%2A> właściwości, aby określić, że rysowane elementy są stałym rozmiarem <xref:System.Windows.Forms.ListBox.DrawItem> i zdarzeniem do przeprowadzenia rysowania każdego elementu w <xref:System.Windows.Forms.ListBox>. Przykładowy kod używa właściwości i metod <xref:System.Windows.Forms.DrawItemEventArgs> klasy przekazaną jako parametr do programu obsługi zdarzeń, aby rysować elementy. Ten przykład wymaga, <xref:System.Windows.Forms.ListBox> aby wywołany `listBox1` formant został dodany do formularza i że <xref:System.Windows.Forms.ListBox.DrawItem> zdarzenie jest obsługiwane przez program obsługi zdarzeń zdefiniowany w przykładowym kodzie. Przykład wymaga również, aby elementy zostały dodane do <xref:System.Windows.Forms.ListBox> z tekstem "Apple", "pomarańczowa" i "śliwe" w tej kolejności.  
  
 [!code-csharp[ListBox.DrawMode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.DrawMode/CS/form1.cs#1)]
 [!code-vb[ListBox.DrawMode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.DrawMode/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.ListBox.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.ListBox.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="listBox.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnGotFocus : EventArgs -&gt; unit" Usage="listBox.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="listBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Określa, kiedy zostanie utworzone uchwyt okna, aby można było ustawić szerokość kolumny i inne cechy. Dziedziczenie klas powinno być <see langword="base.OnHandleCreated" />wywoływane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="listBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Został zastąpiony, aby upewnić się, że elementy są skonfigurowane i wyczyszczone prawidłowo. Kontrolki dziedziczenia powinny <see langword="base.OnHandleDestroyed" />być wywoływane.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="listBox.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MeasureItemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListBox.MeasureItem" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.ListBox.OnMeasureItem%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.ListBox.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.ListBox.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected override void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnParentChanged : EventArgs -&gt; unit" Usage="listBox.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ParentChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnResize : EventArgs -&gt; unit" Usage="listBox.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedIndexChanged">
      <MemberSignature Language="C#" Value="protected override void OnSelectedIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSelectedIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnSelectedIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSelectedIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSelectedIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSelectedIndexChanged : EventArgs -&gt; unit" Usage="listBox.OnSelectedIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.SelectedValueChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedValueChanged">
      <MemberSignature Language="C#" Value="protected override void OnSelectedValueChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnSelectedValueChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.OnSelectedValueChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnSelectedValueChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnSelectedValueChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnSelectedValueChanged : EventArgs -&gt; unit" Usage="listBox.OnSelectedValueChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.ListControl.SelectedValueChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.ListBox.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest istotna dla tej klasy.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> Wartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest istotna dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.ListBox.Padding" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Windows.Forms.ListBox" /> narysowaniu kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.ListBox.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną wysokość wszystkich elementów w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Połączona wysokość (w pikselach) wszystkich elementów w formancie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość pozwala określić wysokość <xref:System.Windows.Forms.ListBox> , do której należy mieć rozmiar, aby można było wyświetlić każdy dostępny element na liście i uniknąć wyświetlania pionowych pasków przewijania. Jeśli <xref:System.Windows.Forms.ListBox> ilość elementów w jest duża, rozmiar kontrolki przy użyciu wartości <xref:System.Windows.Forms.ListBox.PreferredHeight%2A> właściwości może spowodować, że <xref:System.Windows.Forms.ListBox> rozmiar będzie się poza obszarem klienta formularza lub <xref:System.Windows.Forms.ListBox> kontenera.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak <xref:System.Windows.Forms.Control.Size%2A> ustawić właściwość <xref:System.Windows.Forms.ListBox> na podstawie wartości <xref:System.Windows.Forms.ListBox.PreferredHeight%2A> właściwości <xref:System.Windows.Forms.ListBox> w celu wyświetlenia wszystkich elementów z paska przewijania bez użycia. Ten przykład wymaga <xref:System.Windows.Forms.ListBox> , aby kontrolka o `listBox1`nazwie została dodana do formularza.  
  
 [!code-cpp[ListBox.PreferredHeight#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.PreferredHeight/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.PreferredHeight#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.PreferredHeight/CS/form1.cs#1)]
 [!code-vb[ListBox.PreferredHeight#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.PreferredHeight/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public override void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Refresh();" />
      <MemberSignature Language="F#" Value="override this.Refresh : unit -&gt; unit" Usage="listBox.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza, aby formant unieważnił swój obszar klienta i natychmiast ponownie narysować wszystkie formanty podrzędne.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshItem">
      <MemberSignature Language="C#" Value="protected override void RefreshItem (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RefreshItem(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RefreshItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RefreshItem (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RefreshItem(int index);" />
      <MemberSignature Language="F#" Value="override this.RefreshItem : int -&gt; unit" Usage="listBox.RefreshItem index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu do odświeżenia.</param>
        <summary>Odświeża element zawarty w określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona i właściwość w źródle danych, która jest przypisana do <xref:System.Windows.Forms.ListControl.DisplayMember%2A> zmian, użyj <xref:System.Windows.Forms.ListBox.RefreshItem%2A> metody, aby zaktualizować wartość w <xref:System.Windows.Forms.ListBox> kontrolce. <xref:System.Windows.Forms.ListControl.DisplayMember%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshItems">
      <MemberSignature Language="C#" Value="protected override void RefreshItems ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RefreshItems() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RefreshItems" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RefreshItems ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RefreshItems();" />
      <MemberSignature Language="F#" Value="override this.RefreshItems : unit -&gt; unit" Usage="listBox.RefreshItems " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odświeża wszystkie <see cref="T:System.Windows.Forms.ListBox" /> elementy i pobiera z nich nowe ciągi.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected override void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="listBox.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Wartość DPI przed zmianą.</param>
        <param name="deviceDpiNew">Wartość DPI po zmianie.</param>
        <summary>Zapewnia stałe do ponownego skalowania kontrolki po wystąpieniu zmiany DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public override void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetBackColor();" />
      <MemberSignature Language="F#" Value="override this.ResetBackColor : unit -&gt; unit" Usage="listBox.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.BackColor" /> właściwość do wartości domyślnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public override void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetForeColor();" />
      <MemberSignature Language="F#" Value="override this.ResetForeColor : unit -&gt; unit" Usage="listBox.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.ForeColor" /> właściwość do wartości domyślnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.ListBox.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy tekst wyświetlany przez formant jest wyświetlany od prawej do lewej.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.RightToLeft" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia Twoim menu obsługę języków pisanych od prawej do lewej. Gdy ta właściwość jest ustawiona na `true`, tekst elementu jest wyświetlany od prawej do lewej zamiast domyślnej metody od lewej do prawej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="listBox.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Współczynnik, za pomocą którego będzie skalowana wysokość i szerokość kontrolki.</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> Wartość określająca granice formantu do użycia podczas definiowania jego rozmiaru i położenia.</param>
        <summary>Skaluje lokalizację, rozmiar, wypełnienie i margines formantu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollAlwaysVisible">
      <MemberSignature Language="C#" Value="public bool ScrollAlwaysVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScrollAlwaysVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.ScrollAlwaysVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollAlwaysVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ScrollAlwaysVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollAlwaysVisible : bool with get, set" Usage="System.Windows.Forms.ListBox.ScrollAlwaysVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pionowy pasek przewijania jest wyświetlany przez cały czas.</summary>
        <value><see langword="true" />Jeśli pionowy pasek przewijania powinien być zawsze wyświetlany; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość wskazuje, czy pionowy pasek przewijania jest zawsze wyświetlany, nawet jeśli liczba elementów <xref:System.Windows.Forms.ListBox> w elemencie nie wymaga wyświetlania pionowego paska przewijania. <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> Domyślnie jest wyświetlany pionowy pasek przewijania, <xref:System.Windows.Forms.ListBox> gdy jest wystarczająca ilość elementów do wyświetlenia. Dla wielokolumnowej <xref:System.Windows.Forms.ListBox> <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> właściwości Właściwość wskazuje, że wyświetlany jest poziomy pasek przewijania. Pionowy pasek przewijania nigdy nie jest wyświetlany niezależnie od wartości tej właściwości dla wielokolumnowej <xref:System.Windows.Forms.ListBox>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje właociciela <xref:System.Windows.Forms.ListBox> przez <xref:System.Windows.Forms.ListBox.DrawMode%2A> ustawienie właściwości na `OwnerDrawVariable` wartość i obsługę <xref:System.Windows.Forms.ListBox.DrawItem> zdarzeń i <xref:System.Windows.Forms.ListBox.MeasureItem> . Przedstawiono w <xref:System.Windows.Forms.ListBox.BorderStyle%2A> nim również ustawienia i <xref:System.Windows.Forms.ListBox.ScrollAlwaysVisible%2A> właściwości oraz przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.AddRange%2A> metody.  
  
 Aby uruchomić ten przykład, wklej go w postaci pustej, która importuje <xref:System.Drawing> przestrzeń nazw <xref:System.Windows.Forms> i przestrzeń nazw. Wywołanie `InitializeOwnerDrawnListBox` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń.  
  
 [!code-cpp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.HorizontalScrollbar" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndex">
      <MemberSignature Language="C#" Value="public override int SelectedIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectedIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedIndex" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectedIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedIndex : int with get, set" Usage="System.Windows.Forms.ListBox.SelectedIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks (liczony od zera) aktualnie wybranego elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Indeks (liczony od zera) aktualnie wybranego elementu. Wartość ujemna (-1) jest zwracana, jeśli nie wybrano żadnego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku standardu <xref:System.Windows.Forms.ListBox>można użyć tej właściwości, aby określić indeks elementu, który został wybrany <xref:System.Windows.Forms.ListBox>w. `SelectionMode.MultiSimple` <xref:System.Windows.Forms.ListBox>Jeśli właściwość jest<xref:System.Windows.Forms.ListBox> ustawiona na lub`SelectionMode.MultiExtended` (która wskazuje wybór wielokrotny), a na liście wybrano wiele elementów, ta właściwość może zwrócić indeks do dowolnego wybranego elementu. <xref:System.Windows.Forms.ListBox.SelectionMode%2A>  
  
 Aby pobrać kolekcję zawierającą indeksy wszystkich wybranych elementów z wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> Użyj właściwości. Jeśli chcesz uzyskać element, który jest aktualnie wybrany w <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedItem%2A> Użyj właściwości. Ponadto można użyć <xref:System.Windows.Forms.ListBox.SelectedItems%2A> właściwości, aby uzyskać wszystkie wybrane elementy z wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób używania <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> właściwości <xref:System.Windows.Forms.ListBox.TopIndex%2A> z właściwością do przenoszenia aktualnie wybranego elementu do góry listy elementów w obszarze <xref:System.Windows.Forms.ListBox>wyświetlania. W przykładzie przedstawiono dalsze instrukcje usuwania elementów przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> klasy oraz sposób czyszczenia <xref:System.Windows.Forms.ListBox.ClearSelected%2A> wszystkich elementów przy użyciu metody. Kod najpierw przenosi aktualnie zaznaczony element w <xref:System.Windows.Forms.ListBox> górę na początku listy. Następnie kod usuwa wszystkie elementy przed aktualnie wybranym elementem i czyści wszystkie zaznaczenia w <xref:System.Windows.Forms.ListBox>. Ten przykład wymaga, aby <xref:System.Windows.Forms.ListBox> element zawierający elementy został dodany do formularza i że <xref:System.Windows.Forms.ListBox>w.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przypisana wartość jest mniejsza niż-1 lub większa lub równa liczbie elementów.</exception>
        <exception cref="T:System.ArgumentException">Właściwość jest ustawiona na <see langword="None" />. <see cref="P:System.Windows.Forms.ListBox.SelectionMode" /></exception>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndices" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItems" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItem" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectedIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectedIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.SelectedIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectedIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedIndexChanged : EventHandler " Usage="member this.SelectedIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="P:System.Windows.Forms.ListBox.SelectedIndex" /> zmianie właściwości <see cref="P:System.Windows.Forms.ListBox.SelectedIndices" /> lub kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia, aby określić, kiedy wybrany indeks w programie <xref:System.Windows.Forms.ListBox> został zmieniony. Może to być przydatne, gdy konieczne jest wyświetlenie informacji w innych kontrolkach w oparciu o bieżące zaznaczenie <xref:System.Windows.Forms.ListBox>w. Do załadowania informacji w innych kontrolkach można użyć programu obsługi zdarzeń dla tego zdarzenia.  
  
 Jeśli właściwość jest ustawiona na <xref:System.Windows.Forms.SelectionMode.MultiSimple?displayProperty=nameWithType> lub <xref:System.Windows.Forms.SelectionMode.MultiExtended?displayProperty=nameWithType>, każda zmiana <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> w kolekcji, w tym usunięcie elementu z zaznaczenia, spowoduje wystąpienie tego zdarzenia. <xref:System.Windows.Forms.ListBox.SelectionMode%2A>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> zdarzenia w celu wyszukania i wybrania elementu w innej <xref:System.Windows.Forms.ListBox> kontrolce. W przykładzie używa <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> się zdarzenia, aby określić, kiedy wybrany element <xref:System.Windows.Forms.ListBox> w został zmieniony. <xref:System.Windows.Forms.ListBox.SelectedItem%2A> Kod przykładu odczytuje tekst elementu przy użyciu właściwości i <xref:System.Windows.Forms.ListBox.FindString%2A> wywołuje metodę na innym <xref:System.Windows.Forms.ListBox> , używając tekstu zwróconego przez <xref:System.Windows.Forms.ListBox.SelectedItem%2A> pierwsze <xref:System.Windows.Forms.ListBox>. Jeśli element zostanie znaleziony w drugim <xref:System.Windows.Forms.ListBox>, element jest zaznaczony. Ten przykład wymaga, aby <xref:System.Windows.Forms.ListBox> dwie kontrolki `listBox1` , `listBox2`nazwane i, zostały dodane do formularza i że obie <xref:System.Windows.Forms.ListBox> kontrolki zawierają elementy, które są identyczne. Przykład wymaga również, aby metoda obsługi zdarzeń zdefiniowana w przykładzie była połączona ze <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> `listBox1`zdarzeniem.  
  
 [!code-cpp[ListBox.SelectedIndexChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndexChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndexChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="SelectedIndices">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.SelectedIndexCollection SelectedIndices { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/SelectedIndexCollection SelectedIndices" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedIndices" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedIndices As ListBox.SelectedIndexCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::SelectedIndexCollection ^ SelectedIndices { System::Windows::Forms::ListBox::SelectedIndexCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedIndices : System.Windows.Forms.ListBox.SelectedIndexCollection" Usage="System.Windows.Forms.ListBox.SelectedIndices" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+SelectedIndexCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą indeksy zależne od zera dla wszystkich aktualnie wybranych elementów w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox.SelectedIndexCollection" /> Zawiera indeksy elementów aktualnie zaznaczonych w kontrolce. Jeśli żadne elementy nie są obecnie zaznaczone, zwracany <see cref="T:System.Windows.Forms.ListBox.SelectedIndexCollection" /> jest pusty.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>ta właściwość zwraca kolekcję zawierającą indeksy do wszystkich elementów, które są wybrane <xref:System.Windows.Forms.ListBox>w. Dla pojedynczego wyboru <xref:System.Windows.Forms.ListBox>ta właściwość zwraca kolekcję zawierającą pojedynczy element zawierający indeks tylko wybranego elementu <xref:System.Windows.Forms.ListBox>w. Więcej informacji o sposobach manipulowania elementami kolekcji znajduje się w temacie <xref:System.Windows.Forms.ListBox.SelectedIndexCollection>.  
  
 <xref:System.Windows.Forms.ListBox> Klasa zawiera wiele sposobów odwoływania się do wybranych elementów. Zamiast używać <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> właściwości ,aby<xref:System.Windows.Forms.ListBox>uzyskać położenie indeksu aktualnie wybranego elementu w pojedynczym zaznaczeniu, można użyć właściwości.<xref:System.Windows.Forms.ListBox.SelectedIndex%2A> Jeśli chcesz uzyskać element, który jest aktualnie wybrany w <xref:System.Windows.Forms.ListBox>, zamiast pozycji indeksu elementu, <xref:System.Windows.Forms.ListBox.SelectedItem%2A> Użyj właściwości. Ponadto można użyć <xref:System.Windows.Forms.ListBox.SelectedItems%2A> właściwości, jeśli chcesz uzyskać wszystkie wybrane elementy z wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.ListBox.FindString%2A> metody do wyszukiwania wszystkich wystąpień tekstu wyszukiwania w elementach. <xref:System.Windows.Forms.ListBox> W przykładzie stosowana jest wersja <xref:System.Windows.Forms.ListBox.FindString%2A> metody, która pozwala określić początkowy indeks wyszukiwania, z którego ma być ciągłego wyszukiwania wszystkich elementów <xref:System.Windows.Forms.ListBox>w. W przykładzie pokazano również, jak ustalić, <xref:System.Windows.Forms.ListBox.FindString%2A> Kiedy metoda rozpoczyna wyszukiwanie od góry listy po osiągnięciu dolnej części listy elementów, aby zapobiec przeszukiwaniu cyklicznemu. Po znalezieniu elementów w programie <xref:System.Windows.Forms.ListBox>są one wybierane <xref:System.Windows.Forms.ListBox.SetSelected%2A> przy użyciu metody.  
  
 [!code-cpp[ListBox.FindString#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.FindString/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.FindString#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.FindString/CS/form1.cs#1)]
 [!code-vb[ListBox.FindString#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.FindString/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItem" />
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedItems" />
      </Docs>
    </Member>
    <Member MemberName="SelectedItem">
      <MemberSignature Language="C#" Value="public object SelectedItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SelectedItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedItem" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SelectedItem { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedItem : obj with get, set" Usage="System.Windows.Forms.ListBox.SelectedItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia aktualnie wybrany element w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Obiekt, który reprezentuje bieżące zaznaczenie w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku standardu <xref:System.Windows.Forms.ListBox>można użyć tej właściwości, aby określić, który element jest wybrany <xref:System.Windows.Forms.ListBox>w. `SelectionMode.MultiSimple` <xref:System.Windows.Forms.ListBox>Jeśli właściwość jest<xref:System.Windows.Forms.ListBox> ustawiona na lub`SelectionMode.MultiExtended` (która wskazuje wybór wielokrotny), a na liście wybrano wiele elementów, ta właściwość może zwrócić dowolny wybrany element. <xref:System.Windows.Forms.ListBox.SelectionMode%2A>  
  
 Aby pobrać kolekcję zawierającą wszystkie wybrane elementy z wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedItems%2A> Użyj właściwości. Jeśli chcesz uzyskać położenie indeksu aktualnie wybranego elementu w <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> Użyj właściwości. Ponadto można użyć <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> właściwości w celu uzyskania wszystkich wybranych indeksów w wielokrotnym wyborze <xref:System.Windows.Forms.ListBox>.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> zdarzenia w celu wyszukania i wybrania elementu w innej <xref:System.Windows.Forms.ListBox> kontrolce. W przykładzie używa <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> się zdarzenia, aby określić, kiedy wybrany element <xref:System.Windows.Forms.ListBox> w został zmieniony. <xref:System.Windows.Forms.ListBox.SelectedItem%2A> Kod przykładu odczytuje tekst elementu przy użyciu właściwości i <xref:System.Windows.Forms.ListBox.FindString%2A> wywołuje metodę na innym <xref:System.Windows.Forms.ListBox> , używając tekstu zwróconego przez <xref:System.Windows.Forms.ListBox.SelectedItem%2A> pierwsze <xref:System.Windows.Forms.ListBox>. Jeśli element zostanie znaleziony w drugim <xref:System.Windows.Forms.ListBox>, element jest zaznaczony. Ten przykład wymaga, aby <xref:System.Windows.Forms.ListBox> dwie kontrolki `listBox1` , `listBox2`nazwane i, zostały dodane do formularza i że obie <xref:System.Windows.Forms.ListBox> kontrolki zawierają elementy, które są identyczne. Przykład wymaga również, aby metoda obsługi zdarzeń zdefiniowana w przykładzie była połączona ze <xref:System.Windows.Forms.ListBox.SelectedIndexChanged> `listBox1`zdarzeniem.  
  
 [!code-cpp[ListBox.SelectedIndexChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndexChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndexChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndexChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedItems">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ListBox.SelectedObjectCollection SelectedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ListBox/SelectedObjectCollection SelectedItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedItems As ListBox.SelectedObjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ListBox::SelectedObjectCollection ^ SelectedItems { System::Windows::Forms::ListBox::SelectedObjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedItems : System.Windows.Forms.ListBox.SelectedObjectCollection" Usage="System.Windows.Forms.ListBox.SelectedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ListBox+SelectedObjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję zawierającą aktualnie wybrane elementy w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value><see cref="T:System.Windows.Forms.ListBox.SelectedObjectCollection" /> Zawierający elementy aktualnie wybrane w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku wielokrotnego wyboru <xref:System.Windows.Forms.ListBox>ta właściwość zwraca kolekcję zawierającą wszystkie elementy, które są wybrane <xref:System.Windows.Forms.ListBox>w. Dla pojedynczego wyboru <xref:System.Windows.Forms.ListBox>ta właściwość zwraca kolekcję zawierającą pojedynczy element zawierający tylko wybrany element <xref:System.Windows.Forms.ListBox>w. Więcej informacji o sposobach manipulowania elementami kolekcji znajduje się w temacie <xref:System.Windows.Forms.ListBox.SelectedObjectCollection>.  
  
 <xref:System.Windows.Forms.ListBox> Klasa zawiera wiele sposobów odwoływania się do wybranych elementów. Zamiast używać <xref:System.Windows.Forms.ListBox.SelectedItems%2A> właściwości w celu uzyskania aktualnie wybranego elementu w jednym zaznaczeniu <xref:System.Windows.Forms.ListBox> <xref:System.Windows.Forms.ListBox.SelectedItem%2A> , można użyć właściwości. Jeśli chcesz uzyskać położenie indeksu elementu, który jest aktualnie wybrany w <xref:System.Windows.Forms.ListBox>, zamiast samego elementu, <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> Użyj właściwości. Ponadto można użyć <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> właściwości, jeśli chcesz uzyskać pozycje indeksu dla wszystkich zaznaczonych elementów w wielokrotnym wyborze <xref:System.Windows.Forms.ListBox>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionMode">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.SelectionMode SelectionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SelectionMode SelectionMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.SelectionMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property SelectionMode As SelectionMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::SelectionMode SelectionMode { System::Windows::Forms::SelectionMode get(); void set(System::Windows::Forms::SelectionMode value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionMode : System.Windows.Forms.SelectionMode with get, set" Usage="System.Windows.Forms.ListBox.SelectionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SelectionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia metodę, w której elementy są wybrane w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.SelectionMode" /> wartości. Wartość domyślna to <see langword="SelectionMode.One" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość pozwala określić liczbę elementów, <xref:System.Windows.Forms.ListBox> które użytkownik może wybrać jednocześnie, oraz sposób, w jaki użytkownik może dokonać wyboru wielokrotnego. <xref:System.Windows.Forms.ListBox.SelectionMode%2A> Gdy właściwość jest ustawiona na `SelectionMode.MultiExtended`, naciśnij klawisz Shift i klikasz myszą lub naciskając klawisz Shift, a jeden z klawiszy strzałek (Strzałka w górę, Strzałka w dół, Strzałka w lewo i Strzałka w prawo) rozszerza zaznaczenie z wcześniej wybranego elementu do bieżącego elementu. <xref:System.Windows.Forms.ListBox.SelectionMode%2A> . Naciśnięcie klawisza CTRL i kliknięcie myszy powoduje zaznaczenie lub odzaznaczenie elementu na liście. Gdy właściwość jest ustawiona na `SelectionMode.MultiSimple`, kliknięcie lub naciśnięcie klawisza spacji powoduje zaznaczenie lub odzaznaczenie elementu na liście.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.GetSelected%2A> metody w celu ustalenia, które elementy w, <xref:System.Windows.Forms.ListBox> są zaznaczone, aby wybrać elementy, które nie są wybrane i usunąć zaznaczenie wybranych elementów. W przykładzie pokazano również, jak <xref:System.Windows.Forms.ListBox.SelectionMode%2A> użyć właściwości, aby <xref:System.Windows.Forms.ListBox> włączyć więcej niż jeden <xref:System.Windows.Forms.ListBox.Sorted%2A> wybrany element i używa właściwości, <xref:System.Windows.Forms.ListBox> aby zademonstrować sposób sortowania elementów w automatycznie. Ten przykład <xref:System.Windows.Forms.ListBox>wymaga, aby do formularza `listBox1`został dodany, nazwany, i że `InitializeMyListBox` Metoda <xref:System.Windows.Forms.Form.Load> zdefiniowana w przykładzie jest wywoływana ze zdarzenia formularza.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.SelectionMode" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.SelectionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="listBox.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nowa <see cref="P:System.Windows.Forms.Control.Left" /> wartość właściwości formantu.</param>
        <param name="y">Nowa <see cref="P:System.Windows.Forms.Control.Top" /> wartość właściwości formantu.</param>
        <param name="width">Nowa <see cref="P:System.Windows.Forms.Control.Width" /> wartość właściwości formantu.</param>
        <param name="height">Nowa <see cref="P:System.Windows.Forms.Control.Height" /> wartość właściwości formantu.</param>
        <param name="specified">Bitowa kombinacja <see cref="T:System.Windows.Forms.BoundsSpecified" /> wartości.</param>
        <summary>Ustawia określone granice <see cref="T:System.Windows.Forms.ListBox" /> formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wysokość <xref:System.Windows.Forms.ListBox> kontrolki zwiększa się i zmniejsza o wielokrotność <xref:System.Windows.Forms.ListBox.ItemHeight%2A> właściwości. Jeśli Height jest liczbą <xref:System.Windows.Forms.ListBox.ItemHeight%2A>, która nie jest wielokrotnością, Wysokość <xref:System.Windows.Forms.ListBox> zmieni się o największą wielokrotność, która jest mniejsza od wysokości.  
  
 Zwykle parametry, które odpowiadają granicom niezawartym w podanym parametrze, są przesyłane przy użyciu ich bieżących wartości. `height`Na przykład `x` ,, lub `y` właściwości lub<xref:System.Windows.Forms.Control.Location%2A> właściwości mogą być przesyłane w odniesieniu do bieżącego wystąpienia formantu. `width` Wszystkie przesyłane wartości są jednak honorowane i stosowane do kontrolki.  
  
 Parametr reprezentuje elementy kontrolek <xref:System.Windows.Forms.Control.Bounds%2A> zmienione przez aplikację. `specified` Na przykład, jeśli zmienisz <xref:System.Windows.Forms.Control.Size%2A> kontrolkę `specified` , wartość parametru to <xref:System.Windows.Forms.BoundsSpecified.Size>. Jeśli <xref:System.Windows.Forms.Control.Size%2A> jednak zostanie on dostosowany w odpowiedzi <xref:System.Windows.Forms.Control.Dock%2A> na ustawioną `specified` właściwość, wartość parametru to <xref:System.Windows.Forms.BoundsSpecified.None>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodę klasy bazowej, aby wymusić zmianę granic formantu. Klasy pochodne mogą dodawać ograniczenia rozmiaru do <see cref="M:System.Windows.Forms.ListBox.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="SetItemCore">
      <MemberSignature Language="C#" Value="protected override void SetItemCore (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItemCore(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetItemCore(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItemCore (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItemCore(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.SetItemCore : int * obj -&gt; unit" Usage="listBox.SetItemCore (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks tablicy obiektu.</param>
        <param name="value">Obiekt.</param>
        <summary>Ustawia obiekt z określonym indeksem w klasie pochodnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetItemsCore">
      <MemberSignature Language="C#" Value="protected override void SetItemsCore (System.Collections.IList value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetItemsCore(class System.Collections.IList value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetItemsCore(System.Collections.IList)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetItemsCore (value As IList)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetItemsCore(System::Collections::IList ^ value);" />
      <MemberSignature Language="F#" Value="override this.SetItemsCore : System.Collections.IList -&gt; unit" Usage="listBox.SetItemsCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.IList" />
      </Parameters>
      <Docs>
        <param name="value">Tablica obiektów do wstawienia do kontrolki.</param>
        <summary>Czyści zawartość <see cref="T:System.Windows.Forms.ListBox" /> i dodaje określone elementy do kontrolki.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSelected">
      <MemberSignature Language="C#" Value="public void SetSelected (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSelected(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.SetSelected(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSelected (index As Integer, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSelected(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetSelected : int * bool -&gt; unit" Usage="listBox.SetSelected (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu w elemencie, <see cref="T:System.Windows.Forms.ListBox" /> aby zaznaczyć lub wyczyścić zaznaczenie.</param>
        <param name="value"><see langword="true" />, aby wybrać określony element; w przeciwnym razie. <see langword="false" /></param>
        <summary>Zaznacza lub czyści zaznaczenie dla określonego elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można ustawić wybór elementów w wielokrotnym wyborze <xref:System.Windows.Forms.ListBox>. Aby zaznaczyć element w pojedynczym zaznaczeniu <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> Użyj właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak utworzyć <xref:System.Windows.Forms.ListBox> kontrolkę wyświetlającą wiele elementów w kolumnach i na liście kontrolki można wybrać więcej niż jeden element. Kod dla przykładu <xref:System.Windows.Forms.ListBox> dodaje 50 elementów do <xref:System.Windows.Forms.ListBox.ObjectCollection.Add%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection> klasy, a następnie <xref:System.Windows.Forms.ListBox.SetSelected%2A> wybiera trzy elementy z listy przy użyciu metody. Następnie kod <xref:System.Windows.Forms.ListBox.SelectedObjectCollection> wyświetla wartości z kolekcji ( <xref:System.Windows.Forms.ListBox.SelectedItems%2A> przez właściwość) <xref:System.Windows.Forms.ListBox.SelectedIndices%2A> i <xref:System.Windows.Forms.ListBox.SelectedIndexCollection> (przez właściwość). Ten przykład wymaga, aby kod znajdował się w i został wywołany przez <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic ListBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic ListBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic ListBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic ListBox Example/CS/source.cs#1)]
 [!code-vb[Classic ListBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic ListBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Określony indeks znajduje się poza zakresem prawidłowych wartości.</exception>
        <exception cref="T:System.InvalidOperationException">Właściwość została ustawiona na <see langword="None" />wartość. <see cref="P:System.Windows.Forms.ListBox.SelectionMode" /></exception>
        <altmember cref="P:System.Windows.Forms.ListBox.SelectedIndex" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="protected virtual void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.Sort" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Sort ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Sort();" />
      <MemberSignature Language="F#" Value="abstract member Sort : unit -&gt; unit&#xA;override this.Sort : unit -&gt; unit" Usage="listBox.Sort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sortuje elementy w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.ListBox.Sort%2A>wymusza, aby kolekcja dodała każdy element z powrotem do siebie <xref:System.Windows.Forms.ListBox.Sorted%2A> , jeśli `true`właściwość jest. Każdy element jest następnie wstawiany do poprawnej pozycji.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.ListBox.Sort%2A> metody. Przykład ilustruje dziedziczenie z <xref:System.Windows.Forms.ListBox> klasy i <xref:System.Windows.Forms.ListBox.Sort%2A> Zastępowanie metody w klasie pochodnej, aby wykonać sortowanie zdefiniowane przez użytkownika. Aby uruchomić ten przykład, wklej następujący kod w pustym formularzu.  
  
 [!code-cpp[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ListBoxSort#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ListBoxSort/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Można zastąpić tę metodę w klasie pochodnej, aby zapewnić własną procedurę sortowania. Uzyskaj dostęp do wyników zastąpionej <see cref="M:System.Windows.Forms.ListBox.Sort" /> metody przez <see cref="P:System.Windows.Forms.ListBox.Sorted" /> ustawienie właściwości na <see langword="true" />. Podczas dodawania elementów do <see cref="T:System.Windows.Forms.ListBox" />, bardziej wydajne jest sortowanie elementów, a następnie dodawanie nowych elementów.</para></block>
        <altmember cref="P:System.Windows.Forms.ListBox.Sorted" />
      </Docs>
    </Member>
    <Member MemberName="Sorted">
      <MemberSignature Language="C#" Value="public bool Sorted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Sorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Sorted" />
      <MemberSignature Language="VB.NET" Value="Public Property Sorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Sorted { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Sorted : bool with get, set" Usage="System.Windows.Forms.ListBox.Sorted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy elementy w <see cref="T:System.Windows.Forms.ListBox" /> elemencie są sortowane alfabetycznie.</summary>
        <value><see langword="true" />Jeśli elementy w formancie są sortowane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Windows.Forms.ListBox.Sorted%2A> , aby automatycznie sortować ciągi alfabetycznie <xref:System.Windows.Forms.ListBox>w. Elementy dodawane do posortowanych <xref:System.Windows.Forms.ListBox>elementów są przenoszone do odpowiedniej lokalizacji na sortowanej liście. Podczas dodawania elementów do <xref:System.Windows.Forms.ListBox>, bardziej wydajne jest sortowanie elementów, a następnie dodawanie nowych elementów.  
  
 A <xref:System.Windows.Forms.ListBox> z jego <xref:System.Windows.Forms.ListBox.Sorted%2A> zestawem `true` nie <xref:System.Windows.Forms.ListControl.DataSource%2A> powinien być powiązany z danymi przy użyciu właściwości. Aby wyświetlić posortowane dane w <xref:System.Windows.Forms.ListBox>powiązaniu, należy powiązać ze źródłem danych, które obsługuje sortowanie, i że źródło danych udostępnia sortowanie.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób użycia <xref:System.Windows.Forms.ListBox.GetSelected%2A> metody w celu ustalenia, które elementy w, <xref:System.Windows.Forms.ListBox> są zaznaczone, aby wybrać elementy, które nie są wybrane i usunąć zaznaczenie wybranych elementów. W przykładzie pokazano również, jak <xref:System.Windows.Forms.ListBox.SelectionMode%2A> użyć właściwości, aby <xref:System.Windows.Forms.ListBox> włączyć więcej niż jeden <xref:System.Windows.Forms.ListBox.Sorted%2A> wybrany element i używa właściwości, <xref:System.Windows.Forms.ListBox> aby zademonstrować sposób sortowania elementów w automatycznie. Ten przykład <xref:System.Windows.Forms.ListBox>wymaga, aby do formularza `listBox1`został dodany, nazwany, i że `InitializeMyListBox` Metoda <xref:System.Windows.Forms.Form.Load> zdefiniowana w przykładzie jest wywoływana ze zdarzenia formularza.  
  
 [!code-cpp[ListBox.GetSelected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.GetSelected/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.GetSelected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.GetSelected/CS/form1.cs#1)]
 [!code-vb[ListBox.GetSelected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.GetSelected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.ListBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub wyszukuje tekst aktualnie wybranego elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Tekst aktualnie zaznaczonego elementu w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wartość tej właściwości jest ustawiona na wartość ciągu, program <xref:System.Windows.Forms.ListBox> wyszukuje element <xref:System.Windows.Forms.ListBox> w obszarze zgodnym z określonym tekstem i wybiera element. Można także użyć tej właściwości, aby określić, które elementy są aktualnie wybrane w <xref:System.Windows.Forms.ListBox>. <xref:System.Windows.Forms.ListBox.SelectionMode%2A> Jeśli właściwość <xref:System.Windows.Forms.ListBox> jest ustawiona na `SelectionMode.MultiExtended`, ta właściwość zwraca tekst pierwszego wybranego elementu. Jeśli właściwość nie jest ustawiona na `SelectionMode.None`, ta właściwość zwraca tekst pierwszego wybranego elementu. <xref:System.Windows.Forms.ListBox> <xref:System.Windows.Forms.ListBox.SelectionMode%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.ListBox.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.ListBox.Text" /> gdy właściwość zostanie zmieniona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopIndex">
      <MemberSignature Language="C#" Value="public int TopIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TopIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.TopIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TopIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TopIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TopIndex : int with get, set" Usage="System.Windows.Forms.ListBox.TopIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks pierwszego widocznego elementu w <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <value>Indeks (liczony od zera) pierwszego widocznego elementu w formancie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Początkowo element z pozycją indeks równą zero (0) znajduje się w górnej części widocznego regionu <xref:System.Windows.Forms.ListBox>. Jeśli zawartość <xref:System.Windows.Forms.ListBox> programu została przewinięty, inny element może znajdować się w górnej części obszaru wyświetlania formantu. Za pomocą tej właściwości można uzyskać indeks w <xref:System.Windows.Forms.ListBox.ObjectCollection> elemencie <xref:System.Windows.Forms.ListBox> dla elementu, który jest aktualnie umieszczony w górnej części widocznego regionu formantu. Tej właściwości można również użyć do położenia elementu na liście w górnej części widocznego regionu formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje sposób używania <xref:System.Windows.Forms.ListBox.SelectedIndex%2A> właściwości <xref:System.Windows.Forms.ListBox.TopIndex%2A> z właściwością do przenoszenia aktualnie wybranego elementu do góry listy elementów w obszarze <xref:System.Windows.Forms.ListBox>wyświetlania. W przykładzie przedstawiono dalsze instrukcje usuwania elementów przy użyciu <xref:System.Windows.Forms.ListBox.ObjectCollection.RemoveAt%2A> metody <xref:System.Windows.Forms.ListBox.ObjectCollection?displayProperty=nameWithType> klasy oraz sposób czyszczenia <xref:System.Windows.Forms.ListBox.ClearSelected%2A> wszystkich elementów przy użyciu metody. Kod najpierw przenosi aktualnie zaznaczony element w <xref:System.Windows.Forms.ListBox> górę na początku listy. Następnie kod usuwa wszystkie elementy przed aktualnie wybranym elementem i czyści wszystkie zaznaczenia w <xref:System.Windows.Forms.ListBox>. Ten przykład wymaga, aby <xref:System.Windows.Forms.ListBox> element zawierający elementy został dodany do formularza i że <xref:System.Windows.Forms.ListBox>w.  
  
 [!code-cpp[ListBox.SelectedIndex#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.SelectedIndex/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.SelectedIndex#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.SelectedIndex/CS/form1.cs#1)]
 [!code-vb[ListBox.SelectedIndex#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.SelectedIndex/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="listBox.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg reprezentujący <see cref="T:System.Windows.Forms.ListBox" />.</summary>
        <returns>Ciąg określający typ formantu, liczbę elementów w <see cref="T:System.Windows.Forms.ListBox" /> formancie i właściwość Text pierwszego elementu <see cref="T:System.Windows.Forms.ListBox" />w, jeśli liczba nie jest równa 0.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseCustomTabOffsets">
      <MemberSignature Language="C#" Value="public bool UseCustomTabOffsets { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseCustomTabOffsets" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.UseCustomTabOffsets" />
      <MemberSignature Language="VB.NET" Value="Public Property UseCustomTabOffsets As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseCustomTabOffsets { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseCustomTabOffsets : bool with get, set" Usage="System.Windows.Forms.ListBox.UseCustomTabOffsets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy znaki <see cref="T:System.Windows.Forms.ListBox" /> tabulatora są rozpoznawane i rozwijane podczas rysowania ciągów przy <see cref="P:System.Windows.Forms.ListBox.CustomTabOffsets" /> użyciu tablicy liczb całkowitych.</summary>
        <value><see langword="true" />Jeśli znaki <see cref="T:System.Windows.Forms.ListBox" /> tabulacji są rozpoznawane i rozwijane; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ListBox.CustomTabOffsets" />
      </Docs>
    </Member>
    <Member MemberName="UseTabStops">
      <MemberSignature Language="C#" Value="public bool UseTabStops { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTabStops" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.ListBox.UseTabStops" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTabStops As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTabStops { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTabStops : bool with get, set" Usage="System.Windows.Forms.ListBox.UseTabStops" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy znaki <see cref="T:System.Windows.Forms.ListBox" /> tabulacji mogą być rozpoznawane i rozszerzane podczas rysowania ciągów.</summary>
        <value><see langword="true" />Jeśli kontrolka może rozwijać znaki tabulacji; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ilustruje sposób tworzenia <xref:System.Windows.Forms.ListBox> elementu, który wyświetla elementy z znakami tabulacji.  
  
 [!code-cpp[ListBox.UseTabStops#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ListBox.UseTabStops/CPP/form1.cpp#1)]
 [!code-csharp[ListBox.UseTabStops#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ListBox.UseTabStops/CS/form1.cs#1)]
 [!code-vb[ListBox.UseTabStops#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ListBox.UseTabStops/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obsługi kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WmReflectCommand">
      <MemberSignature Language="C#" Value="protected virtual void WmReflectCommand (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WmReflectCommand(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.WmReflectCommand(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WmReflectCommand (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WmReflectCommand(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WmReflectCommand :  -&gt; unit&#xA;override this.WmReflectCommand :  -&gt; unit" Usage="listBox.WmReflectCommand m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Okno najwyższego poziomu wysłane <see cref="T:System.Windows.Forms.ListBox" /> do kontrolki. <see cref="T:System.Windows.Forms.Message" /></param>
        <summary>Przetwarza komunikat <see cref="T:System.Windows.Forms.ListView" /> polecenia otrzymany przez formant od okna najwyższego poziomu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.ListBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="listBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Obiekt komunikatu systemu Windows.</param>
        <summary>Procedura okna listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dziedziczenie klas może przesłonić ten sposób, aby dodać dodatkowe funkcje, <xref:System.Windows.Forms.ListBox.WndProc%2A> ale należy wywołać metodę w klasie bazowej, aby upewnić się, że lista będzie nadal działać prawidłowo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obsługi kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>

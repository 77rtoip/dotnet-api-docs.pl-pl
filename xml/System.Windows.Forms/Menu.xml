<Type Name="Menu" FullName="System.Windows.Forms.Menu">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adf082395a798050141636ba818758d1dede43a6" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36517457" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Menu : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Menu extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Menu" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Menu&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Menu abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Menu = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ListBindable(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje podstawową funkcjonalność we wszystkich menu. Mimo że <see cref="T:System.Windows.Forms.ToolStripDropDown" /> i <see cref="T:System.Windows.Forms.ToolStripDropDownMenu" /> Zastąp oraz dodawać funkcje do <see cref="T:System.Windows.Forms.Menu" /> kontrolę nad poprzednie wersje <see cref="T:System.Windows.Forms.Menu" /> są przechowywane dla zgodności z poprzednimi wersjami i użycia w przyszłości, jeśli zostanie wybrana.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta klasa jest klasą bazową dla <xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, i <xref:System.Windows.Forms.ContextMenu> klasy. Nie można utworzyć wystąpienia tej klasy. Menu dla aplikacji consist z <xref:System.Windows.Forms.MenuItem> obiektów. Mogą one zawierać inne <xref:System.Windows.Forms.MenuItem> obiekty reprezentujące podmenu. <xref:System.Windows.Forms.MenuItem> Obiekty mogą być przechowywane w <xref:System.Windows.Forms.MainMenu> do wyświetlenia jako struktura menu całego formularza lub <xref:System.Windows.Forms.ContextMenu> używany do wyświetlania menu skrótów. Ta klasa udostępnia funkcje, które są wspólne dla wszystkich klas menu.  
  
 W przeciwieństwie do wielu klas podstawowych <xref:System.Windows.Forms.Menu> klasy używa pochodne, aby zdefiniować wiele jego właściwości. Jeśli używasz programu menu w aplikacji interfejsu wielu dokumentów (MDI), możesz użyć <xref:System.Windows.Forms.Menu.MdiListItem%2A> właściwości w celu określenia <xref:System.Windows.Forms.MenuItem> który wyświetla listę formularzy podrzędnych MDI otwartych w aplikacji. <xref:System.Windows.Forms.Menu.MenuItems%2A> Właściwość zawiera listę <xref:System.Windows.Forms.MenuItem> obiektów przechowywanych w klasie menu. Aby uzyskać <xref:System.Windows.Forms.MainMenu> lub <xref:System.Windows.Forms.ContextMenu>, ta właściwość zawiera wszystkie <xref:System.Windows.Forms.MenuItem> obiektów, które są wyświetlane. Aby uzyskać <xref:System.Windows.Forms.MenuItem>, <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwość reprezentuje związane z nim elementy podmenu.  
  
 Oprócz właściwości, które są dostępne dla wszystkich klas pochodnych menu <xref:System.Windows.Forms.Menu> klasy udostępnia metody, takie jak <xref:System.Windows.Forms.Menu.CloneMenu%2A> i <xref:System.Windows.Forms.Menu.MergeMenu%2A>, umożliwiają utworzenie nowego menu z istniejącymi menu, a także scalić dwóch struktury menu razem.  
  
 <xref:System.Windows.Forms.Menu> Klasy definiuje również zagnieżdżonej klasy <xref:System.Windows.Forms.Menu.MenuItemCollection>. Ta klasa definiuje zbiór <xref:System.Windows.Forms.MenuItem> obiektów używanych przez <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwości. Można użyć metody <xref:System.Windows.Forms.Menu.MenuItemCollection> klasy do dodawania i usuwania elementów menu z <xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.ContextMenu>, lub <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje klasy pochodnej <xref:System.Windows.Forms.MenuItem>, aby utworzyć strukturę menu dla formularza. Przykładowy kod dodaje <xref:System.Windows.Forms.MenuItem> do reprezentowania element menu najwyższego poziomu dodaje element podmenu mu do wybierania rozmiar czcionki, a następnie dodanie dwóch elementów podmenu do tego menu, które reprezentują opcji dużych i małych czcionek w aplikacji. Przykład wymóg <xref:System.Windows.Forms.MainMenu> obiektu o nazwie `mainMenu1` i cztery <xref:System.Windows.Forms.MenuItem> obiektów o nazwie `menuItem1`, `menuItem2`, `menuItem3`, i `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
    <altmember cref="T:System.Windows.Forms.MenuItem" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Menu (System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.#ctor(System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Menu(cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Menu : System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.Menu" Usage="new System.Windows.Forms.Menu items" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="items">Tablica typu <see cref="T:System.Windows.Forms.MenuItem" /> zawierających obiekty do dodania do menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Menu" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Windows.Forms.Menu> jest klasą abstrakcyjną, tylko do klasy dziedziczonej można wywołać konstruktora Menu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected internal void CloneMenu (System.Windows.Forms.Menu menuSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void CloneMenu(class System.Windows.Forms.Menu menuSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.CloneMenu(System.Windows.Forms.Menu)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub CloneMenu (menuSrc As Menu)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void CloneMenu(System::Windows::Forms::Menu ^ menuSrc);" />
      <MemberSignature Language="F#" Value="member this.CloneMenu : System.Windows.Forms.Menu -&gt; unit" Usage="menu.CloneMenu menuSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuSrc" Type="System.Windows.Forms.Menu" />
      </Parameters>
      <Docs>
        <param name="menuSrc">
          <see cref="T:System.Windows.Forms.Menu" /> Do skopiowania.</param>
        <summary>Kopie <see cref="T:System.Windows.Forms.Menu" /> przekazanego jako parametr do bieżącego <see cref="T:System.Windows.Forms.Menu" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia skopiowanie całą listę <xref:System.Windows.Forms.MenuItem> obiektów (przechowywane w <xref:System.Windows.Forms.Menu> przekazana do `menuSrc`) do bieżącego menu. Tę metodę w klasie pochodnej służy do klonowania <xref:System.Windows.Forms.MenuItem> obiektów. Następnie umożliwienia ponownego wykorzystania przez innych klas, które pochodzą z <xref:System.Windows.Forms.Menu>, takich jak <xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.ContextMenu>, i <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 W tym przykładzie tworzy menu głównego, `mainMenu1`, z trzema elementami menu: `File`, `Edit`, i `View`. Następnie używa <xref:System.Windows.Forms.Menu.CloneMenu%2A> metodę, aby skopiować `mainMenu1` do `mainMenu2`. Następnie przypisane do formularza i wyświetlić sklonowany menu. Ten program wymaga, że utworzono już <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[CloneMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CloneMenu/CPP/form1.cpp#1)]
 [!code-csharp[CloneMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CloneMenu/CS/form1.cs#1)]
 [!code-vb[CloneMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CloneMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.MainMenu" />
      </Docs>
    </Member>
    <Member MemberName="CreateMenuHandle">
      <MemberSignature Language="C#" Value="protected virtual IntPtr CreateMenuHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int CreateMenuHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.CreateMenuHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateMenuHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr CreateMenuHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateMenuHandle : unit -&gt; nativeint&#xA;override this.CreateMenuHandle : unit -&gt; nativeint" Usage="menu.CreateMenuHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy się <see cref="T:System.Windows.Forms.Menu" />.</summary>
        <returns>Dojście do menu, jeśli metoda zakończy się pomyślnie; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem niezarządzanym. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="menu.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Usuwa zasoby, innego niż pamięci używanej przez <see cref="T:System.Windows.Forms.Menu" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Windows.Forms.Menu.Dispose%2A> po zakończeniu przy użyciu <xref:System.Windows.Forms.Menu>. <xref:System.Windows.Forms.Menu.Dispose%2A> Pozostawia metody <xref:System.Windows.Forms.Menu> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Windows.Forms.Menu.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Windows.Forms.Menu> , można odzyskać pamięci, jej klasy przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Windows.Forms.Menu.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Windows.Forms.Menu>. W przeciwnym razie zasoby <xref:System.Windows.Forms.Menu> jest przy użyciu nie zostanie zwolniona, dopóki wywołania kolekcji pamięci <xref:System.Windows.Forms.Menu> destruktor obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindHandle">
      <MemberSignature Language="C#" Value="public const int FindHandle = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 FindHandle = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Menu.FindHandle" />
      <MemberSignature Language="VB.NET" Value="Public Const FindHandle As Integer  = 0" />
      <MemberSignature Language="C++ CLI" Value="public: int FindHandle = 0;" />
      <MemberSignature Language="F#" Value="val mutable FindHandle : int" Usage="System.Windows.Forms.Menu.FindHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Określa, że <see cref="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" /> metoda ma poszukiwać dojścia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FindMenuItem">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuItem FindMenuItem (int type, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.MenuItem FindMenuItem(int32 type, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindMenuItem (type As Integer, value As IntPtr) As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::MenuItem ^ FindMenuItem(int type, IntPtr value);" />
      <MemberSignature Language="F#" Value="member this.FindMenuItem : int * nativeint -&gt; System.Windows.Forms.MenuItem" Usage="menu.FindMenuItem (type, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Int32" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="type">Typ elementu, aby znaleźć <see cref="T:System.Windows.Forms.MenuItem" />.</param>
        <param name="value">Element do użycia w celu znalezienia <see cref="T:System.Windows.Forms.MenuItem" />.</param>
        <summary>Pobiera <see cref="T:System.Windows.Forms.MenuItem" /> zawierający określona wartość.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.MenuItem" /> Wartości, które odpowiadają; w przeciwnym razie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wyszukać <xref:System.Windows.Forms.MenuItem> przy użyciu dojścia, Przekaż <xref:System.Windows.Forms.Menu.FindHandle> jako typ i dojście pola <xref:System.Windows.Forms.MenuItem> chcesz znaleźć jako wartość.  
  
 Aby wyszukać <xref:System.Windows.Forms.MenuItem> przy użyciu skrótu, Przekaż <xref:System.Windows.Forms.Menu.FindShortcut> pole jako typ i wartość skrótu dla <xref:System.Windows.Forms.MenuItem> chcesz znaleźć jako wartość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla formantów wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="FindMergePosition">
      <MemberSignature Language="C#" Value="protected int FindMergePosition (int mergeOrder);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance int32 FindMergePosition(int32 mergeOrder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.FindMergePosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Function FindMergePosition (mergeOrder As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; int FindMergePosition(int mergeOrder);" />
      <MemberSignature Language="F#" Value="member this.FindMergePosition : int -&gt; int" Usage="menu.FindMergePosition mergeOrder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mergeOrder" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="mergeOrder">Pozycja kolejność scalania dla elementu menu do scalenia.</param>
        <summary>Zwraca pozycję, w którym element menu powinien zostać wstawiony do menu.</summary>
        <returns>Pozycja, w którym element menu powinien zostać wstawiony do menu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Względne położenie, że ten element menu przyjmie założenie, jeśli menu struktury, która określa kolejność scalania elementów menu <xref:System.Windows.Forms.MenuItem> znajduje się w scalony z innym.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindShortcut">
      <MemberSignature Language="C#" Value="public const int FindShortcut = 1;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 FindShortcut = (1)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.Menu.FindShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Const FindShortcut As Integer  = 1" />
      <MemberSignature Language="C++ CLI" Value="public: int FindShortcut = 1;" />
      <MemberSignature Language="F#" Value="val mutable FindShortcut : int" Usage="System.Windows.Forms.Menu.FindShortcut" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>Określa, że <see cref="M:System.Windows.Forms.Menu.FindMenuItem(System.Int32,System.IntPtr)" /> metoda ma poszukiwać skrótu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ContextMenu GetContextMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.ContextMenu GetContextMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.GetContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContextMenu () As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::ContextMenu ^ GetContextMenu();" />
      <MemberSignature Language="F#" Value="member this.GetContextMenu : unit -&gt; System.Windows.Forms.ContextMenu" Usage="menu.GetContextMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.ContextMenu" /> zawierający tego menu.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.ContextMenu" /> Zawierający tego menu. Wartość domyślna to <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pozwala uzyskać odwołania do <xref:System.Windows.Forms.ContextMenu> zawarte w tym menu. Ta właściwość zwraca `null` Jeśli menu nie jest zawarta w <xref:System.Windows.Forms.ContextMenu>. Taka sytuacja może wystąpić, jeśli menu znajduje się w <xref:System.Windows.Forms.MenuItem> lub <xref:System.Windows.Forms.MainMenu>, lub jeśli menu nie znajduje się w dowolnym menu. Ta właściwość służy do określenia, czy menu jest obecnie używany, a także określenie miejsca.  
  
   
  
## Examples  
 W tym przykładzie używamy <xref:System.Windows.Forms.Menu.GetContextMenu%2A> metodę, aby uzyskać odwołania do menu skrótów, które zawiera `menuItem1` lub `menuItem2`i wyświetlać informacje menu skrótów w oknie komunikatu. Programowe tworzenie menu skrótów z dwoma elementami `New` i `Open`. Następnie dodaj funkcje do tych elementów przy tworzenie obsługi zdarzeń odpowiednie. Po uruchomieniu przykładzie otrzymasz komunikat, który informuje, kliknij prawym przyciskiem myszy formularz, aby wyświetlić menu skrótów. Następnie po kliknięciu elementu menu komunikat innym informująca, który element zostanie kliknięta i wyświetla informacje o zawierającego menu skrótów. W tym przykładzie wymaga się, że utworzono już <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[GetContextMenu2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/GetContextMenu2/CPP/form1.cpp#1)]
 [!code-csharp[GetContextMenu2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/GetContextMenu2/CS/form1.cs#1)]
 [!code-vb[GetContextMenu2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/GetContextMenu2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Menu.GetMainMenu" />
      </Docs>
    </Member>
    <Member MemberName="GetMainMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu GetMainMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.MainMenu GetMainMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.GetMainMenu" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMainMenu () As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::MainMenu ^ GetMainMenu();" />
      <MemberSignature Language="F#" Value="member this.GetMainMenu : unit -&gt; System.Windows.Forms.MainMenu" Usage="menu.GetMainMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.MainMenu" /> zawierający tego menu.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.MainMenu" /> Zawierający tego menu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda pozwala uzyskać odwołania do <xref:System.Windows.Forms.MainMenu> tego menu znajduje się obecnie w. Ta właściwość zwraca `null` Jeśli menu nie jest zawarta w <xref:System.Windows.Forms.MainMenu>. Taka sytuacja może wystąpić, jeśli menu znajduje się w <xref:System.Windows.Forms.MenuItem> lub <xref:System.Windows.Forms.ContextMenu>, lub jeśli menu nie znajduje się w dowolnym menu. Ta właściwość służy do określenia, czy menu jest obecnie używany, a także określenie miejsca.  
  
   
  
## Examples  
 W tym przykładzie deklaruje <xref:System.Windows.Forms.MainMenu>, `mainMenu1`i cztery elementy menu, `menuItem1`, `menuItem2`, `menuItem3`, i `menuItem4`. Tylko pierwszy menu trzy elementy są dodawane do `mainMenu1` do wyświetlenia. Program sprawdza, czy `menuItem3` jest używany, która jest `true`i określa formularza, w którym jest używana. Tekst etykiety jest używana do wyświetlania nazwa formularza, który jest hostem <xref:System.Windows.Forms.MainMenu>. Jeśli zmienisz element menu testowanego `menuItem4`, wyrażenie `false` ponieważ `menuItem4` nigdy nie był używany. W tym przykładzie wymaga się, że utworzono <xref:System.Windows.Forms.Form> o nazwie `MyForm` zawierającą <xref:System.Windows.Forms.Label> o nazwie `label1`.  
  
 [!code-cpp[GetMainMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/GetMainMenu/CPP/form1.cpp#1)]
 [!code-csharp[GetMainMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/GetMainMenu/CS/form1.cs#1)]
 [!code-vb[GetMainMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/GetMainMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Menu.GetContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Menu.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość reprezentującą uchwytu okna dla menu.</summary>
        <value>Wartości HMENU menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy można uzyskać dojścia do menu do przeprowadzania specjalnych operacji do menu poza funkcje udostępniane przez tę klasę lub jej klas pochodnych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public virtual bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.Menu.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy menu zawiera wszystkie elementy menu. Ta właściwość jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli menu zawiera <see cref="T:System.Windows.Forms.MenuItem" /> obiekty; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do określenia, czy dowolne <xref:System.Windows.Forms.MenuItem> obiekty są przypisane do tego menu. Jest to równoważne sprawdzanie `null` w <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MainMenu> z dwoma <xref:System.Windows.Forms.MenuItem> obiektów. Następnie używa <xref:System.Windows.Forms.Menu.IsParent%2A> umożliwia określenie, czy `mainMenu1` zawiera elementy menu. Jeśli wyrażenie `true`, ustawia <xref:System.Windows.Forms.MainMenu.RightToLeft%2A> właściwości `true` i wiąże w menu głównym <xref:System.Windows.Forms.Form>. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> utworzony o nazwie `Form1`.  
  
 [!code-cpp[IsParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/IsParent/CPP/form1.cpp#1)]
 [!code-csharp[IsParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/IsParent/CS/form1.cs#1)]
 [!code-vb[IsParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/IsParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do pracy z kodem niezarządzanym. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Windows.Forms.Menu.MenuItems" />
      </Docs>
    </Member>
    <Member MemberName="MdiListItem">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuItem MdiListItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuItem MdiListItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.MdiListItem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiListItem As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuItem ^ MdiListItem { System::Windows::Forms::MenuItem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MdiListItem : System.Windows.Forms.MenuItem" Usage="System.Windows.Forms.Menu.MdiListItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą <see cref="T:System.Windows.Forms.MenuItem" /> używany do wyświetlania listy wielu formularze podrzędne interfejsu (MDI) dokumentu.</summary>
        <value>A <see cref="T:System.Windows.Forms.MenuItem" /> reprezentujący element menu zawierający listę formularzy podrzędnych MDI otwartych w aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do określenia czy <xref:System.Windows.Forms.MenuItem> określono, aby wyświetlić listę okien podrzędnych otwartych w aplikacji MDI. Można użyć określonego <xref:System.Windows.Forms.MenuItem> jako lista MDI ustawić <xref:System.Windows.Forms.MenuItem.MdiList%2A> właściwości w <xref:System.Windows.Forms.MenuItem> do użycia.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MdiList" />
      </Docs>
    </Member>
    <Member MemberName="MenuItems">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu.MenuItemCollection MenuItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu/MenuItemCollection MenuItems" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.MenuItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MenuItems As Menu.MenuItemCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu::MenuItemCollection ^ MenuItems { System::Windows::Forms::Menu::MenuItemCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuItems : System.Windows.Forms.Menu.MenuItemCollection" Usage="System.Windows.Forms.Menu.MenuItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu+MenuItemCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, Kolekcja <see cref="T:System.Windows.Forms.MenuItem" /> obiekty skojarzone z menu.</summary>
        <value>A <see cref="T:System.Windows.Forms.Menu.MenuItemCollection" /> reprezentujący listę <see cref="T:System.Windows.Forms.MenuItem" /> obiekty przechowywane w menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do uzyskania odwołania do listy elementów menu, które są obecnie przechowywane w menu. Aby uzyskać <xref:System.Windows.Forms.MainMenu> i <xref:System.Windows.Forms.ContextMenu> obiektów, <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwość zawiera struktura całe menu w formancie. Aby uzyskać <xref:System.Windows.Forms.MenuItem> klasy <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwość zawiera listę elementów podmenu skojarzone z <xref:System.Windows.Forms.MenuItem>. Z odwołaniem do kolekcji elementów menu dla menu (udostępniony przez tę właściwość) można dodawania i usuwania elementów menu, określić całkowitą liczbę elementów menu oraz wyczyść listę elementów menu z kolekcji. Aby uzyskać więcej informacji na temat zachowania kolekcji elementów menu dla menu, zobacz <xref:System.Windows.Forms.Menu.MenuItemCollection?displayProperty=nameWithType> dokumentacji.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy wystąpienie klasy pochodnej, <xref:System.Windows.Forms.MainMenu>i dodaje <xref:System.Windows.Forms.MenuItem> obiektu do jego kolekcji <xref:System.Windows.Forms.MenuItem> obiektów. W tym przykładzie wymaga, aby metody zdefiniowane w tym przykładzie jest znajdujące się w klasie formularza i wywoływane przez metody klasy formularza.  
  
 [!code-cpp[Classic Menu.MenuItems Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu.MenuItems Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu.MenuItems Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu.MenuItems Example/CS/source.cs#1)]
 [!code-vb[Classic Menu.MenuItems Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu.MenuItems Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu.MenuItemCollection" />
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual void MergeMenu (System.Windows.Forms.Menu menuSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MergeMenu(class System.Windows.Forms.Menu menuSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.MergeMenu(System.Windows.Forms.Menu)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MergeMenu (menuSrc As Menu)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MergeMenu(System::Windows::Forms::Menu ^ menuSrc);" />
      <MemberSignature Language="F#" Value="abstract member MergeMenu : System.Windows.Forms.Menu -&gt; unit&#xA;override this.MergeMenu : System.Windows.Forms.Menu -&gt; unit" Usage="menu.MergeMenu menuSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="menuSrc" Type="System.Windows.Forms.Menu" />
      </Parameters>
      <Docs>
        <param name="menuSrc">
          <see cref="T:System.Windows.Forms.Menu" /> Którego elementy menu są łączone z elementami menu bieżącego menu.</param>
        <summary>Scala <see cref="T:System.Windows.Forms.MenuItem" /> obiektów jednego menu z bieżącego menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda scala <xref:System.Windows.Forms.MenuItem> obiektów z jednego menu z bieżącego menu. <xref:System.Windows.Forms.MenuItem> obiekty są łączone zgodnie z wartościami <xref:System.Windows.Forms.MenuItem.MergeType%2A?displayProperty=nameWithType> i <xref:System.Windows.Forms.MenuItem.MergeOrder%2A?displayProperty=nameWithType> właściwości.  
  
 Scalanie menu jest zazwyczaj wykonywane można scalić menu z tymi jego aktywny formularz podrzędny MDI formularza nadrzędnego wielu interfejsu dokumentów (MDI). Jest to wykonywane automatycznie przez .NET Framework środowisko uruchomieniowe języka wspólnego. Na przykład jeśli formularza nadrzędnego MDI zawiera zestaw menu do obsługi plików formularza podrzędnego MDI, a ponadto elementy menu związany z plikami zestawy menu zostanie automatycznie scalić menu pojedynczy plik ustawić, gdy formularz podrzędny jest wyświetlany w formularza nadrzędnego MDI.  
  
 Można użyć <xref:System.Windows.Forms.Menu.MergeMenu%2A> metody scalania dwie struktury menu, które nie są częścią aplikacji MDI. Ta implementacja może być wywoływany przez <xref:System.Windows.Forms.MainMenu> lub <xref:System.Windows.Forms.ContextMenu> scalić dwóch lub większej liczby obiektów wyprowadzonych z klasy <xref:System.Windows.Forms.Menu>.  
  
 Do połączenia dwóch <xref:System.Windows.Forms.MenuItem> obiekty użyj <xref:System.Windows.Forms.MenuItem.MergeMenu%2A?displayProperty=nameWithType> metody.  
  
   
  
## Examples  
 W tym przykładzie tworzy dwa menu `mainMenu1` i `mainMenu2`. Pierwszy menu zawiera jeden <xref:System.Windows.Forms.MenuItem>, `File`, a drugi zawiera jeden <xref:System.Windows.Forms.MenuItem>, `Edit`. Przy użyciu <xref:System.Windows.Forms.Menu.MergeMenu%2A> metody `mainMenu2` jest scalany z `mainMenu1`. Po wyświetleniu `mainMenu1` będzie zawierać elementy menu dwóch `File` i `Edit`. W tym przykładzie wymaga się, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[MergeMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MergeMenu/CPP/form1.cpp#1)]
 [!code-csharp[MergeMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MergeMenu/CS/form1.cs#1)]
 [!code-vb[MergeMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MergeMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Próbowano ją wykonać można scalić menu z nim samym.</exception>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Menu.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę <see cref="T:System.Windows.Forms.Menu" />.</summary>
        <value>Ciąg reprezentujący nazwę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W czasie projektowania ta właściwość ma ustawioną identyfikator programowy formantu. Jednak ta właściwość nie ma żadnych wpływu na formantu w czasie wykonywania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="menu.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">A <see cref="T:System.Windows.Forms.Message" />, przekazywane przez odwołanie, reprezentujący komunikat okna do przetworzenia.</param>
        <param name="keyData">Jeden z <see cref="T:System.Windows.Forms.Keys" /> wartości, które reprezentuje klucz używany do przetworzenia.</param>
        <summary>Przetwarza polecenia klucza.</summary>
        <returns>
          <see langword="true" /> Jeśli znak został przetworzony przez formant; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Menu.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Menu.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dane zdefiniowane przez użytkownika, skojarzony z formantem.</summary>
        <value>Obiekt reprezentujący dane.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Menu.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="menu.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca <see cref="T:System.String" /> reprezentujący <see cref="T:System.Windows.Forms.Menu" /> formantu.</summary>
        <returns>A <see cref="T:System.String" /> reprezentujący bieżącą <see cref="T:System.Windows.Forms.Menu" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Menu.ToString%2A> Metoda zwraca <xref:System.String> zawierającą typ i liczbę elementów w <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwości formantu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
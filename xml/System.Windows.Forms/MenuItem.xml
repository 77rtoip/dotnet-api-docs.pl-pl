<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8e96b9a562587ce1b84c0314819619ffe1f760d2" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55340288" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje pojedynczy element, który jest wyświetlany w obrębie <see cref="T:System.Windows.Forms.MainMenu" /> lub <see cref="T:System.Windows.Forms.ContextMenu" />. Mimo że <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> zastępuje i dodaje funkcjonalność do <see cref="T:System.Windows.Forms.MenuItem" /> kontrolki z poprzednich wersji <see cref="T:System.Windows.Forms.MenuItem" /> został zachowany na potrzeby zgodności z poprzednimi wersjami i użycia w przyszłości wybranie opcji.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby <xref:System.Windows.Forms.MenuItem> mają być wyświetlane, należy dodać go do <xref:System.Windows.Forms.MainMenu> lub <xref:System.Windows.Forms.ContextMenu>. Aby utworzyć podmenu, możesz dodać <xref:System.Windows.Forms.MenuItem> obiekty do <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwości elementu nadrzędnego <xref:System.Windows.Forms.MenuItem>.  
  
 <xref:System.Windows.Forms.MenuItem> Klasy zawiera właściwości, które umożliwiają skonfigurowanie wyglądu i funkcjonalności elementu menu. Aby wyświetlić znacznik wyboru obok elementu menu, użyj <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwości. Ta funkcja służy do identyfikowania element menu, który jest zaznaczona na liście elementów menu wzajemnie się wykluczają. Na przykład, jeśli masz zestaw elementów menu do ustawiania kolor tekstu w <xref:System.Windows.Forms.TextBox> kontrolki, można użyć <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwość do identyfikacji, jaki kolor jest aktualnie wybrany. <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Właściwość może służyć do definiowania kombinacja klawiszy, który może być naciśnięty w celu wybierz element menu.  
  
 Dla <xref:System.Windows.Forms.MenuItem> obiekty wyświetlane w aplikacji interfejsu dokumencie wielu (MDI), można użyć <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metoda scalania menu MDI nadrzędnego dla z tym jego formularze podrzędne tworzenia struktury skonsolidowany menu. Ponieważ <xref:System.Windows.Forms.MenuItem> nie może zostać ponownie użyte w wielu lokalizacjach w tym samym czasie, takie jak w <xref:System.Windows.Forms.MainMenu> i <xref:System.Windows.Forms.ContextMenu>, możesz użyć <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> metodę, aby utworzyć kopię <xref:System.Windows.Forms.MenuItem> do użycia w innej lokalizacji.  
  
 <xref:System.Windows.Forms.MenuItem.Popup> Zdarzenie pozwala na wykonywanie zadań, przed wyświetleniem menu. Na przykład można utworzyć program obsługi zdarzeń dla tego zdarzenia wyświetlić lub ukryć elementy menu, oparte na stanie swój kod. <xref:System.Windows.Forms.MenuItem.Select> Zdarzenie pozwala na wykonywanie zadań takich jak dostarczanie szczegółową pomoc dla elementów menu w aplikacji po użytkownik umieszcza wskaźnik myszy nad element menu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy strukturę menu dla formularza. Przykładowy kod dodaje <xref:System.Windows.Forms.MenuItem> do reprezentowania element menu najwyższego poziomu, dodaje element podmenu do niego służąca do wybierania rozmiar czcionki, a następnie dodanie dwóch elementów podmenu do tego elementu menu, reprezentujące wybór dużych i małych czcionek w aplikacji. Przykład wymaga, że istnieje <xref:System.Windows.Forms.MainMenu> obiektu o nazwie `mainMenu1` i cztery <xref:System.Windows.Forms.MenuItem> obiektów o nazwie `menuItem1`, `menuItem2`, `menuItem3`, i `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.MenuItem" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje <see cref="T:System.Windows.Forms.MenuItem" /> poprzedzoną puste.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu pustego <xref:System.Windows.Forms.MenuItem> za pomocą tego konstruktora, możesz użyć właściwości i metod <xref:System.Windows.Forms.MenuItem> klasy w celu określenia wyglądu i zachowania usługi <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> przy użyciu tej wersji konstruktora.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Podpis dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.MenuItem" /> klasy z określonym podpisem dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu przy użyciu `text` parametru, można również określić klucz dostępu, umieszczając znaku "&", przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu.  
  
 Ustawienie `text` parametr "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> określający podpisu elementu menu w momencie jest tworzony.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Podpis dla tego elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługująca <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzenia dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy za pomocą określonego podpisu i zdarzenia obsługi dla <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzeń elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu przy użyciu `text` parametru, można również określić klucz dostępu, umieszczając 'i' przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu.  
  
 Ustawienie `text` parametr "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
 Ponadto można użyć tego konstruktora do określenia delegata, która będzie obsługiwać <xref:System.Windows.Forms.MenuItem.Click> zdarzenia dla tworzonego elementu menu. <xref:System.EventHandler> , Aby były przekazywane do tego konstruktora musi być skonfigurowany do obsługi zdarzeń, która może obsłużyć wywołania <xref:System.Windows.Forms.MenuItem.Click> zdarzeń. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> obiektu z określonym podpisem i <xref:System.EventHandler> delegata podłączone do obsługi zdarzeń, który będzie obsługiwać <xref:System.Windows.Forms.MenuItem.Click> zdarzeń dla elementu menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Podpis dla tego elementu menu.</param>
        <param name="items">Tablica <see cref="T:System.Windows.Forms.MenuItem" /> obiektów, które zawierają elementy podmenu dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy z określonym podpisem oraz tablicę elementów podmenu zdefiniowanych dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu przy użyciu `text` parametru, można również określić klucz dostępu, umieszczając 'i' przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu.  
  
 Ustawienie `text` parametr "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
 `items` Parametr umożliwia przypisanie tablicę elementów menu, aby zdefiniować podmenu tego elementu menu. Każdy element w tablicy może być również tablica elementów menu do niej przypisany. Dzięki temu można utworzyć struktury pełne menu i przypisać je do konstruktora dla elementu menu.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt z określonym podpisem, podłączony do metody, która obsłuży zdarzenie programu obsługi zdarzeń poszczególnych elementów menu w tablicy elementów podmenu.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Podpis dla tego elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługująca <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzenia dla tego elementu menu.</param>
        <param name="shortcut">Jedną z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy przy użyciu określonego podpisu, program obsługi zdarzeń i klawisz skrótu skojarzonego elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu przy użyciu `text` parametru, można również określić klucz dostępu, umieszczając 'i' przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu. Ten konstruktor pozwala również na określenie klawisz skrótu, oprócz klucza dostępu, aby zapewnić nawigacji za pomocą klawiatury. Klawisze skrótów umożliwiają określenie kombinację klawiszy, których można użyć do aktywowania elementu menu.  
  
 Ustawienie `text` parametr "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
 Ponadto można użyć tego konstruktora do określenia delegata, która będzie obsługiwać <xref:System.Windows.Forms.MenuItem.Click> zdarzenia dla tworzonego elementu menu. <xref:System.EventHandler> , Aby były przekazywane do tego konstruktora musi być skonfigurowany do obsługi zdarzeń, która może obsłużyć wywołania <xref:System.Windows.Forms.MenuItem.Click> zdarzeń. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt z określonego podpisu, klawisza skrótu i program obsługi zdarzeń podłączony do metody, która obsłuży zdarzenie dla elementu menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Jedną z <see cref="T:System.Windows.Forms.MenuMerge" /> wartości.</param>
        <param name="mergeOrder">Względne położenie tego elementu menu zajmie się w menu. scalony.</param>
        <param name="shortcut">Jedną z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</param>
        <param name="text">Podpis dla tego elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługująca <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzenia dla tego elementu menu.</param>
        <param name="onPopup"><see cref="T:System.EventHandler" /> Obsługująca <see cref="E:System.Windows.Forms.MenuItem.Popup" /> zdarzenia dla tego elementu menu.</param>
        <param name="onSelect"><see cref="T:System.EventHandler" /> Obsługująca <see cref="E:System.Windows.Forms.MenuItem.Select" /> zdarzenia dla tego elementu menu.</param>
        <param name="items">Tablica <see cref="T:System.Windows.Forms.MenuItem" /> obiektów, które zawierają elementy podmenu dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.MenuItem" /> klasy z określonym podpisem; zdefiniowanych obsługi zdarzeń dla <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> i <see cref="E:System.Windows.Forms.MenuItem.Popup" /> zdarzenia; klawisza skrótu typu scalania; i kolejność określona dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu przy użyciu `text` parametru, można również określić klucz dostępu, umieszczając 'i' przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu.  
  
 Ustawienie `text` parametr "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
 `items` Parametr umożliwia przypisanie tablicę elementów menu, aby zdefiniować podmenu tego elementu menu. Każdy element w tablicy może być również tablica elementów menu do niej przypisany. Dzięki temu można utworzyć struktury pełne menu i przypisać je do konstruktora dla elementu menu.  
  
 `mergeType` i `mergeOrder` parametry umożliwiają ustalenie, zachowanie tego elementu menu, gdy element menu jest połączony z innym menu. W zależności od wartości określonej dla `mergeType` parametru, możesz dodać, usunąć, Zastąp lub scalanie elementów menu i jego podmenu elementy menu, które jest scalana. `mergeOrder` Parametr określa, gdzie tworzonego elementu menu zostanie umieszczony po scaleniu menu.  
  
 Ponadto można użyć tego konstruktora do utworzenia <xref:System.Windows.Forms.MenuItem> potem z łatwością połączyć programu obsługi zdarzeń w kodzie, który będzie przetwarzał kliknięcie elementu menu. <xref:System.EventHandler> , Aby były przekazywane do tego konstruktora powinien być skonfigurowany do obsługi zdarzeń, która może obsłużyć wywołania <xref:System.Windows.Forms.MenuItem.Click> zdarzeń. Za pomocą tej wersji konstruktora, można też połączyć <xref:System.Windows.Forms.MenuItem.Popup> i <xref:System.Windows.Forms.MenuItem.Select> zdarzenia w celu określenia, po wybraniu tego elementu menu. Można użyć tych zdarzeń, zadań, takich jak określająca, czy do wyświetlenia znacznik wyboru obok elementów podmenu lub Włącz lub Wyłącz elementy menu, w oparciu o stan aplikacji. <xref:System.Windows.Forms.MenuItem.Select> i <xref:System.Windows.Forms.MenuItem.Click> zdarzenia są wywoływane tylko w przypadku <xref:System.Windows.Forms.MenuItem> obiekty, które są nie nadrzędnych elementów menu. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, który ma klucz podpisu i skrót. Element menu również ma zdefiniowane dla procedury obsługi zdarzeń <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, i <xref:System.Windows.Forms.MenuItem.Select> zdarzenia. Jeśli ten element menu są scalane, doda element menu do menu w kolejności scalania zero.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Windows.Forms.MenuItem" /> znajduje się w osobnych wierszach (dla elementu menu dodane do <see cref="T:System.Windows.Forms.MainMenu" /> obiekt) lub w nowej kolumnie (dla elementu podmenu lub elementu menu wyświetlane w <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> element menu jest umieszczony w nowym wierszu lub w nowej kolumnie; <see langword="false" /> Jeśli element menu pozostanie w jego położenie domyślne. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Forms.MenuItem.BarBreak%2A> właściwości, aby utworzyć menu, gdzie każdy element menu jest umieszczane obok siebie w poziomie zamiast z w pionowy listy. Ta właściwość umożliwia również utworzyć pasek menu, który zawiera wiele wierszy elementów menu górnego poziomu.  
  
 Właściwość ta różni się od <xref:System.Windows.Forms.MenuItem.Break%2A> właściwości czy pasek jest wyświetlany po lewej stronie każdego elementu menu, który ma <xref:System.Windows.Forms.MenuItem.Break%2A> właściwością `true`. Pasku jest wyświetlane tylko wtedy, gdy element menu nie jest element menu najwyższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> z dwoma elementami podmenu. Elementy dwóch podmenu wyświetlane w poziomie w pionie zamiast <xref:System.Windows.Forms.MenuItem.BarBreak%2A> właściwości.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element jest umieszczony w nowym wierszu (dla elementu menu dodane do <see cref="T:System.Windows.Forms.MainMenu" /> obiekt) lub w nowej kolumnie (dla elementu menu lub podmenu elementu wyświetlanego na <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value><see langword="true" /> element menu jest umieszczony w nowym wierszu lub w nowej kolumnie; <see langword="false" /> Jeśli element menu pozostanie w jego położenie domyślne. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Forms.MenuItem.Break%2A> właściwości, aby utworzyć menu, w którym każdego menu jest umieszczane obok siebie w poziomie zamiast z w pionowy listy. Ta właściwość umożliwia również utworzyć pasek menu, który zawiera wiele wierszy elementów menu górnego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy menu z dwa elementy menu najwyższego poziomu w górnym wierszu i element menu jedną w dolnym rzędzie.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest wyświetlany znacznik wyboru obok tekstu elementu menu.</summary>
        <value><see langword="true" /> Jeśli znacznik wyboru obok pozycji menu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwość w połączeniu z innymi elementami menu w menu w celu określenia stanu na potrzeby aplikacji. Na przykład można umieścić znacznik wyboru, element menu w grupy elementów, aby zidentyfikować rozmiar czcionki, który ma być wyświetlany tekst w aplikacji. Można również użyć <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwość do identyfikacji wybranego elementu menu w grupie elementów menu wzajemnie się wykluczają.  
  
> [!NOTE]
>  Nie można ustawić tę właściwość `true` dla elementów menu najwyższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwości, aby zapewnić stan w aplikacji. W tym przykładzie można określić kolor tekstu w grupy elementów menu <xref:System.Windows.Forms.TextBox> kontroli. Program obsługi zdarzeń, pod warunkiem jest używany przez <xref:System.Windows.Forms.MenuItem.Click> zdarzenia trzy elementy menu. Określa kolor tekstu, każdy element menu `menuItemRed` (czerwony), `menuItemGreen` (zielony), lub `menuItemBlue` (niebieski). Określa, który element menu został kliknięty programu obsługi zdarzeń, umieszcza znacznik wyboru do wybranego elementu menu i zmienia kolor tekstu w postaci <xref:System.Windows.Forms.TextBox> kontroli. Przykład wymaga, aby <xref:System.Drawing> przestrzeń nazw została dodana do formularza, który ten kod jest umieszczany w. Przykład wymaga również, aby <xref:System.Windows.Forms.TextBox> została dodana do formularza, który ten przykładowy kod znajduje się w i o nazwie `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Windows.Forms.MenuItem" /> Menu najwyższego poziomu lub ma elementy podrzędne.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po kliknięciu lub wybraniu elementu menu przy użyciu klawisza skrótu lub klawisza dostępu zdefiniowanych dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click> Zdarzenie występuje, gdy to <xref:System.Windows.Forms.MenuItem> po kliknięciu przez użytkownika. To zdarzenie również występuje, gdy użytkownik wybierze element menu przy użyciu klawiatury i naciśnięcie klawisza Enter. Może również wystąpić, jeśli jest wciśnięty klawisz dostępu lub klawisza skrótu skojarzony z <xref:System.Windows.Forms.MenuItem>. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Jeśli <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwość <xref:System.Windows.Forms.MenuItem> zawiera jakiekolwiek elementy to zdarzenie nie jest wywoływane. To zdarzenie nie jest inicjowane dla elementów menu nadrzędnych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Click> zdarzenia w celu wykonywania zadań, kiedy <xref:System.Windows.Forms.MenuItem> kliknięciu. W przykładzie jest tworzony <xref:System.Windows.Forms.MainMenu> o nazwie `mainMenu1` i dodaje dwie <xref:System.Windows.Forms.MenuItem> obiektów `topMenuItem` (`File`) i `menuItem1` (`Open`). Następnie łączy `Click` zdarzenia `menuItem1_Click` programu obsługi zdarzeń. Kiedy użytkownik kliknie `Open` element menu <xref:System.Windows.Forms.OpenFileDialog> zostanie zainicjowana i wyświetlane. Przykład wymaga, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kopię <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>A <see cref="T:System.Windows.Forms.MenuItem" /> reprezentujący element menu zduplikowane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> Nie można używać obiektów w więcej niż jednym miejscu, chyba że uzyskać kopię <xref:System.Windows.Forms.MenuItem>. Możesz wywołać tę metodę, aby utworzyć kopię tego elementu menu, do użytku w <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, lub inne <xref:System.Windows.Forms.MenuItem> w aplikacji. Jeśli zostanie sklonowany element menu, wszystkie procedury obsługi zdarzeń określony w oryginalnym elemencie menu będzie działać w sklonowanej wersji elementu menu. Na przykład, jeśli utworzono <xref:System.Windows.Forms.MenuItem> i jego <xref:System.Windows.Forms.MenuItem.Click> zdarzenie, aby program obsługi zdarzeń. Jeśli zostanie sklonowany element menu, element menu sklonowany wywoła tę samą procedurę obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy kod przykładowy klony <xref:System.Windows.Forms.MenuItem> i wyświetla go w <xref:System.Windows.Forms.ContextMenu>. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> istnieje w <xref:System.Windows.Forms.MainMenu> formularza o nazwie `menuItem1` i <xref:System.Windows.Forms.ContextMenu> obiektu o nazwie `contextMenu1` występuje także w formularzu.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc"><see cref="T:System.Windows.Forms.MenuItem" /> Reprezentujący element menu do skopiowania.</param>
        <summary>Tworzy kopię określonego <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby utworzyć kopie elementów menu, które utworzono już do użycia w menu skrótów lub inną strukturę menu w aplikacji. Ta wersja <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> pozwala określić konkretną <xref:System.Windows.Forms.MenuItem> do skopiowania zamiast elementu menu, która wywołuje metodę. Ta metoda służy do zainicjowania nowej <xref:System.Windows.Forms.MenuItem> obiektu z kopią innego <xref:System.Windows.Forms.MenuItem>. Jeśli zostanie sklonowany element menu, wszystkie procedury obsługi zdarzeń określony w oryginalnym elemencie menu będzie działać w sklonowanej wersji elementu menu. Na przykład, jeśli utworzono <xref:System.Windows.Forms.MenuItem> i jego <xref:System.Windows.Forms.MenuItem.Click> zdarzenie, aby program obsługi zdarzeń. Jeśli zostanie sklonowany element menu, element menu sklonowany wywoła tę samą procedurę obsługi zdarzeń.  
  
   
  
## Examples  
 Inicjuje nowe wystąpienie w poniższym przykładzie kodu <xref:System.Windows.Forms.MenuItem> kopię istniejącego <xref:System.Windows.Forms.MenuItem> używanej w <xref:System.Windows.Forms.MainMenu> w formularzu. Kod następnie doda sklonowany <xref:System.Windows.Forms.MenuItem> do <xref:System.Windows.Forms.ContextMenu> w formularzu. W tym przykładzie wymaga, aby <xref:System.Windows.Forms.MenuItem> wcześniej utworzony i o nazwie `menuItem1` i <xref:System.Windows.Forms.ContextMenu> kontrolki została utworzona i o nazwie `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest domyślny element menu.</summary>
        <value><see langword="true" /> Jeśli element menu jest element domyślny, w menu. w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wklejenie jest domyślny element menu do menu. Gdy użytkownik kliknie dwukrotnie podmenu zawiera element domyślny zaznaczono element domyślny i podmenu jest zamknięty. Możesz użyć <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> właściwości do wskazania domyślnej akcji, który jest oczekiwany w menu lub menu skrótów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu z dwoma elementami podmenu. Przykład ustawia `menuItem2` używając elementu menu domyślne <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> właściwości.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.MenuItem.Dispose%2A> po zakończeniu przy użyciu <xref:System.Windows.Forms.MenuItem>. <xref:System.Windows.Forms.MenuItem.Dispose%2A> Pozostawia metoda <xref:System.Windows.Forms.MenuItem> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Windows.Forms.MenuItem.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Windows.Forms.MenuItem> , dzięki czemu można odzyskać pamięć zajmowaną przez jej przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Windows.Forms.MenuItem.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Windows.Forms.MenuItem>. W przeciwnym razie zasoby <xref:System.Windows.Forms.MenuItem> jest przy użyciu nie zostanie zwolniona, aż do wywołania kolekcji wyrzucania elementów <xref:System.Windows.Forms.MenuItem> destruktor obiektu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> elementu menu jest właściwością <see langword="true" /> i wysłaniu żądania do rysowania elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DrawItemEventArgs> Argument przekazany do <xref:System.Windows.Forms.MenuItem.DrawItem> zawiera program obsługi zdarzeń <xref:System.Drawing.Graphics> obiekt, który umożliwia przeprowadzanie związane z rysowaniem i innych operacji graficznych na powierzchni elementu menu. Ta procedura obsługi zdarzeń służy do tworzenia niestandardowych menu, które spełniają wymagania aplikacji. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób obsługi <xref:System.Windows.Forms.MenuItem.DrawItem> zdarzeń. W tym przykładzie pobiera element przy użyciu menu <xref:System.Drawing.Brush> i <xref:System.Drawing.Font>, a następnie rysuje <xref:System.Drawing.Rectangle> wokół elementu menu. Rysunek odbywa się za pośrednictwem <xref:System.Drawing.Graphics> obiektu, który jest przekazywany do obsługi zdarzeń w <xref:System.Windows.Forms.DrawItemEventArgs> parametru. W tym przykładzie wymaga, że zainicjują <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> właściwość elementu do `true`. Na przykład C# Dodaj następujący kod w Konstruktorze formularza po `InitializeComponent`, aby zaczepić zdarzenie:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest włączone.</summary>
        <value><see langword="true" /> Jeśli element menu jest włączone; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.MenuItem> to znaczy wyłączone jest wyświetlana w kolorze szarym aby wskazać jej stan. Po wyłączeniu nadrzędnego elementu menu nie są wyświetlane wszystkie elementy podmenu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Popup> zdarzenie, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiektów, które zapewniają obsługę wycinania, kopiowania i operacje usuwania są włączone, zanim jest wyświetlany w menu, w jakiej są wyświetlane w. W przykładzie następuje, jeśli `textBox1`, <xref:System.Windows.Forms.TextBox> kontrolować w formularzu, jest włączona, ma fokus wejścia i zawiera tekst zaznaczony przed włączeniem <xref:System.Windows.Forms.MenuItem> obiektów. W tym przykładzie wymaga tego trzech <xref:System.Windows.Forms.MenuItem> obiekty są tworzone o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą położenie elementu menu w jego menu nadrzędnego.</summary>
        <value>Liczony od zera indeks reprezentującą położenie elementu menu w jego menu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia indeksowanej pozycji elementu menu, w kolekcji elementów menu w menu jej nadrzędnej. Ta właściwość służy do zmiany położenia elementów menu w innej lokalizacji, w menu. Można również użyć tej właściwości, tworząc <xref:System.Windows.Forms.MenuItem> do określenia jego położenie w strukturze menu w czasie tworzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia pozycję dwa elementy menu w menu. Poniższy przykład kodu wymaga, że dwa <xref:System.Windows.Forms.MenuItem> obiekty są tworzone o nazwie `menuItem1` i `menuItem2`. `menuItem1` Element menu przenosi w dół o jedną pozycję menu, podczas gdy `menuItem2` zostanie przesunięty o jedną pozycję.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przypisaną wartością jest mniejsza od zera lub większa niż liczba elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element menu zawiera elementy podrzędne.</summary>
        <value><see langword="true" /> Jeśli element menu zawiera elementy menu podrzędne; <see langword="false" /> Jeśli menu jest element menu autonomicznych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Można użyć tej właściwości, za pomocą <xref:System.Windows.Forms.MenuItem.Parent%2A> właściwości do nawigowania po kodzie za pomocą menu całej struktury.  
  
   
  
## Examples  
 Poniższy przykład kodu Określa, czy istnieją wszelkich podmenu skojarzone z <xref:System.Windows.Forms.MenuItem> o nazwie `menuItem1`. Jeśli istnieje wszelkich podmenu, jego wyłącza je, ustawiając <xref:System.Windows.Forms.MenuItem.Enabled%2A> właściwość `false`. Przykład wymaga, że istnieje <xref:System.Windows.Forms.MenuItem> tworzony o nazwie `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu zostanie wypełniona lista okien podrzędnych wielu interfejsu dokumentów (MDI), które są wyświetlane w formularzu skojarzone.</summary>
        <value><see langword="true" /> Jeśli w tym elemencie menu; zostanie wyświetlona lista okien podrzędnych MDI w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wybraniu elementu menu do wyświetlania list okien podrzędnych MDI jako podmenu pozycji menu zostanie wyświetlona lista. Tylko w przypadku formularzy, które są zdefiniowane jako formularzy podrzędnych MDI są wyświetlane na liście okna. Mogą być wyświetlane tylko dziewięć okien podrzędnych w danym momencie. W przypadku więcej niż dziewięć okien podrzędnych wyświetlany element menu "Więcej Windows...", jest wyświetlany na końcu listy okna. Kliknięcie tego elementu menu, wyświetli się okno dialogowe z pełną listą okien podrzędnych, które są aktualnie aktywne.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> używany do wyświetlania listy aktualnie otwarte formularzy podrzędnych MDI w formie MDI.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy menu musi wiedzieć rozmiar elementu menu, przed jego narysowaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dla tego zdarzenia, konieczne jest posiadanie <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> elementu menu właściwością `true`. To zdarzenie jest wywoływane przed menu właściciela rysowane są rysowane umożliwiające rozmiar elementów menu do narysowania należy określić. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.MenuItem.MeasureItem> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.MenuItem> o nazwie `MenuItem1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.MenuItem.MeasureItem> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, identyfikator Windows dla tego elementu menu.</summary>
        <value>Identyfikator Windows dla tego elementu menu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scala to <see cref="T:System.Windows.Forms.MenuItem" /> z inną <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scala to <see cref="T:System.Windows.Forms.MenuItem" /> z inną <see cref="T:System.Windows.Forms.MenuItem" /> i zwraca wynikowy scalony <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>A <see cref="T:System.Windows.Forms.MenuItem" /> reprezentujący element menu scalone.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wywołasz tę wersję <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, <xref:System.Windows.Forms.MenuItem> zwracany jest kopią bieżącego elementu menu którego będzie mogło zostać scalone z innym elementem menu bez wywierania wpływu na funkcjonalność bieżącego elementu. Ta wersja <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metoda jest podobna do wywoływania <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> metodę, która nie zawiera żadnych parametrów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Element <see cref="T:System.Windows.Forms.MenuItem" /> , który określa element menu aby łączyć się z niej.</param>
        <summary>Scala inny element menu przy użyciu tego elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy menu są scalane, zgodnie z wartością elementu menu <xref:System.Windows.Forms.MenuItem.MergeType%2A> i <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> właściwości. Ta wersja <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metoda umożliwia utworzenie scalania dwóch <xref:System.Windows.Forms.MenuItem> obiektów (i ich podmenu) w pojedynczym menu. Scalanie menu jest obsługiwane automatycznie, gdy formularz nadrzędny wielu interfejsu dokumentów (MDI) i element podrzędny ma menu. Można użyć tej wersji metoda scalania dwóch <xref:System.Windows.Forms.MenuItem> obiektów (i ich elementów podmenu) znajduje się w <xref:System.Windows.Forms.MainMenu> kontroli w pojedynczym menu, w ramach <xref:System.Windows.Forms.ContextMenu>. Na przykład, można wywołać tę wersję <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> scalanie elementów menu w menu Plik i Edytuj w pojedynczej metody <xref:System.Windows.Forms.MenuItem> , można następnie dodać do i wyświetlane przez <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje tę wersję <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metodę, aby utworzyć kopię <xref:System.Windows.Forms.MenuItem> i scalić ją z innego. Scalone <xref:System.Windows.Forms.MenuItem> jest dodawane do <xref:System.Windows.Forms.ContextMenu> kontroli. W tym przykładzie wymaga, że istnieją dwa elementy menu o nazwie `menuItem1` i `menuItem2` zawierających podmenu elementów wewnątrz nich i <xref:System.Windows.Forms.ContextMenu> o nazwie `contextMenu1` do wyświetlania elementów menu. `menuItem1` i `menuItem2` menu różne elementy w nich zawarte. Po wywołaniu <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> nawiązaniu ujednoliconej menu zostanie utworzony.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą względne położenie elementu menu, gdy jest scalany z inną.</summary>
        <value>Liczony od zera indeks reprezentującej pozycję kolejności scalania dla tego elementu menu. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność scalania element menu określa położenie względne, prowadzące tego elementu menu Jeśli menu struktury, która <xref:System.Windows.Forms.MenuItem> znajduje się w jest scalany z innego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> właściwości, aby kontrolować sposób, zostanie wyświetlone menu scalone. Jest to kompletny przykład, gotowe do uruchomienia po dodaniu do projektu.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą zachowanie tego elementu menu, po jego menu jest scalany z innego.</summary>
        <value>A <see cref="T:System.Windows.Forms.MenuMerge" /> wartość, która reprezentuje typ scalania elementu menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ scalanie elementów menu wskazuje, jak element menu zachowuje się jeśli ma takiej samej kolejności scalania, jak inny element menu scalane. Scalone menu umożliwia tworzenie menu skonsolidowany oparte na dwóch lub więcej z istniejącymi menu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> z <xref:System.Windows.Forms.MenuItem.MergeType%2A> i <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> określona w taki sposób, aby element menu jest dodawany do menu scalonych na pierwszym miejscu.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisaną wartością nie jest jednym z <see cref="T:System.Windows.Forms.MenuMerge" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą mnemoników znak, który jest skojarzony z tym elementem menu.</summary>
        <value>Znak, który reprezentuje znak mnemoników skojarzone z tym elementem menu. Zwraca znak NUL (ASCII wartość 0), jeśli żaden znak mnemoników jest określona w tekście <see cref="T:System.Windows.Forms.MenuItem" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak mnemoników to pierwszy znak po znaku handlowego "i" (&) w tekście <xref:System.Windows.Forms.MenuItem>. Ta właściwość nie będzie zwracać wartość, jeśli dwa znaki handlowego "i" są umieszczone razem takie znaki są używane do wyświetlania handlowe "i" w tekście <xref:System.Windows.Forms.MenuItem> zamiast definiować go znakiem mnemoników.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Click> zdarzenia w celu wykonywania zadań, kiedy <xref:System.Windows.Forms.MenuItem> kliknięciu. W przykładzie jest tworzony <xref:System.Windows.Forms.MainMenu> o nazwie `mainMenu1` i dodaje dwie <xref:System.Windows.Forms.MenuItem> obiektów `topMenuItem` (`File`) i `menuItem1` (`Open`). Następnie łączy `Click` zdarzenia `menuItem1_Click` programu obsługi zdarzeń. Kiedy użytkownik kliknie `Open` element menu <xref:System.Windows.Forms.OpenFileDialog> zostanie zainicjowana i wyświetlane. Przykład wymaga, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Forms.DrawItemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> metody.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.Popup" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Forms.MeasureItemEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> metody.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.Popup" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Popup> zdarzenie, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiektów, które zapewniają obsługę wycinania, kopiowania i operacje usuwania są włączone, zanim jest wyświetlany w menu, w jakiej są wyświetlane w. W przykładzie następuje, jeśli `textBox1`, <xref:System.Windows.Forms.TextBox> kontrolować w formularzu, jest włączona, ma fokus wejścia i zawiera tekst zaznaczony przed włączeniem <xref:System.Windows.Forms.MenuItem> obiektów. W tym przykładzie wymaga tego trzech <xref:System.Windows.Forms.MenuItem> obiekty są tworzone o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.Select" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Select> zdarzenia <xref:System.Windows.Forms.MenuItem> klasy, aby przypisać tekst pomocy dla <xref:System.Windows.Forms.StatusBarPanel> z <xref:System.Windows.Forms.StatusBar> kontroli. W tym przykładzie wymaga, aby <xref:System.Windows.Forms.MenuItem> obiektów o nazwie `menuOpen`, `menuSave`, i `menuExit` są dodawane do <xref:System.Windows.Forms.MainMenu> kontrolkę w formularzu. Przykład wymaga również, aby <xref:System.Windows.Forms.StatusBar> o nazwie `statusBar1` została dodana do formularza. <xref:System.Windows.Forms.StatusBar> Kontrolki powinien zawierać <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kod, który podasz rysuje element menu lub Windows rysuje element menu.</summary>
        <value><see langword="true" /> Jeśli element menu ma być rysowany przy użyciu kodu; <see langword="false" /> Jeśli element menu ma być rysowany przez Windows. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> właściwość jest ustawiona na `true`, wymagana jest obsługa wszystkich rysowania elementu menu. Ta funkcja służy do tworzenia ekranów specjalne menu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje menu z elementem menu rysowanych przez właściciela. Ten zestaw przykład <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> właściwości i używa `AddHandler` instrukcji i `AddressOf` operatora, aby wyznaczyć delegata do obsługi <xref:System.Windows.Forms.MenuItem.DrawItem> zdarzeń. Aby uruchomić przykład, wklej go w formularzu, który importuje <xref:System>, <xref:System.Windows.Forms>, i <xref:System.Drawing> przestrzeni nazw. Wywołaj `InitializeMenu` z konstruktora formularza lub `Load` metody.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, menu, który zawiera ten element menu.</summary>
        <value>A <see cref="T:System.Windows.Forms.Menu" /> reprezentujący menu, który zawiera ten element menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia uzyskanie dostępu <xref:System.Windows.Forms.Menu> obiekt podmenu. Można rzutować <xref:System.Windows.Forms.Menu> obiektu zwróconego przez tę właściwość, aby <xref:System.Windows.Forms.MenuItem> obiekt do manipulowania go.  
  
   
  
## Examples  
 W tym przykładzie utworzysz menu głównego i element menu najwyższego poziomu `menuItem1` (`File`). Można również utworzyć dwa elementy menu `menuItem2` (`New`) i `menuItem3` (`Open`) i dodaj je do listy elementów menu `menuItem1`. A następnie sprawdź, czy `menuItem3` — otrzymano nadrzędnego menu, które ma wartość true i wyświetlanie informacji o tym menu nadrzędnego w oknie komunikatu. W tym przykładzie wymaga, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Generuje <see cref="E:System.Windows.Forms.Control.Click" /> zdarzenie <see cref="T:System.Windows.Forms.MenuItem" />, symulując kliknięcie przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To menu umożliwia Aktywuj element menu za pomocą kodu bez przekazywania żadnych informacji o zdarzeniach. Na przykład, jeśli chcesz uaktywnić menu na akcję, która występuje w aplikacji, można wywołać elementu podstawie <xref:System.Windows.Forms.MenuItem.PerformClick%2A> metodę, która <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 W tym przykładzie programowo kliknij element menu przy użyciu `PerformClick` metody. Najpierw należy utworzyć menu głównego (`mainMenu1`) i Dodaj do niego dwa elementy menu `menuItem1` (`File`) i `menuItem2` (`Edit`). Możesz także użyć <xref:System.Windows.Forms.MenuItem.Click> zdarzenia w celu wysyłania danych do programu obsługi zdarzeń, po kliknięciu elementu menu. Możesz użyć `PerformClick` metoda kliknij `File` elementu menu. Po uruchomieniu aplikacji, `File` element menu jest aktywowany i okno komunikatu, który zawiera tekst "Kliknięciu menu Plik." zostanie wyświetlone na ekranie. Przykład wymaga, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.MenuItem.Select" /> zdarzenia dla tego elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wywoływanie <xref:System.Windows.Forms.MenuItem.Select> zdarzeń bez przekazywania żadnych informacji o zdarzeniach do narzędzia obsługi zdarzeń.  
  
   
  
## Examples  
 W tym przykładzie programowo wybierz element menu przy użyciu `PerformSelect` metody. Najpierw należy utworzyć menu głównego (`mainMenu1`) i Dodaj do niego dwa elementy menu `menuItem1` (`File`) i `menuItem2` (`Edit`). Możesz także użyć <xref:System.Windows.Forms.MenuItem.Select> zdarzenia w celu wysyłania danych do programu obsługi zdarzeń, gdy zaznaczony zostanie element menu. Następnie możesz użyć `PerformSelect` metodę, aby wybrać `File` elementu menu. Po uruchomieniu aplikacji, `File` zaznaczony zostanie element menu, a okno komunikatu, który zawiera tekst "Wybrane menu Plik." zostanie wyświetlone na ekranie. Przykład wymaga, że utworzono <xref:System.Windows.Forms.Form> o nazwie `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim zostanie wyświetlona lista element menu elementów menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje tylko w przypadku, gdy element menu ma podmenu elementów do wyświetlenia. Ta procedura obsługi zdarzeń umożliwia dodawanie, usuwanie, włączanie, wyłączanie, zaznacz lub wyczyść elementy menu, w oparciu o stan aplikacji, zanim zostaną one wyświetlone. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Popup> zdarzenie, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiektów, które zapewniają obsługę wycinania, kopiowania i operacje usuwania są włączone, zanim jest wyświetlany w menu, w jakiej są wyświetlane w. W przykładzie następuje, jeśli `textBox1`, <xref:System.Windows.Forms.TextBox> kontrolować w formularzu, jest włączona, ma fokus wejścia i zawiera tekst zaznaczony przed włączeniem <xref:System.Windows.Forms.MenuItem> obiektów. W tym przykładzie wymaga tego trzech <xref:System.Windows.Forms.MenuItem> obiekty są tworzone o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="T:System.Windows.Forms.MenuItem" />, jeśli opcja jest zaznaczona, wyświetla przycisku radiowego, zamiast znacznik wyboru.</summary>
        <value><see langword="true" /> Jeśli ma być używana zamiast znacznik wyboru; przycisku radiowego <see langword="false" /> standardowa znacznik wyboru jest wyświetlane, gdy zaznaczone jest pole elementu menu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaczniki wyboru nie musi oznaczać wzajemnie wykluczających się stan grupy elementów menu. Ta właściwość służy do wskazywania użytkownikowi znacznik wyboru elementu menu wzajemnie się wykluczają.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwość można zmienić stanu aplikacji. W tym przykładzie grupa elementów menu są pod warunkiem, że można określić kolor tekstu w <xref:System.Windows.Forms.TextBox> kontroli. W tym przykładzie program obsługi zdarzeń, pod warunkiem jest używany przez <xref:System.Windows.Forms.MenuItem.Click> zdarzeń trzech elementów. Każdy element menu Określa kolor `menuItemRed`, `menuItemGreen`, lub `menuItemBlue`. Określa, który element menu został kliknięty programu obsługi zdarzeń, umieszcza znacznik wyboru do wybranego elementu menu i zmienia kolor tekstu w postaci <xref:System.Windows.Forms.TextBox> o nazwie `textBox1`. W przykładzie użyto również <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> właściwości, aby zademonstrować, jak wyboru przycisk radiowy służy do pokazywania elementów menu, które wzajemnie się wykluczają. W tym przykładzie wymaga, aby <xref:System.Drawing?displayProperty=nameWithType> przestrzeń nazw została dodana do formularza, który zawiera ten kod.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik umieszcza wskaźnik myszy nad element menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane zazwyczaj, gdy użytkownik umieszcza wskaźnik myszy nad element menu. Zdarzenie również może zostać wywołane, gdy użytkownik wyróżnia element menu przy użyciu klawiatury, przez przewinięcie do elementów menu za pomocą klawiszy strzałek. To zdarzenie służy do wyświetlenia ciągu szczegółową pomoc odnoszących się do tego elementu menu na pasku stanu aplikacji. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Jeśli <xref:System.Windows.Forms.Menu.MenuItems%2A> właściwość <xref:System.Windows.Forms.MenuItem> zawiera jakiekolwiek elementy to zdarzenie nie jest wywoływane. To zdarzenie nie jest inicjowane dla elementów menu nadrzędnych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.MenuItem.Select> zdarzenia <xref:System.Windows.Forms.MenuItem> klasy, aby przypisać tekst pomocy dla <xref:System.Windows.Forms.StatusBarPanel> z <xref:System.Windows.Forms.StatusBar> kontroli. W tym przykładzie wymaga, aby <xref:System.Windows.Forms.MenuItem> obiektów o nazwie `menuOpen`, `menuSave`, i `menuExit` są dodawane do <xref:System.Windows.Forms.MainMenu> kontrolkę w formularzu. Przykład wymaga również, aby <xref:System.Windows.Forms.StatusBar> o nazwie `statusBar1` została dodana do formularza. <xref:System.Windows.Forms.StatusBar> Kontrolki powinien zawierać <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, skojarzone z elementem menu klawisza skrótu.</summary>
        <value>Jedną z <see cref="T:System.Windows.Forms.Shortcut" /> wartości. Wartość domyślna to <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klawisze skrótów udostępniają metodę użytkownikom na uaktywnienie często używane elementy menu w menu systemie i zapewnia dostęp z klawiatury do aplikacji dla użytkowników, którzy nie mają dostępu do myszy lub innego urządzenia wskaźnika.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, Ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczna i przedstawiono sposób wyświetlania klawiszy skrótów dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> to znaczy została utworzona o nazwie `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisaną wartością nie jest jednym z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy klawisz skrótu, który jest skojarzony z elementem menu jest wyświetlany obok podpisu elementu menu.</summary>
        <value><see langword="true" /> Jeśli klawisz skrótu jest wyświetlany obok podpisu elementu menu; <see langword="false" /> Jeśli klawisz skrótu nie ma być wyświetlana. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy opcji dla użytkowników ukryć skróty w menu, aby zaoszczędzić miejsce na menu lub ukrywania klawisza skrótu z wyświetleniem.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, Ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczna i przedstawiono sposób wyświetlania klawiszy skrótów dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> to znaczy została utworzona o nazwie `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, podpis elementu menu.</summary>
        <value>Podpis tekstowy elementu menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu, można również określić klucz dostępu, umieszczając 'i' przed znakiem, który ma być używany jako klucz dostępu. Na przykład aby określić "F" w "File" jako klucza dostępu, można będzie Określ podpis dla tego elementu menu, jako "& plik". Ta funkcja służy do zapewnienia klawiatury menu.  
  
 Ustawienie tej właściwości na "`-`" powoduje, że danego elementu menu, który będzie wyświetlany jako separatora (linia pozioma) zamiast elementów menu standardowego.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, Ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczna i przedstawiono sposób wyświetlania klawiszy skrótów dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> to znaczy została utworzona o nazwie `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Ciąg reprezentujący bieżącą <see cref="T:System.Windows.Forms.MenuItem" />. Ciąg zawiera typ i <see cref="P:System.Windows.Forms.MenuItem.Text" /> właściwości formantu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest widoczny.</summary>
        <value><see langword="true" /> Jeśli element menu będzie widoczny w menu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do modyfikowania struktury menu bez konieczności scalania menu lub Wyłącz menu. Na przykład, jeśli chcesz ukryć pełną części funkcji menu dla aplikacji, możesz je ukryć od użytkownika przez ustawienie tej właściwości na `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, Ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczna i przedstawiono sposób wyświetlania klawiszy skrótów dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> to znaczy została utworzona o nazwie `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
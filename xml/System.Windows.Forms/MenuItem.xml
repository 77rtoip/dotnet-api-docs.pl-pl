<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49db1c290139f2cb55f34bbacd2850364305d2f0" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69183497" /></Metadata><TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <TypeSignature Language="F#" Value="type MenuItem = class&#xA;    inherit Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje pojedynczy element, który jest wyświetlany w <see cref="T:System.Windows.Forms.MainMenu" /> lub. <see cref="T:System.Windows.Forms.ContextMenu" /> Mimo <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> że program zamienia i dodaje funkcje <see cref="T:System.Windows.Forms.MenuItem" /> kontroli nad poprzednimi wersjami, <see cref="T:System.Windows.Forms.MenuItem" /> jest zachowywany w celu zapewnienia zgodności z poprzednimi wersjami i w przyszłości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby można było wyświetlić <xref:System.Windows.Forms.MenuItem> element, należy go dodać <xref:System.Windows.Forms.MainMenu> do lub <xref:System.Windows.Forms.ContextMenu>. Aby utworzyć podmenu, można dodać <xref:System.Windows.Forms.MenuItem> obiekty <xref:System.Windows.Forms.Menu.MenuItems%2A> do właściwości elementu nadrzędnego <xref:System.Windows.Forms.MenuItem>.  
  
 <xref:System.Windows.Forms.MenuItem> Klasa zawiera właściwości, które umożliwiają skonfigurowanie wyglądu i funkcjonalności elementu menu. Aby wyświetlić znacznik wyboru obok elementu menu, użyj <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwości. Za pomocą tej funkcji można zidentyfikować element menu, który jest zaznaczony na liście wzajemnie wykluczających się elementów menu. Na przykład, jeśli masz zestaw elementów menu do ustawiania koloru tekstu w <xref:System.Windows.Forms.TextBox> kontrolce, możesz <xref:System.Windows.Forms.MenuItem.Checked%2A> użyć właściwości, aby określić, który kolor jest obecnie zaznaczony. <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Właściwość może służyć do definiowania kombinacji klawiaturowej, którą można nacisnąć, aby wybrać element menu.  
  
 W <xref:System.Windows.Forms.MenuItem> przypadku obiektów wyświetlanych w aplikacji interfejsu wielu dokumentów (MDI) można <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> użyć metody, aby scalić menu elementu nadrzędnego MDI dla z elementem podrzędnym, aby utworzyć skonsolidowaną strukturę menu. <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> <xref:System.Windows.Forms.ContextMenu> <xref:System.Windows.Forms.MainMenu> Ponieważ nie można ponownie użyć w wielu lokalizacjach, takich jak w i a, można użyć metody, aby utworzyć kopię do użycia w innej lokalizacji. <xref:System.Windows.Forms.MenuItem>  
  
 <xref:System.Windows.Forms.MenuItem.Popup> Zdarzenie umożliwia wykonywanie zadań przed wyświetleniem menu. Na przykład można utworzyć procedurę obsługi zdarzeń dla tego zdarzenia, aby wyświetlić lub ukryć elementy menu na podstawie stanu kodu. <xref:System.Windows.Forms.MenuItem.Select> Zdarzenie umożliwia wykonywanie zadań, takich jak dostarczanie szczegółowej pomocy dla elementów menu aplikacji, gdy użytkownik umieści wskaźnik myszy nad elementem menu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy strukturę menu dla formularza. Przykładowy kod dodaje <xref:System.Windows.Forms.MenuItem> do, aby reprezentować element menu najwyższego poziomu, dodaje do niego element podmenu, aby wybrać rozmiar czcionki, a następnie dodaje dwa elementy podmenu do tego elementu menu, które reprezentują duże i małe Opcje czcionki w aplikacji. Przykład wymaga <xref:System.Windows.Forms.MainMenu> , aby obiekt o nazwie `mainMenu1` i cztery <xref:System.Windows.Forms.MenuItem> obiekty o nazwie `menuItem1`, `menuItem2`, `menuItem3`, i `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.MenuItem" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.MenuItem" /> Inicjuje z pustym podpisem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu pustego <xref:System.Windows.Forms.MenuItem> użycia tego konstruktora można użyć właściwości i metod <xref:System.Windows.Forms.MenuItem> klasy, aby określić <xref:System.Windows.Forms.MenuItem>wygląd i zachowanie.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> za pomocą tej wersji konstruktora.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Podpis elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.MenuItem" /> klasy z określonym podpisem dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu za pomocą `text` parametru można także określić klucz dostępu, umieszczając znak "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu.  
  
 Ustawienie parametru na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu. `text`  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> , który określa podpis elementu menu w czasie, gdy jest konstruowany.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Podpis elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługujezdarzenie<see cref="E:System.Windows.Forms.MenuItem.Click" /> dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy z określonym podpisem i obsługą zdarzeń dla <see cref="E:System.Windows.Forms.MenuItem.Click" /> zdarzenia elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu za pomocą `text` parametru można także określić klucz dostępu, umieszczając element "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu.  
  
 Ustawienie parametru na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu. `text`  
  
 Ponadto można użyć tego konstruktora, aby określić delegata, który będzie obsługiwał <xref:System.Windows.Forms.MenuItem.Click> zdarzenie dla tworzonego elementu menu. Przekazany do tego konstruktora musi być skonfigurowany tak, aby wywoływał procedurę obsługi zdarzeń, która może <xref:System.Windows.Forms.MenuItem.Click> obsłużyć zdarzenie. <xref:System.EventHandler> Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> obiekt z określonym podpisem <xref:System.EventHandler> i delegatem połączonym z <xref:System.Windows.Forms.MenuItem.Click> programem obsługi zdarzeń, który będzie obsługiwał zdarzenie dla elementu menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Podpis elementu menu.</param>
        <param name="items">Tablica <see cref="T:System.Windows.Forms.MenuItem" /> obiektów, która zawiera elementy podmenu dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie klasy z określonym podpisem i tablicą elementów podmenu zdefiniowanych dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu za pomocą `text` parametru można także określić klucz dostępu, umieszczając element "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu.  
  
 Ustawienie parametru na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu. `text`  
  
 `items` Parametr umożliwia przypisanie tablicy elementów menu w celu zdefiniowania podmenu tego elementu menu. Każdy element w tablicy może również mieć tablicę elementów menu przypisanych do niego. Dzięki temu można tworzyć kompletne struktury menu i przypisywać je do konstruktora dla elementu menu.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt z określonym podpisem, program obsługi zdarzeń połączony z metodą, która będzie obsługiwać zdarzenie każdego elementu menu w tablicy elementów podmenu.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : string * EventHandler * System.Windows.Forms.Shortcut -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (text, onClick, shortcut)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Podpis elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługujezdarzenie<see cref="E:System.Windows.Forms.MenuItem.Click" /> dla tego elementu menu.</param>
        <param name="shortcut">Jedna z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy z określonym podpisem, programem obsługi zdarzeń i skojarzonym klawiszem skrótu dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu za pomocą `text` parametru można także określić klucz dostępu, umieszczając element "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu. Ten konstruktor umożliwia również określenie klawisza skrótu oprócz klawisza dostępu w celu zapewnienia nawigacji klawiaturowej. Klawisze skrótu umożliwiają określenie kombinacji kluczy, których można użyć do uaktywnienia elementu menu.  
  
 Ustawienie parametru na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu. `text`  
  
 Ponadto można użyć tego konstruktora, aby określić delegata, który będzie obsługiwał <xref:System.Windows.Forms.MenuItem.Click> zdarzenie dla tworzonego elementu menu. Przekazany do tego konstruktora musi być skonfigurowany tak, aby wywoływał procedurę obsługi zdarzeń, która może <xref:System.Windows.Forms.MenuItem.Click> obsłużyć zdarzenie. <xref:System.EventHandler> Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy obiekt z określonym podpisem, klawiszem skrótu i obsługą zdarzeń połączoną z metodą, która będzie obsługiwać zdarzenie dla elementu menu.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.MenuItem : System.Windows.Forms.MenuMerge * int * System.Windows.Forms.Shortcut * string * EventHandler * EventHandler * EventHandler * System.Windows.Forms.MenuItem[] -&gt; System.Windows.Forms.MenuItem" Usage="new System.Windows.Forms.MenuItem (mergeType, mergeOrder, shortcut, text, onClick, onPopup, onSelect, items)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Jedna z <see cref="T:System.Windows.Forms.MenuMerge" /> wartości.</param>
        <param name="mergeOrder">Względne położenie, które ten element menu zajmie w scalonym menu.</param>
        <param name="shortcut">Jedna z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</param>
        <param name="text">Podpis elementu menu.</param>
        <param name="onClick"><see cref="T:System.EventHandler" /> Obsługujezdarzenie<see cref="E:System.Windows.Forms.MenuItem.Click" /> dla tego elementu menu.</param>
        <param name="onPopup"><see cref="T:System.EventHandler" /> Obsługujezdarzenie<see cref="E:System.Windows.Forms.MenuItem.Popup" /> dla tego elementu menu.</param>
        <param name="onSelect"><see cref="T:System.EventHandler" /> Obsługujezdarzenie<see cref="E:System.Windows.Forms.MenuItem.Select" /> dla tego elementu menu.</param>
        <param name="items">Tablica <see cref="T:System.Windows.Forms.MenuItem" /> obiektów, która zawiera elementy podmenu dla tego elementu menu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.MenuItem" /> klasy z określonym podpisem; zdefiniowane programy obsługi zdarzeń <see cref="E:System.Windows.Forms.MenuItem.Click" />dla, i <see cref="E:System.Windows.Forms.MenuItem.Popup" /> zdarzenia; klawisz skrótu <see cref="E:System.Windows.Forms.MenuItem.Select" /> , typ scalania i kolejność określona dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu za pomocą `text` parametru można także określić klucz dostępu, umieszczając element "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu.  
  
 Ustawienie parametru na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu. `text`  
  
 `items` Parametr umożliwia przypisanie tablicy elementów menu w celu zdefiniowania podmenu tego elementu menu. Każdy element w tablicy może również mieć tablicę elementów menu przypisanych do niego. Dzięki temu można tworzyć kompletne struktury menu i przypisywać je do konstruktora dla elementu menu.  
  
 Parametry `mergeType` i`mergeOrder` umożliwiają określenie, jak działa ten element menu, gdy element menu zostanie scalony z innym menu. W zależności od wartości określonej dla `mergeType` parametru można dodać, usunąć, zamienić lub scalić element menu i jego elementy podmenu z menu, z którym jest ono scalane. `mergeOrder` Parametr określa, gdzie tworzony element menu zostanie umieszczony po scaleniu menu.  
  
 Ponadto można użyć tego konstruktora do utworzenia <xref:System.Windows.Forms.MenuItem> i nawiązania połączenia z programem obsługi zdarzeń w kodzie, który będzie przetwarzać kliknięcie elementu menu. Przekazana do tego konstruktora powinna być skonfigurowana w taki sposób, aby wywoływał procedurę obsługi zdarzeń, która <xref:System.Windows.Forms.MenuItem.Click> może obsłużyć zdarzenie. <xref:System.EventHandler> Korzystając z tej wersji konstruktora, można także połączyć zdarzenia i <xref:System.Windows.Forms.MenuItem.Popup> <xref:System.Windows.Forms.MenuItem.Select> , aby określić, kiedy ten element menu jest zaznaczony. Możesz użyć tych zdarzeń do zadań, takich jak określenie, czy wyświetlać znacznik wyboru obok elementów podmenu lub aby włączyć lub wyłączyć elementy menu na podstawie stanu aplikacji. Zdarzenia <xref:System.Windows.Forms.MenuItem.Select> <xref:System.Windows.Forms.MenuItem> i <xref:System.Windows.Forms.MenuItem.Click> są wywoływane tylko dla obiektów, które nie są elementami menu nadrzędnych. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, który ma podpis i klawisz skrótu. Element menu zawiera również programy obsługi zdarzeń zdefiniowane dla <xref:System.Windows.Forms.MenuItem.Popup>zdarzeń, <xref:System.Windows.Forms.MenuItem.Click>i <xref:System.Windows.Forms.MenuItem.Select> . Jeśli ten element menu zostanie scalony, doda element menu do menu z kolejnością scalania równą zero.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BarBreak : bool with get, set" Usage="System.Windows.Forms.MenuItem.BarBreak" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="T:System.Windows.Forms.MenuItem" /> jest umieszczona w nowym wierszu (dla elementu menu dodanego <see cref="T:System.Windows.Forms.MainMenu" /> do obiektu), czy w nowej kolumnie (dla elementu podmenu lub elementu <see cref="T:System.Windows.Forms.ContextMenu" />menu wyświetlanego w elemencie).</summary>
        <value><see langword="true" />Jeśli element menu jest umieszczony w nowym wierszu lub w nowej kolumnie; <see langword="false" /> Jeśli element menu zostanie pozostawiony w domyślnym umieszczaniu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć właściwości, <xref:System.Windows.Forms.MenuItem.BarBreak%2A> aby utworzyć menu, w którym każdy element menu jest umieszczony obok siebie w poziomie, a nie na liście pionowej. Za pomocą tej właściwości można również utworzyć pasek menu zawierający wiele wierszy elementów menu najwyższego poziomu.  
  
 Ta właściwość różni się od <xref:System.Windows.Forms.MenuItem.Break%2A> właściwości w tym, że pasek jest wyświetlany na lewej krawędzi każdego elementu menu, który <xref:System.Windows.Forms.MenuItem.Break%2A> ma właściwość ustawioną na `true`. Pasek jest wyświetlany tylko wtedy, gdy element menu nie jest elementem menu najwyższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> z dwoma podmenu elementów. Dwa elementy podmenu są wyświetlane w <xref:System.Windows.Forms.MenuItem.BarBreak%2A> poziomie zamiast w pionie przy użyciu właściwości.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Break : bool with get, set" Usage="System.Windows.Forms.MenuItem.Break" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element jest umieszczony w nowym wierszu (dla elementu menu dodanego do <see cref="T:System.Windows.Forms.MainMenu" /> obiektu), czy w nowej kolumnie (dla elementu menu lub podmenu wyświetlanego <see cref="T:System.Windows.Forms.ContextMenu" />w elemencie).</summary>
        <value><see langword="true" />Jeśli element menu jest umieszczony w nowym wierszu lub w nowej kolumnie; <see langword="false" /> Jeśli element menu zostanie pozostawiony w domyślnym umieszczaniu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć właściwości, <xref:System.Windows.Forms.MenuItem.Break%2A> aby utworzyć menu, w którym każde menu jest umieszczone obok siebie w poziomie, a nie na liście pionowej. Za pomocą tej właściwości można również utworzyć pasek menu zawierający wiele wierszy elementów menu najwyższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy menu z dwoma elementami menu najwyższego poziomu w górnym wierszu i jednym elementem menu w dolnym wierszu.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Checked : bool with get, set" Usage="System.Windows.Forms.MenuItem.Checked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy obok tekstu elementu menu pojawia się znacznik wyboru.</summary>
        <value><see langword="true" />Jeśli obok elementu menu znajduje się znacznik wyboru, w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwości w połączeniu z innymi elementami menu w menu, aby zapewnić stan dla aplikacji. Na przykład możesz umieścić znacznik wyboru w elemencie menu w grupie elementów, aby określić rozmiar czcionki, która ma być wyświetlana dla tekstu w aplikacji. Możesz również użyć <xref:System.Windows.Forms.MenuItem.Checked%2A> właściwości, aby zidentyfikować wybrany element menu w grupie wzajemnie wykluczających się elementów menu.  
  
> [!NOTE]
>  Tej właściwości nie można ustawić `true` na dla elementów menu najwyższego poziomu.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Windows.Forms.MenuItem.Checked%2A> aby zapewnić stan w aplikacji. W tym przykładzie grupa elementów menu służy do określenia koloru dla tekstu w <xref:System.Windows.Forms.TextBox> kontrolce. Dostarczony program obsługi zdarzeń jest używany przez <xref:System.Windows.Forms.MenuItem.Click> zdarzenie trzech elementów menu. Każdy element menu określa kolor tekstu, `menuItemRed` (czerwony), `menuItemGreen` (zielony) lub `menuItemBlue` (niebieski). Program obsługi zdarzeń określa, który element menu został kliknięty, umieszcza znacznik wyboru w wybranym elemencie menu i zmienia kolor tekstu <xref:System.Windows.Forms.TextBox> kontrolki formularza. Przykład wymaga, <xref:System.Drawing> aby przestrzeń nazw została dodana do formularza, w którym znajduje się ten kod. Przykład wymaga również, <xref:System.Windows.Forms.TextBox> aby został dodany do formularza, w którym znajduje się ten przykładowy kod o nazwie. `textBox1`  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="T:System.Windows.Forms.MenuItem" /> Jest menu najwyższego poziomu lub ma elementy podrzędne.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po kliknięciu lub wybraniu elementu menu przy użyciu klawisza skrótu lub klawisza dostępu zdefiniowanego dla elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie występuje, <xref:System.Windows.Forms.MenuItem> gdy zostanie kliknięty przez użytkownika. <xref:System.Windows.Forms.MenuItem.Click> To zdarzenie występuje również wtedy, gdy użytkownik wybierze element menu za pomocą klawiatury i naciśnie klawisz ENTER. Może się również zdarzyć, gdy zostanie naciśnięty klawisz dostępu lub klawisz skrótu, który jest skojarzony <xref:System.Windows.Forms.MenuItem>z. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Menu.MenuItems%2A> Jeśli Właściwość<xref:System.Windows.Forms.MenuItem> dla zawiera dowolne elementy, to zdarzenie nie zostanie zgłoszone. To zdarzenie nie jest wywoływane dla elementów menu nadrzędnych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Windows.Forms.MenuItem.Click> jak używać zdarzenia do wykonywania zadań <xref:System.Windows.Forms.MenuItem> po kliknięciu. Przykład tworzy <xref:System.Windows.Forms.MainMenu> wywoływane `topMenuItem` `File`i dodaje dwa <xref:System.Windows.Forms.MenuItem> obiekty, () i `menuItem1` (`Open`). `mainMenu1` Następnie łączy `Click` zdarzenie `menuItem1_Click` z programem obsługi zdarzeń. Gdy użytkownik kliknie `Open` element menu <xref:System.Windows.Forms.OpenFileDialog> , zostanie zainicjowany i wyświetlony. Przykład wymaga utworzenia <xref:System.Windows.Forms.Form> nazwy `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy kopię <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.CloneMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy kopię bieżącego <see cref="T:System.Windows.Forms.MenuItem" />elementu.</summary>
        <returns><see cref="T:System.Windows.Forms.MenuItem" /> Reprezentuje zduplikowany element menu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem>obiektów nie można używać w więcej niż jednym miejscu, chyba że zostanie uzyskana kopia <xref:System.Windows.Forms.MenuItem>. Możesz wywołać tę metodę <xref:System.Windows.Forms.ContextMenu>, aby utworzyć kopię tego elementu menu do użycia w, <xref:System.Windows.Forms.MainMenu>lub w innej <xref:System.Windows.Forms.MenuItem> aplikacji. Po sklonowaniu elementu menu wszystkie programy obsługi zdarzeń określone w oryginalnym elemencie menu będą nadal działać w sklonowanej wersji elementu menu. Na przykład, jeśli utworzono <xref:System.Windows.Forms.MenuItem> i połączono swoje <xref:System.Windows.Forms.MenuItem.Click> zdarzenie do programu obsługi zdarzeń. Po sklonowaniu elementu menu sklonowany element menu wywoła ten sam program obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu klonuje <xref:System.Windows.Forms.MenuItem> i wyświetla go <xref:System.Windows.Forms.ContextMenu>w. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> istnieje <xref:System.Windows.Forms.MainMenu> w `menuItem1` formularzu o <xref:System.Windows.Forms.ContextMenu> nazwie i że obiekt o nazwie `contextMenu1` również istnieje w formularzu.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.CloneMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.CloneMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Reprezentuje element menu, który ma zostać skopiowany. <see cref="T:System.Windows.Forms.MenuItem" /></param>
        <summary>Tworzy kopię określonego <see cref="T:System.Windows.Forms.MenuItem" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę, aby utworzyć kopie elementów menu, które zostały już utworzone do użycia w menu skrótów lub w innej strukturze menu w aplikacji. Ta wersja programu <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> umożliwia określenie określonego <xref:System.Windows.Forms.MenuItem> do skopiowania zamiast elementu menu, który wywołuje metodę. Tej metody można użyć do zainicjowania nowego <xref:System.Windows.Forms.MenuItem> obiektu za pomocą kopii innej. <xref:System.Windows.Forms.MenuItem> Po sklonowaniu elementu menu wszystkie programy obsługi zdarzeń określone w oryginalnym elemencie menu będą nadal działać w sklonowanej wersji elementu menu. Na przykład, jeśli utworzono <xref:System.Windows.Forms.MenuItem> i połączono swoje <xref:System.Windows.Forms.MenuItem.Click> zdarzenie do programu obsługi zdarzeń. Po sklonowaniu elementu menu sklonowany element menu wywoła ten sam program obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu inicjuje nową <xref:System.Windows.Forms.MenuItem> z kopią istniejącej <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.MainMenu> , która jest używana w formularzu. Kod następnie dodaje sklonowany <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.ContextMenu> do formularza. Ten przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> został utworzony i nazwany `menuItem1` oraz że <xref:System.Windows.Forms.ContextMenu> formant został utworzony i nazwany `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultItem : bool with get, set" Usage="System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest domyślnym elementem menu.</summary>
        <value><see langword="true" />Jeśli element menu jest elementem domyślnym w menu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślny element menu dla menu to boldfaced. Gdy użytkownik kliknie dwukrotnie podmenu, które zawiera element domyślny, zostanie wybrany element domyślny, a podmenu jest zamknięte. Możesz użyć <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> właściwości, aby wskazać, domyślną akcję, która jest oczekiwana w menu lub menu skrótów.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu z dwoma elementami podmenu. Przykład ustawia `menuItem2` jako domyślny element menu <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> przy użyciu właściwości.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="menuItem.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.MenuItem.Dispose%2A> po zakończeniu korzystania z <xref:System.Windows.Forms.MenuItem>. <xref:System.Windows.Forms.MenuItem.Dispose%2A> Metoda<xref:System.Windows.Forms.MenuItem> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.Windows.Forms.MenuItem.Dispose%2A>należy wydać wszystkie odwołania <xref:System.Windows.Forms.MenuItem> do, aby pamięć, która zajmowała się, mogła być odzyskiwana przez wyrzucanie elementów bezużytecznych.  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Windows.Forms.MenuItem.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.Windows.Forms.MenuItem>do. W przeciwnym razie zasoby, <xref:System.Windows.Forms.MenuItem> które są używane, nie zostaną zwolnione do momentu <xref:System.Windows.Forms.MenuItem> wywołania destruktora obiektu przez wyrzucanie elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberSignature Language="F#" Value="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " Usage="member this.DrawItem : System.Windows.Forms.DrawItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> właściwość elementu menu jest ustawiona na <see langword="true" /> i zostanie wysłane żądanie narysowania elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Argument przesłany <xref:System.Windows.Forms.MenuItem.DrawItem> do procedury obsługi zdarzeń zawiera <xref:System.Drawing.Graphics> obiekt, który umożliwia wykonywanie operacji rysowania i innych graficznych na powierzchni elementu menu. <xref:System.Windows.Forms.DrawItemEventArgs> Możesz użyć tego programu obsługi zdarzeń, aby utworzyć niestandardowe menu, które spełniają wymagania aplikacji. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Windows.Forms.MenuItem.DrawItem> jak obsłużyć zdarzenie. Ten przykład rysuje element menu przy użyciu <xref:System.Drawing.Brush> <xref:System.Drawing.Font>i a <xref:System.Drawing.Rectangle> , a następnie rysuje wokół elementu menu. Rysowanie odbywa się za pomocą <xref:System.Drawing.Graphics> obiektu, który jest przesyłany do programu obsługi zdarzeń <xref:System.Windows.Forms.DrawItemEventArgs> w parametrze. Ten przykład wymaga zainicjowania <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> właściwości dla `true`elementu. Aby uzyskać C# przykład, Dodaj następujący kod w Konstruktorze formularza po `InitializeComponent`, aby podłączyć zdarzenie:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.MenuItem.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest włączony.</summary>
        <value><see langword="true" />Jeśli element menu jest włączony; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> Wyłączony jest kolor szary w celu wskazania jego stanu. Gdy element menu nadrzędny jest wyłączony, wszystkie elementy podmenu nie są wyświetlane.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Windows.Forms.MenuItem.Popup> zdarzenia, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiekty, które zapewniają obsługę operacji wycinania, kopiowania i usuwania, są włączone przed wyświetleniem menu, w którym są wyświetlane. Przykład określa `textBox1` <xref:System.Windows.Forms.TextBox> , czy kontrolka w formularzu jest włączona, ma fokus wprowadzania i ma wybrany <xref:System.Windows.Forms.MenuItem> tekst przed włączeniem obiektów. W tym przykładzie wymagane są <xref:System.Windows.Forms.MenuItem> trzy obiekty o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Index : int with get, set" Usage="System.Windows.Forms.MenuItem.Index" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą położenie elementu menu w jego menu nadrzędnym.</summary>
        <value>Indeks (liczony od zera) reprezentujący położenie elementu menu w jego menu nadrzędnym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zapewnia indeksowane położenie elementu menu w kolekcji elementów menu w menu nadrzędnym. Tej właściwości można użyć do zmiany położenia elementu menu w innej lokalizacji w menu. Tej właściwości można również użyć podczas tworzenia, <xref:System.Windows.Forms.MenuItem> aby określić jej położenie w strukturze menu podczas tworzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu przełącza pozycję dwóch elementów menu w menu. Poniższy przykład kodu wymaga, aby zostały <xref:System.Windows.Forms.MenuItem> utworzone dwa obiekty o `menuItem1` nazwie `menuItem2`i. Element menu przesuwa się w dół o jedno miejsce w menu, `menuItem2` podczas przesuwania w górę o jedno miejsce. `menuItem1`  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Przypisana wartość jest mniejsza od zera lub większa od liczby elementów.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsParent : bool" Usage="System.Windows.Forms.MenuItem.IsParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element menu zawiera elementy menu podrzędnego.</summary>
        <value><see langword="true" />Jeśli element menu zawiera podrzędne elementy menu; <see langword="false" /> Jeśli menu jest autonomicznym elementem menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej właściwości można użyć z <xref:System.Windows.Forms.MenuItem.Parent%2A> właściwością do nawigowania w kodzie za pomocą całej struktury menu.  
  
   
  
## Examples  
 Poniższy przykład kodu określa, czy istnieją podmenu skojarzone z <xref:System.Windows.Forms.MenuItem> nazwą. `menuItem1` Jeśli istnieją jakieś podmenu, zostaną one wyłączone przez ustawienie <xref:System.Windows.Forms.MenuItem.Enabled%2A> właściwości na. `false` Przykład wymaga <xref:System.Windows.Forms.MenuItem> utworzenia nazwanego `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MdiList : bool with get, set" Usage="System.Windows.Forms.MenuItem.MdiList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu będzie wypełniany listą okien podrzędnych interfejsu wielu dokumentów (MDI), które są wyświetlane w skojarzonym formularzu.</summary>
        <value><see langword="true" />Jeśli zostanie wyświetlona lista okien podrzędnych MDI w tym elemencie menu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wybraniu elementu menu, aby wyświetlić listę okien podrzędnych MDI, lista zostanie wyświetlona jako podmenu elementu menu. Na liście okna są wyświetlane tylko formularze zdefiniowane jako formularze podrzędne MDI. Jednocześnie można wyświetlić tylko dziewięć okien podrzędnych. Jeśli jest wyświetlonych więcej niż dziewięć okien podrzędnych, "więcej okien..." na końcu listy okien zostanie wyświetlony element menu. Kliknięcie tego elementu menu spowoduje wyświetlenie okna dialogowego z pełną listą okien podrzędnych, które są obecnie aktywne.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> , który służy do wyświetlania listy aktualnie otwartych formularzy podrzędnych MDI w formularzu MDI.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberSignature Language="F#" Value="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " Usage="member this.MeasureItem : System.Windows.Forms.MeasureItemEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy menu musi znać rozmiar elementu menu przed jego rysowaniem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby to zdarzenie zostało wywołane, musisz mieć <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> właściwość elementu menu ustawione na. `true` To zdarzenie jest wywoływane przed narysowaniem menu rysowanych przez właściciela, aby umożliwić określenie rozmiaru elementu menu. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.MenuItem.MeasureItem> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.MenuItem> o nazwie. `MenuItem1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.MenuItem.MeasureItem> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MenuID : int" Usage="System.Windows.Forms.MenuItem.MenuID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą identyfikator systemu Windows dla tego elementu menu.</summary>
        <value>Identyfikator systemu Windows dla tego elementu menu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Scala ten <see cref="T:System.Windows.Forms.MenuItem" /> program z innym <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : unit -&gt; System.Windows.Forms.MenuItem" Usage="menuItem.MergeMenu " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Scala ten <see cref="T:System.Windows.Forms.MenuItem" /> program z innym <see cref="T:System.Windows.Forms.MenuItem" /> i zwraca wynikowy scalony. <see cref="T:System.Windows.Forms.MenuItem" /></summary>
        <returns><see cref="T:System.Windows.Forms.MenuItem" /> Reprezentujący scalony element menu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu tej wersji programu <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> <xref:System.Windows.Forms.MenuItem> zwracana jest kopia bieżącego elementu menu, którą można scalić z innym elementem menu bez wpływu na funkcjonalność bieżącego elementu. Ta wersja <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metody jest podobna do <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> wywołania metody, która nie zawiera parametrów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberSignature Language="F#" Value="override this.MergeMenu : System.Windows.Forms.MenuItem -&gt; unit" Usage="menuItem.MergeMenu itemSrc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">A <see cref="T:System.Windows.Forms.MenuItem" /> określa element menu, który ma zostać scalony z tym elementem.</param>
        <summary>Scala inny element menu z tym elementem menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy menu są scalane według wartości elementu <xref:System.Windows.Forms.MenuItem.MergeType%2A> menu i <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> właściwości. Ta wersja <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metody umożliwia scalanie dwóch <xref:System.Windows.Forms.MenuItem> obiektów (i ich podmenu) w jednym menu. Scalanie menu jest obsługiwane automatycznie, gdy formularz nadrzędny z interfejsem wielu dokumentów (MDI) i element podrzędny mają menu. Ta wersja metody służy do scalania dwóch <xref:System.Windows.Forms.MenuItem> obiektów (i ich elementów podmenu) znajdujących się <xref:System.Windows.Forms.MainMenu> w kontrolce w jednym menu w obrębie <xref:System.Windows.Forms.ContextMenu>. Na przykład można wywołać tę wersję <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metody, aby scalić elementy menu pliku i menu edycji do jednego <xref:System.Windows.Forms.MenuItem> , który następnie można dodać <xref:System.Windows.Forms.ContextMenu>do i wyświetlić.  
  
   
  
## Examples  
 Poniższy przykład kodu używa tej wersji <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> metody do utworzenia kopii <xref:System.Windows.Forms.MenuItem> a i scalenia z inną. Scalone <xref:System.Windows.Forms.MenuItem> dane są następnie dodawane <xref:System.Windows.Forms.ContextMenu> do kontrolki. W tym przykładzie wymagane są dwa elementy menu o nazwie `menuItem1` i `menuItem2` które zawierają <xref:System.Windows.Forms.ContextMenu> elementy podmenu w nich oraz nazwa `contextMenu1` , aby wyświetlić elementy menu. `menuItem1`i `menuItem2` znajdują się w nich inne elementy menu. Po wywołaniu <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> zostanie utworzone skonsolidowane menu.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MergeOrder : int with get, set" Usage="System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą względną pozycję elementu menu, gdy jest on scalany z innym.</summary>
        <value>Indeks (liczony od zera) reprezentujący pozycję zamówienia scalania dla tego elementu menu. Wartość domyślna to 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejność scalania elementu menu określa względne położenie tego elementu menu, jeśli struktura menu, w której <xref:System.Windows.Forms.MenuItem> znajduje się, jest scalana z inną.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> właściwości, aby kontrolować sposób wyświetlania scalonego menu. Jest to kompletny przykład gotowy do uruchomienia po dodaniu go do projektu.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberSignature Language="F#" Value="member this.MergeType : System.Windows.Forms.MenuMerge with get, set" Usage="System.Windows.Forms.MenuItem.MergeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą zachowanie tego elementu menu, gdy jego menu zostanie scalone z innym.</summary>
        <value><see cref="T:System.Windows.Forms.MenuMerge" /> Wartość, która reprezentuje typ scalania elementu menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typ scalania elementu menu wskazuje, jak działa element menu, gdy ma taki sam porządek scalania jak inny element menu, który jest scalany. Scalonych menu można używać do tworzenia skonsolidowanych kolumn w oparciu o dwa lub więcej istniejących menu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.MenuItem.MergeType%2A> with i <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> , tak aby element menu został dodany do scalonego menu na pierwszej pozycji.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.MenuMerge" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberSignature Language="F#" Value="member this.Mnemonic : char" Usage="System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą znak znaku, który jest skojarzony z tym elementem menu.</summary>
        <value>Znak, który reprezentuje znak znaku skojarzony z tym elementem menu. Zwraca znak NUL (wartość ASCII 0), jeśli w tekście elementu <see cref="T:System.Windows.Forms.MenuItem" />nie określono znaków.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak znaku jest pierwszym znakiem po znaku handlowego "i" (&) w tekście <xref:System.Windows.Forms.MenuItem>. Ta właściwość nie zwróci znaku, jeśli dwa znaki są umieszczane razem, ponieważ znaki handlowe są używane do wyświetlania znaku handlowego "i" w tekście <xref:System.Windows.Forms.MenuItem> zamiast definiować znak.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="menuItem.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Click" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, <xref:System.Windows.Forms.MenuItem.Click> jak używać zdarzenia do wykonywania zadań <xref:System.Windows.Forms.MenuItem> po kliknięciu. Przykład tworzy <xref:System.Windows.Forms.MainMenu> wywoływane `topMenuItem` `File`i dodaje dwa <xref:System.Windows.Forms.MenuItem> obiekty, () i `menuItem1` (`Open`). `mainMenu1` Następnie łączy `Click` zdarzenie `menuItem1_Click` z programem obsługi zdarzeń. Gdy użytkownik kliknie `Open` element menu <xref:System.Windows.Forms.OpenFileDialog> , zostanie zainicjowany i wyświetlony. Przykład wymaga utworzenia <xref:System.Windows.Forms.Form> nazwy `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> metodę klasy bazowej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit&#xA;override this.OnDrawItem : System.Windows.Forms.DrawItemEventArgs -&gt; unit" Usage="menuItem.OnDrawItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.DrawItemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.DrawItem" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInitMenuPopup : EventArgs -&gt; unit&#xA;override this.OnInitMenuPopup : EventArgs -&gt; unit" Usage="menuItem.OnInitMenuPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Popup" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit&#xA;override this.OnMeasureItem : System.Windows.Forms.MeasureItemEventArgs -&gt; unit" Usage="menuItem.OnMeasureItem e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MeasureItemEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.MeasureItem" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> metodę klasy bazowej.</para></block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPopup : EventArgs -&gt; unit&#xA;override this.OnPopup : EventArgs -&gt; unit" Usage="menuItem.OnPopup e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Popup" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Windows.Forms.MenuItem.Popup> zdarzenia, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiekty, które zapewniają obsługę operacji wycinania, kopiowania i usuwania, są włączone przed wyświetleniem menu, w którym są wyświetlane. Przykład określa `textBox1` <xref:System.Windows.Forms.TextBox> , czy kontrolka w formularzu jest włączona, ma fokus wprowadzania i ma wybrany <xref:System.Windows.Forms.MenuItem> tekst przed włączeniem obiektów. W tym przykładzie wymagane są <xref:System.Windows.Forms.MenuItem> trzy obiekty o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> metodę klasy bazowej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelect : EventArgs -&gt; unit&#xA;override this.OnSelect : EventArgs -&gt; unit" Usage="menuItem.OnSelect e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Select" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób <xref:System.Windows.Forms.MenuItem.Select> użycia zdarzenia <xref:System.Windows.Forms.MenuItem> klasy do <xref:System.Windows.Forms.StatusBarPanel> przypisywania <xref:System.Windows.Forms.StatusBar> tekstu pomocy do kontrolki. Ten <xref:System.Windows.Forms.MenuItem> przykład wymaga, aby obiekty `menuOpen`nazwane `menuSave`, i `menuExit` były dodawane do <xref:System.Windows.Forms.MainMenu> kontrolki formularza. Przykład wymaga <xref:System.Windows.Forms.StatusBar> również, aby kontrolka o nazwie `statusBar1` została dodana do formularza. Formant powinien zawierać element <xref:System.Windows.Forms.StatusBarPanel>. <xref:System.Windows.Forms.StatusBar>  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> metodę klasy bazowej.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OwnerDraw : bool with get, set" Usage="System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy podano kod rysuje element menu, czy system Windows rysuje element menu.</summary>
        <value><see langword="true" />Jeśli element menu ma być rysowany przy użyciu kodu; <see langword="false" /> Jeśli element menu ma być rysowany w systemie Windows. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest ustawiona na `true`, należy obsłużyć wszystkie rysunki elementu menu. <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> Możesz użyć tej funkcji do tworzenia własnych, specjalnych wyświetlania menu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje menu z elementem menu rysowanym przez właściciela. Ten przykład ustawia <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> Właściwość i `AddHandler` używa instrukcji i `AddressOf` <xref:System.Windows.Forms.MenuItem.DrawItem> operatora, aby wyznaczyć delegata do obsługi zdarzenia. Aby uruchomić ten przykład, wklej go w formularzu, który importuje <xref:System>, <xref:System.Windows.Forms>i <xref:System.Drawing> przestrzenie nazw. Wywołanie `InitializeMenu` z konstruktora lub `Load` metody formularza.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Menu" Usage="System.Windows.Forms.MenuItem.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą menu, które zawiera ten element menu.</summary>
        <value><see cref="T:System.Windows.Forms.Menu" /> Reprezentujący menu, które zawiera ten element menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można uzyskać <xref:System.Windows.Forms.Menu> obiekt dla podmenu. Można rzutować <xref:System.Windows.Forms.Menu> obiekt zwrócony przez tę właściwość <xref:System.Windows.Forms.MenuItem> na obiekt, aby manipulować nim.  
  
   
  
## Examples  
 W tym przykładzie utworzysz menu główne i element `menuItem1` menu najwyższego poziomu (`File`). `menuItem2` Utworzysz również dwa elementy menu (`New`) i `menuItem3` (`Open` `menuItem1`) i Dodaj je do listy elementów menu. Następnie sprawdź, czy `menuItem3` masz menu nadrzędne, które ma wartość true, i Wyświetl informacje o tym menu nadrzędnym w oknie komunikatu. Ten przykład wymaga utworzenia <xref:System.Windows.Forms.Form> nazwy. `Form1`  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberSignature Language="F#" Value="member this.PerformClick : unit -&gt; unit" Usage="menuItem.PerformClick " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Windows.Forms.Control.Click" /> Generuje zdarzenie<see cref="T:System.Windows.Forms.MenuItem" />dla, symulowane kliknięcie przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tego menu można aktywować element menu za pomocą kodu bez przekazywania informacji o zdarzeniu. Na przykład jeśli chcesz uaktywnić element menu na podstawie akcji, która występuje w aplikacji, możesz wywołać <xref:System.Windows.Forms.MenuItem.PerformClick%2A> metodę dla tej <xref:System.Windows.Forms.MenuItem>metody.  
  
   
  
## Examples  
 W tym przykładzie programowo klikniesz element menu przy użyciu `PerformClick` metody. Najpierw należy utworzyć menu`mainMenu1`główne () i dodać do niego dwa elementy menu, `menuItem1` (`File`) i `menuItem2` (`Edit`). Możesz również użyć <xref:System.Windows.Forms.MenuItem.Click> zdarzenia do wysyłania danych do programu obsługi zdarzeń po kliknięciu elementu menu. Następnie użyj `PerformClick` metody, aby `File` kliknąć element menu. Po uruchomieniu aplikacji `File` element menu jest uaktywniany, a okno komunikatu zawierające tekst "menu plik zostanie kliknięte". pojawia się na ekranie. Przykład wymaga utworzenia <xref:System.Windows.Forms.Form> nazwy `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberSignature Language="F#" Value="abstract member PerformSelect : unit -&gt; unit&#xA;override this.PerformSelect : unit -&gt; unit" Usage="menuItem.PerformSelect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Windows.Forms.MenuItem.Select" /> Podnosi zdarzenie dla tego elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia podnoszenie <xref:System.Windows.Forms.MenuItem.Select> poziomu zdarzenia bez przekazywania informacji o zdarzeniu do programu obsługi zdarzeń.  
  
   
  
## Examples  
 W tym przykładzie programowo wybierasz element menu przy użyciu `PerformSelect` metody. Najpierw należy utworzyć menu`mainMenu1`główne () i dodać do niego dwa elementy menu, `menuItem1` (`File`) i `menuItem2` (`Edit`). Możesz również użyć <xref:System.Windows.Forms.MenuItem.Select> zdarzenia do wysyłania danych do programu obsługi zdarzeń, gdy zostanie wybrany element menu. Następnie użyj `PerformSelect` metody, aby `File` wybrać element menu. Po uruchomieniu aplikacji, `File` element menu zostanie zaznaczony i zostanie wyświetlone okno komunikatu zawierające tekst "menu plik jest zaznaczone". pojawia się na ekranie. Przykład wymaga utworzenia <xref:System.Windows.Forms.Form> nazwy `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberSignature Language="F#" Value="member this.Popup : EventHandler " Usage="member this.Popup : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim zostanie wyświetlona lista elementów menu elementu menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje tylko wtedy, gdy element menu zawiera elementy podmenu do wyświetlenia. Za pomocą tego programu obsługi zdarzeń można dodawać, usuwać, włączać, wyłączać, zaznaczać lub wyznaczać elementy menu w zależności od stanu aplikacji przed ich wyświetleniem. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak użyć <xref:System.Windows.Forms.MenuItem.Popup> zdarzenia, aby określić, czy <xref:System.Windows.Forms.MenuItem> obiekty, które zapewniają obsługę operacji wycinania, kopiowania i usuwania, są włączone przed wyświetleniem menu, w którym są wyświetlane. Przykład określa `textBox1` <xref:System.Windows.Forms.TextBox> , czy kontrolka w formularzu jest włączona, ma fokus wprowadzania i ma wybrany <xref:System.Windows.Forms.MenuItem> tekst przed włączeniem obiektów. W tym przykładzie wymagane są <xref:System.Windows.Forms.MenuItem> trzy obiekty o nazwie `menuCut`, `menuCopy`, i `menuDelete` zostały utworzone.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RadioCheck : bool with get, set" Usage="System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą <see cref="T:System.Windows.Forms.MenuItem" />, czy, jeśli zaznaczone, wyświetla przycisk radiowy zamiast znacznika wyboru.</summary>
        <value><see langword="true" />Jeśli przycisk radiowy ma być używany zamiast znacznika wyboru; <see langword="false" /> Jeśli standardowy znacznik wyboru ma być wyświetlany po zaznaczeniu elementu menu. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znaczniki Check nie muszą oznaczać wzajemnie wykluczających się stanu dla grupy elementów menu. Ta właściwość umożliwia wskazanie użytkownikowi, że znacznik wyboru elementu menu wykluczają się wzajemnie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa właściwości, <xref:System.Windows.Forms.MenuItem.Checked%2A> aby zmienić stan aplikacji. W przykładzie podano grupę elementów menu, która służy do określania koloru tekstu w <xref:System.Windows.Forms.TextBox> kontrolce. W tym przykładzie dostarczony program obsługi zdarzeń jest używany przez <xref:System.Windows.Forms.MenuItem.Click> zdarzenie trzech elementów menu. Każdy element menu określa kolor, `menuItemRed`, `menuItemGreen`, lub `menuItemBlue`. Program obsługi zdarzeń określa, który element menu został kliknięty, umieszcza znacznik wyboru w wybranym elemencie menu i zmienia kolor tekstu <xref:System.Windows.Forms.TextBox> kontrolki formularza o nazwie. `textBox1` W przykładzie użyto <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> również właściwości, aby zademonstrować, jak sprawdzanie przycisku radiowego jest używane do wyświetlania elementów menu, które wzajemnie się wykluczają. Ten przykład wymaga, <xref:System.Drawing?displayProperty=nameWithType> aby przestrzeń nazw została dodana do formularza zawierającego ten kod.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberSignature Language="F#" Value="member this.Select : EventHandler " Usage="member this.Select : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik umieści wskaźnik nad elementem menu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zwykle wywoływane, gdy użytkownik umieści wskaźnik myszy nad elementem menu. Zdarzenie może być również wywoływane, gdy użytkownik podświetla element menu za pomocą klawiatury, przewijając do elementu menu za pomocą klawiszy strzałek. Możesz użyć tego zdarzenia, aby wyświetlić szczegółowy ciąg pomocy dotyczący tego elementu menu na pasku stanu aplikacji. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Menu.MenuItems%2A> Jeśli Właściwość<xref:System.Windows.Forms.MenuItem> dla zawiera dowolne elementy, to zdarzenie nie zostanie zgłoszone. To zdarzenie nie jest wywoływane dla elementów menu nadrzędnych.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób <xref:System.Windows.Forms.MenuItem.Select> użycia zdarzenia <xref:System.Windows.Forms.MenuItem> klasy do <xref:System.Windows.Forms.StatusBarPanel> przypisywania <xref:System.Windows.Forms.StatusBar> tekstu pomocy do kontrolki. Ten <xref:System.Windows.Forms.MenuItem> przykład wymaga, aby obiekty `menuOpen`nazwane `menuSave`, i `menuExit` były dodawane do <xref:System.Windows.Forms.MainMenu> kontrolki formularza. Przykład wymaga <xref:System.Windows.Forms.StatusBar> również, aby kontrolka o nazwie `statusBar1` została dodana do formularza. Formant powinien zawierać element <xref:System.Windows.Forms.StatusBarPanel>. <xref:System.Windows.Forms.StatusBar>  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberSignature Language="F#" Value="member this.Shortcut : System.Windows.Forms.Shortcut with get, set" Usage="System.Windows.Forms.MenuItem.Shortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą klawisz skrótu skojarzony z elementem menu.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.Shortcut" /> wartości. Wartość domyślna to <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klawisze skrótów zapewniają użytkownikom możliwość aktywowania często używanych elementów menu w systemie menu oraz zapewniania dostępu klawiaturowego do aplikacji dla tych użytkowników, którzy nie mają dostępu do myszy lub innego urządzenia wskaźnika.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczny i wyświetla klawisz skrótu dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> został utworzony o nazwie. `menuItem1`  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.Shortcut" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowShortcut : bool with get, set" Usage="System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy klawisz skrótu skojarzony z elementem menu jest wyświetlany obok napisu elementu menu.</summary>
        <value><see langword="true" />Jeśli kombinacja klawiszy skrótów jest wyświetlana obok napisu elementu menu; <see langword="false" /> Jeśli kombinacja klawiszy skrótu nie ma być wyświetlana. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość umożliwia użytkownikom ukrywanie skrótów z menu w celu zachowania obszaru menu lub ukrycia klawisza skrótu z wyświetlania.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczny i wyświetla klawisz skrótu dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> został utworzony o nazwie. `menuItem1`  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.MenuItem.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą podpis elementu menu.</summary>
        <value>Podpis tekstowy elementu menu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu podpisu dla elementu menu można także określić klucz dostępu, umieszczając "&" przed znakiem, który ma być używany jako klucz dostępu. Na przykład, aby określić "F" w "pliku" jako klucz dostępu, należy określić podpis dla elementu menu jako "& plik". Za pomocą tej funkcji można zapewnić nawigację klawiaturową w menu.  
  
 Ustawienie tej właściwości na "`-`" powoduje, że element menu będzie wyświetlany jako separator (linia pozioma), a nie standardowy element menu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczny i wyświetla klawisz skrótu dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> został utworzony o nazwie. `menuItem1`  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="menuItem.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca ciąg, który reprezentuje <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Ciąg, który reprezentuje bieżący <see cref="T:System.Windows.Forms.MenuItem" />. Ciąg zawiera typ i <see cref="P:System.Windows.Forms.MenuItem.Text" /> właściwość formantu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.MenuItem.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy element menu jest widoczny.</summary>
        <value><see langword="true" />Jeśli element menu będzie widoczny w menu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość służy do modyfikowania struktury menu bez konieczności scalania menu lub wyłączania menu. Na przykład, jeśli chcesz ukryć kompletną sekcję funkcji z menu dla aplikacji, możesz ukryć je od użytkownika, ustawiając tę właściwość na `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy element menu, ustawia podpis, przypisuje klawisz skrótu, sprawia, że element menu jest widoczny i wyświetla klawisz skrótu dla elementu menu. Przykład wymaga, aby <xref:System.Windows.Forms.MenuItem> został utworzony o nazwie. `menuItem1`  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

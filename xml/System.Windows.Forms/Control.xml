<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2b3b5195039196a919dfa98b041dcd3ede1d6921" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69194530" /></Metadata><TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Definiuje klasę bazową dla formantów, które są składnikami z reprezentacją wizualną.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby utworzyć własną klasę formantów, Dziedzicz z <xref:System.Windows.Forms.UserControl> <xref:System.Windows.Forms.Control> klas, lub z innych Windows Forms podanych kontrolek. Aby uzyskać więcej informacji na temat tworzenia niestandardowych kontrolek, zobacz [Tworzenie niestandardowych kontrolek Windows Forms przy użyciu .NET Framework](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md).  
  
 <xref:System.Windows.Forms.Control> Klasa implementuje bardzo podstawowe funkcje wymagane przez klasy, które wyświetlają informacje dla użytkownika. Obsługuje ona dane wejściowe użytkownika za pomocą klawiatury i urządzeń wskazujących. Obsługuje ona Routing i zabezpieczenia komunikatów. Definiuje granice formantu (jego położenie i rozmiar), chociaż nie implementuje rysowania. Udostępnia uchwyt okna (`hWnd`).  
  
 Windows Forms kontrolki używają właściwości otoczenia, aby formanty podrzędne mogły wyglądać podobnie jak w otaczającym środowisku. *Właściwość otoczenia* jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Jeśli formant nie ma <xref:System.Windows.Forms.Control.Parent%2A>, a właściwość nie jest ustawiona, kontrolka próbuje określić wartość właściwości otoczenia <xref:System.Windows.Forms.Control.Site%2A> za pomocą właściwości. Jeśli formant nie jest zlokalizowany, Jeśli lokacja nie obsługuje właściwości otoczenia lub jeśli właściwość nie jest ustawiona na <xref:System.Windows.Forms.AmbientProperties>, formant używa własnych wartości domyślnych. Zazwyczaj Właściwość otoczenia reprezentuje cechę kontrolki, na <xref:System.Windows.Forms.Control.BackColor%2A>przykład, która jest przekazywana do formantu podrzędnego. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Właściwości otoczenia <xref:System.Windows.Forms.Control> dostarczone przez klasę obejmują: <xref:System.Windows.Forms.Control.Cursor%2A>, <xref:System.Windows.Forms.Control.Font%2A>, <xref:System.Windows.Forms.Control.BackColor%2A> <xref:System.Windows.Forms.Control.ForeColor%2A>, i <xref:System.Windows.Forms.Control.RightToLeft%2A>.  
  
> [!NOTE]
>  Aby zapewnić obsługę stylów wizualnych przez aplikację Windows Forms, należy ustawić <xref:System.Windows.Forms.FlatStyle> właściwość na i dołączyć manifest do `System` pliku wykonywalnego. Manifest to plik XML, który jest zawarty jako zasób w pliku wykonywalnym aplikacji lub jako oddzielny plik, który znajduje się w tym samym katalogu co plik wykonywalny. Przykład manifestu znajduje się w sekcji <xref:System.Windows.Forms.FlatStyle> przykład wyliczenia. Aby uzyskać więcej informacji na temat używania stylów wizualnych, zobacz [Style wizualne](https://msdn.microsoft.com/library/windows/desktop/bb773187.aspx).  
  
 Windows Forms ma wbudowaną obsługę ułatwień dostępu i zawiera informacje na temat aplikacji, która umożliwia korzystanie z aplikacji klienckich do ułatwienia dostępu, takich jak powiększenie ekranu i narzędzia do przeglądania, narzędzia do wprowadzania głosu, klawiatury ekranowe, Alternatywne urządzenia wejściowe i narzędzia do ulepszania klawiaturowego. Czasami konieczne będzie podanie dodatkowych informacji na temat aplikacji klienckich do ułatwienia dostępu. Istnieją dwa sposoby udostępniania tych dodatkowych informacji. Można ustawić <xref:System.Windows.Forms.Control.AccessibleName%2A>wartości właściwości, <xref:System.Windows.Forms.Control.AccessibleDescription%2A>, <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>i <xref:System.Windows.Forms.Control.AccessibleRole%2A> , które będą zgłaszane do aplikacji klienckich dostępności. Ta metoda jest zwykle używana do zapewnienia ograniczonego dostępu do istniejących kontrolek. Alternatywnie można napisać własną klasę pochodną <xref:System.Windows.Forms.AccessibleObject> klasy lub <xref:System.Windows.Forms.Control.ControlAccessibleObject> , zapewniając możliwie jak najwięcej informacji o ułatwieniach dostępu.  
  
> [!NOTE]
>  Aby zachować lepszą wydajność, nie ustawiaj rozmiaru formantu w jego konstruktorze. Preferowaną metodą jest zastąpienie <xref:System.Windows.Forms.Control.DefaultSize%2A> właściwości.  
  
> [!NOTE]
>  Nie należy dodawać powiązań danych dla elementu <xref:System.Windows.Forms.Control> w konstruktorze. Wykonanie tej czynności spowoduje błędy podczas generowania kodu i może spowodować niepożądane zachowanie.  
  
 Większość formantów w <xref:System.Windows.Forms> przestrzeni nazw używa podstawowej kontrolki programu Windows jako podstawy do kompilowania. Aby uzyskać więcej informacji o typowych kontrolkach systemu Windows, zobacz [Ogólne informacje o formancie](https://msdn.microsoft.com/library/windows/desktop/bb775497.aspx).  
  
 Aby zidentyfikować Windows Forms kontrolki z oddzielnego procesu, użyj `SendMessage` standardowego wywołania do przekazywania komunikatu WM_GETCONTROLNAME. WM_GETCONTROLNAME jest niezależna od języka i hierarchii systemu Windows. Aby uzyskać więcej informacji, zobacz temat "zalecane rozwiązanie dla Windows Forms" w temacie[automatyzacja Windows Forms](https://msdn.microsoft.com/library/ms996405.aspx).  
  
 Użyj właściwości <xref:System.Windows.Forms.Control.InvokeRequired%2A> , aby synchronizować dostęp do formantu z wielu wątków. Aby uzyskać więcej informacji o wielowątkowych kontrolkach Windows Forms [, zobacz How to: Ustaw bezpieczne dla wątków wywołania formantów Windows Forms](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>Tylko następujące elementy członkowskie są bezpieczne wątkowo <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />: <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" /> <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />, <see cref="P:System.Windows.Forms.Control.InvokeRequired" />,, i <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> , jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <see cref="M:System.Windows.Forms.Control.CreateGraphics" /> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe.</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Control" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Control" /> klasy z ustawieniami domyślnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> Klasa jest klasą bazową dla wszystkich kontrolek używanych w aplikacji Windows Forms. Ponieważ ta klasa nie jest zazwyczaj używana do tworzenia wystąpienia klasy, ten Konstruktor zazwyczaj nie jest wywoływany bezpośrednio, ale jest wywoływany przez klasę pochodną.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Tekst wyświetlany przez kontrolkę.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Control" /> klasy z określonym tekstem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> Klasa jest klasą bazową dla wszystkich kontrolek używanych w aplikacji Windows Forms. Ponieważ ta klasa nie jest zazwyczaj używana do tworzenia wystąpienia klasy, ten Konstruktor zazwyczaj nie jest wywoływany bezpośrednio, ale jest wywoływany przez klasę pochodną.  
  
 Ta wersja <xref:System.Windows.Forms.Control.%23ctor%2A> konstruktora ustawia początkową <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości na `text` wartość parametru.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent"><see cref="T:System.Windows.Forms.Control" /> Element jest elementem nadrzędnym formantu.</param>
        <param name="text">Tekst wyświetlany przez kontrolkę.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Control" /> klasy jako kontrolkę podrzędną z określonym tekstem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> Klasa jest klasą bazową dla wszystkich kontrolek używanych w aplikacji Windows Forms. Ponieważ ta klasa nie jest zazwyczaj używana do tworzenia wystąpienia klasy, ten Konstruktor zazwyczaj nie jest wywoływany bezpośrednio, ale jest wywoływany przez klasę pochodną.  
  
 Ta wersja <xref:System.Windows.Forms.Control.%23ctor%2A> konstruktora ustawia początkową <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości na `text` wartość parametru. Konstruktor dodaje również formant do kontrolki <xref:System.Windows.Forms.Control.ControlCollection>nadrzędnej.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">Tekst wyświetlany przez kontrolkę.</param>
        <param name="left"><see cref="P:System.Drawing.Point.X" /> Pozycja formantu (w pikselach) od lewej krawędzi kontenera formantu. Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Left" /> właściwości.</param>
        <param name="top"><see cref="P:System.Drawing.Point.Y" /> Pozycja formantu (w pikselach) od górnej krawędzi kontenera formantu. Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Top" /> właściwości.</param>
        <param name="width">Szerokość formantu (w pikselach). Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Width" /> właściwości.</param>
        <param name="height">Wysokość formantu (w pikselach). Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Height" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Control" /> klasy z określonym tekstem, rozmiarem i lokalizacją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> Klasa jest klasą bazową dla wszystkich kontrolek używanych w aplikacji Windows Forms. Ponieważ ta klasa nie jest zazwyczaj używana do tworzenia wystąpienia klasy, ten Konstruktor zazwyczaj nie jest wywoływany bezpośrednio, ale jest wywoływany przez klasę pochodną.  
  
 Ta wersja <xref:System.Windows.Forms.Control.%23ctor%2A> konstruktora ustawia początkową <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości na `text` wartość parametru. Początkowa <xref:System.Windows.Forms.Control.Size%2A> i <xref:System.Windows.Forms.Control.Location%2A> kontrolkasą`width` określane przez wartości parametrów `top` `height` , i. `left`  
  
> [!NOTE]
>  Aby zachować lepszą wydajność, nie ustawiaj rozmiaru formantu w jego konstruktorze. Preferowaną metodą jest zastąpienie <xref:System.Windows.Forms.Control.DefaultSize%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent"><see cref="T:System.Windows.Forms.Control" /> Element jest elementem nadrzędnym formantu.</param>
        <param name="text">Tekst wyświetlany przez kontrolkę.</param>
        <param name="left"><see cref="P:System.Drawing.Point.X" /> Pozycja formantu (w pikselach) od lewej krawędzi kontenera formantu. Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Left" /> właściwości.</param>
        <param name="top"><see cref="P:System.Drawing.Point.Y" /> Pozycja formantu (w pikselach) od górnej krawędzi kontenera formantu. Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Top" /> właściwości.</param>
        <param name="width">Szerokość formantu (w pikselach). Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Width" /> właściwości.</param>
        <param name="height">Wysokość formantu (w pikselach). Wartość jest przypisana do <see cref="P:System.Windows.Forms.Control.Height" /> właściwości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Control" /> klasy jako kontrolkę podrzędną z określonym tekstem, rozmiarem i lokalizacją.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control> Klasa jest klasą bazową dla wszystkich kontrolek używanych w aplikacji Windows Forms. Ponieważ ta klasa nie jest zazwyczaj używana do tworzenia wystąpienia klasy, ten Konstruktor zazwyczaj nie jest wywoływany bezpośrednio, ale jest wywoływany przez klasę pochodną.  
  
 Ta wersja <xref:System.Windows.Forms.Control.%23ctor%2A> konstruktora ustawia początkową <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości na `text` wartość parametru. Konstruktor dodaje również formant do kontrolki <xref:System.Windows.Forms.Control.ControlCollection>nadrzędnej. Początkowa <xref:System.Windows.Forms.Control.Size%2A> i <xref:System.Windows.Forms.Control.Location%2A> kontrolkasą`width` określane przez wartości parametrów `top` `height` , i. `left`  
  
> [!NOTE]
>  Aby zachować lepszą wydajność, nie ustawiaj rozmiaru formantu w jego konstruktorze. Preferowaną metodą jest zastąpienie <xref:System.Windows.Forms.Control.DefaultSize%2A> właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powiadamia aplikacje klienckie o ułatwieniach dostępu <see cref="T:System.Windows.Forms.AccessibleEvents" />programu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">W <see cref="T:System.Windows.Forms.AccessibleEvents" /> celu powiadomienia aplikacji klienckich o ułatwieniach dostępu.</param>
        <param name="childID">Element podrzędny <see cref="T:System.Windows.Forms.Control" /> do powiadamiania o dostępnym zdarzeniu.</param>
        <summary>Powiadamia aplikacje klienckie dostępności określonego <see cref="T:System.Windows.Forms.AccessibleEvents" /> dla określonej kontrolki podrzędnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy wywołać <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType> metodę dla każdej <xref:System.Windows.Forms.AccessibleEvents> aplikacji klienckiej ułatwień dostępu, aby otrzymywać powiadomienia. Metoda <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> jest zazwyczaj wywoływana, gdy właściwość jest ustawiona lub z procedury obsługi zdarzeń. <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A> Można na przykład wywołać metodę i przekazać <xref:System.Windows.Forms.AccessibleEvents> wartość `Hide` z poziomu programu obsługi zdarzeń dla <xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.AccessibleObject> jak utworzyć formant wykresu z obsługą ułatwień dostępu przy użyciu klas i <xref:System.Windows.Forms.Control.ControlAccessibleObject> , aby uwidocznić dostępne informacje. Kontrolka umieszcza dwie krzywe wraz z legendą. Klasa, która pochodzi od `ControlAccessibleObject` <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> , jest używana w metodzie, aby zapewnić niestandardowe informacje dostępne dla formantu wykresu. `ChartControlAccessibleObject` Ponieważ legenda wykresu nie jest rzeczywistą <xref:System.Windows.Forms.Control> kontrolką, ale zamiast tego jest rysowana przez formant wykresu, nie zawiera żadnych wbudowanych informacji. Z tego `ChartControlAccessibleObject` powodu Klasa <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> przesłania metodę w celu zwrócenia `CurveLegendAccessibleObject` , która reprezentuje dostępne informacje dla każdej części legendy. Gdy aplikacja obsługująca dostęp będzie korzystać z tego formantu, formant może udostępnić wymagane informacje.  
  
 Ten fragment kodu ilustruje wywoływanie <xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A> metody. Zobacz Przegląd <xref:System.Windows.Forms.AccessibleObject> klasy, aby uzyskać pełny przykład kodu.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="objectID" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="childID" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="accEvent">W <see cref="T:System.Windows.Forms.AccessibleEvents" /> celu powiadomienia aplikacji klienckich o ułatwieniach dostępu.</param>
        <param name="objectID">Identyfikator <see cref="T:System.Windows.Forms.AccessibleObject" />.</param>
        <param name="childID">Element podrzędny <see cref="T:System.Windows.Forms.Control" /> do powiadamiania o dostępnym zdarzeniu.</param>
        <summary>Powiadamia aplikacje klienckie dostępności określonego <see cref="T:System.Windows.Forms.AccessibleEvents" /> dla określonej kontrolki podrzędnej.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.AccessibleObject" /> Pobiera przypisany do kontrolki.</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleObject" /> Przypisane do kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby sterować wystąpieniem zwracanym z tej metody, Zastąp <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metodę.  
  
 Jeśli wartość <xref:System.Windows.Forms.AccessibleObject> nie jest obecnie przypisana do kontrolki, tworzone jest nowe wystąpienie jednego z nich.  
  
> [!NOTE]
>  Aby uzyskać lub ustawić <xref:System.Windows.Forms.Control.AccessibilityObject%2A> właściwość, należy dodać odwołanie `Accessibility` do zestawu zainstalowanego z[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
 Aby uzyskać więcej informacji na temat dostępnych obiektów, zobacz temat [Active Accessibility](https://msdn.microsoft.com/library/windows/desktop/dd373592.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślny opis akcji formantu, który ma być używany przez aplikacje klienckie z ułatwieniami dostępu.</summary>
        <value>Domyślny opis akcji formantu do użycia przez aplikacje klienckie ułatwień dostępu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A> Właściwość obiektu opisuje podstawową metodę manipulowania obiektu z punktu widzenia użytkownika. Ta właściwość powinna być czasownikiem lub krótką frazą czasownikową.  
  
> [!NOTE]
>  Nie wszystkie obiekty mają akcje domyślne, a niektóre obiekty mogą mieć domyślną akcję powiązaną z jej <xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType> właściwością, na przykład w następujących przykładach:  
  
-   Zaznaczone pole wyboru ma domyślną akcję "Usuń zaznaczenie" i wartość "Checked".  
  
-   Wyczyszczone pole wyboru ma domyślną akcję "Check" i wartość "unchecked".  
  
-   Przycisk oznaczony etykietą "Drukuj" ma domyślną akcję "naciśnij", bez wartości.  
  
-   Etykieta lub kontrolka pola tekstowego, która pokazuje "drukarka", nie ma żadnej akcji domyślnej, ale ma wartość "drukarka".  
  
 Aby uzyskać więcej informacji na temat właściwości dostępnych obiektów, zobacz [zawartość opisowych właściwości](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opis kontrolki używanej przez aplikacje klienckie dostępności.</summary>
        <value>Opis kontrolki używany przez aplikacje klienckie ułatwień dostępu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Właściwość obiektu zawiera tekstowy opis wyglądu obiektu. Opis służy głównie do zapewnienia większego kontekstu dla użytkowników niedowidzących lub niewidomych, ale może być również używany do wyszukiwania kontekstu lub innych aplikacji.  
  
 <xref:System.Windows.Forms.Control.AccessibleRole%2A> <xref:System.Windows.Forms.Control.AccessibleName%2A> <xref:System.Windows.Forms.AccessibleObject.Value%2A> <xref:System.Windows.Forms.AccessibleObject.State%2A>Właściwość jest wymagana, jeśli opis nie jest oczywisty lub jest nadmiarowy w oparciu o obiekt,, i właściwości. <xref:System.Windows.Forms.Control.AccessibleDescription%2A> Na przykład przycisk z "OK" nie potrzebuje dodatkowych informacji, ale przycisk, który pokazuje obraz Kaktus. Właściwości, i <xref:System.Windows.Forms.Control.AccessibleRole%2A> (ewentualnie <xref:System.Windows.Forms.AccessibleObject.Help%2A>) dla <xref:System.Windows.Forms.Control.AccessibleDescription%2A> przycisku Kaktus będą opisywać jego przeznaczenie, ale Właściwość przeniesie mniej materialne informacje, takie jak "przycisk, który pokazuje obraz Kaktus". <xref:System.Windows.Forms.Control.AccessibleName%2A>  
  
 Aby uzyskać więcej informacji na temat właściwości dostępnych obiektów, zobacz [zawartość opisowych właściwości](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.CheckBox> przykład kodu tworzy wystąpienie `MyCheckBox`klasy pochodnej, <xref:System.Windows.Forms.ButtonBase.Image%2A> przypisuje go <xref:System.Drawing.Image> do właściwości i ustawia <xref:System.Windows.Forms.Control.AccessibleName%2A> właściwości i <xref:System.Windows.Forms.Control.AccessibleDescription%2A> , ponieważ <xref:System.Windows.Forms.Control.Text%2A> Właściwość jest `null`. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.Form> nazwę. `MyForm`  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę kontrolki używanej przez aplikacje klienckie dostępności.</summary>
        <value>Nazwa formantu używanego przez aplikacje klienckie ułatwień dostępu. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość to etykieta, która zwięźle opisuje i identyfikuje obiekt w jego kontenerze, taki jak tekst <xref:System.Windows.Forms.Button>w <xref:System.Windows.Forms.MenuItem>, nazwa lub etykieta wyświetlana obok <xref:System.Windows.Forms.TextBox> formantu. <xref:System.Windows.Forms.Control.AccessibleName%2A>  
  
 Aby uzyskać więcej informacji na temat właściwości dostępnych obiektów, zobacz "[zawartość opisowych właściwości](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.CheckBox> przykład kodu tworzy wystąpienie `MyCheckBox`klasy pochodnej, <xref:System.Windows.Forms.ButtonBase.Image%2A> przypisuje go <xref:System.Drawing.Image> do właściwości i ustawia <xref:System.Windows.Forms.Control.AccessibleName%2A> właściwości i <xref:System.Windows.Forms.Control.AccessibleDescription%2A> , ponieważ <xref:System.Windows.Forms.Control.Text%2A> Właściwość jest `null`. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.Form> nazwę. `MyForm`  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dostępną rolę formantu</summary>
        <value>Jedna z wartości <see cref="T:System.Windows.Forms.AccessibleRole" />. Wartość domyślna to <see langword="Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleRole%2A> Właściwość opisuje rodzaj elementu interfejsu użytkownika, który jest obiektem. Jeśli nie można określić roli kontrolki, <xref:System.Windows.Forms.Control.AccessibleRole%2A> właściwość jest ustawiona na. `Default`  
  
 Aby uzyskać więcej informacji na temat właściwości dostępnych obiektów, zobacz [zawartość opisowych właściwości](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.AccessibleRole" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant może akceptować dane, które użytkownik przeciągnie na ten element.</summary>
        <value><see langword="true" />Jeśli operacje przeciągania i upuszczania są dozwolone w formancie; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikowi przeciąganie obrazu lub pliku obrazu do formularza i wyświetlanie go w momencie, gdy zostanie on usunięty. <xref:System.Windows.Forms.Control.OnPaint%2A> Metoda jest zastępowana, aby odświeżyć obraz za każdym razem, gdy formularz zostanie namalowany; w przeciwnym razie obraz będzie trwał dopiero po następnym odświeżeniu. Metoda <xref:System.Windows.Forms.Control.DragEnter> obsługi zdarzeń określa typ danych, które są przeciągane do formularza i zawiera odpowiednie informacje zwrotne. Metoda obsługi <xref:System.Drawing.Image> zdarzeń wyświetla obraz w formularzu, jeśli można go utworzyć na podstawie danych. <xref:System.Windows.Forms.Control.DragDrop> Ponieważ wartości <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.PointToClient%2A> i są współrzędnymi ekranu, w przykładzie używa się metody do konwertowania ich na współrzędne klienta. <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">w przypadku nieograniczonego dostępu do Schowka w celu <see langword="true" />ustawienia tej właściwości na wartość. Skojarzone Wyliczenie: <see langword="AllClipboard" /> wartość<see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.AllowDrop" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.AllowDrop" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.AllowDrop" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia krawędzie kontenera, z którym jest powiązany formant i określa, jak zmieniany jest rozmiar kontrolki z elementem nadrzędnym.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.AnchorStyles" /> wartości. Wartość domyślna to <see langword="Top" /> i <see langword="Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Windows.Forms.Control.Anchor%2A> , aby określić, w jaki sposób rozmiar kontrolki jest zmieniany automatycznie w miarę zmiany rozmiaru kontrolki nadrzędnej. Zakotwiczenie kontrolki do jej kontrolki nadrzędnej gwarantuje, że zakotwiczone krawędzie pozostaną w tym samym miejscu względem krawędzi kontrolki nadrzędnej, gdy zmieniany jest rozmiar kontrolki nadrzędnej.  
  
 Można zakotwiczyć formant do co najmniej jednej krawędzi jego kontenera. Na przykład, <xref:System.Windows.Forms.Form> Jeśli masz `Top` `Bottom` <xref:System.Windows.Forms.Button> Właściwośćo<xref:System.Windows.Forms.Control.Anchor%2A> właściwości, której wartość jest ustawiona na i, jestrozciągana,abyzachowaćzakotwiczonąodległośćdogórnejidolnejkrawędzi<xref:System.Windows.Forms.Button> <xref:System.Windows.Forms.Form>wmiaręwzrostu. <xref:System.Windows.Forms.Control.Height%2A> <xref:System.Windows.Forms.Form>  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> i <xref:System.Windows.Forms.Control.Dock%2A> właściwości wzajemnie się wykluczają. Można ustawić tylko jeden raz, a ostatni z nich ma pierwszeństwo.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.Windows.Forms.Button> do formularza i ustawia niektóre z jego wspólnych właściwości. Przykład zakotwiczy przycisk w prawym dolnym rogu formularza, aby zachować jego względną pozycję w miarę zmieniania rozmiaru formularza. Następnie ustawia <xref:System.Windows.Forms.Control.BackgroundImage%2A> i zmienia rozmiar przycisku na taki sam rozmiar <xref:System.Drawing.Image>jak. W tym przykładzie jest ustawiana `true` wartość <xref:System.Windows.Forms.Control.TabStop%2A> na i <xref:System.Windows.Forms.Control.TabIndex%2A> ustawia właściwość. Na koniec dodaje procedurę obsługi zdarzeń, aby obsłużyć <xref:System.Windows.Forms.Control.Click> zdarzenie przycisku. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.ImageList> nazwę. `imageList1`  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Anchor" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Anchor" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.Anchor" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokalizację, w <see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" />której jest przewijany formant.</summary>
        <value><see cref="T:System.Drawing.Point" /> Określanie lokalizacji przewijania. Wartość domyślna to lewy górny róg kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest odpowiednia dla tej klasy.</summary>
        <value><see langword="true" />Jeśli ta funkcja jest włączona; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To zdarzenie nie jest istotne dla tej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie nie jest istotne dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła formantu.</summary>
        <value><see cref="T:System.Drawing.Color" /> Reprezentujący kolor tła kontrolki. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość nie obsługuje przezroczystych kolorów, `SupportsTransparentBackColor` chyba że wartość <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> jest ustawiona na `true`. <xref:System.Windows.Forms.Control.BackColor%2A>  
  
 <xref:System.Windows.Forms.Control.BackColor%2A> Właściwość jest właściwością otoczenia. Właściwość otoczenia jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Aby uzyskać więcej informacji o właściwościach otoczenia, <xref:System.Windows.Forms.AmbientProperties> Zobacz klasy <xref:System.Windows.Forms.Control> lub przegląd klas.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Windows.Forms.Control.BackColor%2A> domyślne kolory systemowe i <xref:System.Windows.Forms.Control.ForeColor%2A> kontrolek. Kod cyklicznie wywołuje siebie, Jeśli kontrolka ma jakiekolwiek kontrolki podrzędne. Ten przykład kodu wymaga, aby miało <xref:System.Windows.Forms.Form> co najmniej jedną kontrolkę podrzędną; jednak kontrolka podrzędnego kontenera, taka <xref:System.Windows.Forms.Panel> jak <xref:System.Windows.Forms.GroupBox>lub, z własnymi kontrolkami podrzędnymi lepiej ilustruje rekursję.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.BackColor" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.BackColor" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.BackColor" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.BackColor" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.BackColor%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obraz tła wyświetlany w kontrolce.</summary>
        <value><see cref="T:System.Drawing.Image" /> Reprezentuje obraz, który ma być wyświetlany w tle formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Użyj właściwości <xref:System.Windows.Forms.Control.BackgroundImage%2A> , aby umieścić obraz graficzny na kontrolce.  
  
> [!NOTE]
>  Obrazy z kolorami przezroczystymi lub przezroczystymi nie są obsługiwane przez Windows Forms formanty jako obrazy w tle.  
>   
>  Ta właściwość nie jest obsługiwana w kontrolkach podrzędnych <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> , których `true`właściwość jest.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.Windows.Forms.Button> do formularza i ustawia niektóre z jego wspólnych właściwości. Przykład zakotwiczy przycisk w prawym dolnym rogu formularza, aby zachować jego względną pozycję w miarę zmieniania rozmiaru formularza. Następnie ustawia <xref:System.Windows.Forms.Control.BackgroundImage%2A> i zmienia rozmiar przycisku na taki sam rozmiar <xref:System.Drawing.Image>jak. W tym przykładzie jest ustawiana `true` wartość <xref:System.Windows.Forms.Control.TabStop%2A> na i <xref:System.Windows.Forms.Control.TabIndex%2A> ustawia właściwość. Na koniec dodaje procedurę obsługi zdarzeń, aby obsłużyć <xref:System.Windows.Forms.Control.Click> zdarzenie przycisku. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.ImageList> nazwę. `imageList1`  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.BackgroundImage%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia układ obrazu tła zgodnie z definicją w <see cref="T:System.Windows.Forms.ImageLayout" /> wyliczeniu.</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> Jedna z wartości (<see cref="F:System.Windows.Forms.ImageLayout.Center" /> , <see cref="F:System.Windows.Forms.ImageLayout.None" />, <see cref="F:System.Windows.Forms.ImageLayout.Stretch" />, <see cref="F:System.Windows.Forms.ImageLayout.Tile" />lub ).<see cref="F:System.Windows.Forms.ImageLayout.Zoom" /> <see cref="F:System.Windows.Forms.ImageLayout.Tile" />jest wartością domyślną.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> Użyj właściwości, aby określić położenie i zachowanie obrazu, który został umieszczony na kontrolce. <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>obowiązuje tylko wtedy, <xref:System.Windows.Forms.Control.BackgroundImage%2A> gdy właściwość jest ustawiona.  
  
 Możesz zwiększyć wydajność dla dużych obrazów, jeśli ustawisz <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> coś innego niż. <xref:System.Windows.Forms.ImageLayout.Tile>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Określona wartość wyliczenia nie istnieje.</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest wywoływane, jeśli <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> właściwość zmienia się programowo lub przez interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje delegata asynchronicznie w wątku, w którym został utworzony uchwyt bazowy formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegat metody, która nie przyjmuje żadnych parametrów.</param>
        <summary>Wykonuje określony delegat asynchronicznie w wątku, w którym utworzono uchwyt podstawowy formantu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje wynik<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany asynchronicznie i ta metoda wraca natychmiast. Można wywołać tę metodę z dowolnego wątku, nawet wątek, który jest właścicielem uchwytu formantu. Jeśli dojście kontrolki jeszcze nie istnieje, ta metoda przeszukuje łańcuch nadrzędny kontrolki do momentu znalezienia kontrolki lub formularza, który ma uchwyt okna. Jeśli nie można znaleźć odpowiedniego dojścia, <xref:System.Windows.Forms.Control.BeginInvoke%2A> program zgłosi wyjątek. Wyjątki w ramach metody delegata są uznawane za niezalewkowane i wysyłane do programu obsługi wyjątków niepułapki aplikacji.  
  
 Można wywołać <xref:System.Windows.Forms.Control.EndInvoke%2A> , aby pobrać wartość zwracaną z delegata, jeśli niezbędnych, ale nie jest to wymagane. <xref:System.Windows.Forms.Control.EndInvoke%2A>program zostanie zablokowany do momentu pobrania wartości zwracanej.  
  
> [!NOTE]
>  Większość metod na formancie można wywołać tylko z wątku, w którym formant został utworzony. Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu. Metody Invoke zawsze wywołują swoje wywołania zwrotne w wątku formantu.  
  
> [!NOTE]
>  Wyjątek może być zgłaszany, jeśli wątek, który powinien przetworzyć komunikat, nie jest już aktywny.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.Control.BeginInvoke%2A> metody.  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć odpowiedniego uchwytu okna.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat metody, która pobiera parametry o tej samej liczbie i typie, które znajdują się w <paramref name="args" /> parametrze.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do danej metody. Może to być <see langword="null" /> brak argumentów.</param>
        <summary>Wykonuje określony delegat asynchronicznie z określonymi argumentami w wątku, w którym utworzono uchwyt podstawowy formantu.</summary>
        <returns><see cref="T:System.IAsyncResult" /> Reprezentuje wynik<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> operacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegat jest wywoływany asynchronicznie i ta metoda wraca natychmiast. Można wywołać tę metodę z dowolnego wątku, nawet wątek, który jest właścicielem uchwytu formantu. Jeśli dojście kontrolki jeszcze nie istnieje, ta metoda przeszukuje łańcuch nadrzędny kontrolki do momentu znalezienia kontrolki lub formularza, który ma uchwyt okna. Jeśli nie można znaleźć odpowiedniego dojścia, <xref:System.Windows.Forms.Control.BeginInvoke%2A> program zgłosi wyjątek. Wyjątki w ramach metody delegata są uznawane za niezalewkowane i wysyłane do programu obsługi wyjątków niepułapki aplikacji.  
  
 Można wywołać <xref:System.Windows.Forms.Control.EndInvoke%2A> , aby pobrać wartość zwracaną z delegata, jeśli niezbędnych, ale nie jest to wymagane. <xref:System.Windows.Forms.Control.EndInvoke%2A>program zostanie zablokowany do momentu pobrania wartości zwracanej.  
  
> [!NOTE]
>  Większość metod na formancie można wywołać tylko z wątku, w którym formant został utworzony. Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu. Metody Invoke zawsze wywołują swoje wywołania zwrotne w wątku formantu.  
  
> [!NOTE]
>  Wyjątek może być zgłaszany, jeśli wątek, który powinien przetworzyć komunikat, nie jest już aktywny.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.Control.BeginInvoke%2A> metody.  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można znaleźć odpowiedniego uchwytu okna.</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Forms.BindingContext" /> dla kontrolki.</summary>
        <value>A <see cref="T:System.Windows.Forms.BindingContext" /> dla kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A służy do zwrócenia pojedynczej <xref:System.Windows.Forms.BindingManagerBase> dla <xref:System.Windows.Forms.Control>wszystkich kontrolek powiązanych z danymi zawartych w. <xref:System.Windows.Forms.Control> <xref:System.Windows.Forms.BindingContext> <xref:System.Windows.Forms.BindingManagerBase> Utrzymuje wszystkie kontrolki, które są powiązane z tym samym źródłem danych. Na przykład ustawienie <xref:System.Windows.Forms.BindingManagerBase.Position%2A> właściwości <xref:System.Windows.Forms.BindingManagerBase> określa element elementu na liście podstawowej, do którego mają wskazywać wszystkie kontrolki powiązane z danymi.  
  
 Aby uzyskać więcej informacji na temat tworzenia <xref:System.Windows.Forms.BindingContext> nowego i przypisywania <xref:System.Windows.Forms.Control.BindingContext%2A> go do właściwości, <xref:System.Windows.Forms.BindingContext.%23ctor%2A>Zobacz.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy cztery <xref:System.Windows.Forms.Binding> obiekty <xref:System.Windows.Forms.DateTimePicker> , aby powiązać pięć formantów, a i cztery <xref:System.Windows.Forms.TextBox> kontrolki z kilkoma źródłami danych. Jest następnie używany do <xref:System.Windows.Forms.BindingManagerBase> uzyskania dla każdego źródła danych. <xref:System.Windows.Forms.BindingContext>  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.BindingContext" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.BindingContext" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.BindingContext" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="T:System.Windows.Forms.BindingContext" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby dodać nowy <xref:System.Windows.Forms.BindingContext> element <xref:System.Windows.Forms.Control> do <xref:System.Windows.Forms.Control.BindingContext%2A> właściwości, zobacz <xref:System.Windows.Forms.BindingContext.%23ctor%2A> Konstruktor.  
  
 To zdarzenie jest zgłaszane, gdy <xref:System.Windows.Forms.Control.BindingContext%2A> zmiana właściwości zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.EventHandler> delegata <xref:System.Windows.Forms.Control.BindingContextChanged> do zdarzenia <xref:System.Windows.Forms.TextBox> kontrolki.  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odległość (w pikselach) między dolną krawędzią kontrolki a górną krawędzią obszaru klienckiego kontenera.</summary>
        <value><see cref="T:System.Int32" /> Reprezentujący odległość (w pikselach) między dolną krawędzią kontrolki a górną krawędzią obszaru klienckiego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość tej właściwości jest równa sumie <xref:System.Windows.Forms.Control.Top%2A> wartości właściwości <xref:System.Windows.Forms.Control.Height%2A> i wartości właściwości.  
  
 <xref:System.Windows.Forms.Control.Bottom%2A> Właściwość jest właściwością tylko do odczytu. Tę wartość właściwości można <xref:System.Windows.Forms.Control.Top%2A> manipulować przez zmianę wartości właściwości lub <xref:System.Windows.Forms.Control.Height%2A> wywoływanie <xref:System.Windows.Forms.Control.SetBounds%2A>metod, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>, lub <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> .  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Bottom%2A> właściwości, aby zdefiniować dolny limit <xref:System.Windows.Forms.TextBox> kontrolki względem obszaru klienckiego kontenera.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar i lokalizację formantu, w tym jego elementy nieklienckie, w pikselach względem kontrolki nadrzędnej.</summary>
        <value><see cref="T:System.Drawing.Rectangle" /> W pikselach względem kontrolki nadrzędnej reprezentującej rozmiar i lokalizację kontrolki, w tym jej elementów niebędących klientami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Granice kontrolki obejmują elementy nieklienckie, takie jak paski przewijania, obramowania, paski tytułu i menu. Metoda jest wywoływana w celu <xref:System.Windows.Forms.Control.Bounds%2A> ustawienia właściwości. <xref:System.Windows.Forms.Control.SetBoundsCore%2A> Właściwość nie jest zawsze zmieniana przez jej `set` metodę <xref:System.Windows.Forms.Control.SetBoundsCore%2A> , dlatego należy zastąpić metodę, aby <xref:System.Windows.Forms.Control.Bounds%2A> upewnić się, że kod jest wykonywany, gdy właściwość jest ustawiona. <xref:System.Windows.Forms.Control.Bounds%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi formant na przód z kolejnością z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka jest przenoszona na przód od osi z. Jeśli formant jest elementem podrzędnym innej kontrolki, formant podrzędny jest przenoszony na przód od osi z. <xref:System.Windows.Forms.Control.BringToFront%2A>Program nie tworzy kontrolki najwyższego poziomu i nie zgłasza <xref:System.Windows.Forms.Control.Paint> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu zapewnia, że <xref:System.Windows.Forms.Label> jest widoczny przez <xref:System.Windows.Forms.Control.BringToFront%2A> wywołanie metody. Ten przykład wymaga, <xref:System.Windows.Forms.Form> aby mieć <xref:System.Windows.Forms.Panel> z nazwą `panel1`i <xref:System.Windows.Forms.Label> nazwą `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="P:System.Windows.Forms.Control.ImeMode" /> właściwość może być ustawiona na wartość aktywną, aby włączyć obsługę edytora IME.</summary>
        <value><see langword="true" />we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne mogą przesłonić tę właściwość `false` w celu zwrócenia, jeśli edytor IME nie jest obsługiwany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy formant może odbierać fokus.</summary>
        <value><see langword="true" />Jeśli formant może odbierać fokus; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby formant otrzymywał fokus wprowadzania, formant musi mieć przypisaną dojście, a <xref:System.Windows.Forms.Control.Visible%2A> właściwości i <xref:System.Windows.Forms.Control.Enabled%2A> `true` muszą jednocześnie być ustawione dla kontrolki i wszystkich jej formantów nadrzędnych, a kontrolka musi być formularzem lub najbardziej zewnętrzny element nadrzędny kontrolki musi być formularzem.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia fokus na określony <xref:System.Windows.Forms.Control>, jeśli może odebrać fokus.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy zdarzenia mogą być wywoływane na formancie.</summary>
        <value><see langword="true" />Jeśli formant jest hostowany jako Kontrolka ActiveX, której zdarzenia nie są zamrożone; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli formant jest hostowany jako Kontrolka ActiveX, ta właściwość zwróci `false` wartość, jeśli Kontrolka ActiveX ma zamrożone zdarzenia.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy można wybrać kontrolkę.</summary>
        <value><see langword="true" />Jeśli kontrolka może być zaznaczona; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `true` , `Selectable` Jeśli wartość <xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType> jest ustawiona na `true`, jest zawarta w innym formancie, sama kontrolka jest widoczna i włączona, a wszystkie kontrolki nadrzędne są widoczne i włączone.  
  
 Kontrolki Windows Forms na poniższej liście nie są wybierane i zwracają wartość `false` <xref:System.Windows.Forms.Control.CanSelect%2A> właściwości. Kontrolki pochodne od tych formantów również nie są wybierane.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Jeśli w formancie nie ma żadnego linku)  
  
   
  
## Examples  
 Poniższy przykład kodu wybiera określony <xref:System.Windows.Forms.Control>, jeśli jest wybrany.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kontrolka przechwytuje mysz.</summary>
        <value><see langword="true" />Jeśli formant przechwycił mysz; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy kontrolka przechwytuje mysz, otrzymuje wskaźnik myszy, niezależnie od tego, czy kursor znajduje się w jego granicach. Mysz jest zwykle przechwytywana tylko podczas operacji przeciągania.  
  
 Tylko okno pierwszego planu może przechwycić mysz. Gdy okno tła podejmie próbę wykonania tej czynności, w oknie są odbierane komunikaty tylko dla zdarzeń myszy, które wystąpiły, gdy kursor myszy znajduje się w widocznej części okna. Ponadto, nawet jeśli okno programu na pierwszym planie przechwytuje mysz, użytkownik może nadal klikać inne okna, umieszczając je na pierwszym planie.  
  
 Gdy wskaźnik myszy zostanie przechwycony, klawisze skrótów nie powinny funkcjonować.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.Capture%2A> właściwość. Aby uruchomić ten przykład, wklej następujący kod w postaci zawierającej <xref:System.Windows.Forms.Label> nazwane Label1 i dwie <xref:System.Windows.Forms.ListBox> kontrolki o nazwie ListBox1 i ListBox2. Upewnij się, że <xref:System.Windows.Forms.Control.MouseDown> zdarzenie formularza i kontrolek jest skojarzone z metodą w tym przykładzie.  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby ustawić tę wartość właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kontrolka powoduje wykonanie walidacji w dowolnych kontrolkach, które wymagają walidacji po odebraniu fokusu.</summary>
        <value><see langword="true" />Jeśli kontrolka powoduje, że Walidacja jest przeprowadzana na wszelkich kontrolkach wymagających walidacji po odebraniu fokusu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
 Wartość właściwości jest zwykle ustawiona na `false` dla kontrolek, takich jak przycisk Pomoc. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.TextBox> pochodnej i weryfikuje adres e-mail wprowadzony przez użytkownika. Jeśli adres e-mail nie jest w formacie standardowym (zawierającym "@" and "."), weryfikacja nie powiedzie się <xref:System.Windows.Forms.ErrorProvider> , zostanie wyświetlona ikona, a zdarzenie zostanie anulowane. Jeden z przycisków w formularzu ma swoją <xref:System.Windows.Forms.Control.CausesValidation%2A> Właściwość ustawioną na. `false` Kliknięcie lub ustawienie fokusu tego przycisku nie powoduje wyzwolenia walidacji. Ten przykład wymaga <xref:System.Windows.Forms.TextBox> <xref:System.Windows.Forms.ErrorProvider> , aby w formularzu został utworzony formant, <xref:System.Windows.Forms.Button> kontrolka i a.  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.CausesValidation" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.CausesValidation%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniają się wskazówki dotyczące interfejsu użytkownika (UI) fokusa czy klawiatury.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.ChangeUICues> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.ChangeUICues> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy przechwytywać wywołania niewłaściwego wątku, które uzyskują <see cref="P:System.Windows.Forms.Control.Handle" /> dostęp do właściwości kontrolki, gdy aplikacja jest debugowana.</summary>
        <value><see langword="true" />Jeśli zostaną przechwycone wywołania niewłaściwego wątku; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wątek inny niż tworzony wątek kontrolki próbuje uzyskać dostęp do jednej z metod lub właściwości tej kontrolki, często prowadzi to do nieprzewidzianych wyników. Typowym nieprawidłowym działaniem wątku jest wywołanie niewłaściwego wątku, które uzyskuje <xref:System.Windows.Forms.Control.Handle%2A> dostęp do właściwości kontrolki. Ustaw <xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A>, aby możnabyłołatwiejznajdowaćidiagnozowaćtodziałaniewątku.`true`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy formant zostanie kliknięty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Click> Zdarzenie<xref:System.EventArgs> przekazuje do programu obsługi zdarzeń, więc wskazuje, że wystąpiło kliknięcie. Jeśli potrzebujesz bardziej szczegółowych informacji o myszy (przycisku, liczby kliknięć, rotacji kółka lub lokalizacji), użyj <xref:System.Windows.Forms.Control.MouseClick> zdarzenia. <xref:System.Windows.Forms.Control.MouseClick> Jednak zdarzenie nie zostanie wywołane, jeśli kliknięcie jest powodowane przez akcję inną niż ta, na przykład naciśnięcie klawisza ENTER.  
  
 Dwukrotnie kliknięcie konfiguruje się w ustawieniach myszy w systemie operacyjnym użytkownika. Użytkownik może ustawić czas między kliknięciami przycisku myszy, który powinien być uważany za dwukrotne kliknięcie, a nie dwoma kliknięciami. <xref:System.Windows.Forms.Control.Click> Zdarzenie jest wywoływane za każdym razem, gdy formant zostanie kliknięty dwukrotnie. Na przykład jeśli masz programy obsługi zdarzeń <xref:System.Windows.Forms.Control.Click> dla <xref:System.Windows.Forms.Control.Click> zdarzeń <xref:System.Windows.Forms.Form>i <xref:System.Windows.Forms.Control.DoubleClick> , zdarzenia i <xref:System.Windows.Forms.Control.DoubleClick> są wywoływane, gdy formularz zostanie dwukrotnie kliknięty i obie metody są wywoływane. Po dwukrotnym kliknięciu kontrolki, która nie obsługuje <xref:System.Windows.Forms.Control.DoubleClick> zdarzenia <xref:System.Windows.Forms.Control.Click> , zdarzenie może być wywoływane dwa razy.  
  
 Należy ustawić `StandardClick` <xref:System.Windows.Forms.ControlStyles> wartość na`true` dla tego zdarzenia, które ma zostać wywołane.  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
## <a name="notes-to-inheritors"></a>Uwagi dotyczące dziedziczenia

Dziedziczenie ze standardowego formantu `StandardClick` Windows Forms i zmiana wartości <xref:System.Windows.Forms.ControlStyles> lub `StandardDoubleClick` w celu `true` może spowodować nieoczekiwane zachowanie lub <xref:System.Windows.Forms.Control.Click> nie wpływać na nie, jeśli formant nie obsługuje lub <xref:System.Windows.Forms.Control.DoubleClick>zdarzenia.
  
Poniższa tabela zawiera listę Windows Forms formantów i zdarzenia (<xref:System.Windows.Forms.Control.Click> lub <xref:System.Windows.Forms.Control.DoubleClick>), które są wywoływane w odpowiedzi na określoną akcję myszy.

| formant | Kliknięcie lewym przyciskiem myszy | Lewy dwukrotne kliknięcie | Prawy przycisk myszy | Prawy przycisk dwukrotnego kliknięcia | Środkowy przycisk myszy | Środkowy prawy przycisk myszy | XButton1 kliknięcie myszy | XButton1 dwukrotne kliknięcie myszy | XButton2 kliknięcie myszy | XButton2 dwukrotne kliknięcie myszy | 
| ------- | ---------------- | ----------------------- | ----------------- | ------------------------ | ------------------ | ------------------------- | -------------------- | --------------------------- | -------------------- | --------------------------- |
| <xref:System.Windows.Forms.MonthCalendar>, <xref:System.Windows.Forms.DateTimePicker>, <xref:System.Windows.Forms.HScrollBar>, <xref:System.Windows.Forms.VScrollBar> | brak | brak | brak | brak | brak | brak | brak | brak | brak | brak |
| <xref:System.Windows.Forms.Button>, <xref:System.Windows.Forms.CheckBox>, <xref:System.Windows.Forms.RichTextBox>, <xref:System.Windows.Forms.RadioButton> | Kliknij | Kliknij przycisk, kliknij | brak | brak | brak | brak | brak | brak | brak | brak |
| <xref:System.Windows.Forms.ListBox>, <xref:System.Windows.Forms.CheckedListBox>, <xref:System.Windows.Forms.ComboBox> | Kliknij | Kliknij, kliknięcie | brak | brak | brak | brak | brak | brak | brak | brak |
| <xref:System.Windows.Forms.TextBox>, <xref:System.Windows.Forms.DomainUpDown>, <xref:System.Windows.Forms.NumericUpDown> | Kliknij | Kliknij, kliknięcie | brak | brak | brak | brak | brak | brak | brak | brak |
| \* <xref:System.Windows.Forms.TreeView>, \* <xref:System.Windows.Forms.ListView> | Kliknij | Kliknij, kliknięcie | Kliknij | Kliknij, kliknięcie | brak | brak | brak | brak | brak | brak |
| <xref:System.Windows.Forms.ProgressBar>, <xref:System.Windows.Forms.TrackBar> | Kliknij | Kliknij przycisk, kliknij | Kliknij | Kliknij przycisk, kliknij | Kliknij | Kliknij przycisk, kliknij | Kliknij | Kliknij przycisk, kliknij | Kliknij | Kliknij przycisk, kliknij |
| <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.LinkLabel>, <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.PictureBox>, <xref:System.Windows.Forms.Splitter>, <xref:System.Windows.Forms.StatusBar>, <xref:System.Windows.Forms.ToolBar>, <xref:System.Windows.Forms.TabPage>, \*\* <xref:System.Windows.Forms.TabControl> | Kliknij | Kliknij, kliknięcie | Kliknij | Kliknij, kliknięcie | Kliknij | Kliknij, kliknięcie | Kliknij | Kliknij, kliknięcie | Kliknij | Kliknij, kliknięcie |

\*Wskaźnik myszy musi znajdować się nad obiektem podrzędnym <xref:System.Windows.Forms.ListViewItem>(<xref:System.Windows.Forms.TreeNode> lub).  
  
 * * <xref:System.Windows.Forms.TabControl> Musi mieć co najmniej jeden <xref:System.Windows.Forms.TabPage> w swojej <xref:System.Windows.Forms.TabControl.TabPages> kolekcji.

## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.Control.Click> zdarzenie w programie obsługi zdarzeń.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prostokąt, który reprezentuje obszar klienta kontrolki.</summary>
        <value><see cref="T:System.Drawing.Rectangle" /> Reprezentuje obszar klienta kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar klienta kontrolki jest granicami kontrolki minus elementy nieklienckie, takie jak paski przewijania, obramowania, paski tytułu i menu.  
  
 Ze względu na to, że współrzędne klienta są względne w lewym górnym rogu obszaru klienckiego kontrolki, współrzędne lewego górnego rogu prostokąta zwróconego przez tę właściwość są (0, 0). Ta właściwość umożliwia uzyskanie rozmiaru i współrzędnych obszaru klienta kontrolki dla zadań, takich jak rysowanie na powierzchni formantu.  
  
 Aby uzyskać więcej informacji na temat rysowania na kontrolkach, zobacz [renderowanie kontrolki Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia Autoprzewijanie formularza, zmienia rozmiar formularza i gwarantuje, że przycisk pozostaje widoczny po zmianie rozmiaru formularza. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.Form> nazwę <xref:System.Windows.Forms.Button> z nazwą `button2` .  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość i szerokość obszaru klienckiego kontrolki.</summary>
        <value><see cref="T:System.Drawing.Size" /> Reprezentujący wymiary obszaru klienckiego kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar klienta kontrolki jest granicami kontrolki minus elementy nieklienckie, takie jak paski przewijania, obramowania, paski tytułu i menu. Metoda jest wywoływana w celu <xref:System.Windows.Forms.Control.ClientSize%2A> ustawienia właściwości. <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> Właściwość nie jest zawsze zmieniana przez jej `set` metodę <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> , dlatego należy zastąpić metodę, aby <xref:System.Windows.Forms.Control.ClientSize%2A> upewnić się, że kod jest wykonywany, gdy właściwość jest ustawiona. <xref:System.Windows.Forms.Control.ClientSize%2A>  
  
 Właściwości <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType> i<xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType> reprezentują szerokość i wysokość obszaru klienckiego kontrolki. Ta właściwość umożliwia uzyskanie rozmiaru obszaru klienckiego kontrolki dla zadań, takich jak rysowanie na powierzchni formantu.  
  
 Aby uzyskać więcej informacji na temat rysowania na kontrolkach, zobacz [renderowanie kontrolki Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).  
  
> [!NOTE]
>  Nie można powiązać ustawień aplikacji z tą właściwością. Aby uzyskać więcej informacji na temat ustawień aplikacji, zobacz [Omówienie ustawień aplikacji](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia rozmiar określonej kontrolki, aby formant pomieścił swój sformatowany tekst. Sformatowany tekst to <xref:System.Windows.Forms.Control.Text%2A> właściwość z przypisanym <xref:System.Windows.Forms.Control.Font%2A> do tekstu kontrolką. Metoda w tym przykładzie `textPadding` ma również parametr, który reprezentuje uzupełnienie, które ma zostać zastosowane do wszystkich krawędzi formantu. `AutoSizeControl` Aby dopełnienie było równe, Wyrównaj tekst <xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType> do wartości, Jeśli kontrolka ją obsługuje.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.ClientSize" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.ClientSizeChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.ClientSizeChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę firmy lub twórcę aplikacji zawierającej formant.</summary>
        <value>Nazwa firmy lub twórca aplikacji zawierającej formant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CompanyName%2A> Właściwość jest właściwością tylko do odczytu. Aby zmienić wartość tej właściwości, należy ustawić <xref:System.Reflection.AssemblyCompanyAttribute.Company%2A> wartość <xref:System.Reflection.AssemblyCompanyAttribute>właściwości. Poniższy wiersz C# kodu ustawia <xref:System.Windows.Forms.Control.CompanyName%2A> właściwość.  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  Zdecydowanie zaleca się podanie nazwy firmy, nazwy produktu i wersji produktu dla aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla informacje o aplikacji w <xref:System.Windows.Forms.Label> tabeli zawartej <xref:System.Windows.Forms.Form>przez. Ten przykład wymaga <xref:System.Windows.Forms.Control.CompanyName%2A> <xref:System.Windows.Forms.Control.ProductName%2A> , abyzostałyustawione.<xref:System.Windows.Forms.Control.ProductVersion%2A>  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl"><see cref="T:System.Windows.Forms.Control" /> Do obliczenia.</param>
        <summary>Pobiera wartość wskazującą, czy określony formant jest elementem podrzędnym formantu.</summary>
        <returns><see langword="true" />Jeśli określony formant jest elementem podrzędnym formantu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu zapewnia, że <xref:System.Windows.Forms.Label> jest widoczny przez <xref:System.Windows.Forms.Control.BringToFront%2A> wywołanie metody. Ten przykład wymaga, <xref:System.Windows.Forms.Form> aby mieć <xref:System.Windows.Forms.Panel> z nazwą `panel1`i <xref:System.Windows.Forms.Label> nazwą `label1`.  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka lub jeden z jej formantów podrzędnych aktualnie ma fokus wprowadzania.</summary>
        <value><see langword="true" />Jeśli kontrolka lub jeden z jego formantów podrzędnych aktualnie ma fokus wprowadzania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą tej właściwości można określić, czy kontrolka lub dowolne kontrolki zawarte w niej mają fokus wprowadzania. Aby określić, czy kontrolka ma fokus, niezależnie od tego, czy którykolwiek z formantów podrzędnych ma fokus, użyj <xref:System.Windows.Forms.Control.Focused%2A> właściwości. Aby nadać formantowi fokus wprowadzania, użyj <xref:System.Windows.Forms.Control.Focus%2A> metod lub. <xref:System.Windows.Forms.Control.Select%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia menu skrótów skojarzone z kontrolką.</summary>
        <value><see cref="T:System.Windows.Forms.ContextMenu" /> Reprezentujący menu skrótów skojarzone z kontrolką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj menu skrótów, aby udostępnić użytkownikom opcje menu, po kliknięciu kontrolki prawym przyciskiem myszy.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Windows.Forms.ContextMenu> przypisane do a <xref:System.Windows.Forms.TreeView> po kliknięciu prawym przyciskiem myszy i zwolnienia. Ten kod wymaga, aby było <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.TreeView> na nim. Jest również wymagane, <xref:System.Windows.Forms.TreeView> aby element <xref:System.Windows.Forms.ContextMenu> miał przypisaną do jego <xref:System.Windows.Forms.Control.ContextMenu%2A> właściwości.  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.ContextMenu" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.ContextMenu" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.ContextMenu" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.ContextMenu" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.ContextMenu%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla komunikat, gdy nastąpi zmiana w menu skrótów.  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia <see cref="T:System.Windows.Forms.ContextMenuStrip" /> skojarzoną z tą kontrolką.</summary>
        <value>Dla tego formantu lub <see langword="null" /> Jeśli <see cref="T:System.Windows.Forms.ContextMenuStrip" />nie ma. <see cref="T:System.Windows.Forms.ContextMenuStrip" /> Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli element <xref:System.Windows.Forms.ContextMenu> został również przypisany do kontrolki <xref:System.Windows.Forms.ContextMenu> , ma pierwszeństwo przed <xref:System.Windows.Forms.ContextMenuStrip>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.ToolStripMenuItem> <xref:System.Windows.Forms.ContextMenuStrip>jak dodać trzy obiekty do. Dodatkowo ilustruje to ustawienie <xref:System.Windows.Forms.Control.ContextMenuStrip%2A> właściwości formularza.  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.ContextMenuStripChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.ContextMenuStripChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po dodaniu nowej kontrolki do <see cref="T:System.Windows.Forms.Control.ControlCollection" />elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.ControlAdded> do dodawania kontrolki do formularza i wyświetlania nazwy dodanej kontrolki <xref:System.Windows.Forms.MessageBox>w.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy formant zostanie usunięty z <see cref="T:System.Windows.Forms.Control.ControlCollection" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.ControlRemoved> do usuwania kontrolki z formularza i wyświetlania nazwy usuniętej kontrolki <xref:System.Windows.Forms.MessageBox>w.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję kontrolek znajdujących się w kontrolce.</summary>
        <value><see cref="T:System.Windows.Forms.Control.ControlCollection" /> Reprezentujący kolekcję kontrolek znajdujących się w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Windows.Forms.Control> może działać jako element nadrzędny w kolekcji formantów. Na <xref:System.Windows.Forms.Form>przykład po dodaniu kilku kontrolek do, każda z formantów jest członkiem <xref:System.Windows.Forms.Control.ControlCollection> przypisanej do <xref:System.Windows.Forms.Control.Controls%2A> właściwości formularza, która jest pochodną <xref:System.Windows.Forms.Control> klasy.  
  
 Można manipulować kontrolkami w <xref:System.Windows.Forms.Control.ControlCollection> przypisanych <xref:System.Windows.Forms.Control.Controls%2A> do właściwości przy użyciu metod dostępnych w <xref:System.Windows.Forms.Control.ControlCollection> klasie.  
  
 Podczas dodawania kilku kontrolek do kontrolki nadrzędnej zaleca się wywołanie <xref:System.Windows.Forms.Control.SuspendLayout%2A> metody przed zainicjowaniem kontrolek do dodania. Po dodaniu kontrolek do kontrolki nadrzędnej, <xref:System.Windows.Forms.Control.ResumeLayout%2A> Wywołaj metodę. Wykonanie tej czynności spowoduje zwiększenie wydajności aplikacji z wieloma kontrolkami.  
  
 <xref:System.Windows.Forms.Control.Controls%2A> Użyj właściwości, aby wykonać iterację wszystkich kontrolek formularza, w tym formantów zagnieżdżonych. <xref:System.Windows.Forms.Control.GetNextControl%2A> Użyj metody, aby pobrać poprzedni lub następny formant podrzędny w kolejności tabulacji. Użyj właściwości <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> , aby uzyskać lub ustawić aktywną kontrolę nad kontrolką kontenera.  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa <xref:System.Windows.Forms.Control> <xref:System.Windows.Forms.Control.ControlCollection> z klasy <xref:System.Windows.Forms.Panel> pochodnej, jeśli jest członkiem kolekcji. Przykład <xref:System.Windows.Forms.Panel>wymaga utworzenia <xref:System.Windows.Forms.Button>, a i co <xref:System.Windows.Forms.Form>najmniej jednej <xref:System.Windows.Forms.RadioButton> kontrolki na. Kontrolki są dodawane <xref:System.Windows.Forms.Panel> do kontrolki, a <xref:System.Windows.Forms.Panel> kontrolka dodana do <xref:System.Windows.Forms.Form>. <xref:System.Windows.Forms.RadioButton> Gdy przycisk zostanie kliknięty, przycisk radiowy o `removeButton` nazwie jest usuwany <xref:System.Windows.Forms.Control.ControlCollection>z.  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowy obiekt ułatwień dostępu dla kontrolki.</summary>
        <returns>Nowy <see cref="T:System.Windows.Forms.AccessibleObject" /> dla kontrolki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> Metoda nie zostanie jawnie wywołana, zostanie wywołana, <xref:System.Windows.Forms.Control.AccessibilityObject%2A> gdy zostanie przywoływana właściwość.  
  
> [!NOTE]
>  Aby uzyskać lub ustawić <xref:System.Windows.Forms.Control.AccessibilityObject%2A> właściwość, należy dodać odwołanie `Accessibility` do zestawu zainstalowanego z [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.AccessibleObject> jak utworzyć formant wykresu z obsługą ułatwień dostępu przy użyciu klas i <xref:System.Windows.Forms.Control.ControlAccessibleObject> , aby uwidocznić dostępne informacje. Kontrolka umieszcza dwie krzywe wraz z legendą. Klasa, która pochodzi od `ControlAccessibleObject` <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> , jest używana w metodzie, aby zapewnić niestandardowe informacje dostępne dla formantu wykresu. `ChartControlAccessibleObject` Ponieważ legenda wykresu nie jest rzeczywistą <xref:System.Windows.Forms.Control> kontrolką, ale zamiast tego jest rysowana przez formant wykresu, nie zawiera żadnych wbudowanych informacji. Z tego `ChartControlAccessibleObject` powodu Klasa <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> przesłania metodę w celu zwrócenia `CurveLegendAccessibleObject` , która reprezentuje dostępne informacje dla każdej części legendy. Gdy aplikacja obsługująca dostęp będzie korzystać z tego formantu, formant może udostępnić wymagane informacje.  
  
 Ten fragment kodu ilustruje zastępowanie <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metody. Zobacz Przegląd <xref:System.Windows.Forms.AccessibleObject> klasy, aby uzyskać pełny przykład kodu.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> w klasie pochodnej nie należy wywoływać <see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" /> metody klasy bazowej.</para></block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza utworzenie widocznej kontrolki, włącznie z tworzeniem uchwytu i wszystkimi widocznymi kontrolkami podrzędnymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateControl%2A> Metoda wymusza utworzenie dojścia dla kontrolki i jej formantów podrzędnych. Ta metoda jest używana, gdy potrzebna jest obsługa natychmiast po manipulowaniu formantem lub jego elementami podrzędnymi. po prostu wywołanie konstruktora kontrolki nie powoduje utworzenia <xref:System.Windows.Forms.Control.Handle%2A>.  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A>nie tworzy uchwytu sterującego, jeśli <xref:System.Windows.Forms.Control.Visible%2A> właściwość kontrolki ma `false`wartość. Możesz wywołać <xref:System.Windows.Forms.Control.CreateHandle%2A> metodę lub <xref:System.Windows.Forms.Control.Handle%2A> uzyskać dostęp do właściwości, aby utworzyć uchwyt kontrolki niezależnie od widoczności kontrolki, ale w tym przypadku nie są tworzone żadne uchwyty okna dla elementów podrzędnych formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie kolekcji formantów dla kontrolki.</summary>
        <returns>Nowe wystąpienie <see cref="T:System.Windows.Forms.Control.ControlCollection" /> przypisane do kontrolki.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Wersja klasy bazowej tej metody nie powinna być wywoływana przez klasę pochodną.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy formant został utworzony.</summary>
        <value><see langword="true" />Jeśli formant został utworzony; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca `true` , jeśli został <xref:System.Windows.Forms.Control> pomyślnie utworzony, mimo że dojście kontrolki mogło nie zostać utworzone lub ponownie utworzone. <xref:System.Windows.Forms.Control.Created%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Drawing.Graphics" /> Tworzy dla kontrolki.</summary>
        <returns><see cref="T:System.Drawing.Graphics" /> Dla kontrolki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt, który można pobrać <xref:System.Windows.Forms.Control.CreateGraphics%2A> za pomocą metody, nie powinien zwykle być zachowywany po przetworzeniu bieżącego komunikatu systemu Windows, ponieważ wszystkie elementy rysowane przy użyciu tego obiektu zostaną wymazane przy użyciu następnego komunikatu WM_PAINT. <xref:System.Drawing.Graphics> W <xref:System.Drawing.Graphics> związku z tym nie można buforować obiektu do ponownego użycia, z wyjątkiem używania metod <xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>niewizualnych, takich jak. Zamiast tego należy wywoływać <xref:System.Windows.Forms.Control.CreateGraphics%2A> za każdym razem, gdy chcesz użyć obiektu <xref:System.Drawing.Graphics> , a następnie wywołać <xref:System.Drawing.Graphics.Dispose%2A> po zakończeniu korzystania z niego. Aby uzyskać więcej informacji na temat komunikatów systemu <xref:System.Windows.Forms.Control.WndProc%2A>Windows, zobacz.  
  
 Zgodnie z projektem <xref:System.Windows.Forms.Control.CreateGraphics%2A> program ustawia własność na wątek wywołujący i kończy się niepowodzeniem, jeśli jest wywoływany w innych wątkach.  
  
> [!NOTE]
>  Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia rozmiar określonej kontrolki, aby formant pomieścił swój sformatowany tekst. Sformatowany tekst to <xref:System.Windows.Forms.Control.Text%2A> właściwość z przypisanym <xref:System.Windows.Forms.Control.Font%2A> do tekstu kontrolką. Metoda w tym przykładzie `textPadding` ma również parametr, który reprezentuje uzupełnienie, które ma zostać zastosowane do wszystkich krawędzi formantu. `AutoSizeControl` Aby dopełnienie było równe, Wyrównaj tekst `MiddleCenter` do <xref:System.Drawing.ContentAlignment?displayProperty=nameWithType> wartości, Jeśli kontrolka ją obsługuje.  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby można było wywołać tę metodę w bezpiecznym podsystemie Windows. Skojarzone Wyliczenie: <see langword="SafeSubWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy uchwyt dla kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj nie należy wywoływać <xref:System.Windows.Forms.Control.CreateHandle%2A> metody bezpośrednio. Preferowaną metodą jest wywołanie <xref:System.Windows.Forms.Control.CreateControl%2A> metody, która wymusza tworzenie uchwytu dla kontrolki i jej formantów podrzędnych podczas tworzenia formantu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Obiekt jest w stanie zlikwidowanym.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.CreateHandle" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.CreateHandle" /> metodę klasy bazowej, aby upewnić się, że dojście zostanie utworzone.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymagane parametry tworzenia podczas tworzenia uchwytu sterującego.</summary>
        <value>A <see cref="T:System.Windows.Forms.CreateParams" /> , który zawiera wymagane parametry tworzenia podczas tworzenia uchwytu do kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateParams%2A> Właściwość nie powinna być zastępowana i używana do dostosowywania właściwości formantu pochodnego. <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>Właściwości, takie jak, <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>i <xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType> powinny być ustawiane przez odpowiadające im właściwości w kontrolce, <xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>takie <xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType> jak <xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>, i. Rozszerzenie <xref:System.Windows.Forms.CreateParams> powinno być rozszerzane tylko wtedy, gdy jest zawijana standardowa Klasa formantów systemu Windows lub w celu ustawienia stylów niedostarczonych przez przestrzeń nazw Windows Forms. Aby uzyskać więcej informacji na temat tworzenia parametrów kontroli, `CreateWindow` zobacz `CreateWindowEx` sekcję and oraz [](https://msdn.microsoft.com/library/windows/desktop/ms632603.aspx) dokumentację dotyczącą struktury.  
  
   
  
## Examples  
 Poniższy przykład kodu rozszerza <xref:System.Windows.Forms.Control.CreateParams%2A> Właściwość <xref:System.Windows.Forms.Button> klasy pochodnej. Właściwość zostanie zmieniona, co spowoduje <xref:System.Drawing.Icon> wyświetlenie przycisku zamiast <xref:System.Drawing.Image>. <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType> Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.Button> klasy.  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego do wywołania niezarządzanego kodu podczas pobierania wartości właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.CreateParams" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.CreateParams" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje.</para></block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kursor wyświetlany, gdy wskaźnik myszy znajduje się nad kontrolką.</summary>
        <value>Reprezentuje <see cref="T:System.Windows.Forms.Cursor" /> kursor, który ma być wyświetlany, gdy wskaźnik myszy znajduje się nad kontrolką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor> Przypisz<xref:System.Windows.Forms.Control.Cursor%2A> do właściwości kontrolki, aby zmienić kursor wyświetlany, gdy wskaźnik myszy znajduje się nad kontrolką. Aby tymczasowo zmienić wskaźnik myszy dla wszystkich kontrolek w aplikacji, <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> ustaw właściwość. Zazwyczaj <xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType> właściwość jest ustawiana na kursor oczekiwania podczas <xref:System.Windows.Forms.ComboBox> wypełniania lub zapisywania lub ładowania pliku.  
  
 <xref:System.Windows.Forms.Control.Cursor%2A> Właściwość jest właściwością otoczenia. Właściwość otoczenia jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Aby uzyskać więcej informacji o właściwościach otoczenia, <xref:System.Windows.Forms.AmbientProperties> Zobacz klasy <xref:System.Windows.Forms.Control> lub przegląd klas.  
  
   
  
## Examples  
 Poniższy przykład kodu pełni <xref:System.Windows.Forms.ComboBox> z dostępnymi dyskami logicznymi użytkownika. Przykład ustawia również <xref:System.Windows.Forms.Cursor> właściwość pola kombi, aby kursor był wyświetlany <xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType> , gdy wskaźnik myszy znajduje się nad przyciskiem rozwijanym. Ten kod wymaga, aby było <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.ComboBox> na nim.  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla bezpiecznego systemu Windows, aby ustawić tę wartość właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Cursor" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Cursor" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu <see langword="get" /> metod <see cref="P:System.Windows.Forms.Control.Cursor" /> i <see langword="set" /> właściwości. w razie potrzeby można przesłonić tylko jedną z nich.</para></block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.Cursor" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Cursor%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zmianę kursora myszy przy użyciu <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> właściwości <xref:System.Windows.Forms.Cursor> , klasy i <xref:System.Windows.Forms.Cursors> klasy. Przykład tworzy formularz, który zawiera <xref:System.Windows.Forms.ComboBox> kontrolkę <xref:System.Windows.Forms.Panel> , kontrolkę i <xref:System.Windows.Forms.ListView> kontrolkę. Zawiera wszystkie kursory dostarczone <xref:System.Windows.Forms.Cursors> przez klasę. <xref:System.Windows.Forms.ComboBox> Gdy użytkownik wybierze kursor myszy w <xref:System.Windows.Forms.ComboBox> <xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType> , właściwość jest ustawiona na zaznaczony kursor, co spowoduje <xref:System.Windows.Forms.Panel>zaktualizowanie kursora dla elementu. Aktualizacja <xref:System.Windows.Forms.ListView> jest aktualizowana za każdym <xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType> razem, gdy wystąpi zdarzenie.  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera powiązania danych dla kontrolki.</summary>
        <value>A <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> , który <see cref="T:System.Windows.Forms.Binding" /> zawiera obiekty dla formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, aby uzyskać dostęp <xref:System.Windows.Forms.ControlBindingsCollection>do. <xref:System.Windows.Forms.Control.DataBindings%2A> Po dodaniu <xref:System.Windows.Forms.Binding> obiektów do kolekcji można powiązać każdą właściwość kontrolki z właściwością obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Windows.Forms.Binding> dodaje obiekty <xref:System.Windows.Forms.ControlBindingsCollection> do pięciu kontrolek <xref:System.Windows.Forms.DateTimePicker> : cztery <xref:System.Windows.Forms.TextBox> kontrolki i kontrolkę. Dostęp do niego można uzyskać <xref:System.Windows.Forms.Control.DataBindings%2A> za pomocą właściwości <xref:System.Windows.Forms.Control> klasy. <xref:System.Windows.Forms.ControlBindingsCollection>  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny kolor tła kontrolki.</summary>
        <value>Domyślne tło <see cref="T:System.Drawing.Color" /> formantu. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to domyślna <xref:System.Windows.Forms.Control.BackColor%2A> wartość właściwości ogólnego formantu najwyższego poziomu. Klasy pochodne mogą mieć różne wartości domyślne.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, jak używać elementów członkowskich, <xref:System.Windows.Forms.Control.DefaultFont%2A>i. <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Aby uruchomić przykład, wklej następujący kod w postaci zawierającej <xref:System.Windows.Forms.ListBox> nazwę ListBox1. Wywołaj <xref:System.Windows.Forms.Form.Load> metodę w konstruktorze lub metodzie obsługi zdarzeń. `Populate_ListBox`  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślny kursor dla kontrolki.</summary>
        <value>Obiekt typu <see cref="T:System.Windows.Forms.Cursor" /> reprezentujący bieżący kursor domyślny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przesłoń <xref:System.Windows.Forms.Control.DefaultCursor%2A> , aby skonfigurować domyślny kursor dla kontrolki. Jest to wydajniejsze niż Ustawianie kursora w konstruktorze kontrolki i zapewnia automatyczną obsługę niektórych funkcji projektanta związanych z kursorem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślną czcionkę kontrolki.</summary>
        <value>Wartość domyślna <see cref="T:System.Drawing.Font" /> formantu. Zwracana wartość będzie się różnić w zależności od lokalnego ustawienia kulturowego systemu operacyjnego użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli opisano wartość zwracaną przez <xref:System.Windows.Forms.Control.DefaultFont%2A> program w zależności od systemu operacyjnego i kultury lokalnej.  
  
|System/i lub kultura|Font|  
|----------------------------|----------|  
|Windows NT 4x, wersja japońska|MS UI Gothic, 9 punkt.|  
|Okna Arabskie|Tahoma, 8 punktów.|  
|Inny system operacyjny/kultura|Program MS Shell okno czcionki logicznej, zwykle w sieci San Serif 8.|  
  
 Okno programu MS Shell mapuje na czcionkę ustawioną w rejestrze systemowym.  
  
 Jeśli poprzednie czcionki nie są zainstalowane, domyślną czcionką jest Tahoma, 8 punktów. Jeśli Tahoma, 8 punktów, nie jest zainstalowane, <xref:System.Windows.Forms.Control.DefaultFont%2A> zwraca wartość właściwości <xref:System.Drawing.FontFamily.GenericSansSerif%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, jak używać elementów członkowskich, <xref:System.Windows.Forms.Control.DefaultFont%2A>i. <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Aby uruchomić przykład, wklej następujący kod w postaci zawierającej <xref:System.Windows.Forms.ListBox> nazwę ListBox1. Wywołaj <xref:System.Windows.Forms.Form.Load> metodę w konstruktorze lub metodzie obsługi zdarzeń. `Populate_ListBox`  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Na komputerze klienckim nie są zainstalowane domyślne czcionki ani regionalne alternatywne czcionki.</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny kolor pierwszego planu formantu.</summary>
        <value>Domyślny pierwszy plan <see cref="T:System.Drawing.Color" /> kontrolki. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.ControlText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to domyślna <xref:System.Windows.Forms.Control.ForeColor%2A> wartość właściwości kontrolki niemacierzystej. Klasy pochodne mogą mieć różne wartości domyślne.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.DefaultBackColor%2A>, jak używać elementów członkowskich, <xref:System.Windows.Forms.Control.DefaultFont%2A>i. <xref:System.Windows.Forms.Control.DefaultForeColor%2A> Aby uruchomić przykład, wklej następujący kod w postaci zawierającej <xref:System.Windows.Forms.ListBox> nazwę ListBox1. Wywołaj <xref:System.Windows.Forms.Form.Load> metodę w konstruktorze lub metodzie obsługi zdarzeń. `Populate_ListBox`  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny tryb edytora IME (Input Method Editor) obsługiwany przez formant.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.ImeMode" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Edytor IME (Input Method Editor) to program umożliwiający użytkownikom wprowadzanie złożonych znaków i symboli, takich jak japońskie znaki kanji, przy użyciu standardowej klawiatury.  
  
 Zgodnie z implementacją <xref:System.Windows.Forms.Control> w klasie, ta właściwość zawsze <xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType> zwraca wartość. <xref:System.Windows.Forms.ImeMode.Inherit> Wartość określa, że tryb IME jest Dziedziczony z kontrolki nadrzędnej.  
  
   
  
## Examples  
 Poniższy przykład kodu przesłania <xref:System.Windows.Forms.Control.DefaultImeMode%2A> właściwość, aby wyłączyć Edytor metody wejściowej.  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje.</para></block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera miejsce (w pikselach), które jest określone domyślnie między kontrolkami.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> Reprezentujący domyślny obszar między kontrolkami.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość i wysokość (w pikselach), która jest określana jako domyślny maksymalny rozmiar kontrolki.</summary>
        <value><see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" /> Reprezentujący rozmiar kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera długość i wysokość (w pikselach), która jest określana jako domyślny minimalny rozmiar kontrolki.</summary>
        <value><see cref="T:System.Drawing.Size" /> Reprezentujący rozmiar kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wewnętrzne odstępy (w pikselach) zawartości kontrolki.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> Reprezentuje wewnętrzne odstępy zawartości kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny rozmiar kontrolki.</summary>
        <value>Wartość domyślna <see cref="T:System.Drawing.Size" /> formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DefaultSize%2A> Właściwość<xref:System.Drawing.Size> reprezentuje kontrolkę, gdy zostanie ona początkowo utworzona. Można dostosować rozmiar kontrolki, ustawiając jej <xref:System.Windows.Forms.Control.Size%2A> wartość właściwości.  
  
> [!NOTE]
>  Aby zachować lepszą wydajność, nie ustawiaj <xref:System.Drawing.Size> kontrolki w konstruktorze. Preferowaną metodą jest zastąpienie <xref:System.Windows.Forms.Control.DefaultSize%2A> właściwości.  
  
> [!NOTE]
>  W systemach Windows Server 2003 rozmiar a <xref:System.Windows.Forms.Form> jest ograniczony przez maksymalną szerokość i wysokość pikseli na monitorze.  
  
   
  
## Examples  
 Poniższy przykład kodu przesłania <xref:System.Windows.Forms.Control.DefaultSize%2A> Właściwość i wprowadza domyślny rozmiar kwadratu w postaci 500 pikseli.  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.DefaultSize" /> właściwości w klasie pochodnej zaleca się <see cref="T:System.Drawing.Size" /> zwrócenie z żądanymi wymiarami, a nie przesłonięcie całej implementacji.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc :  -&gt; unit&#xA;override this.DefWndProc :  -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">System Windows <see cref="T:System.Windows.Forms.Message" /> do przetworzenia.</param>
        <summary>Wysyła określony komunikat do domyślnej procedury okna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji o przetwarzaniu komunikatów systemu Windows, zobacz [Funkcja WindowProc](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Niszczy dojście skojarzone z kontrolką.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> metodę klasy bazowej, aby upewnić się, że dojście zostało zniszczone.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość DPI dla urządzenia wyświetlającego, w którym formant jest aktualnie wyświetlany.</summary>
        <value>Wartość DPI urządzenia wyświetlającego.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera prostokąt, który reprezentuje obszar wyświetlania formantu.</summary>
        <value><see cref="T:System.Drawing.Rectangle" /> Reprezentuje obszar wyświetlania formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DisplayRectangle%2A> Właściwość zwraca prostokąt klienta obszaru wyświetlania formantu. Dla podstawowej klasy kontrolki jest równa prostokątowi klienta. Jednak formanty dziedziczenia mogą chcieć zmienić, jeśli ich obszar klienta różni się od obszaru wyświetlania. Prostokąt wyświetlania jest najmniejszy <xref:System.Drawing.Rectangle> , który zawiera kontrolkę i służy do układania kontrolek.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. Alternatywnie należy podać wszystkie implementacje.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Windows.Forms.Control" /> program i jego formanty podrzędne i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose()` <xref:System.Object.Finalize%2A> i metodę.`Dispose()` wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Windows.Forms.Control> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy klasa bazowa <see cref="T:System.Windows.Forms.Control" /> jest w trakcie usuwania.</summary>
        <value><see langword="true" />Jeśli klasa bazowa <see cref="T:System.Windows.Forms.Control" /> jest w trakcie usuwania; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość zwraca `true`, Klasa bazowa <xref:System.Windows.Forms.Control> jest w trakcie usuwania. Po usunięciu kontrolki nie można już odwoływać się do niej jako prawidłowy formant systemu Windows. Mimo że wystąpienie formantu jest usunięte, nadal jest przechowywane w pamięci, dopóki nie zostanie usunięte z pamięci przez wyrzucanie elementów bezużytecznych. Gdy kontrolka jest usuwana, nie można wywołać jej <xref:System.Windows.Forms.Control.RecreateHandle%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, które obramowania kontrolki są zadokowane do kontrolki nadrzędnej i określa, jak zmieniany jest rozmiar kontrolki z elementem nadrzędnym.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.DockStyle" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.DockStyle.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Windows.Forms.Control.Dock%2A> , aby określić, w jaki sposób rozmiar kontrolki jest zmieniany automatycznie w miarę zmiany rozmiaru kontrolki nadrzędnej. Na przykład ustawienie <xref:System.Windows.Forms.Control.Dock%2A> <xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType> powoduje, że formant będzie wyrównany do lewej krawędzi jego kontrolki nadrzędnej i zmienić rozmiar w miarę zmieniania rozmiaru kontrolki nadrzędnej. Kontrolki są zadokowane w ich kolejności Z, która jest wizualną warstwą formantów w formularzu, wzdłuż osi Z (głębokości) formularza.  
  
 Formant można zadokować do jednej krawędzi jego kontenera nadrzędnego lub można zadokować do wszystkich krawędzi i wypełnić kontener nadrzędny.  
  
 <xref:System.Windows.Forms.Control.Margin%2A> Ustawienie właściwości na zadokowanym formancie nie ma wpływu na odległość formantu od krawędzi jego kontenera.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A> i <xref:System.Windows.Forms.Control.Dock%2A> właściwości wzajemnie się wykluczają. Można ustawić tylko jeden raz, a ostatni z nich ma pierwszeństwo.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.GroupBox> i ustawia niektóre z jego wspólnych właściwości. Przykład tworzy i ustawia <xref:System.Windows.Forms.TextBox> jego <xref:System.Windows.Forms.Control.Location%2A> wartość w polu grupy. Następnie ustawia <xref:System.Windows.Forms.Control.Text%2A> właściwość pola Grupa i zadokuje pole grupy w górnej części formularza. W końcu wyłącza pole grupy przez ustawienie <xref:System.Windows.Forms.Control.Enabled%2A> właściwości na `false`, która powoduje wyłączenie wszystkich kontrolek zawartych w polu grupy.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.DockStyle" /> wartości.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Dock" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Dock" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu <see langword="get" /> metod <see cref="P:System.Windows.Forms.Control.Dock" /> i <see langword="set" /> właściwości. w razie potrzeby można przesłonić tylko jedną z nich.</para></block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.Dock" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Dock%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">Dane do przeciągnięcia.</param>
        <param name="allowedEffects">Jedna z <see cref="T:System.Windows.Forms.DragDropEffects" /> wartości.</param>
        <summary>Rozpoczyna operację przeciągania i upuszczania.</summary>
        <returns>Wartość z <see cref="T:System.Windows.Forms.DragDropEffects" /> wyliczenia, która reprezentuje efekt końcowy, który został wykonany podczas operacji przeciągania i upuszczania.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `allowedEffects` Parametr określa, które operacje przeciągania mogą wystąpić. Jeśli operacja przeciągania musi współpracować z aplikacjami w innym procesie, dane powinny być podstawową klasą zarządzaną (<xref:System.String>, <xref:System.Drawing.Bitmap>, lub <xref:System.Drawing.Imaging.Metafile>) lub obiektem, który implementuje <xref:System.Runtime.Serialization.ISerializable> lub <xref:System.Windows.Forms.IDataObject>.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dziękiczemumożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda przechwytuje wszystkie wyjątki i ponownie generuje tylko następujące wyjątki zabezpieczeń i krytycznych:  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje operację przeciągania i upuszczania między dwoma <xref:System.Windows.Forms.ListBox> kontrolkami. Przykład wywołuje metodę, <xref:System.Windows.Forms.Control.DoDragDrop%2A> gdy rozpocznie się akcja przeciągania. Akcja przeciągania rozpocznie się, jeśli mysz została przeniesiona <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> więcej niż z lokalizacji myszy <xref:System.Windows.Forms.Control.MouseDown> podczas zdarzenia. Metoda jest używana do określenia indeksu elementu do przeciągnięcia `MouseDown` podczas zdarzenia. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>  
  
 W przykładzie pokazano również, jak używać niestandardowych kursorów dla operacji przeciągania i upuszczania. Przykład wymaga, aby dwa pliki kursora, `3dwarro.cur` i `3dwno.cur`, istniały w katalogu aplikacji, dla niestandardowych kursorów przeciąganie i nieupuszczanie. Kursory niestandardowe będą używane, jeśli `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> jest zaznaczone. Kursory niestandardowe są ustawiane w <xref:System.Windows.Forms.Control.GiveFeedback> programie obsługi zdarzeń.  
  
 Stan klawiatury jest obliczany w <xref:System.Windows.Forms.Control.DragOver> procedurze obsługi zdarzeń po prawej stronie `ListBox`, aby określić, jaka operacja przeciągania będzie oparta na stanie klawiszy Shift, Ctrl, Alt lub Ctrl + Alt. Lokalizacja w `ListBox` miejscu, w którym występuje porzucanie, jest również określana `DragOver` podczas zdarzenia. Jeśli dane do `String`porzucenia nie są, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> wówczas jest ustawiona na wartość `None` w <xref:System.Windows.Forms.DragDropEffects>. Na koniec stan upuszczenia jest wyświetlany w `DropLocationLabel`. <xref:System.Windows.Forms.Label>  
  
 Dane do porzucenia po prawej stronie `ListBox` są określane <xref:System.Windows.Forms.Control.DragDrop> w programie obsługi zdarzeń, a `String` wartość `ListBox`jest dodawana w odpowiednim miejscu w. Jeśli operacja przeciągania przesunie się poza granice formularza, operacja przeciągania i upuszczania zostanie anulowana w <xref:System.Windows.Forms.Control.QueryContinueDrag> obsłudze zdarzeń.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 Poniższy przykład kodu pokazuje, jak używać wyliczenia, <xref:System.Windows.Forms.DragDropEffects> aby określić, jak dane powinny być transferowane między kontrolkami wykorzystywanymi w operacji przeciągania i upuszczania. Ten przykład wymaga, aby formularz zawierał <xref:System.Windows.Forms.RichTextBox> kontrolkę <xref:System.Windows.Forms.ListBox> i kontrolkę oraz że <xref:System.Windows.Forms.ListBox> formant jest wypełniony listą prawidłowych nazw plików. Gdy użytkownik przeciągnie nazwę pliku na <xref:System.Windows.Forms.RichTextBox> kontrolkę, <xref:System.Windows.Forms.Control.DragEnter> zdarzenie kontrolki jest wywoływane. W ramach procedury obsługi <xref:System.Windows.Forms.DragEventArgs.Effect%2A> zdarzeń Właściwość <xref:System.Windows.Forms.DragEventArgs> jest inicjowana do <xref:System.Windows.Forms.DragDropEffects> wskazywania, że dane, do których odwołuje się ścieżka pliku, powinny być skopiowane do <xref:System.Windows.Forms.RichTextBox> kontrolki.  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy ten formant powinien ponownie narysować powierzchnię przy użyciu pomocniczego buforu, aby zmniejszyć lub zapobiec migotaniu.</summary>
        <value><see langword="true" />Jeśli powierzchnia kontrolki powinna być narysowana przy użyciu podwójnego buforowania; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Buforowane grafiki mogą zmniejszyć lub wyeliminować migotanie spowodowane przez stopniowe przerysowanie części wyświetlanej powierzchni. Grafiki buforowane wymagają, aby zaktualizowane dane graficzne były najpierw zapisywane w buforze. Dane w buforze grafiki są następnie szybko zapisywane w celu wyświetlenia pamięci. Stosunkowo szybki przełącznik wyświetlanej pamięci graficznej zwykle zmniejsza migotanie, które w przeciwnym razie może wystąpić.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A>nie jest właściwością do powiązania.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po dwukrotnym kliknięciu formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwukrotnie kliknięcie konfiguruje się w ustawieniach myszy w systemie operacyjnym użytkownika. Użytkownik może ustawić czas między kliknięciami przycisku myszy, który powinien być uważany za dwukrotne kliknięcie, a nie dwoma kliknięciami. <xref:System.Windows.Forms.Control.Click> Zdarzenie jest wywoływane za każdym razem, gdy formant zostanie kliknięty dwukrotnie. Na przykład jeśli masz programy obsługi zdarzeń <xref:System.Windows.Forms.Control.Click> dla <xref:System.Windows.Forms.Control.Click> zdarzeń <xref:System.Windows.Forms.Form>i <xref:System.Windows.Forms.Control.DoubleClick> , zdarzenia i <xref:System.Windows.Forms.Control.DoubleClick> są wywoływane, gdy formularz zostanie dwukrotnie kliknięty i obie metody są wywoływane. Po dwukrotnym kliknięciu kontrolki, która nie obsługuje <xref:System.Windows.Forms.Control.DoubleClick> zdarzenia <xref:System.Windows.Forms.Control.Click> , zdarzenie może być wywoływane dwa razy.  
  
 Należy ustawić `StandardDoubleClick` wartości `StandardClick` dlaidla`true` tego zdarzenia, które ma zostać wywołane. <xref:System.Windows.Forms.ControlStyles> Te wartości mogą być już ustawione na `true` , Jeśli dziedziczą z istniejących kontrolek Windows Forms.  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Windows.Forms.Control.DoubleClick> używa zdarzenia <xref:System.Windows.Forms.ListBox> do ładowania plików <xref:System.Windows.Forms.ListBox> tekstowych <xref:System.Windows.Forms.TextBox> wymienionych w kontrolce do formantu.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dziedziczenie ze standardowego formantu <see langword="StandardClick" /> Windows Forms i zmiana wartości <see cref="T:System.Windows.Forms.ControlStyles" /> lub <see langword="StandardDoubleClick" /> w celu <see langword="true" /> może spowodować nieoczekiwane zachowanie lub <see cref="E:System.Windows.Forms.Control.Click" /> nie wpływać na nie, jeśli formant nie obsługuje lub <see cref="E:System.Windows.Forms.Control.DoubleClick" />zdarzenia.  
  
Poniższa tabela zawiera listę Windows Forms formantów i zdarzenia (<see cref="E:System.Windows.Forms.Control.Click" /> lub <see cref="E:System.Windows.Forms.Control.DoubleClick" />), które są wywoływane w odpowiedzi na określoną akcję myszy.  
  
 <list type="table"><listheader><term> formant 
 </term><description> Kliknięcie lewym przyciskiem myszy 
 </description><description> Lewy dwukrotne kliknięcie 
 </description><description> Prawy przycisk myszy 
 </description><description> Prawy przycisk dwukrotnego kliknięcia 
 </description><description> Środkowy przycisk myszy 
 </description><description> Środkowy prawy przycisk myszy 
 </description><description> XButton1 kliknięcie myszy 
 </description><description> XButton1 dwukrotne kliknięcie myszy 
 </description><description> XButton2 kliknięcie myszy 
 </description><description> XButton2 dwukrotne kliknięcie myszy 
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />, 
 <see cref="T:System.Windows.Forms.DateTimePicker" />, 
 <see cref="T:System.Windows.Forms.RichTextBox" />, 
 <see cref="T:System.Windows.Forms.HScrollBar" />, 
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />, 
 <see cref="T:System.Windows.Forms.CheckBox" />, 
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />, 
 <see cref="T:System.Windows.Forms.CheckedListBox" />, 
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />, 
 <see cref="T:System.Windows.Forms.DomainUpDown" />, 
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />, 
\*<see cref="T:System.Windows.Forms.ListView" /></term><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description><description> brak 
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />, 
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description><description> Kliknij 
 </description><description> Kliknij przycisk, kliknij 
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />, 
 <see cref="T:System.Windows.Forms.DataGrid" />, 
 <see cref="T:System.Windows.Forms.Label" />, 
 <see cref="T:System.Windows.Forms.LinkLabel" />, 
 <see cref="T:System.Windows.Forms.Panel" />, 
 <see cref="T:System.Windows.Forms.GroupBox" />, 
 <see cref="T:System.Windows.Forms.PictureBox" />, 
 <see cref="T:System.Windows.Forms.Splitter" />, 
 <see cref="T:System.Windows.Forms.StatusBar" />, 
 <see cref="T:System.Windows.Forms.ToolBar" />, 
 <see cref="T:System.Windows.Forms.TabPage" />, 
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description><description> Kliknij 
 </description><description> Kliknij, kliknięcie 
 </description></item></list>  

 \*Wskaźnik myszy musi znajdować się nad obiektem podrzędnym <see cref="T:System.Windows.Forms.ListViewItem" />(<see cref="T:System.Windows.Forms.TreeNode" /> lub).  
  
* * <see cref="T:System.Windows.Forms.TabControl" /> Musi mieć co najmniej jeden <see cref="T:System.Windows.Forms.TabPage" /> w swojej <see cref="P:System.Windows.Forms.TabControl.TabPages" /> kolekcji.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy ustawienie DPI kontrolki zostanie zmienione programowo po zmianie wartości DPI jej kontrolki nadrzędnej lub formularza.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy ustawienie DPI kontrolki zostanie zmienione programowo przed wystąpieniem zdarzenia zmiany DPI dla jego kontrolki nadrzędnej lub formularza.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu operacji przeciągania i upuszczania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Windows.Forms.DragEventArgs.X%2A> <xref:System.Windows.Forms.DragEventArgs.Y%2A> i sąwWspółrzędneekranu,aniewspółrzędneklienta.<xref:System.Windows.Forms.DragEventArgs> Poniższy wiersz kodu wizualizacji C# konwertuje właściwości na klienta <xref:System.Drawing.Point>.  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  W wersjach wcześniejszych niż [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], jeśli <xref:System.Windows.Forms.UserControl> umieścisz zdarzenia with <xref:System.Windows.Forms.Control.DragEnter> i <xref:System.Windows.Forms.Control.DragDrop> <xref:System.Windows.Forms.UserControl> w formularzu systemu Windows i `DropDrop` przeciągasz i upuśćę coś w czasie projektowania, zdarzenia i `DropEnter` są niesienie. Jednak po zamknięciu i ponownym otwarciu rozwiązania <xref:System.Windows.Forms.Control.DragEnter> zdarzenia i <xref:System.Windows.Forms.Control.DragDrop> nie są ponownie zgłaszane.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.DragDrop> zdarzenia. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przeciągnięciu obiektu w granice formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragEnter> Zdarzenie jest zgłaszane, gdy użytkownik po raz pierwszy przeciągnie wskaźnik myszy nad formant podczas operacji przeciągania i upuszczania.  
  
> [!NOTE]
>  W wersjach wcześniejszych niż [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], jeśli <xref:System.Windows.Forms.UserControl> umieścisz zdarzenia with <xref:System.Windows.Forms.Control.DragEnter> i <xref:System.Windows.Forms.Control.DragDrop> <xref:System.Windows.Forms.UserControl> w formularzu systemu Windows i `DropDrop` przeciągasz i upuśćę coś w czasie projektowania, zdarzenia i `DropEnter` są niesienie. Jednak po zamknięciu i ponownym otwarciu rozwiązania <xref:System.Windows.Forms.Control.DragEnter> zdarzenia i <xref:System.Windows.Forms.Control.DragDrop> nie są ponownie zgłaszane.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dziękiczemumożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
    > [!NOTE]
    >  Właściwości <xref:System.Windows.Forms.DragEventArgs.X%2A> <xref:System.Windows.Forms.DragEventArgs.Y%2A> i sąwWspółrzędneekranu,aniewspółrzędneklienta.<xref:System.Windows.Forms.DragEventArgs> Poniższy wiersz kodu wizualizacji C# konwertuje właściwości na klienta <xref:System.Drawing.Point>.  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje operację przeciągania i upuszczania między dwoma <xref:System.Windows.Forms.ListBox> kontrolkami. Przykład wywołuje metodę, <xref:System.Windows.Forms.Control.DoDragDrop%2A> gdy rozpocznie się akcja przeciągania. Akcja przeciągania rozpocznie się, jeśli mysz została przeniesiona <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> więcej niż z lokalizacji myszy <xref:System.Windows.Forms.Control.MouseDown> podczas zdarzenia. Metoda jest używana do określenia indeksu elementu do przeciągnięcia `MouseDown` podczas zdarzenia. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>  
  
 W przykładzie pokazano również, jak używać niestandardowych kursorów dla operacji przeciągania i upuszczania. Przykład wymaga, aby dwa pliki kursora, `3dwarro.cur` i `3dwno.cur`, istniały w katalogu aplikacji, dla niestandardowych kursorów przeciąganie i nieupuszczanie. Kursory niestandardowe będą używane, jeśli `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> jest zaznaczone. Kursory niestandardowe są ustawiane w <xref:System.Windows.Forms.Control.GiveFeedback> programie obsługi zdarzeń.  
  
 Stan klawiatury jest obliczany w <xref:System.Windows.Forms.Control.DragOver> procedurze obsługi zdarzeń po prawej stronie `ListBox`, aby określić, jaka operacja przeciągania będzie oparta na stanie klawiszy Shift, Ctrl, Alt lub Ctrl + Alt. Lokalizacja w `ListBox` miejscu, w którym występuje porzucanie, jest również określana `DragOver` podczas zdarzenia. Jeśli dane do `String`porzucenia nie są, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> wówczas jest ustawiona na wartość `None` w <xref:System.Windows.Forms.DragDropEffects>. Na koniec stan upuszczenia jest wyświetlany w `DropLocationLabel`. <xref:System.Windows.Forms.Label>  
  
 Dane do porzucenia po prawej stronie `ListBox` są określane <xref:System.Windows.Forms.Control.DragDrop> w programie obsługi zdarzeń, a `String` wartość `ListBox`jest dodawana w odpowiednim miejscu w. Jeśli operacja przeciągania przesunie się poza granice formularza, operacja przeciągania i upuszczania zostanie anulowana w <xref:System.Windows.Forms.Control.QueryContinueDrag> obsłudze zdarzeń.  
  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.DragEnter> zdarzenia. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt zostanie przeciągnięty poza granice formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragLeave> Zdarzenie jest zgłaszane, gdy użytkownik przeciągnie kursor z kontrolki lub użytkownik anuluje bieżącą operację przeciągania i upuszczania.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dziękiczemumożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje operację przeciągania i upuszczania między dwoma <xref:System.Windows.Forms.ListBox> kontrolkami. Przykład wywołuje metodę, <xref:System.Windows.Forms.Control.DoDragDrop%2A> gdy rozpocznie się akcja przeciągania. Akcja przeciągania rozpocznie się, jeśli mysz została przeniesiona <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> więcej niż z lokalizacji myszy <xref:System.Windows.Forms.Control.MouseDown> podczas zdarzenia. Metoda jest używana do określenia indeksu elementu do przeciągnięcia `MouseDown` podczas zdarzenia. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>  
  
 W przykładzie pokazano również, jak używać niestandardowych kursorów dla operacji przeciągania i upuszczania. Przykład wymaga, aby dwa pliki kursora, `3dwarro.cur` i `3dwno.cur`, istniały w katalogu aplikacji, dla niestandardowych kursorów przeciąganie i nieupuszczanie. Kursory niestandardowe będą używane, jeśli `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> jest zaznaczone. Kursory niestandardowe są ustawiane w <xref:System.Windows.Forms.Control.GiveFeedback> programie obsługi zdarzeń.  
  
 Stan klawiatury jest obliczany w <xref:System.Windows.Forms.Control.DragOver> procedurze obsługi zdarzeń po prawej stronie `ListBox`, aby określić, jaka operacja przeciągania będzie oparta na stanie klawiszy Shift, Ctrl, Alt lub Ctrl + Alt. Lokalizacja w `ListBox` miejscu, w którym występuje porzucanie, jest również określana `DragOver` podczas zdarzenia. Jeśli dane do `String`porzucenia nie są, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> wówczas jest ustawiona na wartość `None` w <xref:System.Windows.Forms.DragDropEffects>. Na koniec stan upuszczenia jest wyświetlany w `DropLocationLabel`. <xref:System.Windows.Forms.Label>  
  
 Dane do porzucenia po prawej stronie `ListBox` są określane <xref:System.Windows.Forms.Control.DragDrop> w programie obsługi zdarzeń, a `String` wartość `ListBox`jest dodawana w odpowiednim miejscu w. Jeśli operacja przeciągania przesunie się poza granice formularza, operacja przeciągania i upuszczania zostanie anulowana w <xref:System.Windows.Forms.Control.QueryContinueDrag> obsłudze zdarzeń.  
  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.DragLeave> zdarzenia. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy obiekt zostanie przeciągnięty na granicach formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragOver> Zdarzenie jest zgłaszane, gdy wskaźnik myszy przesuwa się w granicach formantu podczas operacji przeciągania i upuszczania.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dlategomożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
    > [!NOTE]
    >  Właściwości <xref:System.Windows.Forms.DragEventArgs.X%2A> <xref:System.Windows.Forms.DragEventArgs.Y%2A> i sąwWspółrzędneekranu,aniewspółrzędneklienta.<xref:System.Windows.Forms.DragEventArgs> Następujący wiersz C# kodu konwertuje właściwości na klienta <xref:System.Drawing.Point>:  
    >   
    >  Point clientPoint = targetControl. PointToClient (nowy punkt (de. X, de. Y));  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje operację przeciągania i upuszczania między dwoma <xref:System.Windows.Forms.ListBox> kontrolkami. Przykład wywołuje metodę, <xref:System.Windows.Forms.Control.DoDragDrop%2A> gdy rozpocznie się akcja przeciągania. Akcja przeciągania rozpocznie się, jeśli mysz została przeniesiona <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> więcej niż z lokalizacji myszy <xref:System.Windows.Forms.Control.MouseDown> podczas zdarzenia. Metoda jest używana do określenia indeksu elementu do przeciągnięcia `MouseDown` podczas zdarzenia. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>  
  
 W przykładzie pokazano również, jak używać niestandardowych kursorów dla operacji przeciągania i upuszczania. Przykład wymaga, aby dwa pliki kursora, `3dwarro.cur` i `3dwno.cur`, istniały w katalogu aplikacji, dla niestandardowych kursorów przeciąganie i nieupuszczanie. Kursory niestandardowe będą używane, jeśli `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> jest zaznaczone. Kursory niestandardowe są ustawiane w <xref:System.Windows.Forms.Control.GiveFeedback> programie obsługi zdarzeń.  
  
 Stan klawiatury jest obliczany w <xref:System.Windows.Forms.Control.DragOver> procedurze obsługi zdarzeń po prawej stronie `ListBox`, aby określić, jaka operacja przeciągania będzie oparta na stanie klawiszy Shift, Ctrl, Alt lub Ctrl + Alt. Lokalizacja w `ListBox` miejscu, w którym występuje porzucanie, jest również określana `DragOver` podczas zdarzenia. Jeśli dane do `String`porzucenia nie są, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> wówczas jest ustawiona na wartość `None` w <xref:System.Windows.Forms.DragDropEffects>. Na koniec stan upuszczenia jest wyświetlany w `DropLocationLabel`. <xref:System.Windows.Forms.Label>  
  
 Dane do porzucenia po prawej stronie `ListBox` są określane <xref:System.Windows.Forms.Control.DragDrop> w programie obsługi zdarzeń, a `String` wartość `ListBox`jest dodawana w odpowiednim miejscu w. Jeśli operacja przeciągania przesunie się poza granice formularza, operacja przeciągania i upuszczania zostanie anulowana w <xref:System.Windows.Forms.Control.QueryContinueDrag> obsłudze zdarzeń.  
  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.DragOver> zdarzenia. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap">Mapa bitowa, na którą ma zostać narysowana.</param>
        <param name="targetBounds">Granice, w których jest renderowany formant.</param>
        <summary>Obsługuje renderowanie do określonej mapy bitowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> Metoda nie jest obsługiwana w przypadku formantów ActiveX. W <xref:System.Windows.Forms.Control.OnPrint%2A> razie potrzeby można zastąpić zdarzenie i zapewnić niestandardową logikę drukowania.  
  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> Metoda ma następujące ograniczenia:  
  
-   <xref:System.ArgumentException> Może zostać zgłoszony w przypadku dużych map bitowych. Maksymalny dozwolony rozmiar jest różny dla komputera.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>Program nie obsługuje `Ink` formantów dla systemu operacyjnego Windows XP Tablet PC Edition 2005.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>nie rysuje elementu <xref:System.Windows.Forms.TextBox> podrzędnego, <xref:System.Windows.Forms.Control.Visible%2A> Jeśli właściwość <xref:System.Windows.Forms.TextBox> jest ustawiona na `false`.  
  
-   Kontrolki wewnątrz kontenerów są renderowane w odwrotnej kolejności.  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A>nie jest w pełni funkcjonalny <xref:System.Windows.Forms.RichTextBox>dla; rysowany jest tylko obramowanie mapy bitowej.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant może reagować na interakcję użytkownika.</summary>
        <value><see langword="true" />Jeśli formant może odpowiedzieć na interakcję z użytkownikiem; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za pomocą <xref:System.Windows.Forms.Control.Enabled%2A> właściwości można włączać lub wyłączać kontrolki w czasie wykonywania. Można na przykład wyłączyć kontrolki, które nie mają zastosowania do bieżącego stanu aplikacji. Możesz również wyłączyć kontrolkę, aby ograniczyć jej użycie. Na przykład przycisk można wyłączyć, aby zapobiec kliknięciu go przez użytkownika. Jeśli kontrolka jest wyłączona, nie można jej wybrać.  
  
> [!IMPORTANT]
>  Ustawienie właściwości na `false` nie powoduje wyłączenia pola sterowania aplikacji lub uniemożliwienie przejęcie fokusu przez okno aplikacji. <xref:System.Windows.Forms.Control.Enabled%2A>  
  
 Gdy kontrolka kontenera ma ustawioną `false`Właściwość Enabled, wszystkie zawarte w niej kontrolki również są wyłączone. Na przykład, jeśli użytkownik kliknie dowolną kontrolkę znajdującą się w wyłączonej <xref:System.Windows.Forms.GroupBox> kontrolce, żadne zdarzenia nie są zgłaszane.  
  
> [!NOTE]
>  Gdy kontrolka przewijania jest wyłączona, paski przewijania również są wyłączone. Na przykład wyłączone wielowierszowe pole tekstowe nie można przewijać w celu wyświetlenia wszystkich wierszy tekstu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.GroupBox> i ustawia niektóre z jego wspólnych właściwości. Przykład tworzy i ustawia <xref:System.Windows.Forms.TextBox> jego <xref:System.Windows.Forms.Control.Location%2A> wartość w polu grupy. Następnie ustawia <xref:System.Windows.Forms.Control.Text%2A> właściwość pola Grupa i zadokuje pole grupy w górnej części formularza. W końcu wyłącza pole grupy przez ustawienie <xref:System.Windows.Forms.Control.Enabled%2A> właściwości na `false`, która powoduje wyłączenie wszystkich kontrolek zawartych w polu grupy.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.Control.Enabled" /> gdy wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Enabled%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa dwóch <xref:System.Windows.Forms.RadioButton> kontrolek do <xref:System.Windows.Forms.Control.EnabledChanged> zademonstrowania zdarzenia. Kliknięcie jednego przycisku zmienia wartość <xref:System.Windows.Forms.Control.Enabled%2A> właściwości drugiego przycisku na `false` i wyświetla <xref:System.Windows.Forms.MessageBox>.  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.EndInvoke(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Reprezentuje określoną operacją asynchroniczną wywołania zwracaną podczas wywoływania <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />. <see cref="T:System.IAsyncResult" /></param>
        <summary>Pobiera wartość zwracaną operacji asynchronicznej reprezentowanej przez <see cref="T:System.IAsyncResult" /> zakończony.</summary>
        <returns><see cref="T:System.Object" /> Wygenerowana przez operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli operacja asynchroniczna nie została ukończona, ta funkcja będzie blokować do momentu udostępnienia wyniku.  
  
> [!NOTE]
>  Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Wartość <paramref name="asyncResult" /> parametru to. <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException">Obiekt nie został utworzony przez poprzednie wywołanie <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> metody z tej samej kontrolki. <paramref name="asyncResult" /></exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po otwarciu formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
> [!NOTE]
>  Zdarzenia <xref:System.Windows.Forms.Control.Enter> i <xref:System.Windows.Forms.Control.Leave> sąpomijane<xref:System.Windows.Forms.Form> przez klasę. Odpowiednie zdarzenia w <xref:System.Windows.Forms.Form> klasie <xref:System.Windows.Forms.Form.Activated> to zdarzenia i <xref:System.Windows.Forms.Form.Deactivate> . Zdarzenia <xref:System.Windows.Forms.Control.Enter> i<xref:System.Windows.Forms.Control.Leave> są hierarchiczne i tworzą kaskadowe i w dół łańcucha nadrzędnego do momentu osiągnięcia odpowiedniej kontroli. Załóżmy na przykład, że <xref:System.Windows.Forms.Form> masz dwie <xref:System.Windows.Forms.GroupBox> kontrolki, a każda <xref:System.Windows.Forms.GroupBox> kontrolka ma jedną <xref:System.Windows.Forms.TextBox> kontrolkę. Gdy karetka jest przenoszona z <xref:System.Windows.Forms.TextBox> jednego do drugiego <xref:System.Windows.Forms.Control.Leave> , <xref:System.Windows.Forms.TextBox> zdarzenie jest zgłaszane dla i <xref:System.Windows.Forms.GroupBox>, a <xref:System.Windows.Forms.Control.Enter> zdarzenie jest zgłaszane dla drugiego <xref:System.Windows.Forms.GroupBox> i <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Więcej informacji można znaleźć `WM_KILLFOCUS` w temacie w sekcji "informacje wejściowe dotyczące klawiatury" i w sekcji "zakleszczenia komunikatów" tematu informacje o komunikatach [i kolejkach komunikatów](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Enter> zdarzenia, aby zmienić kolor pierwszego planu i tła <xref:System.Windows.Forms.TextBox> w określonych warunkach.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera formularz, w którym znajduje się kontrolka.</summary>
        <returns><see cref="T:System.Windows.Forms.Form" /> Czy kontrolka jest włączona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Forms.Control.Parent%2A> właściwości kontrolki nie może być taka sama <xref:System.Windows.Forms.Form> jak zwracana przez <xref:System.Windows.Forms.Control.FindForm%2A> metodę. Na przykład, jeśli <xref:System.Windows.Forms.RadioButton> kontrolka znajduje się <xref:System.Windows.Forms.GroupBox> w kontrolce, <xref:System.Windows.Forms.Form>a <xref:System.Windows.Forms.GroupBox> znajduje się <xref:System.Windows.Forms.GroupBox> na, <xref:System.Windows.Forms.RadioButton> <xref:System.Windows.Forms.Control.Parent%2A> jest to kontrolka i <xref:System.Windows.Forms.GroupBox> <xref:System.Windows.Forms.Control.Parent%2A>jest .<xref:System.Windows.Forms.Form>  
  
   
  
## Examples  
 Poniższy przykład kodu znajduje formularz, który zawiera określony przycisk.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ustawia fokus wprowadzania dla kontrolki.</summary>
        <returns><see langword="true" />Jeśli żądanie fokusu danych wejściowych zakończyło się pomyślnie; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Focus%2A> Metoda zwraca`true` , czy formant pomyślnie otrzymał fokus wprowadzania. Kontrolka może mieć fokus wprowadzania, gdy nie są wyświetlane żadne podpowiedzi wizualne dotyczące fokusu. To zachowanie jest przede wszystkim zaobserwowane przez kontrolki, które nie są wybrane poniżej, lub wszystkie kontrolki pochodne.  
  
 Kontrolka może być zaznaczona i odbierać dane wejściowe, jeśli są spełnione wszystkie następujące warunki: `Selectable` <xref:System.Windows.Forms.ControlStyles> wartość jest ustawiona na `true`, jest zawarta w innej kontrolce, a wszystkie jej kontrolki nadrzędne są widoczne i włączone.  
  
 Nie wybrano formantów Windows Forms na poniższej liście. Kontrolki pochodne od tych formantów również nie są wybierane.  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Jeśli w formancie nie ma żadnego linku)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A>jest metodą niskiego poziomu zamierzoną głównie dla autorów formantów niestandardowych. Zamiast tego Programiści aplikacji powinni używać <xref:System.Windows.Forms.Control.Select%2A> metody <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> lub właściwości dla formantów <xref:System.Windows.Forms.Form.Activate%2A> podrzędnych lub metody dla formularzy.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia fokus na określony <xref:System.Windows.Forms.Control>, jeśli może odebrać fokus.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka ma fokus wprowadzania.</summary>
        <value><see langword="true" />Jeśli kontrolka ma fokus; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wyłącza funkcję, <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.TextBox> Jeśli nie ma fokusu. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> `menuItemEdit` <xref:System.Windows.Forms.MenuItem> <xref:System.Windows.Forms.TextBox> `textBox1` nazwę i dwa obiekty o nazwach `menuItemEditInsertCustomerInfo`i.  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Focused" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Focused" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę tekstu wyświetlanego przez kontrolkę.</summary>
        <value><see cref="T:System.Drawing.Font" /> Do zastosowania do tekstu wyświetlanego przez kontrolkę. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultFont" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Font%2A> Właściwość jest właściwością otoczenia. Właściwość otoczenia jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Aby uzyskać więcej informacji o właściwościach otoczenia, <xref:System.Windows.Forms.AmbientProperties> Zobacz klasy <xref:System.Windows.Forms.Control> lub przegląd klas.  
  
 Ponieważ jest niezmienne (oznacza to, że nie można dostosować żadnej z jej właściwości), można <xref:System.Windows.Forms.Control.Font%2A> przypisać tylko nową <xref:System.Drawing.Font>właściwość. <xref:System.Drawing.Font> Można jednak utworzyć nową czcionkę dla istniejącej czcionki.  
  
 [Visual Basic, C#]  
  
 Poniżej przedstawiono przykład sposobu dostosowywania istniejącej czcionki w celu pogrubienia:  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Windows.Forms.FontDialog> dla użytkownika i <xref:System.Drawing.Font> zmienia <xref:System.Windows.Forms.DateTimePicker> formant. Ten przykład wymaga, aby było <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> możliwe i <xref:System.Windows.Forms.DateTimePicker> .  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Font" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Font" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.Font" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.Font" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Font%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub przez interakcję.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.FontChanged> zdarzenie.  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość czcionki kontrolki.</summary>
        <value>Wysokość <see cref="T:System.Drawing.Font" /> formantu w pikselach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Właściwość nie powinna być ustawiona na wartość inną niż <xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType> wartość kontrolki lub-1. <xref:System.Windows.Forms.Control.FontHeight%2A> Ustawienie <xref:System.Windows.Forms.Control.FontHeight%2A> wartości-1 ma wpływ na wyczyszczenie wartości limitu pamięci podręcznej, a wartość jest obliczana ponownie przy następnym odwołaniu do właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu formantu.</summary>
        <value>Pierwszy plan <see cref="T:System.Drawing.Color" /> formantu. Wartością domyślną jest wartość <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> właściwości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ForeColor%2A> Właściwość jest właściwością otoczenia. Właściwość otoczenia jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Aby uzyskać więcej informacji o właściwościach otoczenia, <xref:System.Windows.Forms.AmbientProperties> Zobacz klasy <xref:System.Windows.Forms.Control> lub przegląd klas.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Windows.Forms.Control.BackColor%2A> domyślne kolory systemowe i <xref:System.Windows.Forms.Control.ForeColor%2A> kontrolek. Kod cyklicznie wywołuje siebie, Jeśli kontrolka ma jakiekolwiek kontrolki podrzędne. Ten przykład kodu wymaga, aby miało <xref:System.Windows.Forms.Form> co najmniej jedną kontrolkę podrzędną; jednak kontrolka podrzędnego kontenera, taka <xref:System.Windows.Forms.Panel> jak <xref:System.Windows.Forms.GroupBox>lub, z własnymi kontrolkami podrzędnymi lepiej ilustruje rekursję.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.ForeColor" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.ForeColor" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.ForeColor" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.ForeColor" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.ForeColor%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub przez interakcję.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Uchwyt okna (<see langword="HWND" />) do wyszukania.</param>
        <summary>Pobiera kontrolkę, która zawiera określone dojście.</summary>
        <returns>Reprezentuje kontrolkę skojarzoną z określonym dojściem; zwraca <see langword="null" /> czy nie znaleziono kontrolki z określonym dojściem. <see cref="T:System.Windows.Forms.Control" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda przeszukuje okno obsługi łańcucha nadrzędnego do momentu znalezienia dojścia, które jest skojarzone z kontrolką. Ta metoda jest bardziej niezawodna <xref:System.Windows.Forms.Control.FromHandle%2A> niż metoda, ponieważ poprawnie zwraca formanty, które są właścicielami więcej niż jednego uchwytu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">Uchwyt okna (<see langword="HWND" />) do wyszukania.</param>
        <summary>Zwraca kontrolkę, która jest aktualnie skojarzona z określonym dojściem.</summary>
        <returns>Reprezentuje kontrolkę skojarzoną z określonym dojściem; zwraca <see langword="null" /> czy nie znaleziono kontrolki z określonym dojściem. <see cref="T:System.Windows.Forms.Control" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.FromChildHandle%2A> Użyj metody, jeśli chcesz zwrócić kontrolki, które są częścią więcej niż jednego uchwytu.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="objectId"><see langword="Int32" /> Który<see cref="T:System.Windows.Forms.AccessibleObject" /> identyfikuje element do pobrania.</param>
        <summary>Pobiera określony <see cref="T:System.Windows.Forms.AccessibleObject" />.</summary>
        <returns>Określony <see cref="T:System.Windows.Forms.AccessibleObject" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą, w jaki sposób formant będzie zachowywać <see cref="P:System.Windows.Forms.Control.AutoSize" /> się po włączeniu jego właściwości.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.AutoSizeMode" /> wartości.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera kontrolę rodzicielską w określonej lokalizacji.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.Point" /> , który zawiera współrzędne, w których chcesz wyszukać kontrolkę. Współrzędne są wyrażane względem lewego górnego rogu obszaru klienckiego kontrolki.</param>
        <summary>Pobiera formant podrzędny, który znajduje się na określonych współrzędnych.</summary>
        <returns><see cref="T:System.Windows.Forms.Control" /> Reprezentuje kontrolkę, która znajduje się w określonym punkcie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku braku formantu podrzędnego w określonym punkcie <xref:System.Windows.Forms.Control.GetChildAtPoint%2A> Metoda zwraca. `null`  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien do wywołania tej metody, jeśli zwrócona kontrolka nie jest elementem podrzędnym formantu. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">A <see cref="T:System.Drawing.Point" /> , który zawiera współrzędne, w których chcesz wyszukać kontrolkę. Współrzędne są wyrażane względem lewego górnego rogu obszaru klienckiego kontrolki.</param>
        <param name="skipValue">Jedna z wartości <see cref="T:System.Windows.Forms.GetChildAtPointSkip" />, określająca, czy ignorować kontrolki podrzędne określonego typu.</param>
        <summary>Pobiera formant podrzędny, który znajduje się na określonych współrzędnych, określając, czy ignorować kontrolki podrzędne określonego typu.</summary>
        <returns>Element podrzędny <see cref="T:System.Windows.Forms.Control" /> na określonych współrzędnych.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca następny <see cref="T:System.Windows.Forms.ContainerControl" /> łańcuch formantów nadrzędnych formantu.</summary>
        <returns>Obiekt <see cref="T:System.Windows.Forms.IContainerControl" />, który reprezentuje element nadrzędny obiektu <see cref="T:System.Windows.Forms.Control" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl"><see cref="T:System.Windows.Forms.Control" /> Aby rozpocząć wyszukiwanie przy użyciu.</param>
        <param name="forward"><see langword="true" />Aby przeszukiwać do przodu w kolejności tabulacji; <see langword="false" /> , aby przeszukać wstecz.</param>
        <summary>Pobiera następną kontrolkę do przodu lub wstecz w kolejności tabulacji w kontrolkach podrzędnych.</summary>
        <returns>Dalej <see cref="T:System.Windows.Forms.Control" /> w kolejności tabulacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GetNextControl%2A> Metoda jest zależna od kolejności tabulacji. Aby wykonać iterację wszystkich kontrolek formularza, w tym formantów zagnieżdżonych, <xref:System.Windows.Forms.Control.Controls%2A> Użyj właściwości. Aby uzyskać lub ustawić aktywną kontrolę nad kontrolką kontenera, użyj <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="proposedSize">Obszar niestandardowy dla kontrolki.</param>
        <summary>Pobiera rozmiar prostokątnego obszaru, w którym może być zamontowany formant.</summary>
        <returns>Uporządkowana para typu <see cref="T:System.Drawing.Size" /> reprezentująca szerokość i wysokość prostokąta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie <xref:System.Windows.Forms.Control.GetPreferredSize%2A> różne przez kontrolkę. <xref:System.Windows.Forms.Control.LayoutEngine%2A> Może nie być możliwe przypisanie zwróconego rozmiaru do kontrolki. Można zwrócić rozmiar większy niż ograniczenia wskazane w `proposedSize` parametrze, ale `proposedSize` powinien zostać zmniejszony w miarę zmniejszania ograniczeń. Na przykład `GetPreferredSize(new Size(100, 0))` nie powinna być większa niż `GetPreferredSize(new Size(200, 0))`. Wyjątek to `proposedSize` 0 lub `Size.Empty`, które są zdefiniowane jako nieograniczone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">Element <see cref="T:System.Drawing.Rectangle" /> określający obszar, dla którego mają zostać pobrane granice wyświetlania.</param>
        <param name="factor">Wysokość i szerokość granic formantu.</param>
        <param name="specified">Jedna z wartości <see cref="T:System.Windows.Forms.BoundsSpecified" /> , która określa granice formantu do użycia podczas definiowania jego rozmiaru i położenia.</param>
        <summary>Pobiera granice, w których kontrolka jest skalowana.</summary>
        <returns><see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice, w których kontrolka jest skalowana.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to metoda pomocnika, która jest wywoływana <xref:System.Windows.Forms.Control.ScaleControl%2A> przez w celu pobrania granic, w których kontrolka jest skalowana. Można zastąpić tę metodę, aby ponownie użyć <xref:System.Windows.Forms.Control.ScaleControl%2A> logiki skalowania, ale musisz podać własne granice. Domyślna implementacja zwraca granice skalowane, które uwzględniają `specified` granice, niezależnie od tego, czy kontrolka jest najwyższego poziomu, czy kontrolka ma stałą szerokość czy automatyczne rozmiary, i wszelkie zakończenia, jakie może mieć formant.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">Bit <see cref="T:System.Windows.Forms.ControlStyles" /> , z którego ma zostać zwrócona wartość.</param>
        <summary>Pobiera wartość określonego bitu stylu kontrolki dla kontrolki.</summary>
        <returns><see langword="true" />Jeśli określony bit stylu kontrolki jest ustawiony na <see langword="true" />; w przeciwnym <see langword="false" />razie,.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flagi bitów stylu formantu są używane do kategoryzacji obsługiwanego zachowania. Kontrolka może włączyć styl, wywołując <xref:System.Windows.Forms.Control.SetStyle%2A> metodę i przekazując odpowiedni <xref:System.Windows.Forms.ControlStyles> bit i wartość logiczną, aby ustawić bit na. Aby określić wartość przypisaną do określonego <xref:System.Windows.Forms.ControlStyles> bitu, <xref:System.Windows.Forms.Control.GetStyle%2A> Użyj <xref:System.Windows.Forms.ControlStyles> metody i przekaż element członkowski do obliczenia.  
  
   
  
## Examples  
 Poniższy przykład kodu zwraca wartość bitów o podwójnym buforze dla elementu <xref:System.Windows.Forms.Form>. Ten przykład zwraca `true` tylko wtedy, gdy wszystkie bity stylu są ustawione `true`na.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Określa, czy formant jest formantem najwyższego poziomu.</summary>
        <returns><see langword="true" />Jeśli formant jest formantem najwyższego poziomu; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje podczas operacji przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GiveFeedback> Zdarzenie jest zgłaszane po rozpoczęciu operacji przeciągania i upuszczania. <xref:System.Windows.Forms.Control.GiveFeedback> Ze zdarzeniem Źródło zdarzenia przeciągania może modyfikować wygląd wskaźnika myszy w celu przedstawienia wizualnej opinii użytkownika podczas operacji przeciągania i upuszczania.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dziękiczemumożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje operację przeciągania i upuszczania między dwoma <xref:System.Windows.Forms.ListBox> kontrolkami. Przykład wywołuje metodę, <xref:System.Windows.Forms.Control.DoDragDrop%2A> gdy rozpocznie się akcja przeciągania. Akcja przeciągania rozpocznie się, jeśli mysz została przeniesiona <xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType> więcej niż z lokalizacji myszy <xref:System.Windows.Forms.Control.MouseDown> podczas zdarzenia. Metoda jest używana do określenia indeksu elementu do przeciągnięcia `MouseDown` podczas zdarzenia. <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>  
  
 W przykładzie pokazano również, jak używać niestandardowych kursorów dla operacji przeciągania i upuszczania. Przykład wymaga, aby dwa pliki kursora, `3dwarro.cur` i `3dwno.cur`, istniały w katalogu aplikacji, dla niestandardowych kursorów przeciąganie i nieupuszczanie. Kursory niestandardowe będą używane, jeśli `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox> jest zaznaczone. Kursory niestandardowe są ustawiane w <xref:System.Windows.Forms.Control.GiveFeedback> programie obsługi zdarzeń.  
  
 Stan klawiatury jest obliczany w <xref:System.Windows.Forms.Control.DragOver> procedurze obsługi zdarzeń po prawej stronie `ListBox`, aby określić, jaka operacja przeciągania będzie oparta na stanie klawiszy Shift, Ctrl, Alt lub Ctrl + Alt. Lokalizacja w `ListBox` miejscu, w którym występuje porzucanie, jest również określana `DragOver` podczas zdarzenia. Jeśli dane do `String`porzucenia nie są, <xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType> wówczas jest ustawiona na wartość `None` w <xref:System.Windows.Forms.DragDropEffects>. Na koniec stan upuszczenia jest wyświetlany w `DropLocationLabel`. <xref:System.Windows.Forms.Label>  
  
 Dane do porzucenia po prawej stronie `ListBox` są określane <xref:System.Windows.Forms.Control.DragDrop> w programie obsługi zdarzeń, a `String` wartość `ListBox`jest dodawana w odpowiednim miejscu w. Jeśli operacja przeciągania przesunie się poza granice formularza, operacja przeciągania i upuszczania zostanie anulowana w <xref:System.Windows.Forms.Control.QueryContinueDrag> obsłudze zdarzeń.  
  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenia. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kontrolka odbierze fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
 **Uwaga** Zdarzenia <xref:System.Windows.Forms.Control.GotFocus> i<xref:System.Windows.Forms.Control.LostFocus> to zdarzenia koncentracji niskiego poziomu, które są powiązane z WM_KILLFOCUS i WM_SETFOCUS komunikatów systemu Windows. Zazwyczaj zdarzenia i <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.LostFocus> są używane tylko w przypadku aktualizowania <xref:System.Windows.Forms.UICues> lub pisania formantów niestandardowych. <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Form.Deactivate> <xref:System.Windows.Forms.Form.Activated> Zamiast tego zdarzenia <xref:System.Windows.Forms.Control.Leave> ipowinnybyćużywanedlawszystkichkontrolekopróczklasy,któraużywazdarzeńi.<xref:System.Windows.Forms.Control.Enter> Aby uzyskać więcej informacji o <xref:System.Windows.Forms.Control.GotFocus> zdarzeniach <xref:System.Windows.Forms.Control.LostFocus> i, zobacz tematy dotyczące [WM_SETFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx) i [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Aby uzyskać więcej informacji, zobacz temat [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.GotFocus> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.GotFocus> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt okna, z którym jest powiązana kontrolka.</summary>
        <value>Element <see cref="T:System.IntPtr" /> zawierający uchwyt okna (<see langword="HWND" />) formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Forms.Control.Handle%2A> właściwości jest Windows `HWND`. Jeśli dojście nie zostało jeszcze utworzone, odwoływanie się do tej właściwości spowoduje wymuszenie utworzenia uchwytu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.Handle%2A> właściwości i. Aby uruchomić przykład, wklej poniższy kod w formularzu. Dodaj dwa przyciski o `Button1` nazwie `Button2` i do formularza i upewnij się, że wszystkie zdarzenia są połączone z ich obsługą zdarzeń.  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utworzeniu dojścia dla kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście jest tworzone, gdy <xref:System.Windows.Forms.Control> jest wyświetlany po raz pierwszy. Na <xref:System.Windows.Forms.Control> przykład jeśli jest tworzony, który ma <xref:System.Windows.Forms.Control.Visible%2A> ustawioną wartość `false`, <xref:System.Windows.Forms.Control.HandleCreated> zdarzenie nie zostanie wywołane, dopóki <xref:System.Windows.Forms.Control.Visible%2A> nie zostanie ustawione `true`na.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.HandleCreated> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.HandleCreated> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy dojście kontrolki jest w trakcie zniszczenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W trakcie <xref:System.Windows.Forms.Control.Handle%2A> <xref:System.Windows.Forms.Control.RecreateHandle%2A> zdarzenia formant jest nadal prawidłowym formantem systemu Windows i można go odtworzyć przez wywołanie metody. <xref:System.Windows.Forms.Control.HandleDestroyed>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.HandleDestroyed> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.HandleDestroyed> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka zawiera co najmniej jedną kontrolkę podrzędną.</summary>
        <value><see langword="true" />Jeśli kontrolka zawiera co najmniej jedną kontrolkę podrzędną; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kolekcja ma <xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A> więcej niż zero`true`, <xref:System.Windows.Forms.Control.HasChildren%2A> właściwość zwróci wartość. <xref:System.Windows.Forms.Control.Controls%2A> Uzyskanie dostępu do <xref:System.Windows.Forms.Control.ControlCollection> właściwościniewymuszautworzeniaelementu,jeśliformantniemaelementówpodrzędnych,dlategoodwołaniedotejwłaściwościmożezapewnićwydajnośćpodczasprzechodzenia<xref:System.Windows.Forms.Control.HasChildren%2A> drzewa kontrolek.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia <xref:System.Windows.Forms.Control.BackColor%2A> domyślne kolory systemowe i <xref:System.Windows.Forms.Control.ForeColor%2A> kontrolek. Kod cyklicznie wywołuje siebie, Jeśli kontrolka ma jakiekolwiek kontrolki podrzędne. Ten przykład kodu wymaga, aby miało <xref:System.Windows.Forms.Form> co najmniej jedną kontrolkę podrzędną; jednak kontrolka podrzędnego kontenera, taka <xref:System.Windows.Forms.Panel> jak <xref:System.Windows.Forms.GroupBox>lub, z własnymi kontrolkami podrzędnymi lepiej ilustruje rekursję.  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość formantu.</summary>
        <value>Wysokość formantu w pikselach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiany wprowadzone do <xref:System.Windows.Forms.Control.Height%2A> wartości właściwości <xref:System.Windows.Forms.Control.Top%2A> i powodują <xref:System.Windows.Forms.Control.Bottom%2A> zmianę wartości właściwości formantu.  
  
> [!NOTE]
>  Minimalna wysokość formantu <xref:System.Windows.Forms.Splitter> pochodnego wynosi jeden piksel. Domyślna wysokość <xref:System.Windows.Forms.Splitter> formantu to trzy piksele. Ustawienie wysokości <xref:System.Windows.Forms.Splitter> kontrolki na wartość mniejszą od 1 spowoduje zresetowanie wartości właściwości do wysokości domyślnej.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zażąda pomocy do formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.HelpRequested> Zdarzenie jest często wywoływane, gdy użytkownik naciśnie klawisz F1 lub kliknięty jest skojarzony kontekstowy przycisk pomocy.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje obsługę <xref:System.Windows.Forms.Control.HelpRequested> zdarzenia w celu wyświetlenia niestandardowej zawartości pomocy w formularzu zawierającym cztery pola adresu. <xref:System.Windows.Forms.Control.HelpRequested> Zdarzenie jest wywoływane przez naciśnięcie klawisza F1 z fokusem w polu adres lub za pomocą przycisku Pomoc kontekstowa i kliknięciem kursora pomocy w polu adres. Właściwość jest ustawiona na wartość true `HelpRequested` , aby wskazać, że zdarzenie jest obsługiwane. <xref:System.Windows.Forms.HelpEventArgs.Handled%2A> W przykładzie pokazano również, jak przechowywać tekst pomocy we <xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType> właściwości.  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukrywa formant od użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ukrycie kontrolki jest równoznaczne z <xref:System.Windows.Forms.Control.Visible%2A> ustawieniem `false`właściwości na. <xref:System.Windows.Forms.Control.Visible%2A> <xref:System.Windows.Forms.Control.Show%2A> Po wywołaniu <xref:System.Windows.Forms.Control.Hide%2A> metody`false` Właściwość zwraca wartość, dopóki metoda nie zostanie wywołana.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa przycisk po naciśnięciu klawisza CTRL po kliknięciu przycisku. Ten przykład wymaga, aby <xref:System.Windows.Forms.Button> nazwa została określona `button1` na. <xref:System.Windows.Forms.Form>  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb edytora IME (Input Method Editor) formantu.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.ImeMode" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.ImeMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Edytor IME to program, który umożliwia użytkownikom wprowadzanie złożonych znaków i symboli, takich jak japońskie znaki kanji, przy użyciu standardowej klawiatury. Właściwość jest zwykle <xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType> ustawiona na dla <xref:System.Windows.Forms.TextBox> kontrolki, która jest przeznaczona tylko do wprowadzania wartości numerycznych. <xref:System.Windows.Forms.Control.ImeMode%2A> Wartość właściwości jest ustawiona na <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> dla <xref:System.Windows.Forms.Form> klasy. <xref:System.Windows.Forms.Control.ImeMode%2A>  
  
 Większość klas, które nie obsługują bezpośrednio edytorów metody wejściowej lub dopuszczają bezpośrednie dane wejściowe z edytora IME, ustawi wartość tej właściwości na <xref:System.Windows.Forms.ImeMode.NoControl>.  
  
> [!IMPORTANT]
>  Użytkownik może się interaktywnie zmienić, <xref:System.Windows.Forms.Control.ImeMode%2A> chyba że jest programowo ustawiony na. <xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType> W takim przypadku użytkownik nie będzie mógł używać edytora IME.  
>   
>  <xref:System.Windows.Forms.Control.ImeMode%2A> Właściwość jest ignorowana w systemie Windows 8, gdy obowiązuje globalny tryb wejścia. Aby uzyskać więcej informacji, zobacz [Przełącz wprowadzanie tekstu zmieniony z na wątek do użytkownika](https://go.microsoft.com/fwlink/?LinkID=256509).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.ImeMode" /> wartości wyliczenia.</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tryb edytora IME formantu.</summary>
        <value>Tryb edytora IME formantu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.Control.ImeMode" /> gdy właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.ImeMode%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub przez interakcję.  
  
 Kontrolki, które nie obsługują menedżerów metody wejściowej, nigdy nie spowodują zgłoszenia tego zdarzenia.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wywoływana po dodaniu kontrolki do innego kontenera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.InitLayout%2A> Metoda jest wywoływana natychmiast po dodaniu kontrolki do kontenera. <xref:System.Windows.Forms.Control.InitLayout%2A> Metoda umożliwia formantowi zainicjowanie stanu układu na podstawie jego kontenera. Na przykład zwykle stosuje się kotwicę i dokowanie do kontrolki w <xref:System.Windows.Forms.Control.InitLayout%2A> metodzie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.InitLayout" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.InitLayout" /> metodę klasy bazowej, aby formant był wyświetlany poprawnie.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Unieważnia określony region kontrolki i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unieważnia całą powierzchnię kontrolki i powoduje jej Odrysowanie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikowi przeciąganie obrazu lub pliku obrazu do formularza i wyświetlanie go w momencie, gdy zostanie on usunięty. <xref:System.Windows.Forms.Control.OnPaint%2A> Metoda jest zastępowana, aby odświeżyć obraz za każdym razem, gdy formularz zostanie namalowany; w przeciwnym razie obraz będzie trwał dopiero po następnym odświeżeniu. Metoda <xref:System.Windows.Forms.Control.DragEnter> obsługi zdarzeń określa typ danych, które są przeciągane do formularza i zawiera odpowiednie informacje zwrotne. Metoda obsługi <xref:System.Drawing.Image> zdarzeń wyświetla obraz w formularzu, jeśli można go utworzyć na podstawie danych. <xref:System.Windows.Forms.Control.DragDrop> Ponieważ wartości <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.PointToClient%2A> i są współrzędnymi ekranu, w przykładzie używa się metody do konwertowania ich na współrzędne klienta. <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren"><see langword="true" />Aby unieważnić kontrolki podrzędne kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Unieważnia określony region kontrolki i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki. Opcjonalnie program unieważnia kontrolki podrzędne przypisane do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje region do unieważnienia.</param>
        <summary>Unieważnia określony region kontrolki (dodaje go do regionu aktualizacji kontrolki, który jest obszarem, który zostanie odmalowany podczas następnej operacji malowania) i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> Do unieważnienia.</param>
        <summary>Unieważnia określony region kontrolki (dodaje go do regionu aktualizacji kontrolki, który jest obszarem, który zostanie odmalowany podczas następnej operacji malowania) i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje region do unieważnienia.</param>
        <param name="invalidateChildren"><see langword="true" />Aby unieważnić kontrolki podrzędne kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Unieważnia określony region kontrolki (dodaje go do regionu aktualizacji kontrolki, który jest obszarem, który zostanie odmalowany podczas następnej operacji malowania) i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki. Opcjonalnie program unieważnia kontrolki podrzędne przypisane do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region"><see cref="T:System.Drawing.Region" /> Do unieważnienia.</param>
        <param name="invalidateChildren"><see langword="true" />Aby unieważnić kontrolki podrzędne kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Unieważnia określony region kontrolki (dodaje go do regionu aktualizacji kontrolki, który jest obszarem, który zostanie odmalowany podczas następnej operacji malowania) i powoduje, że komunikat programu Paint zostanie wysłany do kontrolki. Opcjonalnie program unieważnia kontrolki podrzędne przypisane do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie metody nie wymusza synchronicznego malowania; aby wymusić farby synchroniczne, <xref:System.Windows.Forms.Control.Update%2A> Wywołaj metodę po wywołaniu <xref:System.Windows.Forms.Control.Invalidate%2A> metody. <xref:System.Windows.Forms.Control.Invalidate%2A> Gdy ta metoda jest wywoływana bez parametrów, cały obszar klienta zostanie dodany do regionu aktualizacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy ekran kontrolki wymaga przeprowadzenia ponownej rysowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.Invalidated> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.Invalidated> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje delegata w wątku, który jest właścicielem uchwytu okna bazowego formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">Delegat zawierający metodę, która ma zostać wywołana w kontekście wątku formantu.</param>
        <summary>Wykonuje określony delegat w wątku, który jest właścicielem uchwytu okna bazowego formantu.</summary>
        <returns>Wartość zwracana z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaty są podobne do wskaźników funkcji w języku C++ C lub. Delegaty hermetyzują odwołanie do metody wewnątrz obiektu delegowanego. Obiekt delegata można następnie przekazać do kodu, który wywołuje metodę, do której istnieje odwołanie, a metoda, która ma zostać wywołana, może być nieznana w czasie kompilacji. W przeciwieństwie do wskaźników funkcji w C++języku C lub, Delegaty są zorientowane obiektowo, bezpieczne typu i bezpieczniejsze.  
  
 <xref:System.Windows.Forms.Control.Invoke%2A> Metoda przeszukuje łańcuch nadrzędny kontrolki do momentu znalezienia kontrolki lub formularza, który ma uchwyt okna, jeśli bieżące uchwyt okna kontrolki nie istnieje jeszcze. Jeśli nie można znaleźć odpowiedniego dojścia, <xref:System.Windows.Forms.Control.Invoke%2A> Metoda zgłosi wyjątek. Wyjątki, które są wywoływane podczas wywołania, zostaną przekazane z powrotem do obiektu wywołującego.  
  
> [!NOTE]
>  Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu.  
  
 Delegat może być wystąpieniem <xref:System.EventHandler>, w którym to przypadku parametr nadawcy będzie zawierał tę kontrolkę, a parametr zdarzenia będzie zawierać. <xref:System.EventArgs.Empty?displayProperty=nameWithType> Delegat może być również wystąpieniem <xref:System.Windows.Forms.MethodInvoker>lub innym delegatem, który przyjmuje listę parametrów void. Wywołanie obiektu <xref:System.EventHandler> lub <xref:System.Windows.Forms.MethodInvoker> delegata będzie szybsze niż wywołanie innego typu delegata.  
  
> [!NOTE]
>  Wyjątek może być zgłaszany, jeśli wątek, który powinien przetworzyć komunikat, nie jest już aktywny.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kontrolki, które zawierają delegat. Delegat hermetyzuje metodę, która dodaje elementy do pola listy. Ta metoda jest wykonywana w wątku, który jest właścicielem bazowego uchwytu formularza. Gdy użytkownik kliknie przycisk, `Invoke` uruchamia delegata.  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method">Delegat metody, która pobiera parametry o tej samej liczbie i typie, które znajdują się w <paramref name="args" /> parametrze.</param>
        <param name="args">Tablica obiektów do przekazania jako argumenty do określonej metody. Ten parametr może być <see langword="null" /> , jeśli metoda nie przyjmuje argumentów.</param>
        <summary>Wykonuje określony delegat w wątku, do którego należy uchwyt okna bazowego formantu, z określoną listą argumentów.</summary>
        <returns>Zawiera wartość zwracaną z wywoływanego delegata lub <see langword="null" /> Jeśli delegat nie ma zwracanej wartości. <see cref="T:System.Object" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Delegaty są podobne do wskaźników funkcji w języku C++ C lub. Delegaty hermetyzują odwołanie do metody wewnątrz obiektu delegowanego. Obiekt delegata można następnie przekazać do kodu, który wywołuje metodę, do której istnieje odwołanie, a metoda, która ma zostać wywołana, może być nieznana w czasie kompilacji. W przeciwieństwie do wskaźników funkcji w C++języku C lub, Delegaty są zorientowane obiektowo, bezpieczne typu i bezpieczniejsze.  
  
 Jeśli dojście kontrolki jeszcze nie istnieje, ta metoda przeszukuje łańcuch nadrzędny kontrolki do momentu znalezienia kontrolki lub formularza, który ma uchwyt okna. Jeśli nie można znaleźć odpowiedniego dojścia, metoda zgłasza wyjątek. Wyjątki, które są wywoływane podczas wywołania, zostaną przekazane z powrotem do obiektu wywołującego.  
  
> [!NOTE]
>  Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne dla wątków: <xref:System.Windows.Forms.Control.Invoke%2A>, <xref:System.Windows.Forms.Control.BeginInvoke%2A> <xref:System.Windows.Forms.Control.EndInvoke%2A>,, i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z metod Invoke do skierowania wywołania do wątku formantu.  
  
 Delegat może być wystąpieniem <xref:System.EventHandler>, w którym to przypadku parametr nadawcy będzie zawierał tę kontrolkę, a parametr zdarzenia będzie zawierać. <xref:System.EventArgs.Empty?displayProperty=nameWithType> Delegat może być również wystąpieniem <xref:System.Windows.Forms.MethodInvoker>lub innym delegatem, który przyjmuje listę parametrów void. Wywołanie obiektu <xref:System.EventHandler> lub <xref:System.Windows.Forms.MethodInvoker> delegata będzie szybsze niż wywołanie innego typu delegata.  
  
> [!NOTE]
>  Wyjątek może być zgłaszany, jeśli wątek, który powinien przetworzyć komunikat, nie jest już aktywny.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje kontrolki, które zawierają delegat. Delegat hermetyzuje metodę, która dodaje elementy do pola listy. Ta metoda jest wykonywana w wątku, który jest właścicielem bazowego uchwytu formularza, przy użyciu określonych argumentów. Gdy użytkownik kliknie przycisk, `Invoke` uruchamia delegata.  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke"><see cref="T:System.Windows.Forms.Control" /> Do przypisywania zdarzenia do.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.GotFocus" /> Podnosi zdarzenie dla określonej kontrolki.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke"><see cref="T:System.Windows.Forms.Control" /> Do przypisywania zdarzenia do.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.LostFocus" /> Podnosi zdarzenie dla określonej kontrolki.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke"><see cref="T:System.Windows.Forms.Control" /> Do przypisywania<see cref="E:System.Windows.Forms.Control.Click" /> zdarzenia do.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Click" /> Podnosi zdarzenie dla określonej kontrolki.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> Do przypisywania<see cref="E:System.Windows.Forms.Control.Paint" /> zdarzenia do.</param>
        <param name="e"><see cref="T:System.Windows.Forms.PaintEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> Podnosi zdarzenie dla określonej kontrolki.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> Do przypisywania<see cref="E:System.Windows.Forms.Control.Paint" /> zdarzenia do.</param>
        <param name="e"><see cref="T:System.Windows.Forms.PaintEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see langword="PaintBackground" /> Podnosi zdarzenie dla określonej kontrolki.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISynchronizeInvoke.InvokeRequired</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt wywołujący musi wywołać metodę Invoke podczas wykonywania wywołań metody do kontrolki, ponieważ obiekt wywołujący znajduje się w innym wątku niż ten, w którym został utworzony.</summary>
        <value><see langword="true" />Jeśli formant <see cref="P:System.Windows.Forms.Control.Handle" /> został utworzony w innym wątku niż wątek wywołujący (wskazujący, że musisz wykonać wywołania kontrolki za pomocą metody Invoke); <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolki w Windows Forms są powiązane z określonym wątkiem i nie są bezpieczne wątkowo. W związku z tym, jeśli wywołujesz metodę formantu z innego wątku, musisz użyć jednej z metod wywołania kontrolki do skierowania wywołania do właściwego wątku. Ta właściwość może służyć do określenia, czy należy wywołać metodę Invoke, która może być przydatna, jeśli nie wiesz, który wątek jest właścicielem formantu.  
  
> [!NOTE]
>  Oprócz <xref:System.Windows.Forms.Control.InvokeRequired%2A> właściwości istnieją cztery metody kontrolki, które są bezpieczne do wywołania: <xref:System.Windows.Forms.Control.Invoke%2A>,<xref:System.Windows.Forms.Control.BeginInvoke%2A>, <xref:System.Windows.Forms.Control.EndInvoke%2A> i <xref:System.Windows.Forms.Control.CreateGraphics%2A> Jeśli uchwyt dla kontrolki został już utworzony. Wywołanie <xref:System.Windows.Forms.Control.CreateGraphics%2A> przed utworzeniem uchwytu kontrolki w wątku w tle może spowodować niedozwolone wywołania międzywątkowe. Dla wszystkich innych wywołań metody należy użyć jednej z tych metod wywołania podczas wywoływania z innego wątku.  
  
 Jeśli dojście kontrolki jeszcze nie istnieje, <xref:System.Windows.Forms.Control.InvokeRequired%2A> wyszukuje łańcuch nadrzędny kontrolki do momentu znalezienia formantu lub formularza, który ma uchwyt okna. Jeśli nie można znaleźć odpowiedniego dojścia, <xref:System.Windows.Forms.Control.InvokeRequired%2A> Metoda zwraca. `false`  
  
 Oznacza to, <xref:System.Windows.Forms.Control.InvokeRequired%2A> że może `false` zwrócić <xref:System.Windows.Forms.Control.Invoke%2A> , jeśli nie jest to wymagane (wywołanie odbywa się w tym samym wątku) lub jeśli formant został utworzony w innym wątku, ale Uchwyt kontrolki nie został jeszcze utworzony.  
  
 W przypadku, gdy uchwyt kontrolki nie został jeszcze utworzony, nie należy po prostu wywoływać właściwości, metod ani zdarzeń w formancie. Może to spowodować utworzenie uchwytu kontrolki w wątku w tle, odizolowanie formantu od wątku bez pompki komunikatów i niestabilne działanie aplikacji.  
  
 W tym przypadku można chronić się przed tym przypadkiem, sprawdzając <xref:System.Windows.Forms.Control.IsHandleCreated%2A> wartość <xref:System.Windows.Forms.Control.InvokeRequired%2A> zwracaną `false` w wątku w tle. Jeśli uchwyt kontroli nie został jeszcze utworzony, przed wywołaniem <xref:System.Windows.Forms.Control.Invoke%2A> lub. <xref:System.Windows.Forms.Control.BeginInvoke%2A> Zazwyczaj dzieje się tak tylko wtedy, gdy wątek w tle jest tworzony w Konstruktorze formularza podstawowego dla aplikacji (w `Application.Run(new MainForm())`przypadku, gdy formularz zostanie wyświetlony lub `Application.Run` został wywołany.  
  
 Jednym z rozwiązań jest oczekiwanie na utworzenie uchwytu formularza przed rozpoczęciem wątku w tle. Wymuś tworzenie uchwytów przez wywołanie <xref:System.Windows.Forms.Control.Handle%2A> właściwości lub zaczekaj <xref:System.Windows.Forms.Form.Load> na zdarzenie, aby rozpocząć proces w tle.  
  
 Jeszcze lepszym rozwiązaniem jest użycie `SynchronizationContext` zwracanych przez <xref:System.Threading.SynchronizationContext> , a nie kontrolka do organizowania między wątkami.  
  
> [!NOTE]
>  Wyjątek może być zgłaszany, jeśli wątek, który powinien przetworzyć komunikat, nie jest już aktywny.  
  
 Aby uzyskać więcej informacji o wielowątkowych kontrolkach Windows Forms [, zobacz How to: Użyj wątku w tle, aby wyszukać [pliki](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md) i instrukcje: Ustaw bezpieczne dla wątków wywołania formantów](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)Windows Forms.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant jest widoczny dla aplikacji ułatwień dostępu.</summary>
        <value><see langword="true" />Jeśli formant jest widoczny dla aplikacji ułatwień dostępu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy formant został usunięty.</summary>
        <value><see langword="true" />Jeśli formant został usunięty; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość zwraca `true`, formant jest usuwany i nie może już być przywoływany jako prawidłowy formant systemu Windows. Mimo że wystąpienie formantu jest usunięte, nadal jest przechowywane w pamięci, dopóki nie zostanie usunięte z pamięci przez wyrzucanie elementów bezużytecznych. Gdy kontrolka zostanie usunięta, nie można wywołać jej <xref:System.Windows.Forms.Control.RecreateHandle%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy z kontrolką jest skojarzone dojście.</summary>
        <value><see langword="true" />Jeśli dojście zostało przypisane do kontrolki; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości <xref:System.Windows.Forms.Control.IsHandleCreated%2A> , aby określić, <xref:System.Windows.Forms.Control.CreateHandle%2A> czy został wywołany.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Znak do przetestowania.</param>
        <summary>Określa, czy znak jest znakiem wejściowym rozpoznawanym przez formant.</summary>
        <returns><see langword="true" />Jeśli znak powinien być wysyłany bezpośrednio do kontrolki i nie jest wstępnie przetworzony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `charCode` metodę, aby określić, czy znak określony przez parametr jest znakiem wejściowym żądanym przez formant. <xref:System.Windows.Forms.Control.IsInputChar%2A> Ta metoda jest wywoływana podczas przetwarzania wstępnego komunikatów w oknie, aby określić, czy określony znak wejściowy powinien zostać wstępnie przetworzony lub wysłany bezpośrednio do kontrolki. Jeśli <xref:System.Windows.Forms.Control.IsInputChar%2A> zwraca`true`, określony znak jest wysyłany bezpośrednio do kontrolki. Jeśli <xref:System.Windows.Forms.Control.IsInputChar%2A> zwraca`false`, określony znak jest wstępnie przetworzony i wysyłany tylko do kontrolki, jeśli nie jest używana przez fazę przetwarzania wstępnego. Przetwarzanie wstępne znaku polega na sprawdzeniu, czy znak jest elementem innej kontrolki.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Jedna z <see cref="T:System.Windows.Forms.Keys" /> wartości.</param>
        <summary>Określa, czy określony klucz jest zwykłym kluczem wejściowym, czy specjalnym kluczem wymagającym przetwarzania wstępnego.</summary>
        <returns><see langword="true" />Jeśli określony klucz jest zwykłym kluczem wejściowym; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj `keyData` metodę, aby określić, czy klucz określony przez parametr jest kluczem wejściowym, którego potrzebuje formant. <xref:System.Windows.Forms.Control.IsInputKey%2A> Ta metoda jest wywoływana podczas przetwarzania wstępnego komunikatów systemu Windows w celu ustalenia, czy określony klucz wejściowy powinien zostać wstępnie przetworzony lub wysłany bezpośrednio do kontrolki. Jeśli <xref:System.Windows.Forms.Control.IsInputKey%2A> zwraca`true`, określony klucz jest wysyłany bezpośrednio do kontrolki. Jeśli <xref:System.Windows.Forms.Control.IsInputKey%2A> zwraca`false`, określony klucz jest wstępnie przetworzony i wysyłany tylko do formantu, jeśli nie jest używany przez fazę przetwarzania wstępnego. Wstępnie przetworzone klucze obejmują tabulator, RETURN, ESC i strzałkę w górę, strzałkę w dół, strzałkę w lewo i klawisze strzałek w prawo.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak zastąpić <xref:System.Windows.Forms.Control.IsInputKey%2A> metodę <xref:System.Windows.Forms.TextBox> dla kontrolki. W tym przykładzie `TabTextBox` Klasa obsługuje klawisz Tab. `TabTextBox` Gdy ma fokus, a użytkownik naciśnie klawisz Tab cztery spacje są dodawane w punkcie wstawiania tekstu, zastępując dowolny zaznaczony tekst. Domyślnie <xref:System.Windows.Forms.TextBox> kontrolka obsługuje klawisz Tab, przenosząc fokus wprowadzania do następnej kontrolki. W takim przypadku naciśnięcie nigdy nie osiągnie <xref:System.Windows.Forms.Control.OnKeyDown%2A> metody override. Aby uniknąć tego zachowania domyślnego, <xref:System.Windows.Forms.Control.IsInputKey%2A> Metoda przesłania zwraca wartość `true` , gdy użytkownik naciśnie klawisz Tab. W przypadku wszystkich innych klawiszy <xref:System.Windows.Forms.Control.IsInputKey%2A> przesłonięcie metody zwraca wynik wywołania klasy bazowej metody.  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="keyVal">Caps Lock, NUM LOCK lub Scroll Lock w <see cref="T:System.Windows.Forms.Keys" /> wyliczeniu.</param>
        <summary>Określa, czy klawisz Caps Lock, NUM LOCK lub SCROLL LOCK jest aktywny.</summary>
        <returns><see langword="true" />Jeśli określony klucz lub klucze są stosowane; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.IsKeyLocked%2A> Użyj właściwości, aby określić, czy klucze Caps Lock, NUM LOCK lub Scroll Lock są włączone, niezależnie czy w połączeniu.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla komunikat informujący o tym, czy określony klucz (klawisz Caps Lock w tym przypadku) obowiązuje.  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="keyVal" /> Parametr odwołuje się do klucza innego niż Caps Lock, NUM LOCK lub Scroll Lock Key.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka jest duplikatem.</summary>
        <value><see langword="true" />Jeśli kontrolka jest dublowana; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka lustrzana wyświetla układ i tekst od prawej do lewej. Aby uzyskać więcej informacji, zobacz [jak: Tworzenie dublowanych Windows Forms i kontrolek](https://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">Znak do przetestowania.</param>
        <param name="text">Ciąg do wyszukania.</param>
        <summary>Określa, czy określony znak jest znakiem znaku przypisanym do kontrolki w określonym ciągu.</summary>
        <returns><see langword="true" />Jeśli znak jest znakiem znaku przypisanym do formantu; w przeciwnym razie <see langword="false" />,. <paramref name="charCode" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Znak jest znakiem bezpośrednio po pierwszym wystąpieniu "&" w <xref:System.String>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje rozszerzenie klasy Button, która zastępuje <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodę, aby wystawiać zachowanie niestandardowe. W przykładzie pokazano również, <xref:System.Windows.Forms.Control.CanSelect%2A> jak używać właściwości i. <xref:System.Windows.Forms.Control.IsMnemonic%2A> Aby uruchomić ten przykład, wklej poniższy kod po klasie form w tym samym pliku. Dodaj przycisk typu `MnemonicButton` do formularza.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po naciśnięciu klawisza, gdy kontrolka ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia klawiszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Aby obsłużyć zdarzenia klawiatury tylko na poziomie formularza i nie umożliwić innym kontrolkom odbierania zdarzeń klawiatury, należy <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> ustawić właściwość w metodzie <xref:System.Windows.Forms.Control.KeyPress> obsługi zdarzeń w formularzu na `true`. Niektóre klucze, takie jak karta, RETURN, ESC i klawisze strzałek są obsługiwane przez formanty automatycznie. Aby te klucze podnieść <xref:System.Windows.Forms.Control.KeyDown> zdarzenie, należy <xref:System.Windows.Forms.Control.IsInputKey%2A> zastąpić metodę w każdej kontrolce w formularzu. Kod przesłonięcia <xref:System.Windows.Forms.Control.IsInputKey%2A> musi określać, czy jeden z kluczy specjalnych zostanie nacionięty i zwraca `true`wartość. Zamiast przesłaniać <xref:System.Windows.Forms.Control.IsInputKey%2A> metodę, można <xref:System.Windows.Forms.Control.PreviewKeyDown> obsłużyć zdarzenie i ustawić <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> właściwość na `true`. Aby uzyskać przykład kodu, zobacz <xref:System.Windows.Forms.Control.PreviewKeyDown> zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyDown> zdarzenia do określenia typu znaku wprowadzonego w kontrolce.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
 Poniższy przykład kodu demonstruje kolejność <xref:System.Windows.Forms.Control.KeyDown>wywoływania, <xref:System.Windows.Forms.Control.KeyUp>, <xref:System.Windows.Forms.Control.KeyPress> zdarzeń i sposobu rejestrowania obsługi zdarzeń na nich.  
 
 [!code-csharp[Control.KeyDown#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyDown#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy znak. klawisz Backspace lub Backspace jest wciśnięty, gdy kontrolka ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia klawiszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Zdarzenie nie jest wywoływane przez klucze nieznakowe inne niż spacja i Backspace, jednak klucze niebędące znakami <xref:System.Windows.Forms.Control.KeyDown> powodują wystąpienie zdarzeń i <xref:System.Windows.Forms.Control.KeyUp>. <xref:System.Windows.Forms.Control.KeyPress>  
  
 Użyj właściwości <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> , aby próbkować naciśnięcia klawiszy w czasie wykonywania i wykorzystać lub zmodyfikować podzestaw wspólnych naciśnięć klawiszy.  
  
 Aby obsłużyć zdarzenia klawiatury tylko na poziomie formularza i nie umożliwić innym kontrolkom odbierania zdarzeń klawiatury, należy <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> ustawić właściwość w metodzie <xref:System.Windows.Forms.Control.KeyPress> obsługi zdarzeń w formularzu na `true`.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyPress> zdarzenia, aby zapobiec wprowadzaniu formantu przez znaki.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
  Poniższy przykład kodu demonstruje porządek wzrostu <xref:System.Windows.Forms.Control.KeyDown> <xref:System.Windows.Forms.Control.KeyUp> i zdarzeń, a <xref:System.Windows.Forms.Control.KeyPress> także sposoby rejestrowania na nich programów obsługi zdarzeń.  
 
 [!code-csharp[Control.KeyPress#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyPress#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy klucz zostanie wydzierżawiony, gdy kontrolka ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia klawiszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 Aby obsłużyć zdarzenia klawiatury tylko na poziomie formularza i nie umożliwić innym kontrolkom odbierania zdarzeń klawiatury, należy <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> ustawić właściwość w metodzie <xref:System.Windows.Forms.Control.KeyPress> obsługi zdarzeń w formularzu na `true`. Niektóre klucze, takie jak karta, RETURN, ESC i klawisze strzałek są obsługiwane przez formanty automatycznie. Aby te klucze podnieść <xref:System.Windows.Forms.Control.KeyUp> zdarzenie, należy <xref:System.Windows.Forms.Control.IsInputKey%2A> zastąpić metodę w każdej kontrolce w formularzu. Kod przesłonięcia <xref:System.Windows.Forms.Control.IsInputKey%2A> musi określać, czy jeden z kluczy specjalnych zostanie nacionięty i zwraca `true`wartość.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyUp> zdarzenia <xref:System.Windows.Forms.Help> z klasą w celu wyświetlenia pomocy dotyczącej stylu podręcznego dla użytkownika.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
 
 
  Poniższy przykład kodu demonstruje porządek wzrostu <xref:System.Windows.Forms.Control.KeyDown> <xref:System.Windows.Forms.Control.KeyUp> i zdarzeń, a <xref:System.Windows.Forms.Control.KeyPress> także sposoby rejestrowania na nich programów obsługi zdarzeń.  
 
 [!code-csharp[Control.KeyUp#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyUp#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy formant powinien zmienić położenie swoich formantów podrzędnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Layout> Zdarzenie występuje po dodaniu lub usunięciu formantów podrzędnych, gdy granice kontrolki zmienią się, a w przypadku innych zmian, które mogą wpływać na układ formantu. Zdarzenie układu można pominąć przy użyciu <xref:System.Windows.Forms.Control.SuspendLayout%2A> metod i. <xref:System.Windows.Forms.Control.ResumeLayout%2A> Zawieszenie układu pozwala wykonać wiele operacji na formancie bez konieczności egzekwowania układu dla każdej zmiany. Na przykład, jeśli zmienisz rozmiar i przeniesiesz kontrolkę, każda operacja <xref:System.Windows.Forms.Control.Layout> spowodowałaby wystąpienie zdarzenia.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest <xref:System.Windows.Forms.Form> wyśrodkowany na ekranie <xref:System.Windows.Forms.Control.Layout> w zdarzeniu. Dzięki temu formularz zostanie wyśrodkowany, gdy użytkownik zmieni jego rozmiar. Ten przykład wymaga, aby utworzono <xref:System.Windows.Forms.Form> formant.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera buforowane wystąpienie aparatu układu formantu.</summary>
        <value><see cref="T:System.Windows.Forms.Layout.LayoutEngine" /> Dla zawartości kontrolki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.LayoutEngine%2A> Właściwość pobiera aparat układu dla elementów podrzędnych formantu, a nie dla samego formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po usunięciu fokusu wprowadzania z formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
> [!NOTE]
>  Zdarzenia <xref:System.Windows.Forms.Control.Enter> i <xref:System.Windows.Forms.Control.Leave> sąpomijane<xref:System.Windows.Forms.Form> przez klasę. Odpowiednie zdarzenia w <xref:System.Windows.Forms.Form> klasie <xref:System.Windows.Forms.Form.Activated> to zdarzenia i <xref:System.Windows.Forms.Form.Deactivate> . Zdarzenia <xref:System.Windows.Forms.Control.Enter> i<xref:System.Windows.Forms.Control.Leave> są hierarchiczne i tworzą kaskadowe i w dół łańcucha nadrzędnego do momentu osiągnięcia odpowiedniej kontroli. Załóżmy na przykład, że <xref:System.Windows.Forms.Form> masz dwie <xref:System.Windows.Forms.GroupBox> kontrolki, a każda <xref:System.Windows.Forms.GroupBox> kontrolka ma jedną <xref:System.Windows.Forms.TextBox> kontrolkę. Gdy karetka jest przenoszona z <xref:System.Windows.Forms.TextBox> jednego do drugiego <xref:System.Windows.Forms.Control.Leave> , <xref:System.Windows.Forms.TextBox> zdarzenie jest zgłaszane dla i <xref:System.Windows.Forms.GroupBox>, a <xref:System.Windows.Forms.Control.Enter> zdarzenie jest zgłaszane dla drugiego <xref:System.Windows.Forms.GroupBox> i <xref:System.Windows.Forms.TextBox>.  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Aby uzyskać więcej informacji, zobacz temat [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Leave> zdarzenia do resetowania kontrolki do wcześniejszego stanu.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odległość (w pikselach) między lewą krawędzią kontrolki a lewą krawędzią obszaru klienckiego kontenera.</summary>
        <value><see cref="T:System.Int32" /> Reprezentujący odległość (w pikselach) między lewą krawędzią kontrolki a lewą krawędzią obszaru klienckiego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest równoznaczna <xref:System.Drawing.Point.X%2A?displayProperty=nameWithType> z właściwością <xref:System.Windows.Forms.Control.Location%2A> wartości właściwości formantu. <xref:System.Windows.Forms.Control.Left%2A>  
  
 Zmiany wprowadzone do <xref:System.Windows.Forms.Control.Width%2A> wartości właściwości <xref:System.Windows.Forms.Control.Left%2A> i powodują <xref:System.Windows.Forms.Control.Right%2A> zmianę wartości właściwości formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia współrzędne górnego lewego rogu kontrolki względem lewego górnego rogu jego kontenera.</summary>
        <value><see cref="T:System.Drawing.Point" /> Reprezentuje lewy górny róg kontrolki względem lewego górnego rogu jego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ Klasa jest typem wartości (`Structure` w Visual Basic, `struct` w wizualizacji C#), jest zwracana przez wartość, co oznacza, że dostęp do właściwości zwraca kopię lewego górnego rogu kontrolki. <xref:System.Drawing.Point> Dlatego <xref:System.Drawing.Point.X%2A> dostosowanie <xref:System.Windows.Forms.Control.Bottom%2A> lub <xref:System.Drawing.Point.Y%2A> właściwości <xref:System.Drawing.Point> zwracanejz<xref:System.Windows.Forms.Control.Top%2A>tej właściwości nie wpłynie na wartości właściwości <xref:System.Windows.Forms.Control.Right%2A> ,,,lub.<xref:System.Windows.Forms.Control.Left%2A> Aby dostosować te właściwości, ustaw każdą pojedynczą wartość właściwości lub ustaw <xref:System.Windows.Forms.Control.Location%2A> właściwość na nową. <xref:System.Drawing.Point>  
  
 <xref:System.Windows.Forms.Control> Jeśli jest<xref:System.Windows.Forms.Control.Location%2A> , wartość właściwości<xref:System.Windows.Forms.Form> reprezentuje lewy górny róg współrzędnej ekranu. <xref:System.Windows.Forms.Form>  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.GroupBox> i ustawia niektóre z jego wspólnych właściwości. Przykład tworzy i ustawia <xref:System.Windows.Forms.TextBox> jego <xref:System.Windows.Forms.Control.Location%2A> wartość w polu grupy. Następnie ustawia <xref:System.Windows.Forms.Control.Text%2A> właściwość pola Grupa i zadokuje pole grupy w górnej części formularza. W końcu wyłącza pole grupy przez ustawienie <xref:System.Windows.Forms.Control.Enabled%2A> właściwości na `false`, która powoduje wyłączenie wszystkich kontrolek zawartych w polu grupy.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.Control.Location" /> gdy wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Location%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub przez interakcję.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wywołuje <xref:System.Windows.Forms.Control.LocationChanged> zdarzenie <xref:System.Windows.Forms.StatusStrip> na, gdy zmieniany jest rozmiar formularza.  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public System.Drawing.Size LogicalToDeviceUnits (System.Drawing.Size value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size LogicalToDeviceUnits(valuetype System.Drawing.Size value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size LogicalToDeviceUnits(System::Drawing::Size value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Rozmiar do skalowania.</param>
        <summary>Przekształca rozmiar od logicznego do jednostek urządzeń przez skalowanie go dla bieżącej wartości DPI i Zaokrąglenie do najbliższej liczby całkowitej dla szerokości i wysokości.</summary>
        <returns>Rozmiar skalowany.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">Wartość logiczna do przekonwertowania.</param>
        <summary>Konwertuje wartość logicznej DPI na równoważną wartość DeviceUnit DPI.</summary>
        <returns>Uzyskana wartość DeviceUnit.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utracie fokusu przez formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Jeśli `true` Właściwość <xref:System.ComponentModel.CancelEventArgs> jest ustawiona na w delegatze<xref:System.Windows.Forms.Control.Validating> zdarzenia, wszystkie zdarzenia, które zwykle przechodzą po zdarzeniu są <xref:System.Windows.Forms.Control.Validating> pomijane.  
  
> [!NOTE]
>  Zdarzenia <xref:System.Windows.Forms.Control.GotFocus> i<xref:System.Windows.Forms.Control.LostFocus> to zdarzenia koncentracji niskiego poziomu, które są powiązane z WM_KILLFOCUS i WM_SETFOCUS komunikatów systemu Windows. Zazwyczaj zdarzenia i <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.LostFocus> są używane tylko w przypadku aktualizowania <xref:System.Windows.Forms.UICues> lub pisania formantów niestandardowych. <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Form.Deactivate> <xref:System.Windows.Forms.Form.Activated> Zamiast tego zdarzenia <xref:System.Windows.Forms.Control.Leave> ipowinnybyćużywanedlawszystkichkontrolekopróczklasy,któraużywazdarzeńi.<xref:System.Windows.Forms.Control.Enter> Aby uzyskać więcej informacji o <xref:System.Windows.Forms.Control.GotFocus> zdarzeniach <xref:System.Windows.Forms.Control.LostFocus> i, zobacz tematy dotyczące [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) i [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Aby uzyskać więcej informacji, zobacz temat [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx) .  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje walidację tekstu dla TextBox1. Pokazuje również obsługę <xref:System.Windows.Forms.Control.LostFocus> zdarzenia przez <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> ustawienie właściwości na tekst w TextBox1. Przykładowy kod użył <xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType> metody do wyszukania błędu przed otwarciem okna dialogowego plik. Aby uruchomić ten przykład, wklej następujący kod do formularza zawierającego <xref:System.Windows.Forms.TextBox> nazwane `TextBox1` <xref:System.Windows.Forms.Button> , <xref:System.Windows.Forms.OpenFileDialog> nazwane `OpenFileDialog1`, nazwane `Button1`i <xref:System.Windows.Forms.ErrorProvider> nazwane `ErrorProvider1`. Upewnij się, że wszystkie zdarzenia są skojarzone z ich obsługą zdarzeń.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odstęp między kontrolkami.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> Reprezentująca odstęp między kontrolkami.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolki otrzymują wartości domyślne <xref:System.Windows.Forms.Control.Margin%2A> dla, które są w rozsądny sposób zbliżone do wskazówek dotyczących interfejsu użytkownika systemu Windows. Niektóre zmiany mogą nadal być niezbędne dla określonych aplikacji.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Margin%2A> Ustawienie właściwości na zadokowanym formancie nie ma wpływu na odległość formantu od krawędzi jego kontenera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się margines formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.MarginChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.MarginChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar, który jest górnym limitem <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> , który może być określony.</summary>
        <value>Uporządkowana para typu <see cref="T:System.Drawing.Size" /> reprezentująca szerokość i wysokość prostokąta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar, który jest dolnym limitem <see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> , który może być określony.</summary>
        <value>Uporządkowana para typu <see cref="T:System.Drawing.Size" /> reprezentująca szerokość i wysokość prostokąta.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, która z klawiszy modyfikujących (SHIFT, CTRL i ALT) jest w stanie naciśniętym.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.Keys" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.Keys.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ukrywa przycisk po naciśnięciu klawisza CTRL, gdy przycisk zostanie kliknięty. Ten przykład wymaga, aby <xref:System.Windows.Forms.Button> nazwa została określona `button1` na. <xref:System.Windows.Forms.Form>  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, która z przycisków myszy jest w stanie naciśniętym.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.MouseButtons" /> wartości wyliczenia. Wartość domyślna to <see cref="F:System.Windows.Forms.MouseButtons.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.Control.BackColor%2A>kodu demonstruje <xref:System.Windows.Forms.Control.MouseButtons%2A> <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, jak używać elementów członkowskich, <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> ,,, i. <xref:System.Windows.Forms.Control.PointToScreen%2A> Aby uruchomić przykład, wklej następujący kod w formularzu o nazwie Form1 zawierającym kilka kontrolek. Ten przykład wymaga <xref:System.Windows.Forms.Control.MouseDown>, aby zdarzenia <xref:System.Windows.Forms.Control.MouseMove>, i <xref:System.Windows.Forms.Control.MouseUp> były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kontrolka utraci przechwytywanie myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W rzadkich scenariuszach może być konieczne wykrycie nieoczekiwanego danych wejściowych. Rozważmy na przykład następujące scenariusze.  
  
-   Podczas operacji myszy użytkownik otwiera menu Start, naciskając klawisz Windows lub CTRL + ESC.  
  
-   Podczas operacji myszy użytkownik przechodzi do innego programu, naciskając klawisze ALT + TAB.  
  
-   Podczas operacji myszy inny program wyświetla okno lub komunikat, który ma fokus od bieżącej aplikacji.  
  
 Operacje myszy mogą obejmować kliknięcie i przytrzymanie myszy na formularzu lub kontrolce lub wykonanie operacji przeciągania myszą. Jeśli konieczne jest wykrycie, gdy formularz lub formant utraci przechwycenie myszy dla tych i powiązanych nieoczekiwanych scenariuszy, można <xref:System.Windows.Forms.Control.MouseCaptureChanged> użyć zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.MouseCaptureChanged> zdarzenie <xref:System.Windows.Forms.Button> dla kontrolki.  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 Aby przetestować ten przykład, uruchom go w debugerze, naciskając klawisz F5. Otwórz okno **danych wyjściowych** w programie Visual Studio, aby zobaczyć, kiedy są zgłaszane zdarzenia. <xref:System.Windows.Forms.Button> Kliknij i zwróć uwagę na następujące dane wyjściowe.  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 Teraz kliknij i przytrzymaj lewy przycisk myszy na <xref:System.Windows.Forms.Button> kontrolce. Mimo że klikasz myszą, naciśnij klawisze ALT + TAB, aby przełączyć się do innego programu. Zwróć uwagę na <xref:System.Windows.Forms.Control.MouseCaptureChanged> to, że zdarzenie jest zgłaszane, umożliwiając potencjalnie obsługę tego scenariusza. W <xref:System.Windows.Forms.Control.MouseUp> zależności od akcji zdarzenie może nie zostać zgłoszone. Możesz również wypróbować ten test przy użyciu klawisza systemu Windows lub CTRL + ESC.  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po kliknięciu kontrolki myszą.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Naciśnięcie przycisku myszy, gdy kursor znajduje się nad kontrolką zwykle podnosi następującą serię zdarzeń z formantu:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown>wydarzen.  
  
2.  <xref:System.Windows.Forms.Control.Click>wydarzen.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick>wydarzen.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>wydarzen.  
  
 W takim przypadku nie można wyłączyć różnych zdarzeń w klasie formantu.  
  
 Dwa pojedyncze kliknięcia, które wystąpiły blisko czasu, zgodnie z ustawieniami myszy systemu operacyjnego użytkownika, wygenerują <xref:System.Windows.Forms.Control.MouseDoubleClick> zdarzenie zamiast drugiego <xref:System.Windows.Forms.Control.MouseClick> zdarzenia.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click>zdarzenia mają logiczne zdarzenia wyższego poziomu formantu. Często są one inicjowane przez inne czynności, takie jak naciśnięcie klawisza ENTER przy ustawionym fokusie na formancie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.MouseClick> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.MouseClick> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po dwukrotnym kliknięciu kontrolki przez mysz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MouseDoubleClick> Zdarzenie występuje, gdy użytkownik naciśnie przycisk myszy dwa razy w krótkim czasie, gdy kursor znajduje się nad kontrolką. Przedział czasu oddzielający dwa pojedyncze kliknięcia od dwukrotnego kliknięcia jest określany przez ustawienia myszy systemu operacyjnego użytkownika.  
  
 Następująca seria zdarzeń jest podnoszona przez kontrolkę, gdy ma miejsce taka akcja użytkownika:  
  
1.  <xref:System.Windows.Forms.Control.MouseDown>wydarzen.  
  
2.  <xref:System.Windows.Forms.Control.Click>wydarzen.  
  
3.  <xref:System.Windows.Forms.Control.MouseClick>wydarzen.  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>wydarzen.  
  
5.  <xref:System.Windows.Forms.Control.MouseDown>wydarzen.  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick>wydarzen.  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick>wydarzen.  
  
8.  <xref:System.Windows.Forms.Control.MouseUp>wydarzen.  
  
 W takim przypadku nie można wyłączyć różnych zdarzeń w klasie formantu.  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick>zdarzenia mają logiczne zdarzenia wyższego poziomu formantu. Mogą one być wywoływane przez inne akcje użytkownika, takie jak kombinacje klawiszy skrótów.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.MouseDoubleClick> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.MouseDoubleClick> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po umieszczeniu wskaźnika myszy nad formantem i naciśnięciu przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po umieszczeniu wskaźnika myszy na formancie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy zatrzyma się na dłużej na formancie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowym zastosowaniem <xref:System.Windows.Forms.Control.MouseHover> jest wyświetlenie etykietki narzędzia po zatrzymaniu myszy na kontrolce w określonym obszarze wokół formantu ("prostokąt aktywowany"). Wstrzymanie wymagane dla tego zdarzenia jest określone w milisekundach przez <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A> właściwość.  
  
 Zdarzenie jest definiowane i wykrywane w połączeniu <xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A> z właściwościami <xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>i. <xref:System.Windows.Forms.Control.MouseHover>  
  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po odsunięciu wskaźnika myszy znad formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przesunięciu wskaźnika myszy nad formantem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typowym zastosowaniem programu <xref:System.Windows.Forms.Control.MouseMove> jest zmiana koloru kontrolki lub malowanie podniesionym prostokątem wokół formantu.  
  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pozycję kursora myszy we współrzędnych ekranu.</summary>
        <value>A <see cref="T:System.Drawing.Point" /> , który zawiera współrzędne kursora myszy względem lewego górnego rogu ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość zwraca obiekt <xref:System.Drawing.Point> , który reprezentuje pozycję kursora myszy w czasie, do którego odwołuje się właściwość. <xref:System.Windows.Forms.Control.MousePosition%2A> Współrzędne wskazują położenie na ekranie, nie względem kontrolki i są zwracane bez względu na to, czy kursor znajduje się nad kontrolką. Współrzędne lewego górnego rogu ekranu to 0, 0.  
  
 Właściwość jest taka sama jak <xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType> właściwość. <xref:System.Windows.Forms.Control.MousePosition%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu umieszcza <xref:System.Windows.Forms.TreeNode> etykietę w stanie edytowalnym, gdy użytkownik naciśnie kombinację klawiszy ALT + E, gdy kursor myszy znajduje się nad węzłem drzewa. Po zakończeniu edycji etykiety przez użytkownika nie można ponownie edytować etykiet do momentu ponownego naciśnięcia kombinacji klawiszy ALT + E. Ten przykład wymaga, aby znajdował <xref:System.Windows.Forms.TreeView> się <xref:System.Windows.Forms.Form>na. Widok drzewa powinien również zawierać co najmniej jeden <xref:System.Windows.Forms.TreeNode> w swojej <xref:System.Windows.Forms.TreeView.Nodes%2A> kolekcji.  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po umieszczeniu wskaźnika myszy nad formantem i zwolnieniu przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  Następujące zdarzenia nie są wywoływane dla klasy, <xref:System.Windows.Forms.TabControl> chyba że w <xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType> kolekcji znajduje się przynajmniej <xref:System.Windows.Forms.TabPage> jedna z nich: <xref:System.Windows.Forms.Control.Click>, <xref:System.Windows.Forms.Control.DoubleClick>, <xref:System.Windows.Forms.Control.MouseDown> <xref:System.Windows.Forms.Control.MouseUp> <xref:System.Windows.Forms.Control.MouseHover> <xref:System.Windows.Forms.Control.MouseEnter>,,, <xref:System.Windows.Forms.Control.MouseLeave> i .<xref:System.Windows.Forms.Control.MouseMove> Jeśli w kolekcji znajduje się co <xref:System.Windows.Forms.TabPage> najmniej jeden, a użytkownik współdziała z nagłówkiem kontrolki karta ( <xref:System.Windows.Forms.TabPage> gdzie pojawiają się <xref:System.Windows.Forms.TabControl> nazwy), wywołuje odpowiednie zdarzenie. Jeśli jednak interakcja użytkownika znajduje się w obszarze klienta strony karty, <xref:System.Windows.Forms.TabPage> wywołuje odpowiednie zdarzenie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przesunięciu kółka myszy, gdy kontrolka ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas obsługi <xref:System.Windows.Forms.Control.MouseWheel> zdarzenia ważne jest przestrzeganie standardów interfejsu użytkownika (UI) skojarzonych z kółkiem myszy. Wartość <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType> właściwości wskazuje ilość przenoszonego kółka myszy. Interfejs użytkownika powinien być przewijany, gdy skumulowana różnica wynosi Plus lub minus 120. Interfejs użytkownika powinien przewinąć liczbę wierszy logicznych zwracanych przez <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> właściwość dla każdej osiągniętej wartości delty. Możesz również przewinąć bardziej płynnie w mniejszym stopniu 120 jednostek, jednak współczynnik powinien pozostać stałą, czyli <xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType> linie przewijane na 120 jednostek zmian koła.  
  
 Aby uzyskać więcej informacji o obsłudze komunikatów kółka myszy, zobacz temat [WM_MOUSEWHEEL](https://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx) .  
  
 Zdarzenia myszy zachodzą w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie różnych zdarzeń myszy do rysowania ścieżki myszy na <xref:System.Windows.Forms.Panel>. Segment linii jest dodawany do <xref:System.Drawing.Drawing2D.GraphicsPath> dla każdego <xref:System.Windows.Forms.Control.MouseMove> i <xref:System.Windows.Forms.Control.MouseDown> zdarzenia, które wystąpiły. <xref:System.Windows.Forms.Control.Invalidate%2A> Aby zaktualizować grafikę, metoda jest wywoływana <xref:System.Windows.Forms.Panel> dla każdego `MouseDown` zdarzenia i `MouseUp` . Ponadto ścieżka graficzna jest przewijana w górę lub w dół w przypadku <xref:System.Windows.Forms.Control.MouseWheel> wystąpienia zdarzenia. Dodatkowe zdarzenia myszy, takie <xref:System.Windows.Forms.Control.MouseHover>jak, są również identyfikowane na ekranie. Również wyświetlane na ekranie są dodatkowymi informacjami na temat myszy z <xref:System.Windows.Forms.SystemInformation> klasy.  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po przeniesieniu formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Move> zdarzenia do wyświetlania lokalizacji formularza we współrzędnych ekranu na pasku podpisu formularza.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę formantu.</summary>
        <value>Nazwa formantu. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Name%2A> Właściwość może być używana w czasie wykonywania do oszacowania obiektu według nazwy, a nie typu i nazwy programowanej. `Select` `switch` C# [!INCLUDE[vcprvc](~/includes/vcprvc-md.md)]Ponieważ właściwość zwraca typ, może być oceniona w instrukcjach logiki w stylu Case (instrukcja w Visual Basic, instrukcja w wizualizacji i). <xref:System.String> <xref:System.Windows.Forms.Control.Name%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla <xref:System.Windows.Forms.Control.Name%2A> kontrolkę <xref:System.Windows.Forms.MessageBox> w czasie, gdy kontrolka jest dodawana lub usuwana z formularza.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea"><see cref="T:System.Drawing.Rectangle" /> Reprezentujący obszar do unieważnienia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Invalidated" /> Podnosi zdarzenie z określonym regionem kontrolki do unieważnienia.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.AutoSizeChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.CausesValidationChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.UICuesEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ChangeUICues" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnChangeUICues%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Click" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnClick%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje zastępowanie <xref:System.Windows.Forms.Control.OnClick%2A> metody w klasie pochodnej. Aby uruchomić przykład, wklej poniższy kod po klasie form w tym samym pliku. Dodaj pole tekstowe typu `SingleClickTextBox` do formularza.  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 Poniższy przykład kodu pokazuje jeden z wielu użycia <xref:System.Windows.Forms.Control.Click> zdarzeń i obsługi zdarzeń.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ClientSizeChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.ControlEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlAdded" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana, gdy do formantu zostanie dodany formant podrzędny.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnControlAdded%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.ControlAdded> do dodawania kontrolki do formularza i wyświetlania nazwy dodanej kontrolki <xref:System.Windows.Forms.MessageBox>w.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.ControlEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlRemoved" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływana, gdy formant podrzędny zostanie usunięty z formantu.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnControlRemoved%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.ControlRemoved> do usuwania kontrolki z formularza i wyświetlania nazwy usuniętej kontrolki <xref:System.Windows.Forms.MessageBox>w.  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.CreateControl" /> Podnosi metodę.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A> Metoda jest wywoływana, gdy formant jest tworzony po raz pierwszy.  
  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnCursorChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DockChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDockChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DoubleClick" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDoubleClick%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu <xref:System.Windows.Forms.Control.DoubleClick> używa zdarzenia <xref:System.Windows.Forms.ListBox> do ładowania plików <xref:System.Windows.Forms.ListBox> tekstowych <xref:System.Windows.Forms.TextBox> wymienionych w kontrolce do formantu.  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.DpiChangedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDragDrop%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDragEnter%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDragLeave%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnDragOver%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.EnabledChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Enter" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnEnter%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Enter> zdarzenia, aby zmienić kolor pierwszego planu i tła <xref:System.Windows.Forms.TextBox> w określonych warunkach.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnFontChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">A <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.GiveFeedback" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.GotFocus" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnGotFocus%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnHandleCreated%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">A <see cref="T:System.Windows.Forms.HelpEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HelpRequested" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnHelpRequested%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ImeModeChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.InvalidateEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Invalidated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnInvalidated%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyDown" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnKeyDown%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyDown> zdarzenia do określenia typu znaku wprowadzonego w kontrolce.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyPress" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnKeyPress%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyPress> zdarzenia, aby zapobiec wprowadzaniu formantu przez znaki.  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyUp" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnKeyUp%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.KeyUp> zdarzenia <xref:System.Windows.Forms.Help> z klasą w celu wyświetlenia pomocy dotyczącej stylu podręcznego dla użytkownika.  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">A <see cref="T:System.Windows.Forms.LayoutEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Layout" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnLayout%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierali zdarzenie i dla typowych funkcji dokowania i zakotwiczania do pracy. Klasy pochodne powinny zastąpić tę metodę, aby wykonać dowolną niestandardową logikę układu.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Leave" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnLeave%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Leave> zdarzenia do resetowania kontrolki do wcześniejszego stanu.  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.LocationChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnLocationChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.LostFocus" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnLostFocus%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MarginChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMarginChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.MouseEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseClick" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseClick%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.MouseEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDoubleClick" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDown" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseDown%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseEnter" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseEnter%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseHover" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseHover%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób przesłania <xref:System.Windows.Forms.Control.OnMouseHover%2A> metod i <xref:System.Windows.Forms.Control.OnMouseMove%2A> w klasie pochodnej. Aby uruchomić ten przykład, wklej poniższy kod w nowym formularzu i wklej tę klasę, tworząc ten sam plik po formularzu. Dodaj przycisk typu `FunButton` do formularza.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseLeave" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseLeave%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseMove" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseMove%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób przesłania <xref:System.Windows.Forms.Control.OnMouseHover%2A> metod i <xref:System.Windows.Forms.Control.OnMouseMove%2A> w klasie pochodnej. Aby uruchomić ten przykład, wklej poniższy kod w nowym formularzu i wklej tę klasę, tworząc ten sam plik po formularzu. Dodaj przycisk typu `FunButton` do formularza.  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseUp" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseUp%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseWheel" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMouseWheel%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Move" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnMove%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Move> zdarzenia do wyświetlania lokalizacji formularza we współrzędnych ekranu na pasku podpisu formularza.  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> Reprezentuje komunikat systemu Windows.</param>
        <summary>Powiadamia o kontroli komunikatów systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Windows.Forms.Control.OnNotifyMessage%2A> jest wywoływana, jeśli bit `EnableNotifyMessage` stylu kontrolki jest ustawiony w <xref:System.Windows.Forms.ControlStyles>. Styl w programie <xref:System.Windows.Forms.ControlStyles> umożliwia powiadomienia, gdy <xref:System.Windows.Forms.Control.WndProc%2A> Metoda odbierze komunikat systemu Windows. `EnableNotifyMessage` Dzięki tej metodzie częściowo zaufane formanty mogą nasłuchiwać komunikatów systemu Windows bez włączania ich do modyfikowania komunikatów.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> w klasie pochodnej wywoływanie <see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" /> metody klasy bazowej nie jest konieczne, ponieważ nie istnieje początkowa implementacja.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.PaddingChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnPaint%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikowi przeciąganie obrazu lub pliku obrazu do formularza i wyświetlanie go w miejscu, w którym został porzucony. <xref:System.Windows.Forms.Control.OnPaint%2A> Metoda jest zastępowana, aby odświeżyć obraz za każdym razem, gdy formularz zostanie namalowany; w przeciwnym razie obraz będzie trwał dopiero po następnym odświeżeniu. Metoda <xref:System.Windows.Forms.Control.DragEnter> obsługi zdarzeń określa typ danych, które są przeciągane do formularza i zawiera odpowiednie informacje zwrotne. Metoda obsługi <xref:System.Drawing.Image> zdarzeń wyświetla obraz w formularzu, jeśli można go utworzyć na podstawie danych. <xref:System.Windows.Forms.Control.DragDrop> Ponieważ wartości <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.PointToClient%2A> i są współrzędnymi ekranu, w przykładzie używa się metody do konwertowania ich na współrzędne klienta. <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera informacje o kontrolce do malowania.</param>
        <summary>Maluje tło formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnPaintBackground%2A> Metoda włącza klasy pochodne do obsługi żądań wymazania w tle systemu Windows.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Dziedziczenie klas powinno przesłaniać tę metodę w celu obsługi żądania wymazania w tle z systemu Windows. Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> w klasie pochodnej nie trzeba wywoływać <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />klasy bazowej.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.BackColor" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.BackColorChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.BindingContext" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.ParentChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.Enabled" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.EnabledChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.Font" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.FontChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentFontChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.ForeColor" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.RightToLeft" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Podnosi zdarzenie, gdy wartość <see cref="P:System.Windows.Forms.Control.Visible" /> właściwości kontenera formantu zostanie zmieniona. <see cref="E:System.Windows.Forms.Control.VisibleChanged" /></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.PreviewKeyDown" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `UserPaint` Jeśli bit <xref:System.Windows.Forms.ControlStyles> jest ustawiony, można przesłonić <xref:System.Windows.Forms.Control.OnPrint%2A> do rysowania warstwowego. Aby uzyskać więcej informacji, zobacz <xref:System.Windows.Forms.Control.SetStyle%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="e" /></exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">A <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.QueryContinueDrag" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po rozpoczęciu przeciągania ta metoda jest wywoływana wielokrotnie przez, [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] dopóki operacja przeciągania nie zostanie anulowana lub ukończona.  
  
> [!NOTE]
>  Zastąp tę metodę, jeśli chcesz zmienić punkt, w którym przeciąganie zostało anulowane lub w którym występuje porzucanie.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.RegionChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnRegionChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnResize%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie. Metodę można wywołać w czasie konstruowania, dlatego jeśli przesłonięcie <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> może być wywołane przed wywołaniem konstruktora sterowania. <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /></para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.SizeChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnSizeChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.StyleChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnStyleChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabIndexChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabStopChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnTabStopChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnTextChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnValidated%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.CancelEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validating" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnValidating%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.VisibleChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.Control.OnVisibleChanged%2A> Metoda włącza również klasy pochodne do obsługi zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
   
  
## Examples  
 Poniższy przykład kodu jest metodą podnoszenia zdarzeń, która jest wykonywana, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` `On` ** `Changed` ** Klasa ma kilka metod o nazwie PropertyName wzorca nazwy, która wywołuje odpowiednie zdarzenie PropertyName w przypadku zmiany wartości PropertyName ( <xref:System.Windows.Forms.Control>  *PropertyName* reprezentuje nazwę odpowiedniej właściwości.  
  
 Poniższy przykład kodu zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> <xref:System.Windows.Forms.TextBox> klasy pochodnej wyświetlającej dane walutowe. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga, aby masz klasę, która dziedziczy z <xref:System.Windows.Forms.TextBox> klasy.  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia uzupełnienie w kontrolce.</summary>
        <value><see cref="T:System.Windows.Forms.Padding" /> Reprezentujący charakterystykę wewnętrznych odstępów formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku kontenerów <xref:System.Windows.Forms.GroupBox> , <xref:System.Windows.Forms.TabControl>takich jak <xref:System.Windows.Forms.Control.Padding%2A> i, Właściwość pobiera lub ustawia <xref:System.Windows.Forms.Control.DisplayRectangle%2A> odpowiednie właściwości. Właściwość jest równa jego <xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType> właściwości. <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType>  
  
 Kontrolki otrzymują wartości domyślne <xref:System.Windows.Forms.Control.Padding%2A> dla, które są w rozsądny sposób zbliżone do wskazówek dotyczących interfejsu użytkownika systemu Windows. Niektóre zmiany mogą nadal być niezbędne dla określonych aplikacji.  
  
 Wszystkie kontrolki, <xref:System.Windows.Forms.Control.GetPreferredSize%2A> które implementują, są powiększone <xref:System.Windows.Forms.Control.Padding%2A> o kwotę `true`w czasie gdy <xref:System.Windows.Forms.Control.AutoSize%2A> jest.  
  
 Następujące kontrolki nie są używane <xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   Kontrolki, które nie <xref:System.Windows.Forms.Control.AutoSize%2A> są implementowane przez<xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   Formanty niestandardowe, które dziedziczą się bezpośrednio z<xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się dopełnienie kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.PaddingChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.PaddingChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po odświeżeniu formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Paint> Zdarzenie jest zgłaszane, gdy kontrolka zostanie narysowana ponownie. Przekazuje ono wystąpienie <xref:System.Windows.Forms.PaintEventArgs> do metod, które <xref:System.Windows.Forms.Control.Paint> obsługują zdarzenie.  
  
 Podczas tworzenia nowej kontrolki niestandardowej lub dziedziczonej kontrolki przy użyciu innego wyglądu wizualizacji, należy dostarczyć kod, aby renderować formant, zastępując <xref:System.Windows.Forms.Control.OnPaint%2A> metodę. Aby uzyskać więcej informacji, zobacz [przesłanianie metody OnPaint](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md) i [malowanie i renderowanie kontrolek niestandardowych](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md).  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.PictureBox> kontrolkę w formularzu i <xref:System.Windows.Forms.Control.Paint> używa zdarzenia do narysowania.  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontener nadrzędny formantu.</summary>
        <value><see cref="T:System.Windows.Forms.Control" /> Reprezentujący kontrolkę nadrzędną lub kontenerową formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie wartości `null` <xref:System.Windows.Forms.Control.ControlCollection> właściwości na wartość usuwa formant z bieżącej kontrolki nadrzędnej. <xref:System.Windows.Forms.Control.Parent%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.Control.Parent%2A> właściwości <xref:System.Windows.Forms.Control.FindForm%2A> i metody do ustawiania właściwości kontrolki nadrzędnej przycisku i jego formularza.  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby uzyskać tę wartość właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.Parent" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Parent%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wymusza stosowanie przez formant logiki układu do formantów podrzędnych.</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza stosowanie logiki układu do wszystkich jej formantów podrzędnych przez formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda została wywołana przed <xref:System.Windows.Forms.Control.PerformLayout%2A> wywołaniem metody, <xref:System.Windows.Forms.Control.Layout> zdarzenie jest pomijane. <xref:System.Windows.Forms.Control.SuspendLayout%2A>  
  
 `null` Właściwości <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> i<xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A>dlautworzonychsą ustawiane<xref:System.Windows.Forms.Control.PerformLayout%2A> na, jeśli nie podano żadnych wartości podczas wywołania metody. <xref:System.Windows.Forms.LayoutEventArgs>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.Control.PerformLayout%2A> metody. Przedstawiono w nim również sposoby, w <xref:System.Windows.Forms.Control.Layout> których zdarzenie jest zgłaszane. W tym przykładzie `Click` procedura obsługi zdarzeń dla `Button1` jawnych wywołań <xref:System.Windows.Forms.Control.PerformLayout%2A>. Procedura obsługi `Button2` zdarzeń dla niejawnie wywoływanych wywołań <xref:System.Windows.Forms.Control.PerformLayout%2A>. `Click` <xref:System.Windows.Forms.Control.PerformLayout%2A>jest również wywoływana, gdy formularz zostanie załadowany. `Button3`zwraca formant do stanu, w którym został załadowany. W każdym przypadku <xref:System.Windows.Forms.Control.Layout> zdarzenie jest zgłaszane.  
  
 Jest to kompletny przykład. Aby uruchomić przykład, wklej następujący kod w pustym formularzu.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl"><see cref="T:System.Windows.Forms.Control" /> Reprezentujący ostatnio zmieniony formant.</param>
        <param name="affectedProperty">Nazwa ostatnio zmienionej właściwości formantu.</param>
        <summary>Wymusza stosowanie logiki układu do wszystkich jej formantów podrzędnych przez formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli metoda została wywołana przed <xref:System.Windows.Forms.Control.PerformLayout%2A> wywołaniem metody, <xref:System.Windows.Forms.Control.Layout> zdarzenie jest pomijane. <xref:System.Windows.Forms.Control.SuspendLayout%2A>  
  
 Oba parametry `affectedProperty`imogą być ustawione na `null`wartość. `affectedControl` Wykonanie tej czynności powoduje <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A> , <xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A> że i właściwości <xref:System.Windows.Forms.LayoutEventArgs> utworzone do `null`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.Control.PerformLayout%2A> metody. Przedstawiono w nim również sposoby, w <xref:System.Windows.Forms.Control.Layout> których zdarzenie jest zgłaszane. W tym przykładzie `Click` procedura obsługi zdarzeń dla `Button1` jawnych wywołań <xref:System.Windows.Forms.Control.PerformLayout%2A>. Procedura obsługi `Button2` zdarzeń dla niejawnie wywoływanych wywołań <xref:System.Windows.Forms.Control.PerformLayout%2A>. `Click` <xref:System.Windows.Forms.Control.PerformLayout%2A>jest również wywoływana, gdy formularz zostanie załadowany. `Button3`zwraca formant do stanu, w którym został załadowany. W każdym przypadku <xref:System.Windows.Forms.Control.Layout> zdarzenie jest zgłaszane.  
  
 Jest to kompletny przykład. Aby uruchomić przykład, wklej następujący kod w pustym formularzu.  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Współrzędna <see cref="T:System.Drawing.Point" /> ekranu do przekonwertowania.</param>
        <summary>Oblicza lokalizację określonego punktu ekranu na współrzędnych klienta.</summary>
        <returns>Reprezentujący przekonwertowane <see cref="T:System.Drawing.Point" />, <paramref name="p" />w współrzędnej klienta. <see cref="T:System.Drawing.Point" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikowi przeciąganie obrazu lub pliku obrazu do formularza i wyświetlanie go w momencie, gdy zostanie on usunięty. <xref:System.Windows.Forms.Control.OnPaint%2A> Metoda jest zastępowana, aby odświeżyć obraz za każdym razem, gdy formularz zostanie namalowany; w przeciwnym razie obraz będzie trwał dopiero po następnym odświeżeniu. Metoda <xref:System.Windows.Forms.Control.DragEnter> obsługi zdarzeń określa typ danych, które są przeciągane do formularza i zawiera odpowiednie informacje zwrotne. Metoda obsługi <xref:System.Drawing.Image> zdarzeń wyświetla obraz w formularzu, jeśli można go utworzyć na podstawie danych. <xref:System.Windows.Forms.Control.DragDrop> Ponieważ wartości <xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.PointToClient%2A> i są współrzędnymi ekranu, w przykładzie używa się metody do konwertowania ich na współrzędne klienta. <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">Koordynuje <see cref="T:System.Drawing.Point" /> klienta do konwersji.</param>
        <summary>Obliczy lokalizację określonego punktu klienta we współrzędnych ekranu.</summary>
        <returns>Reprezentujący przekonwertowane <see cref="T:System.Drawing.Point" />, <paramref name="p" />, we współrzędnych ekranu. <see cref="T:System.Drawing.Point" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.Control.BackColor%2A>kodu demonstruje <xref:System.Windows.Forms.Control.MouseButtons%2A> <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, jak używać elementów członkowskich, <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> ,,, i. <xref:System.Windows.Forms.Control.PointToScreen%2A> Aby uruchomić przykład, wklej następujący kod w formularzu o nazwie Form1 zawierającym kilka kontrolek. Ten przykład wymaga <xref:System.Windows.Forms.Control.MouseDown>, aby zdarzenia <xref:System.Windows.Forms.Control.MouseMove>, i <xref:System.Windows.Forms.Control.MouseUp> były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar prostokątnego obszaru, do którego można dopasować formant.</summary>
        <value><see cref="T:System.Drawing.Size" /> Zawierający wysokość i szerokość (w pikselach).</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage :  -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg"><see cref="T:System.Windows.Forms.Message" /> Reprezentuje komunikat do przetworzenia.</param>
        <summary>Wstępnie przetwarza komunikaty klawiatury i komunikaty wejściowe w obrębie pętli komunikatów przed ich wysłaniem.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.PreProcessControlState" /> wartości, w zależności od tego, <see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> czy <see langword="true" /> <see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> <see langword="false" /> <see langword="true" /> jest, czy <see langword="false" /> i czy lub czy lub.<see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage :  -&gt; bool&#xA;override this.PreProcessMessage :  -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat do przetworzenia. Możliwe wartości to PRZETŁUMACZYŁA, WM_SYSKEYDOWN, WM_CHAR i WM_SYSCHAR.</param>
        <summary>Wstępnie przetwarza komunikaty klawiatury i komunikaty wejściowe w obrębie pętli komunikatów przed ich wysłaniem.</summary>
        <returns><see langword="true" />Jeśli komunikat został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A>jest wywoływana przez pętlę komunikatów aplikacji w celu wstępnego przetworzenia komunikatów wejściowych przed ich wysłaniem. Możliwe wartości `msg` parametru to przetłumaczyła, WM_SYSKEYDOWN, WM_CHAR i WM_SYSCHAR.  
  
 Podczas zastępowania <xref:System.Windows.Forms.Control.PreProcessMessage%2A>formant powinien powrócić `true` , aby wskazać, że przetworzył komunikat. W przypadku wiadomości, które nie są przetwarzane przez formant, wynik `base.PreProcessMessage` powinien zostać zwrócony. Formanty zwykle przesłonią jedną z bardziej <xref:System.Windows.Forms.Control.IsInputChar%2A>wyspecjalizowanych metod <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>, takich <xref:System.Windows.Forms.Control.IsInputKey%2A>jak, <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>,, <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> lub zamiast przesłaniać. <xref:System.Windows.Forms.Control.PreProcessMessage%2A>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla bezpośredniego wywołującego, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed <see cref="E:System.Windows.Forms.Control.KeyDown" /> zdarzeniem po naciśnięciu klawisza, gdy fokus jest ustawiony na tym formancie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre naciśnięcia klawiszy, takie jak TAB, RETURN, ESC i klawiszy strzałek, są zwykle ignorowane przez niektóre kontrolki, ponieważ nie są one uznawane za naciskanie klawiszy wejściowych. Na przykład domyślnie <xref:System.Windows.Controls.Button> formant ignoruje klawisze strzałek. Naciśnięcie klawiszy strzałek zazwyczaj powoduje przejście fokusu do poprzedniej lub następnej kontrolki. Klawisze strzałek są uważane za klawisze nawigacyjne i naciskając te klucze zazwyczaj nie powodują <xref:System.Windows.Forms.Control.KeyDown> zdarzenia. <xref:System.Windows.Controls.Button> Jednak naciśnięcie klawiszy strzałek dla elementu <xref:System.Windows.Controls.Button> powoduje <xref:System.Windows.Forms.Control.PreviewKeyDown> wystąpienie zdarzenia. <xref:System.Windows.Forms.Control.PreviewKeyDown> Przez obsługę <xref:System.Windows.Forms.Control.KeyDown> zdarzenia <xref:System.Windows.Controls.Button> dla i ustawienie <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> właściwości na `true`, można podnieść zdarzenie po naciśnięciu klawiszy strzałek. Jednak w przypadku obsługi klawiszy strzałek fokus nie będzie już przenoszony do poprzedniej lub następnej kontrolki.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.Button> , że <xref:System.Windows.Forms.ContextMenuStrip>zawiera. Gdy ma fokus i naciśniesz strzałkę w górę lub strzałkę w dół <xref:System.Windows.Forms.ContextMenuStrip> , pojawia się okno. <xref:System.Windows.Forms.Button> Program obsługi <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> `true`zdarzeń wykrywa, kiedy naciśnięto klawisze STRZAŁKA w górę lub Strzałka w dół i ustawia właściwość na. <xref:System.Windows.Forms.Control.PreviewKeyDown> Wywołuje <xref:System.Windows.Forms.Control.KeyDown> to zdarzenie, aby można było <xref:System.Windows.Forms.ContextMenuStrip>wyświetlić. Nie należy umieszczać żadnych logiki w programie <xref:System.Windows.Forms.Control.PreviewKeyDown> obsługi zdarzeń, oprócz <xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A> ustawiania właściwości. Zamiast tego należy umieścić logikę w programie <xref:System.Windows.Forms.Control.KeyDown> obsługi zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat okna do przetworzenia.</param>
        <param name="keyData">Jedna z <see cref="T:System.Windows.Forms.Keys" /> wartości reprezentujących klucz do przetworzenia.</param>
        <summary>Przetwarza klucz polecenia.</summary>
        <returns><see langword="true" />Jeśli znak został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana podczas przetwarzania wstępnego komunikatów w celu obsługi kluczy poleceń. Klucze poleceń to klucze, które zawsze mają pierwszeństwo przed zwykłymi kluczami wejściowymi. Przykłady kluczy poleceń zawierają akceleratory i skróty menu. Metoda musi zostać zwrócona `true` , aby wskazać, że przetworzył klucz polecenia, lub `false` aby wskazać, że klucz nie jest kluczem polecenia. Ta metoda jest wywoływana tylko wtedy, gdy kontrolka jest hostowana w aplikacji Windows Forms lub jako Kontrolka ActiveX.  
  
 Metoda najpierw określa <xref:System.Windows.Forms.ContextMenu>, czy kontrolka ma, i <xref:System.Windows.Forms.ContextMenu> Jeśli tak, umożliwia przetworzenie klucza polecenia. <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> Jeśli klucz polecenia nie jest skrótem menu, a kontrolka ma element nadrzędny, ten klucz jest przesyłany do <xref:System.Windows.Forms.Control.ProcessCmdKey%2A> metody elementu nadrzędnego. Efektem netto jest to, że klucze poleceń są "bąbelkowe" w hierarchii formantów. Oprócz klawisza naciśniętego przez użytkownika, dane klucza wskazują również, które klucze modyfikatorów zostały naciśnięte w tym samym czasie co klucz. Klawisze modyfikujące obejmują klawisze SHIFT, CTRL i ALT.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośrednich wywołujących i dziedziczących klas do wywołania tej metody. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> metody w klasie pochodnej formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył klucz. W przypadku kluczy, które nie są przetwarzane przez formant, należy zwrócić wynik wywołania <see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" /> metody klasy bazowej. Kontrolki będą rzadko, jeśli kiedykolwiek trzeba przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Znak do przetworzenia.</param>
        <summary>Przetwarza znak okna dialogowego.</summary>
        <returns><see langword="true" />Jeśli znak został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana podczas przetwarzania wstępnego komunikatów w celu obsługi znaków okna dialogowego, takich jak znaki kontrolne. Ta metoda jest wywoływana tylko wtedy, <xref:System.Windows.Forms.Control.IsInputChar%2A> gdy metoda wskazuje, że formant nie przetwarza znaku. Metoda po prostu wysyła znak do <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> metody elementu nadrzędnego lub zwraca `false` , jeśli formant nie ma elementu nadrzędnego. <xref:System.Windows.Forms.Control.ProcessDialogChar%2A> <xref:System.Windows.Forms.Form> Klasa zastępuje tę metodę, aby wykonać rzeczywiste przetwarzanie znaków okna dialogowego. Ta metoda jest wywoływana tylko wtedy, gdy kontrolka jest hostowana w aplikacji Windows Forms lub jako Kontrolka ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> metody w klasie pochodnej formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył znak. W przypadku znaków, które nie są przetwarzane przez formant, należy zwrócić wynik wywołania <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> metody klasy bazowej. Kontrolki będą rzadko, jeśli kiedykolwiek trzeba przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Jedna z <see cref="T:System.Windows.Forms.Keys" /> wartości reprezentujących klucz do przetworzenia.</param>
        <summary>Przetwarza klucz okna dialogowego.</summary>
        <returns><see langword="true" />Jeśli klucz został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana podczas przetwarzania wstępnego komunikatów w celu obsługi znaków okna dialogowego, takich jak TAB, RETURN, ESC i klawiszy strzałek. Ta metoda jest wywoływana tylko wtedy, <xref:System.Windows.Forms.Control.IsInputKey%2A> gdy metoda wskazuje, że formant nie przetwarza klucza. Po prostu wysyła znak do <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> metody elementu nadrzędnego lub zwraca `false` , jeśli formant nie ma elementu nadrzędnego. <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> <xref:System.Windows.Forms.Form> Klasa zastępuje tę metodę, aby wykonać rzeczywiste przetwarzanie kluczy okna dialogowego. Ta metoda jest wywoływana tylko wtedy, gdy kontrolka jest hostowana w aplikacji Windows Forms lub jako Kontrolka ActiveX.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" /> metody w klasie pochodnej formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył klucz. W przypadku kluczy, które nie są przetwarzane przez formant, należy zwrócić wynik wywołania <see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" /> metody klasy bazowej. Kontrolki będą rzadko, jeśli kiedykolwiek trzeba przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs :  -&gt; bool&#xA;override this.ProcessKeyEventArgs :  -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat okna do przetworzenia.</param>
        <summary>Przetwarza komunikat klucza i generuje odpowiednie zdarzenia sterujące.</summary>
        <returns><see langword="true" />Jeśli komunikat został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy kontrolka odbierze komunikat z klawiatury. Metoda jest odpowiedzialna za generowanie odpowiednich kluczowych zdarzeń dla wiadomości przez wywołanie <xref:System.Windows.Forms.Control.OnKeyPress%2A>metod, <xref:System.Windows.Forms.Control.OnKeyDown%2A>lub <xref:System.Windows.Forms.Control.OnKeyUp%2A> . `m` Parametr zawiera komunikat okna, który musi zostać przetworzony. Możliwe wartości <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> właściwości to WM_CHAR, przetłumaczyła, WM_SYSKEYDOWN, WM_KEYUP, WM_SYSKEYUP i WM_IME_CHAR.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> metody w klasie pochodnej formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył klucz. W przypadku kluczy, które nie są przetwarzane przez formant, należy zwrócić wynik wywołania <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> metody klasy bazowej. Kontrolki będą rzadko, jeśli kiedykolwiek trzeba przesłonić tę metodę.</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage :  -&gt; bool&#xA;override this.ProcessKeyMessage :  -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat okna do przetworzenia.</param>
        <summary>Przetwarza komunikat z klawiatury.</summary>
        <returns><see langword="true" />Jeśli komunikat został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, gdy kontrolka odbierze komunikat z klawiatury. Metoda najpierw określa, czy kontrolka ma element nadrzędny; Jeśli tak, wywołuje <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metodę elementu nadrzędnego. Jeśli <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> Metoda nadrzędna nie przetwarza komunikatu <xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A> , metoda jest wywoływana w celu wygenerowania odpowiednich zdarzeń klawiatury. `m` Parametr zawiera komunikat okna, który musi zostać przetworzony. Możliwe wartości <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> właściwości to WM_CHAR, przetłumaczyła, WM_SYSKEYDOWN, WM_KEYUP i WM_SYSKEYUP.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" /> metody formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył klucz. W przypadku kluczy, które nie są przetwarzane przez formant, <see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" /> należy zwrócić wynik klasy bazowej. Kontrolki będą rzadko, jeśli kiedykolwiek trzeba przesłonić tę metodę.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview :  -&gt; bool&#xA;override this.ProcessKeyPreview :  -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">A <see cref="T:System.Windows.Forms.Message" />, przez odwołanie, które reprezentuje komunikat okna do przetworzenia.</param>
        <summary>Przegląda komunikat z klawiatury.</summary>
        <returns><see langword="true" />Jeśli komunikat został przetworzony przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez formant podrzędny, gdy formant podrzędny odbiera komunikat z klawiatury. Formant podrzędny wywołuje tę metodę przed wygenerowaniem wszystkich zdarzeń klawiatury dla wiadomości. Jeśli ta metoda zwraca `true`, formant podrzędny traktuje komunikat przetworzony i nie generuje żadnych zdarzeń z klawiatury. `m` Parametr zawiera komunikat okna do podglądu. Możliwe wartości <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType> właściwości to WM_CHAR, przetłumaczyła, WM_SYSKEYDOWN, WM_KEYUP i WM_SYSKEYUP. Metoda po prostu wysyła znak do <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> metody elementu nadrzędnego lub zwraca `false` , jeśli formant nie ma elementu nadrzędnego. <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A> <xref:System.Windows.Forms.Form> Klasa zastępuje tę metodę, aby wykonać rzeczywiste przetwarzanie kluczy okna dialogowego.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> metody w klasie pochodnej formant powinien powrócić <see langword="true" /> , aby wskazać, że przetworzył klucz. W przypadku kluczy, które nie są przetwarzane przez formant, należy zwrócić wynik wywołania <see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" /> metody klasy bazowej.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Znak do przetworzenia.</param>
        <summary>Przetwarza znak metaznaku.</summary>
        <returns><see langword="true" />Jeśli znak został przetworzony jako skrót przez formant; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana, aby dać formantowi możliwość przetworzenia znaku. Metoda powinna określać, czy formant jest w stanie do przetwarzania symboli i czy dany znak reprezentuje element. Jeśli tak, metoda powinna wykonać akcję skojarzoną z elementem i Return `true`. W przeciwnym razie metoda powinna zwrócić `false`. Implementacje tej metody często wykorzystują <xref:System.Windows.Forms.Control.IsMnemonic%2A> metodę, aby określić, czy dany znak pasuje do tekstu kontrolki.  
  
 Na przykład:  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 Ta domyślna implementacja <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metody po prostu zwraca wartość `false` , aby wskazać, że formant nie ma żadnych symboli.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje rozszerzenie klasy Button, która zastępuje <xref:System.Windows.Forms.Control.ProcessMnemonic%2A> metodę, aby wystawiać zachowanie niestandardowe. W przykładzie pokazano również, <xref:System.Windows.Forms.Control.CanSelect%2A> jak używać właściwości i. <xref:System.Windows.Forms.Control.IsMnemonic%2A> Aby uruchomić ten przykład, wklej poniższy kod po klasie form w tym samym pliku. Dodaj przycisk typu `MnemonicButton` do formularza.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien dla dziedziczenia klas do wywołania tej metody. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę produktu zestawu zawierającego formant.</summary>
        <value>Nazwa produktu zestawu zawierającego formant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductName%2A> Właściwość jest właściwością tylko do odczytu. Aby zmienić wartość tej właściwości, należy ustawić <xref:System.Reflection.AssemblyProductAttribute.Product%2A> wartość <xref:System.Reflection.AssemblyProductAttribute>właściwości. Poniższy wiersz C# kodu ustawia <xref:System.Windows.Forms.Control.ProductName%2A> właściwość.  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  Zdecydowanie zaleca się podanie nazwy firmy, nazwy produktu i wersji produktu. Udostępnienie tych informacji umożliwia korzystanie z funkcji Windows Forms, takich <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> jak ułatwianie pisania aplikacji, które są zgodne z programem "Certified for Windows". Więcej informacji o programie Certified for Windows znajduje się w temacie http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla informacje o aplikacji w <xref:System.Windows.Forms.Label> tabeli zawartej <xref:System.Windows.Forms.Form>przez. Ten przykład wymaga <xref:System.Windows.Forms.Control.CompanyName%2A> <xref:System.Windows.Forms.Control.ProductName%2A> , abyzostałyustawione.<xref:System.Windows.Forms.Control.ProductVersion%2A>  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję zestawu zawierającego formant.</summary>
        <value>Wersja pliku zestawu zawierającego formant.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductVersion%2A> Właściwość jest właściwością tylko do odczytu. Aby zmienić wartość tej właściwości, należy ustawić <xref:System.Reflection.AssemblyVersionAttribute.Version%2A> wartość <xref:System.Reflection.AssemblyVersionAttribute>właściwości. Poniższy wiersz C# kodu ustawia <xref:System.Windows.Forms.Control.ProductVersion%2A> właściwość.  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  Zdecydowanie zaleca się podanie nazwy firmy, nazwy produktu i wersji produktu. Udostępnienie tych informacji umożliwia korzystanie z funkcji Windows Forms, takich <xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType> jak ułatwianie pisania aplikacji, które są zgodne z programem "Certified for Windows". Więcej informacji o programie Certified for Windows znajduje się w temacie http://msdn.microsoft.com/certification.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla informacje o aplikacji w <xref:System.Windows.Forms.Label> tabeli zawartej <xref:System.Windows.Forms.Form>przez. Ten przykład wymaga <xref:System.Windows.Forms.Control.CompanyName%2A> <xref:System.Windows.Forms.Control.ProductName%2A> , abyzostałyustawione.<xref:System.Windows.Forms.Control.ProductVersion%2A>  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który reprezentuje tryb przechodzenia do propagacji.</summary>
        <value>Obiekt, który reprezentuje tryb przenoszonego edytora IME.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="T:System.Windows.Forms.AccessibleObject" /> gdy zapewnia pomoc dla aplikacji ułatwień dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć klasy, <xref:System.Windows.Forms.HelpProvider> aby umożliwić użytkownikom wywoływanie pomocy dotyczącej dostępnego obiektu przez naciśnięcie klawisza F1. Korzystanie z <xref:System.Windows.Forms.HelpProvider> programu zapewnia pełne informacje <xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>w. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.AccessibleObject> jak utworzyć formant wykresu z obsługą ułatwień dostępu przy użyciu klas i <xref:System.Windows.Forms.Control.ControlAccessibleObject> , aby uwidocznić dostępne informacje. Kontrolka umieszcza dwie krzywe wraz z legendą. Klasa, która pochodzi od `ControlAccessibleObject` <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> , jest używana w metodzie, aby zapewnić niestandardowe informacje dostępne dla formantu wykresu. `ChartControlAccessibleObject` Ponieważ legenda wykresu nie jest rzeczywistą <xref:System.Windows.Forms.Control> kontrolką, ale zamiast tego jest rysowana przez formant wykresu, nie zawiera żadnych wbudowanych informacji. Z tego `ChartControlAccessibleObject` powodu Klasa <xref:System.Windows.Forms.AccessibleObject.GetChild%2A> przesłania metodę w celu zwrócenia `CurveLegendAccessibleObject` , która reprezentuje dostępne informacje dla każdej części legendy. Gdy aplikacja obsługująca dostęp będzie korzystać z tego formantu, formant może udostępnić wymagane informacje.  
  
 Ten fragment kodu ilustruje obsługę <xref:System.Windows.Forms.Control.QueryAccessibilityHelp> zdarzenia. Zobacz Przegląd <xref:System.Windows.Forms.AccessibleObject> klasy, aby uzyskać pełny przykład kodu.  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje podczas operacji przeciągania i upuszczania oraz umożliwia źródłom przeciągania określenie, czy należy anulować operację przeciągania i upuszczania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.QueryContinueDrag> Zdarzenie jest zgłaszane w przypadku zmiany stanu przycisku klawiatury lub myszy podczas operacji przeciągania i upuszczania. <xref:System.Windows.Forms.Control.QueryContinueDrag> Zdarzenie włącza Źródło przeciągania, aby określić, czy operacja przeciągania i upuszczania powinna zostać anulowana.  
  
 Poniżej opisano, jak i kiedy są zgłaszane zdarzenia związane z operacjami przeciągania i upuszczania.  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A> Metoda określa kontrolkę pod bieżącą lokalizacją kursora. Następnie sprawdza, czy formant jest prawidłowym obiektem docelowym upuszczania.  
  
 Jeśli formant jest prawidłowym obiektem docelowym upuszczania, <xref:System.Windows.Forms.Control.GiveFeedback> zdarzenie jest wywoływane z określonym efektem przeciągania i upuszczania. Aby zapoznać się z listą efektów przeciągania i upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
 Zmiany położenia kursora myszy, stanu klawiatury i stanu przycisku myszy są śledzone.  
  
-   Jeśli użytkownik wyjdzie z okna, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
-   Jeśli mysz przejdzie do innej kontrolki <xref:System.Windows.Forms.Control.DragEnter> , zostanie wywołane dla tej kontrolki.  
  
-   Jeśli mysz jest przenoszona, ale pozostaje w tej samej kontrolce, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jest zgłaszane.  
  
 W przypadku zmiany stanu <xref:System.Windows.Forms.Control.QueryContinueDrag> przycisku klawiatury lub myszy zdarzenie jest wywoływane i określa, czy kontynuować przeciąganie, porzucić dane, czy anulować operację na podstawie wartości <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> <xref:System.Windows.Forms.QueryContinueDragEventArgs>właściwości zdarzenia.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Continue`, <xref:System.Windows.Forms.Control.DragOver> zdarzenie jestwywoływanewcelukontynuowaniaoperacji,azdarzeniejestzgłaszaneznowymefektem,dziękiczemumożnaustawićodpowiednieopiniewizualne.<xref:System.Windows.Forms.Control.GiveFeedback> Aby uzyskać listę prawidłowych efektów upuszczania, zobacz <xref:System.Windows.Forms.DragDropEffects> Wyliczenie.  
  
    > [!NOTE]
    >  Zdarzenia i są sparowane, dzięki czemu wskaźnik myszy porusza się nad elementem docelowym upuszczania, a <xref:System.Windows.Forms.Control.GiveFeedback> użytkownik otrzymuje najbardziej aktualne informacje na temat pozycji myszy. <xref:System.Windows.Forms.Control.DragOver>  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> jest `Drop`równa, wartość efektu upuszczania jest zwracana do źródła, więc aplikacja źródłowa może wykonać odpowiednią operację na danych źródłowych, na przykład wyciąć dane, jeśli operacja była przenoszona.  
  
-   Jeśli wartość <xref:System.Windows.Forms.DragAction> to `Cancel`, <xref:System.Windows.Forms.Control.DragLeave> zdarzenie jest zgłaszane.  
  
 Domyślnie <xref:System.Windows.Forms.Control.QueryContinueDrag> , <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> `Drop` <xref:System.Windows.Forms.DragAction> Jeśli klawisz ESC został nacionięty i ustawiony na wartość w, po naciśnięciu przycisku myszy po lewej stronie, Środkowej lub prawej. <xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A> `Cancel` <xref:System.Windows.Forms.DragAction>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Ten fragment kodu ilustruje użycie <xref:System.Windows.Forms.Control.QueryContinueDrag> zdarzenia do anulowania operacji przeciągania i upuszczania, jeśli operacja przeciągania przesunie się poza granice formularza. <xref:System.Windows.Forms.Control.DoDragDrop%2A> Zobacz metodę pełnego przykładu kodu.  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Zdarzenie, które należy podnieść.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary>Wywołuje odpowiednie zdarzenie przeciągania.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Zdarzenie, które należy podnieść.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary>Wywołuje odpowiednie zdarzenie klucza.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Zdarzenie, które należy podnieść.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary>Wywołuje odpowiednie zdarzenie myszy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">Zdarzenie, które należy podnieść.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary>Wywołuje odpowiednie zdarzenie malowania.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza ponowne utworzenie uchwytu dla kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest wywoływana za każdym razem, gdy wymagane są parametry dla nowej kontrolki, ale użycie <xref:System.Windows.Forms.Control.UpdateStyles%2A> wywołania <xref:System.Windows.Forms.Control.CreateParams%2A> z do nie jest wystarczające. <xref:System.Windows.Forms.Control.RecreateHandle%2A> Ta metoda wywołuje również <xref:System.Windows.Forms.Control.DestroyHandle%2A> wywołania <xref:System.Windows.Forms.Control.CreateHandle%2A> i i <xref:System.Windows.Forms.Control.RecreatingHandle%2A> ustawia `true`do.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka aktualnie odtwarza swój uchwyt.</summary>
        <value><see langword="true" />Jeśli kontrolka aktualnie odtwarza swój uchwyt; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Windows.Forms.Control.RecreatingHandle%2A> zwraca `true` , Jeśli<xref:System.Windows.Forms.Control.RecreateHandle%2A> Metoda jest nadal uruchomiona na formancie.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Współrzędna <see cref="T:System.Drawing.Rectangle" /> ekranu do przekonwertowania.</param>
        <summary>Oblicza rozmiar i lokalizację określonego prostokąta ekranu we współrzędnych klienta.</summary>
        <returns>Reprezentujący przekonwertowane <see cref="T:System.Drawing.Rectangle" />, <paramref name="r" />w współrzędnej klienta. <see cref="T:System.Drawing.Rectangle" /></returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">Koordynuje <see cref="T:System.Drawing.Rectangle" /> klienta do konwersji.</param>
        <summary>Oblicza rozmiar i lokalizację określonego prostokąta klienta we współrzędnych ekranu.</summary>
        <returns>Reprezentujący przekonwertowane <see cref="T:System.Drawing.Rectangle" />, <paramref name="p" />, we współrzędnych ekranu. <see cref="T:System.Drawing.Rectangle" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład <xref:System.Windows.Forms.Control.BackColor%2A>kodu demonstruje <xref:System.Windows.Forms.Control.MouseButtons%2A> <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Control.RectangleToScreen%2A>, jak używać elementów członkowskich, <xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType> ,,, i. <xref:System.Windows.Forms.Control.PointToScreen%2A> Aby uruchomić przykład, wklej następujący kod w formularzu o nazwie **Form1** zawierającym kilka kontrolek. Ten przykład wymaga <xref:System.Windows.Forms.Control.MouseDown>, aby zdarzenia <xref:System.Windows.Forms.Control.MouseMove>, i <xref:System.Windows.Forms.Control.MouseUp> były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie.  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint *  -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd"><see cref="T:System.IntPtr" /> Reprezentujący uchwyt kontrolki, do której zostanie odzwierciedlony komunikat.</param>
        <param name="m"><see cref="T:System.Windows.Forms.Message" /> Reprezentujący komunikat systemu Windows, który ma zostać odzwierciedlony.</param>
        <summary>Odzwierciedla określony komunikat do kontrolki, która jest powiązana z określonym dojściem.</summary>
        <returns><see langword="true" />Jeśli komunikat został odzwierciedlony; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ReflectMessage%2A> Metoda jest metodą infrastruktury i zwykle nie powinna być wywoływana z kodu.  
  
 Jeśli parametr nie reprezentuje prawidłowej kontrolki <xref:System.Windows.Forms.Control.ReflectMessage%2A> , metoda zwraca `false`. `hWnd`  
  
 Ponieważ komunikaty systemu Windows są zwracane do okna najwyższego poziomu, <xref:System.Windows.Forms.Control.ReflectMessage%2A> Metoda jest używana do propagowania komunikatu zwrotnego do kontrolki, która wysłała komunikat.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby wywołać tę metodę. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza, aby formant unieważnił swój obszar klienta i natychmiast ponownie narysować wszystkie formanty podrzędne.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.Refresh" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.Refresh" /> metodę klasy bazowej, tak aby formant i jego kontrolki podrzędne były unieważnione i ponownie narysowane.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia region okna skojarzony z kontrolką.</summary>
        <value>Okno <see cref="T:System.Drawing.Region" /> skojarzone z kontrolką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Region okna to zbiór pikseli w oknie, w którym system operacyjny umożliwia rysowanie. System operacyjny nie wyświetla żadnej części okna, która leży poza regionem okna. Współrzędne regionu kontrolki odnoszą się do lewego górnego rogu kontrolki, a nie obszaru klienckiego kontrolki.  
  
> [!NOTE]
>  Kolekcja pikseli zawartych w regionie może być nieciągła.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, jak używać <xref:System.Windows.Forms.Control.Region%2A> właściwości, tworząc przycisk Round. Aby uruchomić przykład, wklej poniższy kod w postaci zawierającej przycisk o nazwie `roundButton`. Ten przykład wymaga, <xref:System.Windows.Forms.Control.Paint> aby zdarzenie zostało połączone z programem obsługi zdarzeń zdefiniowanym w przykładzie.  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby ustawić tę wartość właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.Control.Region" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.RegionChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.RegionChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość jest obecnie przestarzała.</summary>
        <value><see langword="true" />Jeśli formant jest renderowany od prawej do lewej; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Wartość DPI przed zmianą.</param>
        <param name="deviceDpiNew">Wartość DPI po zmianie.</param>
        <summary>Zapewnia stałe do ponownego skalowania kontrolki po wystąpieniu zmiany DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.BackColor" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że formant powiązany z <see cref="T:System.Windows.Forms.BindingSource" /> , aby ponownie wczytał wszystkie elementy na liście i odświeżyć wyświetlane wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.Cursor" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.Font" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.ForeColor" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.ImeMode" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje kontrolkę, aby obsłużyć <see cref="E:System.Windows.Forms.Control.MouseLeave" /> zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.RightToLeft" /> właściwość do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.Control.Text" /> właściwość do wartości domyślnej (<see cref="F:System.String.Empty" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana zazwyczaj w przypadku tworzenia projektanta dla <xref:System.Windows.Forms.Control> lub tworzenia własnej kontrolki zawierającej. <xref:System.Windows.Forms.Control>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie rozmiaru formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić <xref:System.Windows.Forms.Control.Size%2A> zmiany rozmiaru formantu, można `sender` rzutować parametr zarejestrowanej <xref:System.Windows.Forms.ControlEventHandler> metody na <xref:System.Windows.Forms.Control> i uzyskać <xref:System.Windows.Forms.Control.Size%2A> Właściwość (lub <xref:System.Windows.Forms.Control.Height%2A> i <xref:System.Windows.Forms.Control.Width%2A> właściwości pojedynczo).  
  
 Aby obsłużyć niestandardowe układy, <xref:System.Windows.Forms.Control.Layout> Użyj zdarzenia zamiast zdarzenia zmiany rozmiaru. Zdarzenie jest zgłaszane w odpowiedzi <xref:System.Windows.Forms.Control.Resize> na zdarzenie, ale również w odpowiedzi na inne zmiany, które wpływają na układ formantu. <xref:System.Windows.Forms.Control.Layout>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu obsługuje <xref:System.Windows.Forms.Control.Resize> zdarzenie. <xref:System.Windows.Forms.Form> Po zmianie rozmiaru formularza program obsługi zdarzeń zapewnia, że formularz pozostaje kwadratowy ( <xref:System.Windows.Forms.Control.Height%2A> i <xref:System.Windows.Forms.Control.Width%2A> pozostaje równy). Aby uruchomić ten przykład, należy upewnić się, że ta metoda obsługi zdarzeń jest <xref:System.Windows.Forms.Control.Resize> skojarzona z zdarzeniem formularza.  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant jest odświeżany po zmianie rozmiaru.</summary>
        <value><see langword="true" />Jeśli formant jest odświeżany po zmianie rozmiaru; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest równoważna wartości <xref:System.Windows.Forms.Control.GetStyle%2A> zwracanej przez <xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType> metodę podczas przekazywania wartości jako parametru. <xref:System.Windows.Forms.Control.ResizeRedraw%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wznawia logikę zwykłą układu.</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia normalną logikę układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ResumeLayout%2A> Wywołanie metody wymusza natychmiastowy układ, jeśli istnieją oczekujące żądania układu.  
  
 Metody <xref:System.Windows.Forms.Control.SuspendLayout%2A> <xref:System.Windows.Forms.Control.Layout> i <xref:System.Windows.Forms.Control.ResumeLayout%2A> są używane wspólnie do pomijania wielu zdarzeń podczas dostosowywania wielu atrybutów formantu. Na przykład zwykle wywołuje się <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodę, a następnie <xref:System.Windows.Forms.Control.Size%2A>ustawia właściwości <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, <xref:System.Windows.Forms.Control.ResumeLayout%2A> , lub <xref:System.Windows.Forms.Control.Dock%2A> kontrolki, a następnie Wywołaj metodę, aby zmiany zaczęły obowiązywać.  
  
 Nie ma żadnych oczekujących wywołań <xref:System.Windows.Forms.Control.SuspendLayout%2A> dla programu <xref:System.Windows.Forms.Control.ResumeLayout%2A> , aby można było pomyślnie wywołać.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje dwa przyciski do formularza. Przykład transakcji Dodawanie przycisków przy użyciu <xref:System.Windows.Forms.Control.SuspendLayout%2A> metod i. <xref:System.Windows.Forms.Control.ResumeLayout%2A>  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout"><see langword="true" />Aby wykonać oczekujące żądania układu; w przeciwnym razie. <see langword="false" /></param>
        <summary>Wznawia normalną logikę układu, opcjonalnie wymusza natychmiastowy układ oczekujących żądań układu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ResumeLayout%2A> Wywołanie metody wymusza natychmiastowy układ, jeśli istnieją oczekujące żądania układu. Gdy parametr jest ustawiony na `true`, natychmiastowy układ występuje, jeśli istnieją oczekujące żądania układu. `performLayout`  
  
 Metody <xref:System.Windows.Forms.Control.SuspendLayout%2A> <xref:System.Windows.Forms.Control.Layout> i <xref:System.Windows.Forms.Control.ResumeLayout%2A> są używane wspólnie do pomijania wielu zdarzeń podczas dostosowywania wielu atrybutów formantu. Na przykład zwykle wywołuje się <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodę, a następnie <xref:System.Windows.Forms.Control.Size%2A>ustawia właściwości <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, <xref:System.Windows.Forms.Control.ResumeLayout%2A> , lub <xref:System.Windows.Forms.Control.Dock%2A> kontrolki, a następnie Wywołaj metodę, aby zmiany zaczęły obowiązywać.  
  
 Nie ma żadnych oczekujących wywołań <xref:System.Windows.Forms.Control.SuspendLayout%2A> dla programu <xref:System.Windows.Forms.Control.ResumeLayout%2A> , aby można było pomyślnie wywołać.  
  
> [!NOTE]
>  Podczas dodawania kilku kontrolek do kontrolki nadrzędnej zaleca się wywołanie <xref:System.Windows.Forms.Control.SuspendLayout%2A> metody przed zainicjowaniem kontrolek do dodania. Po dodaniu kontrolek do kontrolki nadrzędnej, <xref:System.Windows.Forms.Control.ResumeLayout%2A> Wywołaj metodę. Spowoduje to zwiększenie wydajności aplikacji z wieloma kontrolkami.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera odległość (w pikselach) między prawą krawędzią kontrolki a lewą krawędzią obszaru klienckiego kontenera.</summary>
        <value><see cref="T:System.Int32" /> Reprezentuje odległość (w pikselach) między prawą krawędzią kontrolki a lewą krawędzią obszaru klienckiego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Forms.Control.Right%2A> właściwości jest równa sumie <xref:System.Windows.Forms.Control.Left%2A> wartości właściwości i <xref:System.Windows.Forms.Control.Width%2A> wartości właściwości.  
  
 Właściwość <xref:System.Windows.Forms.Control.Right%2A> jest tylko do odczytu. Tę wartość właściwości można zmienić pośrednio, zmieniając wartość <xref:System.Windows.Forms.Control.Left%2A> lub <xref:System.Windows.Forms.Control.Width%2A> właściwości lub wywołując <xref:System.Windows.Forms.Control.SetBounds%2A>metody, <xref:System.Windows.Forms.Control.SetBoundsCore%2A>, <xref:System.Windows.Forms.Control.UpdateBounds%2A>lub <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> .  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy elementy kontrolki są wyrównane do obsługi ustawień regionalnych przy użyciu czcionek od prawej do lewej.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.RightToLeft" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.RightToLeft.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> Właściwość jest właściwością otoczenia. Właściwość otoczenia jest właściwością kontrolki, która jeśli nie jest ustawiona, zostanie pobrana z kontrolki nadrzędnej. Na przykład wartość a <xref:System.Windows.Forms.Button> będzie taka sama <xref:System.Windows.Forms.Control.BackColor%2A> jak jej element nadrzędny <xref:System.Windows.Forms.Form> domyślnie. Aby uzyskać więcej informacji o właściwościach otoczenia, <xref:System.Windows.Forms.AmbientProperties> Zobacz klasy <xref:System.Windows.Forms.Control> lub przegląd klas.  
  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> Właściwość jest używana w przypadku aplikacji międzynarodowych, w których język jest pisany od prawej do lewej, na przykład hebrajski lub arabski. Gdy ta właściwość jest ustawiona na <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>, elementy sterujące zawierające tekst są wyświetlane od prawej do lewej.  
  
> [!NOTE]
>  Jeśli wartość <xref:System.Windows.Forms.Control.RightToLeft%2A> właściwości jest zmieniana w czasie wykonywania, zachowywany jest tylko nieprzetworzony tekst bez formatowania.  
  
 Poniżej przedstawiono kilka przykładów, dla których ma wpływ <xref:System.Windows.Forms.Control.RightToLeft%2A> <xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType> wartość właściwości:  
  
-   Pionowe paski przewijania są wyświetlane po lewej stronie, a nie po prawej stronie kontrolek przewijanych (na przykład <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Panel>,, wielowierszowych <xref:System.Windows.Forms.RichTextBox> <xref:System.Windows.Forms.TextBox>i).  
  
-   Poziome paski przewijania zaczynają się od pola przewijania, które jest wyrównane do prawej strony.  
  
-   Wyrównanie elementu pola wyboru, kontrolowane przez `CheckAlign` właściwość, jest odwrócone dla <xref:System.Windows.Forms.CheckBox> i <xref:System.Windows.Forms.RadioButton> kontrolki.  
  
-   Elementy w polu listy, polu kombi i kontrolki w górę są wyrównane do prawej.  
  
-   Przyciski w <xref:System.Windows.Forms.NumericUpDown> górę i w dół są wyrównane do lewej <xref:System.Windows.Forms.DomainUpDown> strony i są kontrolkami.  
  
-   Menu (<xref:System.Windows.Forms.MainMenu>, <xref:System.Windows.Forms.MenuItem>, i <xref:System.Windows.Forms.ContextMenu>) są wyświetlane wyrównane do prawej.  
  
-   Właściwość nie ma wpływ <xref:System.Windows.Forms.ToolBar> <xref:System.Windows.Forms.ToolBarButton> na wyrównanie przycisków paska narzędzi na kontrolce lub wyrównanie tekstu. <xref:System.Windows.Forms.Control.RightToLeft%2A>  
  
-   <xref:System.Windows.Forms.AxHost>obsługuje wyrównanie od prawej do lewej; jednak efekt na kontrolce ActiveX zależy od zakresu, w którym zaimplementowano autora kontrolki obsługującej Wyświetlanie od prawej do lewej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.RightToLeft" /> wartości.</exception>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.RightToLeft" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.RightToLeft" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.RightToLeft" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.RightToLeft" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu jest programem obsługi zdarzeń, który jest wykonywany, gdy <xref:System.Windows.Forms.Control.Text%2A> wartość właściwości zostanie zmieniona. ** `Changed` ** ** Klasa ma kilka metod o nazwie PropertyName wzorca nazw, które są wywoływane w przypadku zmiany odpowiadającej wartości PropertyName (PropertyName reprezentuje nazwę odpowiedniej właściwości). <xref:System.Windows.Forms.Control>  
  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konwertuje bieżące wyrównanie na odpowiednie wyrównanie, aby zapewnić obsługę tekstu od prawej do lewej.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Drawing.ContentAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Drawing.ContentAlignment" /> element na odpowiedni <see cref="T:System.Drawing.ContentAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Drawing.ContentAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Windows.Forms.HorizontalAlignment" /> element na odpowiedni <see cref="T:System.Windows.Forms.HorizontalAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Windows.Forms.LeftRightAlignment" /> element na odpowiedni <see cref="T:System.Windows.Forms.LeftRightAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Drawing.ContentAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Drawing.ContentAlignment" /> element na odpowiedni <see cref="T:System.Drawing.ContentAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Drawing.ContentAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Windows.Forms.HorizontalAlignment" /> element na odpowiedni <see cref="T:System.Windows.Forms.HorizontalAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align">Jedna z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości.</param>
        <summary>Konwertuje określony <see cref="T:System.Windows.Forms.LeftRightAlignment" /> element na odpowiedni <see cref="T:System.Windows.Forms.LeftRightAlignment" /> do obsługi tekstu od prawej do lewej.</summary>
        <returns>Jedna z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.Control.RightToLeft%2A> `No`właściwość jest ustawiona na`align` , wartość zwracana jest równa przekazaniu parametru. <xref:System.Windows.Forms.RightToLeft>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Skaluje formant i wszystkie kontrolki podrzędne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">A <see cref="T:System.Drawing.SizeF" /> zawierające poziomy skalowania w poziomie i w pionie.</param>
        <summary>Skaluje formant i wszystkie kontrolki podrzędne według określonego czynnika skalowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda skaluje formant o określonym skalowaniu `factor`. <xref:System.Windows.Forms.Control.Scale%2A> Również rekursywnie skaluje wszystkie kontrolki podrzędne <xref:System.Windows.Forms.Control.ScaleChildren%2A> , jeśli `true`właściwość jest. Wewnętrznie ta metoda wywołuje <xref:System.Windows.Forms.Control.ScaleControl%2A> do skalowania każdej kontrolki.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">Współczynnik używany do skalowania.</param>
        <summary>Skaluje formant i wszystkie kontrolki podrzędne.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Współczynnik skalowania w poziomie.</param>
        <param name="dy">Współczynnik skalowania w pionie.</param>
        <summary>Skaluje całą kontrolkę i wszystkie kontrolki podrzędne.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice :  -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">Mapa bitowa do skalowania.</param>
        <summary>Skaluje wartość logicznej mapy bitowej do jej równoważnej wartości jednostki urządzenia po wystąpieniu zmiany DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą skalowanie formantów podrzędnych.</summary>
        <value><see langword="true" />Jeśli kontrolki podrzędne będą skalowane, <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" /> <see langword="false" />gdy wywoływana jest metoda dla tego formantu; w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość ma `true`wartość, <xref:System.Windows.Forms.Control.Scale%2A> Metoda rekursywnie wywoła <xref:System.Windows.Forms.Control.ScaleControl%2A> metodę dla każdej z jej formantów podrzędnych. <xref:System.Windows.Forms.Control.ScaleChildren%2A>  
  
 Domyślna implementacja <xref:System.Windows.Forms.Control.ScaleChildren%2A> zawsze zwraca wartość `true`. Klasy pochodne można <xref:System.Windows.Forms.Control.ScaleChildren%2A> przesłonić `false` w celu wskazania, że skalowanie nie powinno być wykonywane na ich elementach podrzędnych.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">Współczynnik, za pomocą którego będzie skalowana wysokość i szerokość kontrolki.</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> Wartość określająca granice formantu do użycia podczas definiowania jego rozmiaru i położenia.</param>
        <summary>Skaluje lokalizację, rozmiar, wypełnienie i margines formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli kontrolka jest najwyższego poziomu, nie będzie skalować lokalizacji kontrolki. Nie powoduje to skalowania elementów podrzędnych ani rozmiaru formantów o rozmiarze automatycznym. Możesz pominąć skalowanie w dowolnym kierunku, zmieniając wartość `specified` parametru.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">Współczynnik skalowania w poziomie.</param>
        <param name="dy">Współczynnik skalowania w pionie.</param>
        <summary>Ta metoda nie jest odpowiednia dla tej klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktywuje formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Metoda uaktywnia formant, jeśli bit <xref:System.Windows.Forms.ControlStyles.Selectable?displayProperty=nameWithType> stylu kontrolki jest ustawiony na `true`, jest zawarty w innej kontrolce, a wszystkie jej kontrolki nadrzędne są widoczne i włączone. <xref:System.Windows.Forms.Control.Select%2A>

Nie wybrano formantów Windows Forms na poniższej liście. Formanty pochodzące z formantów na liście również nie będą wybierane.
  
- <xref:System.Windows.Forms.Label>  
- <xref:System.Windows.Forms.Panel>  
- <xref:System.Windows.Forms.GroupBox>
- <xref:System.Windows.Forms.PictureBox>  
- <xref:System.Windows.Forms.ProgressBar>
- <xref:System.Windows.Forms.Splitter>
- <xref:System.Windows.Forms.LinkLabel>(Jeśli w formancie nie ma żadnego linku)
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktywuje formant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  

Poniższy przykład kodu wybiera określony <xref:System.Windows.Forms.Control>, jeśli jest wybrany.
  
[!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
[!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
[!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed"><see langword="true" />Aby określić kierunek wybierania kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <param name="forward"><see langword="true" />Aby przejść do przodu w kolejności tabulacji; <see langword="false" /> , aby przejść do tyłu w kolejności tabulacji.</param>
        <summary>Aktywuje formant podrzędny. Opcjonalnie określa kierunek w kolejności tabulacji, z której ma zostać wybrana kontrolka.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parametry `directed` i`forward` są używane przez kontrolki w stylu kontenera. Gdy parametr jest ustawiony na `true`, `forward` parametr jest oceniane, aby określić, którą kontrolkę wybrać. `directed` Gdy `forward` jest ustawiona na `true`, wybrano następną kontrolkę w kolejności tabulacji; `false`gdy zostanie wybrana Poprzednia kontrolka w kolejności tabulacji.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl"><see cref="T:System.Windows.Forms.Control" /> Na którym ma zostać rozpoczęte wyszukiwanie.</param>
        <param name="forward"><see langword="true" />Aby przejść do przodu w kolejności tabulacji; <see langword="false" /> , aby przejść do tyłu w kolejności tabulacji.</param>
        <param name="tabStopOnly"><see langword="true" />do ignorowania kontrolek z <see cref="P:System.Windows.Forms.Control.TabStop" /> właściwością ustawioną na <see langword="false" />; <see langword="false" />w przeciwnym razie.</param>
        <param name="nested"><see langword="true" />Aby uwzględnić zagnieżdżone (podrzędne elementy sterujące podrzędnymi) kontrolki podrzędne; w przeciwnym razie. <see langword="false" /></param>
        <param name="wrap"><see langword="true" />Aby kontynuować wyszukiwanie od pierwszego formantu w kolejności tabulacji po osiągnięciu ostatniej kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Aktywuje następną kontrolkę.</summary>
        <returns><see langword="true" />Jeśli formant został aktywowany; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda aktywuje następną kontrolkę w kolejności tabulacji, jeśli bit `Selectable` stylu kontrolki jest ustawiony na `true` wartość w <xref:System.Windows.Forms.ControlStyles>, jest zawarty w innej kontrolce, a wszystkie jej kontrolki nadrzędne są widoczne i włączone. <xref:System.Windows.Forms.Control.SelectNextControl%2A>  
  
 Nie wybrano formantów Windows Forms na poniższej liście. Formanty pochodzące z formantów na liście również nie będą wybierane.  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel>(Jeśli w formancie nie ma żadnego linku)  
  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
   
  
## Examples  
 Poniższy kod exampleshows <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodę używaną w formularzu, który ma pewne kontrolki. Przy każdym kliknięciu formularza jest uaktywniany następny formant. <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> Właściwość pobiera aktualnie aktywną kontrolkę w kontrolce kontenera.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.Control.SelectNextControl%2A> metodę używaną w formularzu, który <xref:System.Windows.Forms.Button> ma i inne kontrolki. Po kliknięciu <xref:System.Windows.Forms.Button>, następna kontrolka <xref:System.Windows.Forms.Button> po aktywowaniu. Zwróć uwagę, że musisz uzyskać element nadrzędny <xref:System.Windows.Forms.Button> formantu. Ponieważ <xref:System.Windows.Forms.Button> nie jest kontenerem, wywoływanie <xref:System.Windows.Forms.Control.SelectNextControl%2A> bezpośrednio na <xref:System.Windows.Forms.Button> nie spowoduje zmiany aktywacji.  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wysyła formant do tyłu kolejności z.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka jest przenoszona do tyłu kolejności z. Jeśli formant jest elementem podrzędnym innej kontrolki, formant podrzędny jest przenoszony do tyłu z kolejnością z. Jeśli formant jest formantem najwyższego poziomu, ta metoda nie będzie działała prawidłowo, chyba że formant jest aktywny. Formant najwyższego poziomu to kontrolka, taka jak <xref:System.Windows.Forms.Form>, która nie jest elementem podrzędnym innej kontrolki. Aktywny formant jest widoczną kontrolką z fokusem wprowadzania. Aby użyć <xref:System.Windows.Forms.Control.SendToBack%2A> metody z nieaktywną kontrolką najwyższego poziomu, najpierw <xref:System.Windows.Forms.Control.BringToFront%2A> Wywołaj metodę w kontrolce.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">Jedna z <see cref="T:System.Windows.Forms.AutoSizeMode" /> wartości.</param>
        <summary>Ustawia wartość wskazującą, w jaki sposób formant będzie zachowywać <see cref="P:System.Windows.Forms.Control.AutoSize" /> się po włączeniu jego właściwości.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ustawia granice formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Nowa <see cref="P:System.Windows.Forms.Control.Left" /> wartość właściwości formantu.</param>
        <param name="y">Nowa <see cref="P:System.Windows.Forms.Control.Top" /> wartość właściwości formantu.</param>
        <param name="width">Nowa <see cref="P:System.Windows.Forms.Control.Width" /> wartość właściwości formantu.</param>
        <param name="height">Nowa <see cref="P:System.Windows.Forms.Control.Height" /> wartość właściwości formantu.</param>
        <summary>Ustawia granice kontrolki na określoną lokalizację i rozmiar.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nowa <see cref="P:System.Windows.Forms.Control.Left" /> wartość właściwości formantu.</param>
        <param name="y">Nowa <see cref="P:System.Windows.Forms.Control.Top" /> wartość właściwości formantu.</param>
        <param name="width">Nowa <see cref="P:System.Windows.Forms.Control.Width" /> wartość właściwości formantu.</param>
        <param name="height">Nowa <see cref="P:System.Windows.Forms.Control.Height" /> wartość właściwości formantu.</param>
        <param name="specified">Bitowa kombinacja <see cref="T:System.Windows.Forms.BoundsSpecified" /> wartości. Dla dowolnego parametru, który nie został określony, zostanie użyta bieżąca wartość.</param>
        <summary>Ustawia określone granice kontrolki na określoną lokalizację i rozmiar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu jest <xref:System.Windows.Forms.Form> wyśrodkowany na ekranie <xref:System.Windows.Forms.Control.Layout> w zdarzeniu. Dzięki temu formularz zostanie wyśrodkowany, gdy użytkownik zmieni jego rozmiar. Ten przykład wymaga, aby utworzono <xref:System.Windows.Forms.Form> formant.  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Nowa <see cref="P:System.Windows.Forms.Control.Left" /> wartość właściwości formantu.</param>
        <param name="y">Nowa <see cref="P:System.Windows.Forms.Control.Top" /> wartość właściwości formantu.</param>
        <param name="width">Nowa <see cref="P:System.Windows.Forms.Control.Width" /> wartość właściwości formantu.</param>
        <param name="height">Nowa <see cref="P:System.Windows.Forms.Control.Height" /> wartość właściwości formantu.</param>
        <param name="specified">Bitowa kombinacja <see cref="T:System.Windows.Forms.BoundsSpecified" /> wartości.</param>
        <summary>Wykonuje zadanie ustawiania określonych granic tej kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle parametry, które odpowiadają granicom niezawartym w `specified` parametrze, są przesyłane przy użyciu ich bieżących wartości. <xref:System.Windows.Forms.Control.Height%2A>Na przykład <xref:System.Drawing.Point.X%2A> ,, lub <xref:System.Drawing.Point.Y%2A> właściwości lub<xref:System.Windows.Forms.Control.Location%2A> właściwości mogą być przesyłane w odniesieniu do bieżącego wystąpienia formantu. <xref:System.Windows.Forms.Control.Width%2A> Wszystkie wartości, które zostały przesłane, są honorowane i stosowane do kontrolki.  
  
 Parametr reprezentuje elementy kontrolek <xref:System.Windows.Forms.Control.Bounds%2A> zmienione przez aplikację. `boundsSpecified` Na <xref:System.Windows.Forms.Control.Size%2A> przykład jeśli zmienisz kontrolkę `boundsSpecified` , <xref:System.Windows.Forms.BoundsSpecified>wartość parametru jest `Size` równa wartości. Jeśli <xref:System.Windows.Forms.Control.Size%2A> jednak zostanie on dostosowany w odpowiedzi <xref:System.Windows.Forms.Control.Dock%2A> na ustawioną `boundsSpecified` właściwość, wartość parametru jest `None` równa wartości <xref:System.Windows.Forms.BoundsSpecified>.  
  
> [!NOTE]
>  W systemach Windows Server 2003 rozmiar a <xref:System.Windows.Forms.Form> jest ograniczony przez maksymalną szerokość i wysokość pikseli na monitorze.  
  
   
  
## Examples  
 Poniższy przykład kodu przesłania <xref:System.Windows.Forms.Control.SetBoundsCore%2A> metodę, aby upewnić się, że formant pozostaje stały rozmiar. Ten przykład wymaga, aby istnieje Klasa, która jest bezpośrednio lub pośrednio pochodną <xref:System.Windows.Forms.Control> klasy.  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metodę klasy bazowej, aby wymusić zmianę granic formantu. Klasy pochodne mogą dodawać ograniczenia rozmiaru do <see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" /> metody.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Szerokość obszaru klienta (w pikselach).</param>
        <param name="y">Wysokość obszaru klienta (w pikselach).</param>
        <summary>Ustawia rozmiar obszaru klienckiego kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obszar klienta jest uruchamiany w lokalizacji (0, 0) i rozciąga się do lokalizacji (`x`, `y`).  
  
 Zazwyczaj nie należy ustawiać <xref:System.Windows.Forms.Control.ClientSize%2A> formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu przesłania <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> metodę, aby upewnić się, że formant pozostaje kwadrat. Ten przykład wymaga, aby istnieje Klasa, która jest bezpośrednio lub pośrednio pochodną <xref:System.Windows.Forms.Control> klasy.  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" /> metodę <see cref="P:System.Windows.Forms.Control.ClientSize" /> klasy bazowej, aby właściwość została dopasowana.  
  
Aby uzyskać więcej informacji na temat rysowania na kontrolkach, zobacz [renderowanie kontrolki Windows Forms](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md).</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag"><see cref="T:System.Windows.Forms.ControlStyles" /> Bit do ustawienia.</param>
        <param name="value"><see langword="true" />Aby zastosować określony styl do kontrolki; w przeciwnym razie. <see langword="false" /></param>
        <summary>Ustawia określoną <see cref="T:System.Windows.Forms.ControlStyles" /> flagę <see langword="true" /> na lub <see langword="false" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Flagi bitów stylu formantu są używane do kategoryzacji obsługiwanego zachowania. Kontrolka może włączyć styl przez wywołanie <xref:System.Windows.Forms.Control.SetStyle%2A> metody i przekazanie odpowiednich <xref:System.Windows.Forms.ControlStyles> bitów (lub bitów) i wartości logicznej w celu ustawienia bitów na. Aby określić wartość przypisaną do określonego <xref:System.Windows.Forms.ControlStyles> bitu, <xref:System.Windows.Forms.Control.GetStyle%2A> Użyj <xref:System.Windows.Forms.ControlStyles> metody i przekaż element członkowski do obliczenia.  
  
> [!CAUTION]
>  Ustawienie bitów stylu kontrolki może znacząco zmienić zachowanie formantu. Zapoznaj się z dokumentacją <xref:System.Windows.Forms.Control.SetStyle%2A> wyliczenia,abypoznaćskutkizmianybitówstyluformantuprzedwywołaniemmetody.<xref:System.Windows.Forms.ControlStyles>  
  
   
  
## Examples  
 Poniższy przykład kodu włącza buforowanie podwójne na <xref:System.Windows.Forms.Form> a i aktualizuje style, aby odzwierciedlić zmiany.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" />Aby ustawić formant jako formant najwyższego poziomu; w przeciwnym razie. <see langword="false" /></param>
        <summary>Ustawia formant jako formant najwyższego poziomu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W <xref:System.Windows.Forms.Control.SetTopLevel%2A> przypadku wywołania `true`metody <xref:System.Windows.Forms.Form> a i `false`przekazania wartości, formularz nie będzie widoczny dopóki nie zostanie ponownie wywołana <xref:System.Windows.Forms.Control.SetTopLevel%2A> , przekazując wartość.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parametr jest ustawiony na <see langword="true" /> , a formant jest kontrolką ActiveX. <paramref name="value" /></exception>
        <exception cref="T:System.Exception">Zwracana wartość nie jest równa <paramref name="value" /> parametrowi, a <see cref="P:System.Windows.Forms.Control.Parent" /> właściwość nie <see langword="null" />jest. <see cref="M:System.Windows.Forms.Control.GetTopLevel" /></exception>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby ustawić kontrolkę jako kontrolkę najwyższego poziomu, jeśli jest ona dowolnego typu innego <see cref="T:System.Windows.Forms.Form" />niż. To uprawnienie jest wymagane tylko wtedy, <paramref name="value" /> gdy parametr <see langword="true" /> jest i formant nie jest kontrolką ActiveX. Skojarzone Wyliczenie: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />wartość.</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value"><see langword="true" />Aby formant był widoczny; w przeciwnym razie. <see langword="false" /></param>
        <summary>Ustawia formant do określonego widocznego stanu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj metoda ta jest zastępowana, aby dokonać zmian w zachowaniu widoczności formantu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" /> metodę klasy bazowej, aby wymusić zmianę widoczności kontrolki.</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyświetla formant dla użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wyświetlanie formantu jest równoznaczne z ustawieniem <xref:System.Windows.Forms.Control.Visible%2A> właściwości na `true`. <xref:System.Windows.Forms.Control.Visible%2A> <xref:System.Windows.Forms.Control.Hide%2A> Po wywołaniu <xref:System.Windows.Forms.Control.Show%2A> metody`true` Właściwość zwraca wartość, dopóki metoda nie zostanie wywołana.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla okno dialogowe informacje i tymczasowo rysuje niebieski kwadrat na powierzchni. Ten przykład wymaga zdefiniowania klasy, która pochodzi od <xref:System.Windows.Forms.Form> nazwy. `AboutDialog`  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka ma wyświetlać prostokąty fokusu.</summary>
        <value><see langword="true" />Jeśli kontrolka ma wyświetlać prostokąty koncentracji uwagi; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat tej funkcji, zobacz tematy [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)i [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje.</para></block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy interfejs użytkownika jest w odpowiednim stanie, aby pokazać lub ukryć akceleratory klawiatury.</summary>
        <value><see langword="true" />Jeśli akceleratory klawiatury są widoczne; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W kontrolkach utworzonych w projektancie Windows Forms, akceleratory klawiatury są widoczne domyślnie.  
  
 Aby uzyskać więcej informacji na temat tej funkcji, zobacz tematy [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx), [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)i [WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokację formantu.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> Skojarzone<see cref="T:System.Windows.Forms.Control" />z, jeśli istnieje.</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wysokość i szerokość kontrolki.</summary>
        <value><see cref="T:System.Drawing.Size" /> Reprezentuje wysokość i szerokość formantu w pikselach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ Klasa jest typem wartości (`Structure` w Visual Basic, `struct` w wizualizacji C#), jest zwracana przez wartość, co oznacza, że dostęp do właściwości zwraca kopię rozmiaru formantu. <xref:System.Drawing.Size> <xref:System.Drawing.Size.Width%2A> Dlatego dopasowanie <xref:System.Windows.Forms.Control.Height%2A> właściwości <xref:System.Drawing.Size.Height%2A> lubwartości<xref:System.Windows.Forms.Control.Width%2A> zwracanej z tej właściwości nie wpłynie na ani kontrolki. <xref:System.Drawing.Size> Aby <xref:System.Windows.Forms.Control.Width%2A> dostosować lub <xref:System.Windows.Forms.Control.Size%2A> <xref:System.Drawing.Size> <xref:System.Windows.Forms.Control.Height%2A> <xref:System.Windows.Forms.Control.Width%2A> kontrolkę <xref:System.Windows.Forms.Control.Height%2A> , należy ustawić kontrolkę lub właściwość, lub ustawić właściwość na nową.  
  
> [!NOTE]
>  Aby zachować lepszą wydajność, nie ustawiaj <xref:System.Drawing.Size> kontrolki w konstruktorze. Preferowaną metodą jest zastąpienie <xref:System.Windows.Forms.Control.DefaultSize%2A> właściwości.  
  
> [!NOTE]
>  W systemach Windows Server 2003 rozmiar a <xref:System.Windows.Forms.Form> jest ograniczony przez maksymalną szerokość i wysokość pikseli na monitorze.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.Windows.Forms.Button> do formularza i ustawia niektóre z jego wspólnych właściwości. Przykład zakotwiczy przycisk w prawym dolnym rogu formularza, aby zachować jego względną pozycję w miarę zmieniania rozmiaru formularza. Następnie ustawia <xref:System.Windows.Forms.Control.BackgroundImage%2A> i zmienia rozmiar przycisku na taki sam rozmiar <xref:System.Drawing.Image>jak. W tym przykładzie jest ustawiana `true` wartość <xref:System.Windows.Forms.Control.TabStop%2A> na i <xref:System.Windows.Forms.Control.TabIndex%2A> ustawia właściwość. Na koniec dodaje procedurę obsługi zdarzeń, aby obsłużyć <xref:System.Windows.Forms.Control.Click> zdarzenie przycisku. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.ImageList> nazwę. `imageList1`  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.Size" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zalecane jest używanie <xref:System.Windows.Forms.Control.Layout> zdarzenia do obsługi układów niestandardowych. Zdarzenie jest zgłaszane w odpowiedzi na <xref:System.Windows.Forms.Control.Resize> zdarzenia, ale również w innych warunkach, gdy konieczne może być zastosowanie układu. <xref:System.Windows.Forms.Control.Layout>  
  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Size%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.Control.SizeChanged> zdarzenie. Zostało dostarczone wystąpienie <xref:System.Windows.Forms.Button> kontrolki, które może być skalowane w poziomie i w pionie. <xref:System.Windows.Forms.NumericUpDown> Wystąpienie zapewnia wartość skali poziomej i pionowej. Wystąpienie o nazwie **OK** służy do ustawiania wartości <xref:System.Windows.Forms.Button> skali dla wystąpienia formantu. <xref:System.Windows.Forms.Button> Za każdym razem, gdy zmieniany jest rozmiar kontrolki, zostanie wywołana <xref:System.Windows.Forms.Control.SizeChanged> procedura obsługi zdarzeń skojarzona ze zdarzeniem formantu. Ta procedura obsługi zdarzeń wyświetla komunikat informujący o tym, że rozmiar kontrolki został zmieniony.  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="clientSize"><see cref="T:System.Drawing.Size" /> Wartość reprezentująca wysokość i szerokość obszaru klienckiego kontrolki.</param>
        <summary>Określa rozmiar całego formantu od wysokości i szerokości jego obszaru klienckiego.</summary>
        <returns><see cref="T:System.Drawing.Size" /> Wartość reprezentująca wysokość i szerokość całej kontrolki.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie stylu formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie <xref:System.Windows.Forms.Control.StyleChanged> występuje, gdy <xref:System.Windows.Forms.ControlStyles> flagi zostały dodane lub zmienione.  
  
 To zdarzenie jest inicjowane po zmianie stylu formantu wskutek modyfikacji programowej lub wykonania czynności przez użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.StyleChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.StyleChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tymczasowo wstrzymuje logikę układu dla kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Logika układu kontrolki jest zawieszona do momentu <xref:System.Windows.Forms.Control.ResumeLayout%2A> wywołania metody.  
  
 Metody <xref:System.Windows.Forms.Control.SuspendLayout%2A> <xref:System.Windows.Forms.Control.Layout> i <xref:System.Windows.Forms.Control.ResumeLayout%2A> są używane wspólnie do pomijania wielu zdarzeń podczas dostosowywania wielu atrybutów formantu. Na przykład zwykle wywołuje się <xref:System.Windows.Forms.Control.SuspendLayout%2A> metodę, a następnie <xref:System.Windows.Forms.Control.Size%2A>ustawia właściwości <xref:System.Windows.Forms.Control.Location%2A>, <xref:System.Windows.Forms.Control.Anchor%2A>, <xref:System.Windows.Forms.Control.ResumeLayout%2A> , lub <xref:System.Windows.Forms.Control.Dock%2A> kontrolki, a następnie Wywołaj metodę, aby zmiany zaczęły obowiązywać.  
  
 Nie ma żadnych oczekujących wywołań <xref:System.Windows.Forms.Control.SuspendLayout%2A> dla programu <xref:System.Windows.Forms.Control.ResumeLayout%2A> , aby można było pomyślnie wywołać.  
  
> [!NOTE]
>  Podczas dodawania kilku kontrolek do kontrolki nadrzędnej zaleca się wywołanie <xref:System.Windows.Forms.Control.SuspendLayout%2A> metody przed zainicjowaniem kontrolek do dodania. Po dodaniu kontrolek do kontrolki nadrzędnej, <xref:System.Windows.Forms.Control.ResumeLayout%2A> Wywołaj metodę. Spowoduje to zwiększenie wydajności aplikacji z wieloma kontrolkami.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje dwa przyciski do formularza. Przykład transakcji Dodawanie przycisków przy użyciu <xref:System.Windows.Forms.Control.SuspendLayout%2A> metod i. <xref:System.Windows.Forms.Control.ResumeLayout%2A>  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.EventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">A <see cref="T:System.Windows.Forms.DragEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieniają się kolory systemowe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane w przypadku <xref:System.Drawing.SystemColors> zmiany przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.SystemColorsChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.SystemColorsChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejność tabulacji kontrolki w jej kontenerze.</summary>
        <value>Wartość indeksu kontrolki w obrębie zestawu kontrolek w kontenerze. Kontrolki w kontenerze są uwzględniane w kolejności tabulacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Indeks karty może składać się z dowolnej poprawnej liczby całkowitej większej lub równej zero, a mniejsza liczba jest wcześniejsza w kolejności tabulacji. Jeśli więcej niż jedna kontrolka w tym samym formancie nadrzędnym ma ten sam indeks karty, porządek osi z formantów określa kolejność, w której kontrolki mają być przetworzone.  
  
 Aby formant został uwzględniony w kolejności tabulacji, jego <xref:System.Windows.Forms.Control.TabStop%2A> właściwość musi być ustawiona na. `true`  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.Windows.Forms.Button> do formularza i ustawia niektóre z jego wspólnych właściwości. Przykład zakotwiczy przycisk w prawym dolnym rogu formularza, aby zachować jego względną pozycję w miarę zmieniania rozmiaru formularza. Następnie ustawia <xref:System.Windows.Forms.Control.BackgroundImage%2A> i zmienia rozmiar przycisku na taki sam rozmiar <xref:System.Drawing.Image>jak. W tym przykładzie jest ustawiana `true` wartość <xref:System.Windows.Forms.Control.TabStop%2A> na i <xref:System.Windows.Forms.Control.TabIndex%2A> ustawia właściwość. Na koniec dodaje procedurę obsługi zdarzeń, aby obsłużyć <xref:System.Windows.Forms.Control.Click> zdarzenie przycisku. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.ImageList> nazwę. `imageList1`  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.TabIndex" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.TabIndex%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.TabIndexChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.TabIndexChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy użytkownik może nadać fokus temu formantowi przy użyciu klawisza TAB.</summary>
        <value><see langword="true" />Jeśli użytkownik może nadawać fokus kontrolki za pomocą klawisza TAB; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.  
  
 <block subset="none" type="note"><para>  
 Ta właściwość zawsze zwraca <see langword="true" /> wartość <see cref="T:System.Windows.Forms.Form" /> dla wystąpienia klasy.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy użytkownik naciśnie klawisz TAB, fokus wprowadzania jest ustawiany na następną kontrolkę w kolejności tabulacji. Kontrolki z <xref:System.Windows.Forms.Control.TabStop%2A> `false` wartością właściwości nie są uwzględniane w kolekcji formantów w kolejności tabulacji. Kolejność tabulacji można manipulować przez ustawienie wartości <xref:System.Windows.Forms.Control.TabIndex%2A> właściwości kontrolki.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje <xref:System.Windows.Forms.Button> do formularza i ustawia niektóre z jego wspólnych właściwości. Przykład zakotwiczy przycisk w prawym dolnym rogu formularza, aby zachować jego względną pozycję w miarę zmieniania rozmiaru formularza. Następnie ustawia <xref:System.Windows.Forms.Control.BackgroundImage%2A> i zmienia rozmiar przycisku na taki sam rozmiar <xref:System.Drawing.Image>jak. W tym przykładzie jest ustawiana `true` wartość <xref:System.Windows.Forms.Control.TabStop%2A> na i <xref:System.Windows.Forms.Control.TabIndex%2A> ustawia właściwość. Na koniec dodaje procedurę obsługi zdarzeń, aby obsłużyć <xref:System.Windows.Forms.Control.Click> zdarzenie przycisku. Ten przykład wymaga, aby miał <xref:System.Windows.Forms.ImageList> nazwę. `imageList1`  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.TabStop" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.TabStop%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Control.TabStopChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.Control>, takich <xref:System.Windows.Forms.Button> jak lub <xref:System.Windows.Forms.ComboBox>. Następnie nadaj nazwę wystąpieniu `Control1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.Control.TabStopChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera dane dotyczące formantu.</summary>
        <value><see cref="T:System.Object" /> Zawierający dane o kontrolce. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Każdy typ pochodny <xref:System.Object> klasy może być przypisany do tej właściwości. <xref:System.Windows.Forms.Control.Tag%2A> Jeśli właściwość jest ustawiana za pomocą projektanta Windows Forms, można przypisać tylko tekst.  
  
 Typowym zastosowaniem dla <xref:System.Windows.Forms.Control.Tag%2A> właściwości jest przechowywanie danych, które są ściśle powiązane z formantem. Na przykład, jeśli masz kontrolkę, która wyświetla informacje o kliencie, możesz przechowywać <xref:System.Data.DataSet> , która zawiera historię zamówienia klienta we <xref:System.Windows.Forms.Control.Tag%2A> właściwości tej kontrolki, dzięki czemu można szybko uzyskać dostęp do danych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla formularz i zapisuje `Customer` w nim <xref:System.Windows.Forms.Control.Tag%2A> właściwość. Ten przykład wymaga zdefiniowania klasy, która pochodzi od <xref:System.Windows.Forms.Form> nazwy `CustomerForm` i zdefiniowanej przez `Customer`użytkownika.  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst skojarzony z tym formantem.</summary>
        <value>Tekst skojarzony z tym formantem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Text%2A> Właściwość kontrolki jest używana inaczej dla każdej klasy pochodnej. Na przykład <xref:System.Windows.Forms.Control.Text%2A> Właściwość a <xref:System.Windows.Forms.Form> jest wyświetlana na pasku tytułu w górnej części formularza, jest dość mała w liczbie znaków i zazwyczaj wyświetla nazwę aplikacji lub dokumentu. <xref:System.Windows.Forms.Control.Text%2A> Jednak Właściwość<xref:System.Windows.Forms.RichTextBox> klasy może być duża i może zawierać wiele znaków niewizualnych używanych do formatowania tekstu. Na przykład tekst wyświetlany w a <xref:System.Windows.Forms.RichTextBox> może być sformatowany przez <xref:System.Drawing.Font> dostosowanie właściwości lub przez dodanie spacji lub znaków tabulacji w celu wyrównania tekstu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy <xref:System.Windows.Forms.GroupBox> i ustawia niektóre z jego wspólnych właściwości. Przykład tworzy i ustawia <xref:System.Windows.Forms.TextBox> jego <xref:System.Windows.Forms.Control.Location%2A> wartość w polu grupy. Następnie ustawia <xref:System.Windows.Forms.Control.Text%2A> właściwość pola Grupa i zadokuje pole grupy w górnej części formularza. W końcu wyłącza pole grupy przez ustawienie <xref:System.Windows.Forms.Control.Enabled%2A> właściwości na `false`, która powoduje wyłączenie wszystkich kontrolek zawartych w polu grupy.  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="P:System.Windows.Forms.Control.Text" /> właściwości w klasie pochodnej należy użyć <see cref="P:System.Windows.Forms.Control.Text" /> właściwości klasy bazowej, aby zwiększyć podstawową implementację. W przeciwnym razie musisz podać wszystkie implementacje. Nie jest wymagane przesłonięcie obu metod <see langword="get" /> i <see langword="set" /> dostępu <see cref="P:System.Windows.Forms.Control.Text" /> do właściwości; w razie potrzeby można przesłonić tylko jeden.</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.Text" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Text%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu zmienia <xref:System.Windows.Forms.Control.ForeColor%2A> dane <xref:System.Windows.Forms.TextBox> z wyświetlanej waluty. Przykład konwertuje tekst na liczbę dziesiętną i zmienia wartość <xref:System.Windows.Forms.Control.ForeColor%2A> na <xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType> , jeśli liczba jest ujemna i do <xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType> , jeśli liczba jest dodatnia. Ten przykład wymaga <xref:System.Windows.Forms.Form> , aby <xref:System.Windows.Forms.TextBox>zawierał.  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odległość (w pikselach) między górną krawędzią kontrolki a górną krawędzią obszaru klienckiego kontenera.</summary>
        <value><see cref="T:System.Int32" /> Reprezentujący odległość (w pikselach) między dolną krawędzią kontrolki a górną krawędzią obszaru klienckiego kontenera.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest równoznaczna <xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType> z właściwością <xref:System.Windows.Forms.Control.Location%2A> wartości właściwości formantu. <xref:System.Windows.Forms.Control.Top%2A>  
  
 Zmiany wprowadzone do <xref:System.Windows.Forms.Control.Height%2A> wartości właściwości <xref:System.Windows.Forms.Control.Top%2A> i powodują <xref:System.Windows.Forms.Control.Bottom%2A> zmianę wartości właściwości formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera formant nadrzędny, który nie jest elementem nadrzędnym przez inny formant Windows Forms. Zwykle jest to zewnętrzny <see cref="T:System.Windows.Forms.Form" /> , w którym znajduje się kontrolka.</summary>
        <value><see cref="T:System.Windows.Forms.Control" /> Reprezentuje kontrolkę najwyższego poziomu, która zawiera bieżącą kontrolkę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kontrolka najwyższego poziomu jest definiowana jako kontrolka nadrzędna, która nie jest nadrzędna przez inny formant Windows Forms. Zwykle jest to zewnętrzny <xref:System.Windows.Forms.Form> , w którym znajduje się kontrolka. Na przykład, jeśli formant jest zawarty w elemencie podrzędnym <xref:System.Windows.Forms.Form>MDI, to formant najwyższego poziomu jest obiektem nadrzędnym <xref:System.Windows.Forms.Form>wielu dokumentów (MDI). Jeśli formant nie jest elementem nadrzędnym, ta <xref:System.Windows.Forms.Form>właściwość zwróci `null`wartość.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby uzyskać tę wartość właściwości. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że formant odświeża regiony unieważnione w obszarze klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wykonuje wszystkie oczekujące żądania rysowania.  
  
 Istnieją dwa sposoby odświeżenia formularza i jego zawartości:  
  
-   Można użyć jednego z przeciążeń <xref:System.Windows.Forms.Control.Invalidate%2A> metody <xref:System.Windows.Forms.Control.Update%2A> za pomocą metody.  
  
-   Można wywołać <xref:System.Windows.Forms.Control.Refresh%2A> metodę, która wymusza, aby formant mógł ponownie narysować i wszystkie jego elementy podrzędne. Jest to równoznaczne z ustawieniem <xref:System.Windows.Forms.Control.Invalidate%2A> metody na `true` i używanie jej <xref:System.Windows.Forms.Control.Update%2A>w programie.  
  
 <xref:System.Windows.Forms.Control.Invalidate%2A> Metoda kontroluje, co jest rysowane lub odświeżane. <xref:System.Windows.Forms.Control.Update%2A> Metoda reguluje się, gdy następuje malowanie lub Odrysowanie. W przypadku użycia metod <xref:System.Windows.Forms.Control.Invalidate%2A> i <xref:System.Windows.Forms.Control.Update%2A> zamiast wywoływania <xref:System.Windows.Forms.Control.Refresh%2A>, co jest <xref:System.Windows.Forms.Control.Invalidate%2A> odświeżene, zależy od tego, którego przeciążenia używasz. Metoda po prostu wymusza od razu narysowanie kontrolki, ale metoda <xref:System.Windows.Forms.Control.Invalidate%2A> ta reguluje <xref:System.Windows.Forms.Control.Update%2A> pomalowanie podczas wywoływania metody. <xref:System.Windows.Forms.Control.Update%2A>  
  
 Aby uzyskać więcej informacji, zobacz temat [WM_PAINT](https://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx) .  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Aktualizuje granice formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualizuje granice formantu o bieżącym rozmiarze i lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nowa <xref:System.Windows.Forms.Control.Size%2A> kontrolka różni się od poprzedniej <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> zdarzenie jest zgłaszane. Podobnie, jeśli <xref:System.Windows.Forms.Control.Location%2A> kontrolka ulegnie zmianie <xref:System.Windows.Forms.Control.LocationChanged> , zdarzenie jest zgłaszane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x"><see cref="P:System.Drawing.Point.X" /> Współrzędna kontrolki.</param>
        <param name="y"><see cref="P:System.Drawing.Point.Y" /> Współrzędna kontrolki.</param>
        <param name="width"><see cref="P:System.Drawing.Size.Width" /> Kontrolka.</param>
        <param name="height"><see cref="P:System.Drawing.Size.Height" /> Kontrolka.</param>
        <summary>Aktualizuje granice kontrolki o określonym rozmiarze i lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nowa <xref:System.Windows.Forms.Control.Size%2A> kontrolka różni się od poprzedniej <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> zdarzenie jest zgłaszane. Podobnie jak w przypadku zmiany kontrolki <xref:System.Windows.Forms.Control.LocationChanged> , zdarzenie jest zgłaszane. <xref:System.Windows.Forms.Control.Location%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x"><see cref="P:System.Drawing.Point.X" /> Współrzędna kontrolki.</param>
        <param name="y"><see cref="P:System.Drawing.Point.Y" /> Współrzędna kontrolki.</param>
        <param name="width"><see cref="P:System.Drawing.Size.Width" /> Kontrolka.</param>
        <param name="height"><see cref="P:System.Drawing.Size.Height" /> Kontrolka.</param>
        <param name="clientWidth">Klient <see cref="P:System.Drawing.Size.Width" /> formantu.</param>
        <param name="clientHeight">Klient <see cref="P:System.Drawing.Size.Height" /> formantu.</param>
        <summary>Aktualizuje granice kontrolki o określonym rozmiarze, lokalizacji i rozmiarze klienta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli nowa <xref:System.Windows.Forms.Control.Size%2A> kontrolka różni się od poprzedniej <xref:System.Drawing.Size>, <xref:System.Windows.Forms.Control.SizeChanged> zdarzenie jest zgłaszane. Podobnie, jeśli <xref:System.Windows.Forms.Control.Location%2A> kontrolka ulegnie zmianie <xref:System.Windows.Forms.Control.LocationChanged> , zdarzenie jest zgłaszane.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza, aby przypisane style były ponownie stosowane do kontrolki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda wywołuje <xref:System.Windows.Forms.Control.CreateParams%2A> metodę w celu uzyskania stylów do zastosowania. Style przypisane do <xref:System.Windows.Forms.CreateParams.Style%2A> i <xref:System.Windows.Forms.CreateParams.ExStyle%2A> właściwości <xref:System.Windows.Forms.CreateParams> przypisane do <xref:System.Windows.Forms.Control.CreateParams%2A> właściwości kontrolki są ponownie stosowane. Formant zostanie odmalowany, aby odzwierciedlić zmiany stylu w razie potrzeby.  
  
 Metoda nie ma wpływu, <xref:System.Windows.Forms.Control.IsHandleCreated%2A> Jeśli wartość właściwości to `false`. <xref:System.Windows.Forms.Control.UpdateStyles%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu włącza buforowanie podwójne na <xref:System.Windows.Forms.Form> a i aktualizuje style, aby odzwierciedlić zmiany.  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualizuje formant w porządku osi z elementu nadrzędnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.UpdateZOrder%2A> Metoda aktualizuje pozycję kontrolki w kolejności z jej formantu nadrzędnego. Na przykład, jeśli ten formant jest nowo utworzonym formantem, który został dodany <xref:System.Windows.Forms.Control.ControlCollection>do, porządek osi z zostanie zaktualizowany przy użyciu nowej kontrolki dodanej do tyłu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy należy użyć kursora oczekiwania dla bieżącej kontrolki i wszystkich formantów podrzędnych.</summary>
        <value><see langword="true" />Aby użyć kursora oczekiwania dla bieżącej kontrolki i wszystkich formantów podrzędnych; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Za każdym razem, gdy wykonujesz operację, która ma zauważalny czas, Użyj kursora. Należy jednak pamiętać, że operacje blokujące wątek interfejsu użytkownika również blokują zmianę kursora. W związku z tym ta właściwość powinna być używana tylko w przypadku wykonywania czasochłonnych operacji w innym wątku. Aby zmienić kursor globalnie i natychmiast, zobacz <xref:System.Windows.Forms.Cursor.Current%2A> właściwość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zakończeniu sprawdzania poprawności formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Jeśli `true` Właściwość <xref:System.ComponentModel.CancelEventArgs> jest ustawiona na w delegatze<xref:System.Windows.Forms.Control.Validating> zdarzenia, wszystkie zdarzenia, które zwykle przechodzą po zdarzeniu są <xref:System.Windows.Forms.Control.Validating> pomijane.  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Aby uzyskać więcej informacji, zobacz temat [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) i sekcję "zakleszczenia komunikatów" tematu [Informacje o komunikatach i kolejkach komunikatów](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx) .  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.TextBox> pochodnej i weryfikuje adres e-mail wprowadzony przez użytkownika. Jeśli adres e-mail nie jest w formacie standardowym (zawierającym "@" and "."), weryfikacja nie powiedzie się <xref:System.Windows.Forms.ErrorProvider> , zostanie wyświetlona ikona, a zdarzenie zostanie anulowane. Ten przykład wymaga, aby <xref:System.Windows.Forms.TextBox> w <xref:System.Windows.Forms.ErrorProvider> formularzu został utworzony formant i.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy formant sprawdza poprawność.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zmienisz fokus przy użyciu klawiatury (Tab, Shift + Tab itd.), wywołując <xref:System.Windows.Forms.Control.Select%2A> metody lub <xref:System.Windows.Forms.Control.SelectNextControl%2A> <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType> , lub ustawiając właściwość na bieżącą formę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 Gdy zmienisz fokus przy użyciu myszy lub wywołując <xref:System.Windows.Forms.Control.Focus%2A> metodę, zdarzenia fokusu występują w następującej kolejności:  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 Jeśli właściwość jest ustawiona na `false`, <xref:System.Windows.Forms.Control.Validating> zdarzenia i <xref:System.Windows.Forms.Control.Validated> są pomijane. <xref:System.Windows.Forms.Control.CausesValidation%2A>  
  
 <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> Jeśli `true` Właściwość <xref:System.ComponentModel.CancelEventArgs> jest ustawiona na w delegatze<xref:System.Windows.Forms.Control.Validating> zdarzenia, wszystkie zdarzenia, które zwykle przechodzą po zdarzeniu są <xref:System.Windows.Forms.Control.Validating> pomijane.  
  
> [!CAUTION]
>  Nie należy próbować ustawić <xref:System.Windows.Forms.Control.Enter>fokusu w ramach obsługi zdarzeń <xref:System.Windows.Forms.Control.GotFocus> <xref:System.Windows.Forms.Control.Leave>, <xref:System.Windows.Forms.Control.LostFocus> <xref:System.Windows.Forms.Control.Validating>,,, lub <xref:System.Windows.Forms.Control.Validated> . Wykonanie tej operacji może spowodować, że Twoja aplikacja lub system operacyjny przestaną odpowiadać. Aby uzyskać więcej informacji, zobacz `WM_KILLFOCUS` temat w sekcji "odwołanie do danych wejściowych z klawiatury" i sekcję "zakleszczenia komunikatów" w temacie "informacje o kolejkach komunikatów i komunikatów" w bibliotece MSDN pod http://msdn.microsoft.com/libraryadresem.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.TextBox> pochodnej i weryfikuje adres e-mail wprowadzony przez użytkownika. Jeśli adres e-mail nie jest w formacie standardowym (zawierającym "@" and "."), weryfikacja nie powiedzie się <xref:System.Windows.Forms.ErrorProvider> , zostanie wyświetlona ikona, a zdarzenie zostanie anulowane. Ten przykład wymaga, aby <xref:System.Windows.Forms.TextBox> w <xref:System.Windows.Forms.ErrorProvider> formularzu został utworzony formant i.  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy formant i wszystkie jego kontrolki podrzędne są wyświetlane.</summary>
        <value><see langword="true" />Jeśli kontrolka i wszystkie kontrolki podrzędne są wyświetlane; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy pamiętać, że `Visible` nawet jeśli jest `true`ustawiona na, formant może nie być widoczny dla użytkownika, jeśli zostanie zasłonięty za pomocą innych kontrolek.  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.VScrollBar> przykład kodu używa klas pochodnych i <xref:System.Windows.Forms.HScrollBar> ustawia ich <xref:System.Windows.Forms.Control.Visible%2A> <xref:System.Drawing.Image> wartości właściwości na podstawie rozmiaru wyświetlanego w <xref:System.Windows.Forms.PictureBox> kontrolce. Ten przykład wymaga, aby <xref:System.Windows.Forms.PictureBox> został utworzony w formularzu <xref:System.Windows.Forms.HScrollBar> i <xref:System.Windows.Forms.VScrollBar> formanty zostały utworzone w <xref:System.Windows.Forms.PictureBox>. Ten kod powinien zostać wywołany, gdy obraz zostanie załadowany do pola obrazu i przez <xref:System.Windows.Forms.Control.Resize> zdarzenie formularza.  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.Control.Visible" /> wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest zgłaszane, jeśli <xref:System.Windows.Forms.Control.Visible%2A> właściwość zostanie zmieniona przez modyfikację programistyczną lub interakcję użytkownika.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wywołuje zdarzenie, <xref:System.Windows.Forms.Control.VisibleChanged> <xref:System.Windows.Forms.Control.Visible%2A> gdy wartość <xref:System.Windows.Forms.Label> właściwości kontrolki uległa zmianie.  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość kontrolki.</summary>
        <value>Szerokość formantu w pikselach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmiany wprowadzone do <xref:System.Windows.Forms.Control.Width%2A> wartości właściwości <xref:System.Windows.Forms.Control.Left%2A> i powodują <xref:System.Windows.Forms.Control.Right%2A> zmianę wartości właściwości formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy trzy <xref:System.Windows.Forms.Button> kontrolki w formularzu i ustawia ich rozmiar i lokalizację przy użyciu różnych właściwości związanych z wielkością i zależnościami. Ten przykład wymaga, aby miało <xref:System.Windows.Forms.Form> szerokość i wysokość co najmniej 300 pikseli.  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ta właściwość nie jest odpowiednia dla tej klasy.</summary>
        <value>NativeWindow zawarty w kontrolce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość nie jest odpowiednia dla tej klasy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">System Windows <see cref="T:System.Windows.Forms.Message" /> do przetworzenia.</param>
        <summary>Przetwarza wiadomości systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wszystkie komunikaty są wysyłane do <xref:System.Windows.Forms.Control.WndProc%2A> metody po przefiltrowaniu <xref:System.Windows.Forms.Control.PreProcessMessage%2A> za pomocą metody.  
  
 Metoda odpowiada dokładnie funkcji systemu Windows `WindowProc`. <xref:System.Windows.Forms.Control.WndProc%2A> Aby uzyskać więcej informacji o przetwarzaniu komunikatów systemu Windows, zobacz [Funkcja WindowProc](https://go.microsoft.com/fwlink/?LinkId=181565).  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje zastępowanie <xref:System.Windows.Forms.Control.WndProc%2A> metody do obsługi komunikatów systemu operacyjnego określonych <xref:System.Windows.Forms.Message> w strukturze. W tym przykładzie jest obsługiwany komunikat systemu operacyjnego [WM_ACTIVATEAPP](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx) , aby dowiedzieć się, kiedy inna aplikacja staje się aktywna. Zapoznaj się z następującymi tematami, <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>aby <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>zrozumieć dostępne <xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType> wartości, i. Rzeczywiste wartości stałych można znaleźć w pliku nagłówkowym systemu Windows. h.  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
        <block subset="none" type="overrides"><para>Kontrolki dziedziczenia powinny wywołać <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" /> metodę klasy bazowej, aby przetwarzać wszystkie komunikaty, które nie są obsługiwane.</para></block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>

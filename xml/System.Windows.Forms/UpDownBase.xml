<Type Name="UpDownBase" FullName="System.Windows.Forms.UpDownBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="129867a7b3d824b27b20f7f778864d8aa98a3243" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69175643" /></Metadata><TypeSignature Language="C#" Value="public abstract class UpDownBase : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit UpDownBase extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.UpDownBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class UpDownBase&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class UpDownBase abstract : System::Windows::Forms::ContainerControl" />
  <TypeSignature Language="F#" Value="type UpDownBase = class&#xA;    inherit ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.UpDownBaseDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementuje podstawowe funkcje wymagane przez pole pokrętła (nazywane również kontrolką w górę).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pole pokrętła składa się z pola tekstowego i małego pionowego paska przewijania, zwanego często kontrolką przycisku pokrętła. <xref:System.Windows.Forms.UpDownBase> Klasa łączy dwie kontrolki i zezwala użytkownikowi na zmianę wyświetlania w polu tekstowym przez kliknięcie przycisków w górę lub w dół lub poprzez wprowadzenie odpowiedniego typu wartości bezpośrednio w polu tekstowym. Użyj pola pokrętła w przypadkach, w których chcesz ograniczyć listę wartości, które użytkownik może wybrać, podobnie jak pole listy lub pole kombi. W zależności od typu listy, która ma zostać wyświetlona, zaletą korzystania z pola pokrętła jest możliwość szybkiego ustawiania zakresu prawidłowych wartości, a nie dodawania pojedynczych elementów naraz. Implementacja pola pokrętła wymaga mniej walidacji danych niż pole tekstowe, ponieważ można ograniczyć typ danych podczas wyprowadzania klasy z <xref:System.Windows.Forms.UpDownBase>. Przykładem jest <xref:System.Windows.Forms.NumericUpDown> Klasa, która ogranicza wartości do typu liczbowego i <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> używa właściwości i <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> do walidacji danych.  
  
 Aby zezwolić użytkownikowi na używanie klawiszy strzałek do zmiany zawartości pola pokrętła, ustaw <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> właściwość na. `true` Aby ograniczyć użytkownika do określonych wartości, ustaw <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> właściwość na. `true` Aby kontrolować wyrównanie tekstu w polu pokrętła, ustaw <xref:System.Windows.Forms.UpDownBase.TextAlign%2A> właściwość. Aby ustawić wyrównanie przycisków w górę i w dół w odniesieniu do części pola tekstowego kontrolki, ustaw <xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> właściwość na wartość <xref:System.Windows.Forms.LeftRightAlignment.Left> lub <xref:System.Windows.Forms.LeftRightAlignment.Right>.  
  
 Metody <xref:System.Windows.Forms.UpDownBase.UpButton%2A> i<xref:System.Windows.Forms.UpDownBase.DownButton%2A> , gdy są zastępowane, obsługują klikanie przycisków w górę lub w dół. Gdy jest <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> zastępowany, <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A> metody i sprawdzają poprawność wartości (wybrane lub wprowadzone) i aktualizują tekst wyświetlany w polu pokrętła. Jeśli wartość nie powiedzie się, użyj <xref:System.Windows.Forms.UpDownBase.Select%2A> metody, aby zaznaczyć nieprawidłowy tekst. Dzięki temu użytkownik może szybko poprawić tekst, wpisując nową wartość bez konieczności ręcznego zaznaczania ani usuwania istniejącego tekstu.  
  
 Począwszy od .NET Framework 4,6, rozmiar <xref:System.Windows.Forms.UpDownBase> kontrolki zostanie zmieniony na podstawie ustawienia DPI systemu, gdy plik App. config zawiera następujący wpis:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
  
```  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga <xref:System.Windows.Forms.NumericUpDown> formantu o nazwie `numericUpDown1`, dwóch <xref:System.Windows.Forms.ComboBox> kontrolek o `comboBox1` nazwach i `comboBox2`i trzech <xref:System.Windows.Forms.CheckBox> formantów o nazwach `checkBox2` `checkBox1`, `checkBox2` i utworzone w formularzu. Dodaj następujące elementy `comboBox1`do: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy `comboBox2`do: `Left`, `Right`, i `Center`.  
  
 Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>W przypadku dziedziczenia <see cref="T:System.Windows.Forms.UpDownBase" />z, należy zastąpić następujące elementy członkowskie: <see cref="M:System.Windows.Forms.UpDownBase.DownButton" />, <see cref="M:System.Windows.Forms.UpDownBase.UpButton" /> <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" />, i <see cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />.</para></block>
    <altmember cref="T:System.Windows.Forms.NumericUpDown" />
    <altmember cref="T:System.Windows.Forms.DomainUpDown" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UpDownBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UpDownBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.UpDownBase" /> klasy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.NumericUpDown" />
        <altmember cref="T:System.Windows.Forms.DomainUpDown" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScroll : bool with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScroll" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontener zezwoli użytkownikowi na przewijanie do wszystkich kontrolek umieszczonych poza widocznymi granicami.</summary>
        <value><see langword="false" />we wszystkich przypadkach.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase> Formant nie<xref:System.Windows.Forms.UpDownBase.AutoScroll%2A> używa właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollMargin">
      <MemberSignature Language="C#" Value="public System.Drawing.Size AutoScrollMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScrollMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScrollMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScrollMargin As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size AutoScrollMargin { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollMargin : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScrollMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozmiar marginesu autoprzewijania.</summary>
        <value><see cref="T:System.Drawing.Size" /> Reprezentujący wysokość i szerokość w pikselach marginesu autoprzewijania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase> Formant nie<xref:System.Windows.Forms.UpDownBase.AutoScrollMargin%2A> używa właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Drawing.Size.Height" /> Lub<see cref="P:System.Drawing.Size.Width" /> jest mniejsza od 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoScrollMinSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size AutoScrollMinSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScrollMinSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoScrollMinSize" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScrollMinSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size AutoScrollMinSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollMinSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.AutoScrollMinSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia minimalny rozmiar obszaru przewijania automatyczne.</summary>
        <value><see cref="T:System.Drawing.Size" /> Reprezentujący minimalną wysokość i szerokość (w pikselach) pasków przewijania.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase> Formant nie<xref:System.Windows.Forms.UpDownBase.AutoScrollMinSize%2A> używa właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.UpDownBase.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Visible)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy rozmiar formantu ma być automatycznie zmieniany na podstawie jego zawartości.</summary>
        <value><see langword="true" />Aby wskazać, że formant ma być automatycznie zmieniany na podstawie jego zawartości; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.UpDownBase.AutoSize" /> zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.UpDownBase.AutoSizeChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu, który dziedziczy z <xref:System.Windows.Forms.UpDownBase>, takich <xref:System.Windows.Forms.NumericUpDown> jak lub <xref:System.Windows.Forms.DomainUpDown>. Następnie nadaj nazwę wystąpieniu `UpDownBase1` i upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.UpDownBase.AutoSizeChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#380](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#380)]
 [!code-vb[System.Windows.Forms.EventExamples#380](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#380)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.UpDownBase.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła części pola tekstowego pola pokrętła (nazywanego również kontrolką w dół).</summary>
        <value><see cref="T:System.Drawing.Color" /> Reprezentujący kolor tła części pola pokrętła.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.UpDownBase.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obraz tła dla <see cref="T:System.Windows.Forms.UpDownBase" />.</summary>
        <value>Obraz <see cref="T:System.Windows.Forms.UpDownBase" />tła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość nie ma wpływu na wygląd <xref:System.Windows.Forms.UpDownBase> kontrolki; w związku z tym jest ukryta w Projektancie i funkcji IntelliSense. <xref:System.Windows.Forms.UpDownBase.BackgroundImage%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImage" /> zmieniona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.UpDownBase.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia układ <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImage" /> <see cref="T:System.Windows.Forms.UpDownBase" />elementu.</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.ImageLayout" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość nie ma wpływu na wygląd <xref:System.Windows.Forms.UpDownBase> kontrolki; w związku z tym jest ukryta w Projektancie i funkcji IntelliSense. <xref:System.Windows.Forms.UpDownBase.BackgroundImageLayout%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości zostanie <see cref="P:System.Windows.Forms.UpDownBase.BackgroundImageLayout" /> zmieniona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.UpDownBase.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl obramowania pola pokrętła (nazywanego również kontrolką w górę).</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.BorderStyle" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.BorderStyle.Fixed3D" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz użyć <xref:System.Windows.Forms.TextBoxBase.BorderStyle%2A> właściwości, aby utworzyć nieobramowane i płaskie kontrolki oprócz domyślnej kontrolki trójwymiarowej.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga <xref:System.Windows.Forms.NumericUpDown> formantu o nazwie `numericUpDown1`, dwóch <xref:System.Windows.Forms.ComboBox> kontrolek o `comboBox1` nazwach i `comboBox2`i trzech <xref:System.Windows.Forms.CheckBox> formantów o nazwach `checkBox2` `checkBox1`, `checkBox2` i utworzone w formularzu. Dodaj następujące elementy `comboBox1`do: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy `comboBox2`do: `Left`, `Right`, i `Center`.  
  
 Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.BorderStyle" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.BorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="ChangingText">
      <MemberSignature Language="C#" Value="protected bool ChangingText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChangingText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ChangingText" />
      <MemberSignature Language="VB.NET" Value="Protected Property ChangingText As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ChangingText { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ChangingText : bool with get, set" Usage="System.Windows.Forms.UpDownBase.ChangingText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy właściwość Text jest zmieniana wewnętrznie przez jej klasę nadrzędną.</summary>
        <value><see langword="true" />Jeśli właściwość jest zmieniana wewnętrznie <see cref="T:System.Windows.Forms.UpDownBase" /> przez klasę; w przeciwnym razie <see langword="false" />. <see cref="P:System.Windows.Forms.UpDownBase.Text" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość działa jako flaga <xref:System.Windows.Forms.UpDownBase> dla klasy. <xref:System.Windows.Forms.UpDownBase.ChangingText%2A> Ta właściwość jest używana przez klasy pochodne do wskazania, kiedy Klasa zmienia bieżącą <xref:System.Windows.Forms.UpDownBase.Text%2A> Właściwość wewnętrznie. Jeśli ta właściwość jest ustawiona na `false`, formant wymaga, aby użytkownik <xref:System.Windows.Forms.UpDownBase.Text%2A> zmieniał <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> Właściwość i ustawił właściwość na `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.UpDownBase.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia menu skrótów skojarzone z polem pokrętła (nazywane również kontrolką w górę).</summary>
        <value><see cref="T:System.Windows.Forms.ContextMenu" /> Skojarzone z polem pokrętła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Preferowany sposób kojarzenia menu skrótów z węzłem drzewa jest z <xref:System.Windows.Forms.UpDownBase.ContextMenuStrip%2A> właściwością.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.UpDownBase.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia menu skrótów dla pola pokrętła (nazywanego również kontrolką w górę).</summary>
        <value><see cref="T:System.Windows.Forms.ContextMenuStrip" /> Skojarzone z kontrolką.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Menu skrótów pojawia się, gdy użytkownik kliknie prawym przyciskiem myszy pole pokrętła.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.UpDownBase.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymagane parametry tworzenia podczas tworzenia uchwytu sterującego.</summary>
        <value>Parametry tworzenia.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wywoływanie niezarządzanego kodu. Skojarzone Wyliczenie <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.UpDownBase.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny rozmiar kontrolki.</summary>
        <value>Wartość domyślna <see cref="T:System.Drawing.Size" /> formantu.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="upDownBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez formant i jego kontrolki podrzędne oraz opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DockPadding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ScrollableControl.DockPaddingEdges DockPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ScrollableControl/DockPaddingEdges DockPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.DockPadding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DockPadding As ScrollableControl.DockPaddingEdges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ScrollableControl::DockPaddingEdges ^ DockPadding { System::Windows::Forms::ScrollableControl::DockPaddingEdges ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DockPadding : System.Windows.Forms.ScrollableControl.DockPaddingEdges" Usage="System.Windows.Forms.UpDownBase.DockPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollableControl+DockPaddingEdges</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ustawienia dopełnienia dokowania dla wszystkich krawędzi <see cref="T:System.Windows.Forms.UpDownBase" /> formantu.</summary>
        <value>Ustawienia dopełnienia dokowania dla tego formantu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase> Formant nie<xref:System.Windows.Forms.UpDownBase.DockPadding%2A> używa właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DownButton">
      <MemberSignature Language="C#" Value="public abstract void DownButton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DownButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.DownButton" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub DownButton ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void DownButton();" />
      <MemberSignature Language="F#" Value="abstract member DownButton : unit -&gt; unit" Usage="upDownBase.DownButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, obsługuje kliknięcie przycisku w dół w polu pokrętła (nazywanego również kontrolką w dół).</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" /> metodę.</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public override bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.UpDownBase.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kontrolka ma fokus wprowadzania.</summary>
        <value><see langword="true" />Jeśli kontrolka ma fokus; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.UpDownBase.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu pola pokrętła (nazywanego również kontrolką w dół).</summary>
        <value>Pierwszy plan <see cref="T:System.Drawing.Color" /> pola pokrętła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.UpDownBase.ForeColor%2A> Właściwość zmieni kolor tekstu w części pola tekstowego pola pokrętła.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InterceptArrowKeys">
      <MemberSignature Language="C#" Value="public bool InterceptArrowKeys { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InterceptArrowKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
      <MemberSignature Language="VB.NET" Value="Public Property InterceptArrowKeys As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InterceptArrowKeys { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InterceptArrowKeys : bool with get, set" Usage="System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy użytkownik może użyć klawiszy Strzałka w górę i Strzałka w dół, aby wybrać wartości.</summary>
        <value><see langword="true" />Jeśli kontrolka umożliwia użycie klawiszy Strzałka w górę i Strzałka w dół w celu wybrania wartości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona na `true` , a pole pokrętła (nazywane również kontrolką w górę) ma fokus, użytkownik może użyć klawiszy Strzałka w górę i Strzałka w dół, aby wybrać wartości. <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga <xref:System.Windows.Forms.NumericUpDown> formantu o nazwie `numericUpDown1`, dwóch <xref:System.Windows.Forms.ComboBox> kontrolek o `comboBox1` nazwach i `comboBox2`i trzech <xref:System.Windows.Forms.CheckBox> formantów o nazwach `checkBox2` `checkBox1`, `checkBox2` i utworzone w formularzu. Dodaj następujące elementy `comboBox1`do: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy `comboBox2`do: `Left`, `Right`, i `Center`.  
  
 Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar pola pokrętła (nazywanego również kontrolką w górę).</summary>
        <value>Wartość <see cref="T:System.Drawing.Size" />, która jest maksymalnym rozmiarem pola pokrętła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bez względu na określoną wartość <xref:System.Drawing.Size.Height%2A> maksymalny rozmiar będzie zawsze równy 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.UpDownBase.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia minimalny rozmiar pola pokrętła (nazywanego również kontrolką w górę).</summary>
        <value><see cref="T:System.Drawing.Size" />, Który jest minimalnym rozmiarem pola pokrętła.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po umieszczeniu wskaźnika myszy na <see cref="T:System.Windows.Forms.UpDownBase" /> kontrolce.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po umieszczeniu wskaźnika myszy na <see cref="T:System.Windows.Forms.UpDownBase" /> kontrolce.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy opuści <see cref="T:System.Windows.Forms.UpDownBase" /> formant.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.UpDownBase.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy nad <see cref="T:System.Windows.Forms.UpDownBase" /> formantem.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChanged : obj * EventArgs -&gt; unit&#xA;override this.OnChanged : obj * EventArgs -&gt; unit" Usage="upDownBase.OnChanged (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Gdy jest zastępowany w klasie pochodnej, podnosi zmienione zdarzenie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="upDownBase.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnFontChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnFontChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="upDownBase.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnHandleCreated%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnHandleCreated(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="upDownBase.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnHandleDestroyed%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnHandleDestroyed(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (e As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="upDownBase.OnLayout e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.LayoutEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Layout" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnLayout%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.  
  
Przykład</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDown" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseDown%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs mevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs mevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (mevent As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ mevent);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseUp mevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mevent" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mevent">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseUp" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wystąpi dwukrotne kliknięcie, <xref:System.Windows.Forms.UpDownBase.OnMouseUp%2A> metoda spowoduje <xref:System.Windows.Forms.Control.DoubleClick> wystąpienie zdarzenia.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseUp%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="upDownBase.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseWheel" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli pole pokrętła (nazywane również kontrolką w górę) ma fokus w momencie wystąpienia tego zdarzenia, jest określany kierunek przechodzenia przez użytkownika kółkiem myszy, a <xref:System.Windows.Forms.UpDownBase.UpButton%2A> Metoda or <xref:System.Windows.Forms.UpDownBase.DownButton%2A> jest wywoływana.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnMouseWheel%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="upDownBase.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnPaint%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnPaint(System.Windows.Forms.PaintEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxKeyDown (object source, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxKeyDown(object source, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxKeyDown (source As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxKeyDown(System::Object ^ source, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxKeyDown : obj * System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnTextBoxKeyDown : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="upDownBase.OnTextBoxKeyDown (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyDown" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona na `true` , a użytkownik naciśnie klawisz Strzałka w <xref:System.Windows.Forms.UpDownBase.UpButton%2A> górę, Metoda zostanie wywołana. <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> Podobnie, jeśli użytkownik naciśnie klawisz Strzałka w dół, <xref:System.Windows.Forms.UpDownBase.DownButton%2A> Metoda zostanie wywołana.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="P:System.Windows.Forms.UpDownBase.InterceptArrowKeys" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxKeyPress (object source, System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxKeyPress(object source, class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxKeyPress (source As Object, e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxKeyPress(System::Object ^ source, System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxKeyPress : obj * System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnTextBoxKeyPress : obj * System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="upDownBase.OnTextBoxKeyPress (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e">A <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyPress" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxKeyPress(System.Object,System.Windows.Forms.KeyPressEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxLostFocus (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxLostFocus(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxLostFocus (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxLostFocus(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxLostFocus : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxLostFocus : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxLostFocus (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.LostFocus" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda sprawdza poprawność tekstu w części pola tekstowego kontrolki, gdy pole pokrętła (nazywane również kontrolką w górę) utraci fokus.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxLostFocus(System.Object,System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxResize">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxResize (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxResize(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxResize (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxResize(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxResize : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxResize : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxResize (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda dostosowuje rozmiar pola pokrętła (nazywanego również kontrolką w górę), gdy zmieniany jest rozmiar pola tekstowego kontrolki.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxResize%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxResize(System.Object,System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnTextBoxTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextBoxTextChanged (object source, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextBoxTextChanged(object source, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextBoxTextChanged (source As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextBoxTextChanged(System::Object ^ source, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextBoxTextChanged : obj * EventArgs -&gt; unit&#xA;override this.OnTextBoxTextChanged : obj * EventArgs -&gt; unit" Usage="upDownBase.OnTextBoxTextChanged (source, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">Źródło zdarzenia.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.OnTextBoxTextChanged(System.Object,System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="PreferredHeight">
      <MemberSignature Language="C#" Value="public int PreferredHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.PreferredHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredHeight { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredHeight : int" Usage="System.Windows.Forms.UpDownBase.PreferredHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wysokość pola pokrętła (nazywanego również kontrolką w górę).</summary>
        <value>Wysokość pola pokrętła (w pikselach).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość właściwości jest zależna <xref:System.Windows.Forms.TextBoxBase.PreferredHeight%2A> od właściwości części pola tekstowego kontrolki i jest dostosowywana do stylu obramowania. <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga, aby <xref:System.Windows.Forms.NumericUpDown> kontrolka, dwie <xref:System.Windows.Forms.ComboBox> kontrolki i trzy <xref:System.Windows.Forms.CheckBox> kontrolki zostały utworzone w formularzu. Oznacz kontrolki <xref:System.Windows.Forms.UpDownBase.BorderStyle%2A> i <xref:System.Windows.Forms.UpDownBase.TextAlign%2A>. <xref:System.Windows.Forms.ComboBox> Oznacz kontrolki <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> ,<xref:System.Windows.Forms.UpDownBase.ReadOnly%2A>i .<xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> <xref:System.Windows.Forms.CheckBox> Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła. Dodaj następujące elementy do pola kombi oznaczonego obramowaniem: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy do pola kombi oznaczonego jako TextAlign: `Left`, `Right`, i `Center`.  
  
 [!code-cpp[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.PreferredHeight" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Windows.Forms.UpDownBase.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy tekst można zmienić przy użyciu przycisków w górę i w dół.</summary>
        <value><see langword="true" />Jeśli tekst można zmienić przy użyciu przycisków w górę lub w dół. w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawiając <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> właściwość na `true`, należy wyeliminować konieczność <xref:System.Windows.Forms.UpDownBase.Text%2A> stosowania wielu walidacji właściwości. Zmiany <xref:System.Windows.Forms.UpDownBase.Text%2A> wartości są ograniczone przy użyciu przycisków w górę i w dół. Zezwala na ich tylko na wybór określonych wartości.  
  
> [!NOTE]
>  W klasie <xref:System.Windows.Forms.DomainUpDown>pochodnej zachowanie opisane jest nieco inne. Gdy <xref:System.Windows.Forms.UpDownBase.ReadOnly%2A> jest ustawiona na `true` , a klawisz jest wciśnięty, formant wybiera pierwszy element w kolekcji, w którym pierwszy znak pasuje do naciśniętego klawisza.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga, aby <xref:System.Windows.Forms.NumericUpDown> kontrolka, dwie <xref:System.Windows.Forms.ComboBox> kontrolki i trzy <xref:System.Windows.Forms.CheckBox> kontrolki zostały utworzone w formularzu. Oznacz kontrolki <xref:System.Windows.Forms.UpDownBase.BorderStyle%2A> i <xref:System.Windows.Forms.UpDownBase.TextAlign%2A>. <xref:System.Windows.Forms.ComboBox> Oznacz kontrolki <xref:System.Windows.Forms.UpDownBase.InterceptArrowKeys%2A> ,<xref:System.Windows.Forms.UpDownBase.ReadOnly%2A>i .<xref:System.Windows.Forms.UpDownBase.UpDownAlign%2A> <xref:System.Windows.Forms.CheckBox> Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła. Dodaj następujące elementy do pola kombi oznaczonego obramowaniem: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy do pola kombi oznaczonego jako TextAlign: `Left`, `Right`, i `Center`.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected override void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="upDownBase.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Wartość DPI przed zmianą.</param>
        <param name="deviceDpiNew">Wartość DPI po zmianie.</param>
        <summary>Zapewnia stałe do ponownego skalowania kontrolki po wystąpieniu zmiany DPI.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.Select(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int start, int length);" />
      <MemberSignature Language="F#" Value="override this.Select : int * int -&gt; unit" Usage="upDownBase.Select (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">Pozycja pierwszego znaku, który ma zostać wybrany.</param>
        <param name="length">Łączna liczba znaków do wybrania.</param>
        <summary>Wybiera zakres tekstu w polu pokrętła (znanym także jako kontrolka w górę) określający pozycję początkową i liczbę znaków do wybrania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda może być używana, gdy pole pokrętła uzyskuje fokus, lub <xref:System.Windows.Forms.UpDownBase.Text%2A> gdy nie można sprawdzić poprawności danych właściwości. <xref:System.Windows.Forms.UpDownBase.Select%2A> Podczas dodawania kodu sprawdzania poprawności dla <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> metody w klasie pochodnej, <xref:System.Windows.Forms.UpDownBase.Select%2A> Wywołaj metodę, gdy Walidacja nie powiedzie się.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown>pochodnej. Ten kod wymaga, aby <xref:System.Windows.Forms.NumericUpDown> formant i obiekt <xref:System.Windows.Forms.Button> został utworzony <xref:System.Drawing> w formularzu i przestrzeń nazw została dodana jako odwołanie. Na zdarzeniu dla przycisku rozmiar tekstu <xref:System.Windows.Forms.NumericUpDown> w kontrolce rośnie. <xref:System.Windows.Forms.Control.Click> Zostanie wyświetlony komunikat z prośbą o <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A> dostosowanie jej właściwości tak, aby cały tekst był widoczny w formancie. Gdy użytkownik wprowadzi nową wartość i opuszcza <xref:System.Windows.Forms.NumericUpDown> formant, tekst jest konwertowany na wartość liczbową z wartości ciągu i zweryfikowany, aby znajdował się <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> między i <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> . Jeśli wartość jest nieprawidłowa, <xref:System.Windows.Forms.MessageBox> zostanie wyświetlony komunikat o błędzie, <xref:System.Windows.Forms.UpDownBase.Select%2A> a metoda spowoduje wybranie tekstu, aby użytkownik mógł wprowadzić nową wartość.  
  
 [!code-cpp[Classic UpDownBase.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="upDownBase.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="y" Type="System.Int32" Index="1" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="width" Type="System.Int32" Index="2" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="height" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="4" FrameworkAlternate="netframework-1.1" />
      </Parameters>
      <Docs>
        <param name="x">Nowa <see cref="P:System.Windows.Forms.Control.Left" /> wartość właściwości formantu.</param>
        <param name="y">Nowa <see cref="P:System.Windows.Forms.Control.Top" /> wartość właściwości formantu.</param>
        <param name="width">Nowa <see cref="P:System.Windows.Forms.Control.Width" /> wartość właściwości formantu.</param>
        <param name="height">Nowa <see cref="P:System.Windows.Forms.Control.Height" /> wartość właściwości formantu.</param>
        <param name="specified">Bitowa kombinacja wartości wyliczenia.</param>
        <summary>Wykonuje zadanie ustawiania określonych granic tej kontrolki.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.UpDownBase.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst wyświetlany w polu pokrętła (znanym także jako kontrolka w dół).</summary>
        <value>Wartość ciągu wyświetlana w polu pokrętła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A> jest wywoływana, <xref:System.Windows.Forms.UpDownBase.Text%2A> Jeśli <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> właściwość jest ustawiona, gdy właściwość jest ustawiona na `true`. Metoda <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> jest wywoływana, <xref:System.Windows.Forms.UpDownBase.Text%2A> Jeśli <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> właściwość jest ustawiona, gdy właściwość jest ustawiona na `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown>pochodnej. Ten kod wymaga, aby <xref:System.Windows.Forms.NumericUpDown> formant i obiekt <xref:System.Windows.Forms.Button> został utworzony <xref:System.Drawing> w formularzu i przestrzeń nazw została dodana jako odwołanie. Na zdarzeniu dla przycisku rozmiar tekstu <xref:System.Windows.Forms.NumericUpDown> w kontrolce rośnie. <xref:System.Windows.Forms.Control.Click> Zostanie wyświetlony komunikat z prośbą o <xref:System.Windows.Forms.UpDownBase.PreferredHeight%2A> dostosowanie właściwości, tak aby cały tekst był widoczny w formancie. Gdy użytkownik wprowadzi nową wartość i opuszcza <xref:System.Windows.Forms.NumericUpDown> formant, tekst jest konwertowany na wartość liczbową z wartości ciągu i zweryfikowany, aby znajdował się <xref:System.Windows.Forms.NumericUpDown.Minimum%2A> między i <xref:System.Windows.Forms.NumericUpDown.Maximum%2A> . Jeśli wartość jest nieprawidłowa, <xref:System.Windows.Forms.MessageBox> zostanie wyświetlony komunikat o błędzie, <xref:System.Windows.Forms.UpDownBase.Select%2A> a metoda spowoduje wybranie tekstu, aby użytkownik mógł wprowadzić nową wartość.  
  
 [!code-cpp[Classic UpDownBase.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase.Text Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="TextAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment TextAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment TextAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.TextAlign" />
      <MemberSignature Language="VB.NET" Value="Public Property TextAlign As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment TextAlign { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.TextAlign : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.UpDownBase.TextAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wyrównanie tekstu w polu pokrętła (nazywanego również kontrolką w górę).</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.HorizontalAlignment.Left" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga <xref:System.Windows.Forms.NumericUpDown> formantu o nazwie `numericUpDown1`, dwóch <xref:System.Windows.Forms.ComboBox> kontrolek o `comboBox1` nazwach i `comboBox2`i trzech <xref:System.Windows.Forms.CheckBox> formantów o nazwach `checkBox2` `checkBox1`, `checkBox2` i utworzone w formularzu. Dodaj następujące elementy `comboBox1`do: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy `comboBox2`do: `Left`, `Right`, i `Center`.  
  
 Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.HorizontalAlignment" /> wartości.</exception>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UpDownAlign" />
      </Docs>
    </Member>
    <Member MemberName="UpButton">
      <MemberSignature Language="C#" Value="public abstract void UpButton ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.UpButton" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub UpButton ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void UpButton();" />
      <MemberSignature Language="F#" Value="abstract member UpButton : unit -&gt; unit" Usage="upDownBase.UpButton " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, obsługuje kliknięcie przycisku w górę w polu pokrętła (nazywanego również kontrolką w dół).</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody w klasie pochodnej należy wywołać <see cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" /> metodę.</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="UpdateEditText">
      <MemberSignature Language="C#" Value="protected abstract void UpdateEditText ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void UpdateEditText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub UpdateEditText ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void UpdateEditText();" />
      <MemberSignature Language="F#" Value="abstract member UpdateEditText : unit -&gt; unit" Usage="upDownBase.UpdateEditText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, aktualizuje tekst wyświetlany w polu pokrętła (znany również jako kontrolka w dół).</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody w klasie pochodnej należy zaktualizować <see cref="P:System.Windows.Forms.UpDownBase.Text" /> właściwość pola pokrętła.</para></block>
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpButton" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.DownButton" />
      </Docs>
    </Member>
    <Member MemberName="UpDownAlign">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.LeftRightAlignment UpDownAlign { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.LeftRightAlignment UpDownAlign" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.UpDownAlign" />
      <MemberSignature Language="VB.NET" Value="Public Property UpDownAlign As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::LeftRightAlignment UpDownAlign { System::Windows::Forms::LeftRightAlignment get(); void set(System::Windows::Forms::LeftRightAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.UpDownAlign : System.Windows.Forms.LeftRightAlignment with get, set" Usage="System.Windows.Forms.UpDownBase.UpDownAlign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia wyrównanie przycisków w górę i w dół w polu pokrętła (znanym także jako kontrolka w dół).</summary>
        <value>Jedna z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości. Wartość domyślna to <see cref="F:System.Windows.Forms.LeftRightAlignment.Right" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu używa klasy <xref:System.Windows.Forms.NumericUpDown> pochodnej i ustawia niektóre właściwości pochodne od. <xref:System.Windows.Forms.UpDownBase> Ten kod wymaga <xref:System.Windows.Forms.NumericUpDown> formantu o nazwie `numericUpDown1`, dwóch <xref:System.Windows.Forms.ComboBox> kontrolek o `comboBox1` nazwach i `comboBox2`i trzech <xref:System.Windows.Forms.CheckBox> formantów o nazwach `checkBox2` `checkBox1`, `checkBox2` i utworzone w formularzu. Dodaj następujące elementy `comboBox1`do: `None`, `Fixed3D`, i `FixedSingle`. Dodaj następujące elementy `comboBox2`do: `Left`, `Right`, i `Center`.  
  
 Kod umożliwia zmianę wartości właściwości w czasie wykonywania i zobacz, jak każdy ma wpływ na wygląd i zachowanie pola pokrętła.  
  
 [!code-cpp[Classic UpDownBase Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic UpDownBase Example/CPP/source.cpp#1)]
 [!code-csharp[Classic UpDownBase Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic UpDownBase Example/CS/source.cs#1)]
 [!code-vb[Classic UpDownBase Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic UpDownBase Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Przypisana wartość nie jest jedną z <see cref="T:System.Windows.Forms.LeftRightAlignment" /> wartości.</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="UserEdit">
      <MemberSignature Language="C#" Value="protected bool UserEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.UpDownBase.UserEdit" />
      <MemberSignature Language="VB.NET" Value="Protected Property UserEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UserEdit { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UserEdit : bool with get, set" Usage="System.Windows.Forms.UpDownBase.UserEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wartość została wprowadzona przez użytkownika.</summary>
        <value><see langword="true" />Jeśli użytkownik zmienił <see cref="P:System.Windows.Forms.UpDownBase.Text" /> Właściwość; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość jest ustawiona, <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> gdy właściwość <xref:System.Windows.Forms.UpDownBase.UpdateEditText%2A> jest ustawiona na `true`, wywoływana jest metoda. <xref:System.Windows.Forms.UpDownBase.Text%2A> Jeśli właściwość jest ustawiona, <xref:System.Windows.Forms.UpDownBase.UserEdit%2A> gdy właściwość <xref:System.Windows.Forms.UpDownBase.ValidateEditText%2A> jest ustawiona na `false`, wywoływana jest metoda. <xref:System.Windows.Forms.UpDownBase.Text%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.UpdateEditText" />
        <altmember cref="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      </Docs>
    </Member>
    <Member MemberName="ValidateEditText">
      <MemberSignature Language="C#" Value="protected virtual void ValidateEditText ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ValidateEditText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.ValidateEditText" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ValidateEditText ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ValidateEditText();" />
      <MemberSignature Language="F#" Value="abstract member ValidateEditText : unit -&gt; unit&#xA;override this.ValidateEditText : unit -&gt; unit" Usage="upDownBase.ValidateEditText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gdy jest zastępowany w klasie pochodnej, sprawdza poprawność tekstu wyświetlanego w polu pokrętła (nazywanego również kontrolką w dół).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Przykładami walidacji są porównanie tekstu wprowadzonego do typu danych ustawionego w klasie pochodnej, porównywanie tekstu z listą wartości lub sprawdzanie, czy tekst ma znajdować się w zakresie wartości.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania tej metody w klasie pochodnej należy dodać kod w tej metodzie, aby zweryfikować tekst pola pokrętła. Ta metoda zostanie wywołana, <see cref="P:System.Windows.Forms.UpDownBase.UserEdit" /> Jeśli właściwość jest ustawiona na <see langword="false" /> , <see cref="P:System.Windows.Forms.UpDownBase.Text" /> gdy właściwość jest ustawiona.</para></block>
        <altmember cref="P:System.Windows.Forms.UpDownBase.UserEdit" />
        <altmember cref="P:System.Windows.Forms.UpDownBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.UpDownBase.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="upDownBase.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">System Windows <see cref="T:System.Windows.Forms.Message" /> do przetworzenia.</param>
        <summary>Przetwarza wiadomości systemu Windows.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do wywoływania kodu niezarządzanego. Powiązane wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>

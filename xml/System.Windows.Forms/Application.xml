<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="61c0b9ddd34084dbe9cf048ad5351e4777e4afcb" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36349910" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia <see langword="static" /> metody i właściwości, aby zarządzać aplikacją, takich jak metody, aby uruchomić i zatrzymać aplikację do przetwarzania komunikatów systemu Windows i właściwości, aby uzyskać informacje o aplikacji. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> Klasa zawiera metody do uruchamiania i zatrzymywania aplikacji i wątków oraz do przetwarzania komunikatów systemu Windows, w następujący sposób:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> Uruchamia pętli komunikatów aplikacji w bieżącym wątku i, opcjonalnie, powoduje, że formularz widoczna.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> lub <xref:System.Windows.Forms.Application.ExitThread%2A> zatrzymuje pętli komunikatów.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> przetwarza wiadomości, gdy program jest w pętli.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Dodaje filtr komunikatu do przekazywanie komunikatów aplikacji do monitorowania komunikatów systemu Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> Umożliwia zatrzymanie zdarzenie z zgłaszanych lub wykonywać operacje specjalne, zanim wywoła funkcję obsługi zdarzeń.  
  
 Ta klasa ma <xref:System.Windows.Forms.Application.CurrentCulture%2A> i <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> właściwości do pobrania lub ustawienia kultury informacje dla bieżącego wątku.  
  
 Nie można utworzyć wystąpienia tej klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każdym kliknięciu `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikacji, który tworzy formularz, `listBox1` i `button1`. Po kliknięciu przez użytkownika `button1`, `button1_Click` metoda Wyświetla <xref:System.Windows.Forms.MessageBox>. Gdy użytkownik kliknie `No` na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metody dodaje numer do listy. Gdy użytkownik kliknie `Yes`, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A> przetworzyć wszystkie pozostałe wiadomości w kolejce, a następnie, aby zakończyć.  
  
> [!NOTE]
>  Wywołanie <xref:System.Windows.Forms.Application.Exit%2A> zakończy się niepowodzeniem w częściowej relacji zaufania.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> interfejsu do zainstalowania.</param>
        <summary>Dodaje filtr komunikatu do monitorowania komunikatów systemu Windows, aż do ich miejsc docelowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj filtru wiadomości, aby zapobiec określonych zdarzeń zgłaszanych lub wykonania operacji specjalne zdarzenia przed przekazaniem do programu obsługi zdarzeń. Filtry komunikatów są unikatowe z konkretnym wątkiem.  
  
 Aby zapobiec wiadomości wysyłane, `value` wystąpienia parametru, które przekazujesz do tej metody należy zastąpić <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> metody z kodu do obsługi wiadomości. Metoda musi zwracać `false`.  
  
> [!CAUTION]
>  Dodawanie filtry komunikatów do przekazywanie komunikatów w aplikacji może obniżyć wydajność.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy filtr komunikatu o nazwie `TestMessageFilter`. Ten filtr blokuje wszystkie komunikaty o lewego przycisku myszy. Przed użyciem filtru komunikatów, musi dostarczyć implementację dla <xref:System.Windows.Forms.IMessageFilter> interfejsu.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obiektu wywołującego bezpośrednio wywoływać kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy element wywołujący może zakończyć tę aplikację.</summary>
        <value>
          <see langword="true" /> Jeśli element wywołujący można zakończyć tej aplikacji, w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `false` gdy została wywołana z <xref:System.Windows.Forms.Control> obsługiwane w przeglądarce sieci Web. W związku z tym <xref:System.Windows.Forms.Control> nie można zakończyć <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zostanie zamknięta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy dołączyć do obsługi zdarzeń <xref:System.Windows.Forms.Application.Exit%2A> zdarzenia w celu wykonania nieobsługiwany, wymagane zadania przed aplikacja przestanie działać. Możesz zamknąć pliki otwarte w tej aplikacji lub Usuń obiekty, które nie odzyskać wyrzucanie elementów bezużytecznych.  
  
 Ponieważ jest to statyczne zdarzenia, należy odłączyć żadnych programów obsługi zdarzeń dołączony do tego zdarzenia w <xref:System.Windows.Forms.Application.ApplicationExit> obsługi zdarzeń, sama. Jeśli te programy obsługi nie jest odłączyć, będzie pozostaną dołączone do zdarzenia, a w dalszym ciągu korzystać z pamięci.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia dwa formularze i zamyka aplikację, gdy oba formularze są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, jest zapamiętany pozycji każdego formularza. W tym przykładzie pokazano, za pomocą <xref:System.Windows.Forms.Application.ApplicationExit> zdarzenie, aby dowiedzieć się, gdy położenie formularza powinny zostać utrwalony do pliku i po `FileStream` powinno zostać zamknięte.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi podczas każdego formularza jest zamknięty i kończy działanie bieżącego wątku, gdy są one obu. Klasa pamięta pozycji każdego formularza po jego zamknięciu. Gdy <xref:System.Windows.Forms.Application.ApplicationExit> wystąpi zdarzenie, klasa zapisuje pozycji każdego użytkownika do pliku. Dane położenie formularza są przechowywane w pliku zatytułowany `appdata.txt` utworzonego w lokalizacji ustaleniami <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` do uruchomienia aplikacji, podanych <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod jest fragment przykład pokazany na <xref:System.Windows.Forms.ApplicationContext> Przegląd klasy. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji, która jest wspólna dla wszystkich użytkowników.</summary>
        <value>Ścieżka do danych aplikacji, który jest współużytkowany przez wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Podstawowa ścieżka*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> pierwszy wygląda czy zestaw zawierający głównego pliku wykonywalnego, który ma `AssemblyInformationalVersion` atrybutu na nim. Jeśli ten atrybut istnieje, jest ona używana zarówno dla <xref:System.Windows.Forms.Application.ProductVersion%2A> i <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Jeśli ten atrybut nie istnieje, obie właściwości użyć wersji pliku wykonywalnego.  
  
 Ścieżka będzie się różnił w zależności od tego, czy w aplikacji formularzy systemu Windows jest wdrażane za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacje są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w C:\Documents and Settings\\*username* katalogu. Aby uzyskać więcej informacji, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji, która jest wspólna dla wszystkich użytkowników.</summary>
        <value>A <see cref="T:Microsoft.Win32.RegistryKey" /> reprezentujących klucz rejestru danych aplikacji, która jest wspólna dla wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, jest on tworzony w następującym formacie:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę firmy, skojarzone z aplikacją.</summary>
        <value>Nazwa firmy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o ustawieniach kulturowych bieżącego wątku.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> reprezentujący informacji o kulturze dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">we wszystkich oknach ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący język dla bieżącego wątku.</summary>
        <value>
          <see cref="T:System.Windows.Forms.InputLanguage" /> Reprezentujący bieżący język dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obiektu wywołującego bezpośrednio wywoływać kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przetwarza wszystkie komunikaty systemu Windows w kolejce wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu formularza systemu Windows, tworzy nowy formularz, następnie czeka na zdarzenia do obsługi. Zawsze formularza obsługuje zdarzenie przetwarza cały kod skojarzony z tym zdarzeniem. Wszystkie inne zdarzenia oczekiwać w kolejce. Gdy swój kod obsługi zdarzenia, aplikacja nie odpowiada. Na przykład jeśli inne okno zostanie przeciągnięty u góry okna odświeżenia nie.  
  
 Jeśli należy wywołać <xref:System.Windows.Forms.Application.DoEvents%2A> w kodzie, aplikacja może obsługiwać inne zdarzenia. Na przykład, jeśli masz formularz, który dodaje dane do <xref:System.Windows.Forms.ListBox> i Dodaj <xref:System.Windows.Forms.Application.DoEvents%2A> do kodu, gdy inne okno zostanie przeciągnięty nad nim odświeża formularza. Jeśli usuniesz <xref:System.Windows.Forms.Application.DoEvents%2A> z poziomu kodu formularza nie będzie odświeżenia dopiero po zakończeniu obsługi zdarzeń kliknięcia przycisku wykonywania. Aby uzyskać więcej informacji dotyczących obsługi wiadomości, zobacz [dane wejściowe użytkownika w formularzach systemu Windows](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 W przeciwieństwie do programu Visual Basic 6.0 <xref:System.Windows.Forms.Application.DoEvents%2A> nie wywołuje metody <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody.  
  
 Zwykle Użyj tej metody w pętli do przetwarzania komunikatów.  
  
> [!CAUTION]
>  Wywołanie tej metody powoduje, że bieżący wątek zostanie zawieszona podczas przetwarzania wszystkich komunikatów okien oczekiwania. Jeśli komunikat spowoduje wyzwolenie zdarzenia, może wykonywać innych obszarach kod aplikacji. Może to spowodować wykazują nieoczekiwane zachowania, które są trudne do debugowania aplikacji. Jeśli wykonywane operacje lub obliczenia, które zająć dużo czasu, często zaleca się wykonanie w nowym wątku. Aby uzyskać więcej informacji na temat programowania asynchronicznego, zobacz [asynchronicznego programowania modelu (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, przy użyciu <xref:System.Windows.Forms.Application.DoEvents%2A> metody. Po uruchomieniu przykładzie użytkownik może wybrać plików graficznych z <xref:System.Windows.Forms.OpenFileDialog>. Wybrane pliki są wyświetlane w formularzu. <xref:System.Windows.Forms.Application.DoEvents%2A> Metody wymusza odświeżenia formularza dla każdego pliku grafiki otwarty. Aby uruchomić ten przykład, wklej następujący kod w nadrzędnym formularza <xref:System.Windows.Forms.PictureBox> o nazwie `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> o nazwie `OpenFileDialog1`, a przycisk o nazwie `fileButton`. Wywołanie `InitializePictureBox` i `InitializeOpenFileDialog` metody z konstruktora formularza lub `Load` metody.  
  
> [!NOTE]
>  W programie Visual Studio, jeśli dodasz <xref:System.Windows.Forms.OpenFileDialog> do formularza przy użyciu operacji przeciągania, należy zmodyfikować następujące elementy `InitializeOpenFileDialog` metody przez usunięcie wiersza, który tworzy nowe wystąpienie klasy <xref:System.Windows.Forms.OpenFileDialog>.  
  
 Przykład wymaga również, aby <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> zdarzenie <xref:System.Windows.Forms.Button> kontroli i <xref:System.Windows.Forms.FileDialog.FileOk> zdarzenie <xref:System.Windows.Forms.OpenFileDialog> są podłączone do obsługi zdarzeń zdefiniowanych w przykładzie. Kiedy przykładzie jest uruchomiona, zostanie wyświetlone okno dialogowe przez kliknięcie przycisku.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia style wizualne dla aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia style wizualne dla aplikacji. Style wizualne są kolory, czcionki i inne elementy wizualne, które tworzą motywu systemu operacyjnego. Formanty narysuje przy użyciu stylów wizualnych, jeśli formant i system operacyjny obsługuje. Moc <xref:System.Windows.Forms.Application.EnableVisualStyles> musi zostać wywołana przed utworzeniem jakichkolwiek formantów w aplikacji; zwykle <xref:System.Windows.Forms.Application.EnableVisualStyles> jest to pierwszy wiersz w `Main` funkcji. Oddzielne manifest nie jest wymagane ma włączyć style wizualne podczas wywoływania metody <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Przed programu .NET Framework 2.0 `FlatStyle` właściwości niektóre formanty, takie jak formantów, które pochodzą z <xref:System.Windows.Forms.ButtonBase>, ma ustawiony <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> w kolejności kontrolek być rysowane przy użyciu stylów wizualnych. W aplikacji napisanej dla platformy .NET Framework 2.0 to nie jest już konieczne.  
  
> [!NOTE]
>  Ta metoda nie wpłyną formantów hostowanej w programie Internet Explorer.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje wywołanie <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> w `Main` funkcji ma włączyć style wizualne dla aplikacji.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja ma wprowadzić stanu modalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do formularzy systemu Windows i upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> uprawnienie do nasłuchiwania na zdarzenie.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do pliku wykonywalnego, który uruchomił aplikację, łącznie z nazwą pliku wykonywalnego.</summary>
        <value>Nazwa ścieżki i plik wykonywalny dla pliku wykonywalnego, który uruchomił aplikację.  Ta ścieżka będzie się różnił w zależności od tego, czy w aplikacji formularzy systemu Windows jest wdrażane za pomocą [! INCLUDE[ndptecclick](~/includes/ndptecclick-MD.MD)]. [! INCLUDE[ndptecclick](~/includes/ndptecclick-MD.MD)] aplikacji są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w C:\Documents and Settings\\* username * katalogu. Aby uzyskać więcej informacji, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uzyskiwania ścieżki. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informuje o wszystkich pomp komunikat one musi zakończyć, a następnie zamyka wszystkich aplikacji systemu windows, po przetworzeniu wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informuje o wszystkich pomp komunikat one musi zakończyć, a następnie zamyka wszystkich aplikacji systemu windows, po przetworzeniu wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> — Metoda powoduje zatrzymanie wszystkich uruchomionych pętli komunikatów na wszystkie wątki i zamknięcie wszystkich okien aplikacji. Ta metoda nie wymusza niekoniecznie aplikacji, aby zakończyć. <xref:System.Windows.Forms.Application.Exit%2A> Metoda jest wywoływana zwykle z pętli komunikatów i wymusza <xref:System.Windows.Forms.Application.Run%2A> do zwrócenia. Aby wyjść z pętli komunikatów dla bieżącego wątku, należy wywołać <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> informuje o następujących zdarzeniach i wykonuje skojarzonych z nimi działań warunkowego:  
  
-   A <xref:System.Windows.Forms.Form.FormClosing> zdarzenie jest wywoływane dla każdego formularza reprezentowany przez <xref:System.Windows.Forms.Application.OpenForms%2A> właściwości. To zdarzenie może być anulowane przez ustawienie <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość ich <xref:System.Windows.Forms.FormClosingEventArgs> parametr `true`.  
  
-   Jeśli jednego lub więcej programów obsługi umożliwia anulowanie zdarzenia, następnie <xref:System.Windows.Forms.Application.Exit%2A> zwraca bez dalszego działania. W przeciwnym razie <xref:System.Windows.Forms.Form.FormClosed> zdarzenie jest wywoływane dla każdego Otwórz formularz, a następnie wszystkie uruchomione pętli komunikatów i formularze są zamknięte.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> — Metoda nie wygenerował <xref:System.Windows.Forms.Form.Closed> i <xref:System.Windows.Forms.Form.Closing> zdarzenia, które są przestarzałe, począwszy od programu [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każdym kliknięciu `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikacji, który tworzy formularz, `listBox1`, i `button1`. Po kliknięciu przez użytkownika `button1`, `button1_Click` metoda dodaje liczby jednej do trzech do pola listy i wyświetla <xref:System.Windows.Forms.MessageBox>. Gdy użytkownik kliknie **nr** na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metody dodaje inny numer do listy. Gdy użytkownik kliknie **tak**, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A>, aby przetworzyć wszystkie pozostałe wiadomości w kolejce, a następnie, aby zakończyć.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały utworzone i umieszczane na formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obiektu wywołującego bezpośrednio wywoływać kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zwraca czy <see cref="T:System.Windows.Forms.Form" /> aplikacji anulowany zakończenia.</param>
        <summary>Informuje o wszystkich pomp komunikat one musi zakończyć, a następnie zamyka wszystkich aplikacji systemu windows, po przetworzeniu wiadomości.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Zezwolenie na zakończenie uruchomionej na wątku aplikacji. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Opuszcza pętlę komunikatów w bieżącym wątku i zamknięcie wszystkich okien w wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby zakończyć pętli komunikatów bieżącego wątku. Ta metoda powoduje wywołanie <xref:System.Windows.Forms.Application.Run%2A> bieżącego wątku do zwrócenia. Aby zakończyć działanie całej aplikacji, należy wywołać <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obiektu wywołującego bezpośrednio wywoływać kodu niezarządzanego. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat zdarzenia systemu Windows do filtrowania.</param>
        <summary>Jest uruchamiana żadnych filtrów dla komunikatów okien i zwraca kopia wiadomości zmodyfikowane.</summary>
        <returns>
          <see langword="True" /> Jeśli filtry przetworzono; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zakończy przetwarzanie i ma wprowadzić w stan bezczynności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli masz zadania, które należy wykonać przed wątku jest bezczynny, dołącz je do tego zdarzenia.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.Application.Idle> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do formularza systemu Windows i upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.Idle> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja ma opuścić stan modalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do formularzy systemu Windows i upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji użytkownika lokalnego, roamingu.</summary>
        <value>Ścieżka do danych aplikacji użytkownika lokalnego, roamingu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik lokalny jest której profil użytkownika jest przechowywany na komputerze, na którym użytkownik jest zalogowany. Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Podstawowa ścieżka*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Typowe ścieżki podstawowej jest C:\Documents and Settings\\*username*\Local danych. Ta ścieżka może się różnić, jednak w przypadku wdrażania aplikacji formularzy systemu Windows przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tworzy własny katalog danych aplikacji, która jest odizolowana od innych aplikacji. Aby uzyskać więcej informacji, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia dwa formularze i zamyka aplikację, gdy oba formularze są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, jest zapamiętany pozycji każdego formularza. Mimo że w tym przykładzie pokazano, za pomocą <xref:System.Windows.Forms.Application.UserAppDataPath%2A> właściwości do przechowywania danych aplikacji dla użytkownika, <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> może być użyty.  
  
 `MyApplicationContext` Klasa dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi informacje podczas każdego formularza jest zamknięty i kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdego formularza dla użytkownika. Dane położenie formularza są przechowywane w pliku zatytułowany `Appdata.txt` utworzonego w lokalizacji ustaleniami <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` do uruchomienia aplikacji, podanych <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod jest fragment przykład pokazany na <xref:System.Windows.Forms.ApplicationContext> Przegląd klasy. Kod nie jest wyświetlana wyłącznie w celu skrócenia. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pętli komunikatów istnieje dla tego wątku.</summary>
        <value>
          <see langword="true" /> Jeśli istnieje pętla wiadomości w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odnośnie do hostowania formularzy systemu Windows w innych środowiskach, takich jak aplikacje niezarządzane, ta właściwość zawsze zwraca `false`. Użyj <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> nakazać formularzy systemu Windows, jeśli środowisko macierzyste nadal ma pętli aktywnych wiadomości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje OLE w bieżącym wątku.</summary>
        <returns>Jeden z <see cref="T:System.Threading.ApartmentState" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed wywołaniem dowolnej `Microsoft.Win32` metodę, która wymaga OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> najpierw sprawdza, czy OLE została zainicjowana w bieżącym wątku. Jeśli nie, inicjuje wątku dla OLE.  
  
> [!NOTE]
>  Chyba, że wątek bezpośrednio wywołuje metody OLE, nie trzeba wywołać tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">
          <see cref="T:System.Exception" /> Reprezentujący wyjątek, który został zgłoszony.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.Application.ThreadException" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Windows.Forms.Application.OnThreadException%2A> Aby zgłosić wyjątek, który spowoduje zatrzymanie przetwarzania aplikacji.  
  
 <xref:System.Windows.Forms.Application> Klasa ma <xref:System.Windows.Forms.Application.ThreadException> zdarzeń. Program obsługi zdarzeń można dołączyć do tego zdarzenia w celu przetwarzania niestandardowych potrzebne dla nieobsługiwanych wyjątków. Jeśli program obsługi zdarzeń, nie dołączaj <xref:System.Windows.Forms.Application.OnThreadException%2A> wykona zachowanie domyślne, które obejmuje wyświetlanie okna dialogowego informują użytkownika o tym, że wystąpił błąd.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> tylko implementuje domyślne zachowanie wyjątek nieobsługiwanych wyjątków, które występują w wątkach należących do formularzy systemu Windows. Nieobsługiwane wyjątki na inne wątki są obsługiwane przez <xref:System.AppDomain.UnhandledException> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję otwartych formularzy należące do aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Forms.FormCollection" /> zawierający wszystkie aktualnie otwarte formularze należących do tej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> Właściwość reprezentuje kolekcję tylko do odczytu formularzy należące do aplikacji. Ta kolekcja można wyszukiwać według pozycji indeksu lub <xref:System.Windows.Forms.Control.Name%2A> z <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Obiekt wywołujący musi mieć uprawnienia dostępu do wszystkich okien, zgodnie z definicją w <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> wartość <see cref="T:System.Security.Permissions.UIPermissionWindow" /> wyliczenia.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę produktu skojarzonych z tą aplikacją.</summary>
        <value>Nazwa produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` jest pobierana z metadanych zestawu zawierającego formularzu głównym bieżącej aplikacji. Można ją ustawić przez ustawienie <xref:System.Reflection.AssemblyProductAttribute> w manifeście zestawu. Aby uzyskać więcej informacji, zobacz [manifestu zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję produktu skojarzonych z tą aplikacją.</summary>
        <value>Wersja produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj będzie wyświetlany jako numer wersji *główne numer*.* niewielkie numer*.* numer kompilacji*.* numer części prywatnej*. Można ustawić jawnie ustawiając wersja zestawu w manifeście zestawu. Aby uzyskać więcej informacji, zobacz [manifestu zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> pierwszy wygląda czy zestaw zawierający głównego pliku wykonywalnego, który ma `AssemblyInformationalVersion` atrybutu na nim. Jeśli ten atrybut istnieje, jest ona używana zarówno dla <xref:System.Windows.Forms.Application.ProductVersion%2A> i <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Jeśli ten atrybut nie istnieje, obie właściwości użyć wersji pliku wykonywalnego.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Obiekty do przekazania do <see cref="E:System.Windows.Forms.Application.Idle" /> zdarzeń.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.Application.Idle" /> zdarzeń w obsługiwanych scenariuszach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana, odnośnie do hostowania w innym środowisku, takich jak niezarządzanej aplikacji formularzy systemu Windows. Należy wywołać <xref:System.Windows.Forms.Application.RaiseIdle%2A> podczas obsługi aplikacji przejdzie w stan bezczynności. Dzięki temu niektóre formanty formularzy systemu Windows i składniki w pracy tła ważne, gdy użytkownik nie jest interakcji z aplikacją.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywoływana, gdy formularzy systemu Windows musi sprawdzić, czy środowisko macierzyste nadal wysyła wiadomości.</param>
        <summary>Rejestruje wywołanie zwrotne do sprawdzania, czy pętli komunikatów działa w środowiskach hostowanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana, odnośnie do hostowania w innym środowisku, takich jak niezarządzanej aplikacji formularzy systemu Windows. W środowiskach hostowanych <xref:System.Windows.Forms.Application.MessageLoop%2A> właściwość zawsze zwraca wartość false, jeśli formularze systemu Windows nie przetwarza wiadomości. Użyj tego wywołania zwrotnego mówić formularzy systemu Windows, jeśli środowisko macierzyste nadal przetwarza wiadomości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> można usunąć z aplikacji.</param>
        <summary>Usuwa filtr komunikatu z przekazywanie komunikatów aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Filtr komunikatu można usunąć, jeśli nie chcesz przechwytywać komunikaty systemu Windows przed ich wysłaniem.  
  
   
  
## Examples  
 Przed użyciem filtru komunikatów, musi dostarczyć implementację dla <xref:System.Windows.Forms.IMessageFilter> interfejsu. Następujące klasy tworzy filtr komunikatu o nazwie `TestMessageFilter`. Ten filtr blokuje wszystkie komunikaty o lewego przycisku myszy.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy bieżąca aplikacja jest rysowania formantów przy użyciu stylów wizualnych.</summary>
        <value>
          <see langword="true" /> Jeżeli style wizualne są włączone dla formantów w klienckim obszarze okna aplikacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli jest rysowany kontrolkę niestandardową, ta właściwość umożliwia podjęcie decyzji o narysować kontrolkę z lub bez stylów wizualnych, tak, aby jej wygląd jest zgodny z innymi formantów w aplikacji.  
  
 W poniższej tabeli przedstawiono cztery warunki, które musi istnieć dla <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> do zwrócenia `true`.  
  
|Warunek|Opis|  
|---------------|-----------------|  
|System operacyjny obsługuje style wizualne|Aby sprawdzić oddzielnie ten warunek, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> właściwość <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Użytkownik ma włączyć style wizualne w systemie operacyjnym|Aby sprawdzić oddzielnie ten warunek, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> właściwość <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Style wizualne są włączone w aplikacji|Style wizualne można włączyć w aplikacji przez wywołanie metody <xref:System.Windows.Forms.Application.EnableVisualStyles> metody lub za pomocą aplikacji do manifestu, który określa, że wersja pliku ComCtl32.dll 6 lub nowszej będzie używany do rysowania formantów.|  
|Style wizualne są używane do rysowania obszaru klienckiego aplikacji systemu windows|Aby sprawdzić oddzielnie ten warunek, użyj <xref:System.Windows.Forms.Application.VisualStyleState%2A> właściwość <xref:System.Windows.Forms.Application> klasy i sprawdź, czy wartość <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> lub <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację i natychmiast uruchamia nowe wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najczęstszym powodem wywołania `Restart` jest rozpoczęcie nowej wersji aplikacji, w której zostały pobrane za pośrednictwem [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] przy użyciu `Update` lub `UpdateAsync` metody.  
  
 Aplikacje są ponownie uruchamiane w kontekście, w którym pierwotnie został uruchomiony. Jeśli aplikacja została uruchomiona z użyciem adresu URL wskazujący bezpośrednio do głównego pliku wykonywalnego aplikacji, zostanie ono uruchomione przy użyciu tego samego adresu URL. Jeśli aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, zostanie ono uruchomione przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Jeśli aplikacja została pierwotnie podane opcje wiersza polecenia po wykonaniu najpierw, <xref:System.Windows.Forms.Application.Restart%2A> spowoduje uruchomienie aplikacji ponownie, używając tych samych opcji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Kod nie jest aplikacji formularzy systemu Windows. Nie można wywołać tej metody, w tym kontekście.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> uprawnienia.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Uruchamia pętli komunikatów standardowych aplikacji w bieżącym wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Uruchamia pętli komunikatów standardowych aplikacji w bieżącym wątku bez formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W formularzu systemu Windows lub na podstawie Win32 aplikacji, pętla wiadomości jest procedury w kodzie, który przetwarza zdarzenia użytkownika, takie jak kliknięcie myszą i pociągnięć klawiatury. Każdy działającej aplikacji opartych na systemie Windows wymaga pętli aktywnych wiadomości o nazwie pętli komunikatów głównego. Po zamknięciu pętli komunikatów głównego kończy działanie aplikacji. W formularzach systemu Windows, ta pętla jest zamknięty kiedy <xref:System.Windows.Forms.Application.Exit%2A> wywoływana jest metoda, lub gdy <xref:System.Windows.Forms.Application.ExitThread%2A> metoda jest wywoływana w wątku, który jest uruchomiony w pętli komunikatów głównego.  
  
 Większość deweloperów formularzy systemu Windows nie trzeba używać tej wersji metody. Należy używać <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> przeciążenia do uruchomienia aplikacji z formularzem głównym, tak aby aplikacja kończy się po zamknięciu formularza głównego. W innych sytuacjach należy użyć <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> przeciążenia, który obsługuje dostarczanie <xref:System.Windows.Forms.ApplicationContext> obiektu, aby uzyskać lepszą kontrolę nad istnienia aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Pętla wiadomości głównego jest już uruchomione w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">
          <see cref="T:System.Windows.Forms.ApplicationContext" /> w uruchamiania aplikacji.</param>
        <summary>Uruchamia pętli komunikatów standardowych aplikacji w bieżącym wątku z <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uruchamia pętli komunikatów do <xref:System.Windows.Forms.Application.Exit%2A> lub <xref:System.Windows.Forms.Application.ExitThread%2A> jest wywoływana lub <xref:System.Windows.Forms.Application.ThreadExit> zdarzenie jest wywoływane na obiekt kontekstu.  
  
   
  
## Examples  
 Przykład przedstawia dwa formularze i zamyka aplikację, gdy oba formularze są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, jest zapamiętany pozycji każdego formularza. W tym przykładzie przedstawiono sposób użycia <xref:System.Windows.Forms.ApplicationContext>, wraz z `Application.Run(context)` metody, aby wyświetlić wielu formularzy podczas uruchamiania aplikacji.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi informacje podczas każdego formularza jest zamknięty i kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdego formularza dla użytkownika. Dane położenie formularza są przechowywane w pliku zatytułowany `Appdata.txt` utworzonego w lokalizacji ustaleniami <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` do uruchomienia aplikacji, podanych <xref:System.Windows.Forms.ApplicationContext>.  
  
 Kod `AppForm1` i `AppForm2` formularzy nie jest wyświetlany wyłącznie w celu skrócenia. Zobacz <xref:System.Windows.Forms.ApplicationContext> Przegląd klasy listę całego kodu.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Pętla wiadomości głównego jest już uruchomione w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">A <see cref="T:System.Windows.Forms.Form" /> reprezentujący formularza, aby były widoczne.</param>
        <summary>Uruchamia pętli komunikatów standardowych aplikacji w bieżącym wątku i powoduje, że określony formularz jest widoczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj główną funkcją aplikacji wywołuje tę metodę i przekazuje do niego w głównym oknie aplikacji.  
  
 Ta metoda dodaje obsługi zdarzeń do `mainForm` parametr <xref:System.Windows.Forms.Form.Closed> zdarzeń. Wywołań obsługi zdarzeń <xref:System.Windows.Forms.Application.ExitThread%2A> czyszczenie aplikacji.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A> Metody <xref:System.Windows.Forms.Form> klasy zostanie wywołana przed zwracany tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każdym kliknięciu `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikacji, który tworzy formularz, `listBox1`, i `button1`. Po kliknięciu przez użytkownika `button1`, `button1_Click` metoda dodaje liczby jednej do trzech do pola listy i wyświetla <xref:System.Windows.Forms.MessageBox>. Gdy użytkownik kliknie **nr** na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metody dodaje inny numer do listy. Gdy użytkownik kliknie **tak**, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A> przetworzyć wszystkie pozostałe wiadomości w kolejce, a następnie, aby zakończyć.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały utworzone i umieszczane na formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Pętla wiadomości głównego jest już uruchomione w bieżącym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg formatu do zastosowania do podpisów okien najwyższego poziomu, gdy są wyświetlane z transparentu ostrzeżenie.</summary>
        <value>Ciąg formatu do podpisów okien najwyższego poziomu.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">we wszystkich oknach ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna dla nowych formantów. Jeśli <see langword="true" />, nowe formanty obsługujące <c>UseCompatibleTextRendering</c> Użyj [! Na podstawie include[ndptecgdiplus](~/includes/ndptecgdiplus-MD.MD)] <see cref="T:System.Drawing.Graphics" /> klasy do renderowania tekstu; Jeśli <see langword="false" />nowe steruje użyciem [! Na podstawie include[ndptecgdi](~/includes/ndptecgdi-MD.MD)] <see cref="T:System.Windows.Forms.TextRenderer" /> klasy.</param>
        <summary>Ustawia domyślną całej aplikacji <c>UseCompatibleTextRendering</c> właściwość zdefiniowaną w niektórych formantów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre formanty formularzy systemu Windows umożliwiający renderowanie tekstu przy użyciu <xref:System.Windows.Forms.TextRenderer> klasy, która jest oparta na [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] bibliotekę grafiki lub <xref:System.Drawing.Graphics> klasy, która jest oparta na [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] bibliotekę grafiki. Ta zmiana została wprowadzona w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] z powodu problemów dotyczących wydajności i lokalizacja z [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Użyj <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> można ustawić wartość domyślną `UseCompatibleTextRendering` właściwości formantów, które ją obsługują.  
  
 `UseCompatibleTextRendering` Właściwości mają na celu dostarczenie visual zgodność formanty formularzy systemu Windows w tym renderowania tekstu przy użyciu <xref:System.Windows.Forms.TextRenderer> klasy i [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] i [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] aplikacji, które wykonują renderowanie tekstu niestandardowego za pomocą <xref:System.Drawing.Graphics>klasy. W większości przypadków, jeśli aplikacja nie jest uaktualniany z [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] lub [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], zaleca się pozostawienie `UseCompatibleTextRendering` ustawioną wartość domyślną `false`.  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Na podstawie <xref:System.Windows.Forms.TextRenderer> klasy została wprowadzona w systemie [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] zwiększyć wydajność, aby tekst wygląd i lepszą obsługę międzynarodowe czcionki. W starszych wersjach [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] na podstawie <xref:System.Drawing.Graphics> klasa została użyta do wykonania wszystkich renderowanie tekstu. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] oblicza odstępy i zawijanie zależy od [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. W aplikacji formularzy systemu Windows, która używa <xref:System.Drawing.Graphics> klasy do renderowania tekstu, może to spowodować tekstu dla kontrolek, które używają <xref:System.Windows.Forms.TextRenderer> się pojawić różne od innego tekstu w aplikacji. Aby rozwiązać ten niezgodności, można ustawić `UseCompatibleTextRendering` właściwości `true`. Aby ustawić `UseCompatibleTextRendering` do `true` dla wszystkich obsługiwanych formantów w aplikacji, należy wywołać <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> metody z parametrem `true`.  
  
 Nigdy nie powinien wywoływać tej metody, jeśli kod formularzy systemu Windows jest hostowana w innej aplikacji, takich jak program Internet Explorer. Tę metodę należy wywoływać tylko w autonomicznej aplikacji formularzy systemu Windows.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Aby ustawić wartość domyślną dla `UseCompatibleTextRendering` w [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] lub później, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 W [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] lub nowszym, wywołanie <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> jest automatycznie generowany w pliku Program.cs. Aby zmienić domyślne renderowanie tekstu, zmodyfikuj wygenerowanego kodu.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tę metodę można wywołać tylko przed utworzeniem okna pierwszej aplikacji formularzy systemu Windows.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Forms.PowerState" /> wskazujący tryb działania zasilania, do którego przejście.</param>
        <param name="force">
          <see langword="true" /> Aby wymusić natychmiastowe; tryb wstrzymania <see langword="false" /> do systemu Windows wysłać żądanie wstrzymania wszystkich aplikacji.</param>
        <param name="disableWakeEvent">
          <see langword="true" /> Aby wyłączyć Przywracanie stanu zasilania systemu na aktywny w zdarzeniu wznawiania, <see langword="false" /> umożliwiające przywracanie stanu zasilania systemu na aktywny w zdarzeniu wznawiania.</param>
        <summary>Wstrzymuje Hibernacja systemu lub żąda zawieszone systemu lub hibernacji.</summary>
        <returns>
          <see langword="true" /> Jeśli system jest wstrzymywane, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja nie odpowiada na żądanie wstrzymania w ciągu 20 sekund, system Windows określa jest w stanie przestanie odpowiadać, i że aplikacji albo można umieścić w stan uśpienia lub zakończony. Gdy aplikacja odpowiada na żądanie wstrzymania, jednak może potrwać niezależnie od czasu należy go wyczyścić zasoby i zamknąć aktywnych procesów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że aplikacja odpowiadanie na nieobsługiwanych wyjątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia obsługi zdarzeń wyjątków, które występują wątków formularzy systemu Windows i wyjątków występujących na inne wątki. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracyjnym aplikacji użytkownika. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia w celu obsługi wyjątków wątku interfejsu użytkownika i <xref:System.AppDomain.UnhandledException> zdarzenia w celu obsługi wyjątków wątku bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie mogą uniemożliwiać aplikacji z przerywanie, przykładzie po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie przyjęto założenie, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> formantów, `button1` i `button2`na Twojej <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode">
          <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Wartości opisujące sposób aplikacji zachowania w przypadku, jeśli wyjątek nie zostanie przechwycony.</param>
        <summary>Powoduje, że aplikacja odpowiadanie na nieobsługiwanych wyjątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Często nie jest to możliwe, aby przechwytywać wszystkie wyjątki wyrzucane przez formularze systemu Windows. Za pomocą tej metody, można nakazać aplikacji czy powinna catch wszystkie nieobsługiwane wyjątki zgłaszane przez składniki formularzy systemu Windows i kontynuowania działania lub czy powinny ujawniać je użytkownikowi i zatrzymuje wykonywanie.  
  
 Wywołanie <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpienia głównego formularza za pomocą aplikacji <xref:System.Windows.Forms.Application.Run%2A> metody.  
  
 Przechwytywanie wyjątków występujących w wątkach nie został utworzony i należących do formularzy systemu Windows, użyj <xref:System.AppDomain.UnhandledException> obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia obsługi zdarzeń wyjątków, które występują wątków formularzy systemu Windows i wyjątków występujących na inne wątki. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracyjnym aplikacji użytkownika. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia w celu obsługi wyjątków wątku interfejsu użytkownika i <xref:System.AppDomain.UnhandledException> zdarzenia w celu obsługi wyjątków wątku bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie mogą uniemożliwiać aplikacji z przerywanie, przykładzie po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie przyjęto założenie, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> formantów, `button1` i `button2`na Twojej <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątków, po jej utworzeniu jego pierwsze okno.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode">
          <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Wartości opisujące sposób aplikacji zachowania w przypadku, jeśli wyjątek nie zostanie przechwycony.</param>
        <param name="threadScope">
          <see langword="true" /> można ustawić trybu wyjątków wątku; w przeciwnym razie <see langword="false" />.</param>
        <summary>Powoduje, że aplikacja odpowiadanie na nieobsługiwanych wyjątków, opcjonalnie stosowania zachowanie właściwe dla wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Często nie jest to możliwe, aby przechwytywać wszystkie wyjątki wyrzucane przez formularze systemu Windows. Za pomocą tej metody, można nakazać aplikacji czy powinna catch wszystkie nieobsługiwane wyjątki zgłaszane przez składniki formularzy systemu Windows i kontynuowania działania lub czy powinny ujawniać je użytkownikowi i zatrzymuje wykonywanie.  
  
 Wywołanie <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpienia głównego formularza za pomocą aplikacji <xref:System.Windows.Forms.Application.Run%2A> metody.  
  
 Gdy `threadScope` jest `true`, trybu wyjątków wątku jest ustawiona. Trybu wyjątków wątku zastępuje trybu wyjątków aplikacji, jeśli `mode` nie jest ustawiony na <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Gdy `threadScope` jest `false`, trybu wyjątków aplikacji jest ustawiony. Trybu wyjątków aplikacji jest używany dla wszystkich wątków, które mają <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> tryb. Ustawienie trybu wyjątków aplikacji nie ma wpływu na ustawienia bieżącego wątku.  
  
 Przechwytywanie wyjątków występujących w wątkach nie został utworzony i należących do formularzy systemu Windows, użyj <xref:System.AppDomain.UnhandledException> obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia obsługi zdarzeń wyjątków, które występują wątków formularzy systemu Windows i wyjątków występujących na inne wątki. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracyjnym aplikacji użytkownika. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia w celu obsługi wyjątków wątku interfejsu użytkownika i <xref:System.AppDomain.UnhandledException> zdarzenia w celu obsługi wyjątków wątku bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie mogą uniemożliwiać aplikacji z przerywanie, przykładzie po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie przyjęto założenie, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> formantów, `button1` i `button2`na Twojej <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątków, po jej utworzeniu jego pierwsze okno.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do pliku wykonywalnego, który uruchomił aplikację, nie zawiera nazwy pliku wykonywalnego.</summary>
        <value>Ścieżka do pliku wykonywalnego, który uruchomił aplikację.  Ta ścieżka będzie się różnił w zależności od tego, czy w aplikacji formularzy systemu Windows jest wdrażane za pomocą [! INCLUDE[ndptecclick](~/includes/ndptecclick-MD.MD)]. [! INCLUDE[ndptecclick](~/includes/ndptecclick-MD.MD)] aplikacji są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w C:\Documents and Settings\\* username * katalogu. Aby uzyskać więcej informacji, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce] (http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` została umieszczona w formularzu.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">uzyskiwania ścieżki. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek untrapped wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia aplikacji formularzy systemu Windows do uchwytu, w przeciwnym razie nieobsługiwany wyjątków, które występują w wątków formularzy systemu Windows. Dołączanie programu obsługi zdarzeń do <xref:System.Windows.Forms.Application.ThreadException> zdarzeń radzenia sobie z tych wyjątków, które pozostanie w nieznanym stanie aplikacji. Jeśli to możliwe, wyjątki powinny być traktowane przez obsługi bloku wyjątków strukturalnych.  
  
 Można określić, czy to wywołanie zwrotne służy do nieobsługiwanych wyjątków wątku formularzy systemu Windows przez ustawienie <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Przechwytywanie wyjątków występujących w wątkach nie został utworzony i należących do formularzy systemu Windows, użyj <xref:System.AppDomain.UnhandledException> obsługi zdarzeń.  
  
> [!NOTE]
>  Aby zagwarantować, że nie są bez aktywacji tego zdarzenia, należy dołączyć obsługi przed wywołaniem <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia obsługi zdarzeń wyjątków, które występują wątków formularzy systemu Windows i wyjątków występujących na inne wątki. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracyjnym aplikacji użytkownika. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia w celu obsługi wyjątków wątku interfejsu użytkownika i <xref:System.AppDomain.UnhandledException> zdarzenia w celu obsługi wyjątków wątku bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie mogą uniemożliwiać aplikacji z przerywanie, przykładzie po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie przyjęto założenie, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> formantów, `button1` i `button2`na Twojej <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do obiektu wywołującego bezpośrednio wywoływać kodu niezarządzanego, podczas dodawania obsługi do tego zdarzenia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wątek zostanie zamknięta. Gdy wątku głównego aplikacji ma zostać wyłączony, to zdarzenie powstaje najpierw, a następnie <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy dołączyć do obsługi zdarzeń <xref:System.Windows.Forms.Application.ThreadExit> zdarzeń, aby wykonać dowolne nieobsługiwany, wymagane zadania przed wątek przestanie działać. Zamknij pliki otwarte przez ten wątek lub usuwania obiektów, które nie odzyskać moduł garbage collector.  
  
> [!CAUTION]
>  Ponieważ jest to statyczne zdarzenia, należy odłączyć programu obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.Application.ThreadExit> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do formularzy systemu Windows i upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.ThreadExit> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyrejestrowuje wywołania zwrotnego pętli komunikatów z <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji użytkownika.</summary>
        <value>Ścieżka do danych aplikacji użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Podstawowa ścieżka*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Dane przechowywane w tej ścieżce jest częścią profilu użytkownika, który jest włączony dla mobilnych. Działa użytkowników mobilnych na wiele komputerów w sieci. Profil użytkownika mobilnego użytkownika jest przechowywany na serwerze w sieci i jest ładowany do systemu, gdy użytkownik loguje się. Dla profilu użytkownika to zostać uwzględnione podczas roamingu system operacyjny musi obsługiwać profilów mobilnych i musi być włączona.  
  
 Typowe ścieżki podstawowej jest C:\Documents and Settings\\*username*\Application danych. Ta ścieżka może się różnić, jednak w przypadku wdrażania aplikacji formularzy systemu Windows przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] tworzy własny katalog danych aplikacji, która jest odizolowana od innych aplikacji. Aby uzyskać więcej informacji, zobacz [dostęp do lokalnych i zdalnych danych w aplikacjach ClickOnce](http://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia dwa formularze i zamyka aplikację, gdy oba formularze są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, jest zapamiętany pozycji każdego formularza. W tym przykładzie pokazano, przy użyciu <xref:System.Windows.Forms.Application.UserAppDataPath%2A> właściwości do przechowywania danych aplikacji użytkownika.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi informacje podczas każdego formularza jest zamknięty i kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdego formularza dla użytkownika. Dane położenie formularza są przechowywane w pliku zatytułowany `Appdata.txt` utworzonego w lokalizacji ustaleniami <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` do uruchomienia aplikacji, podanych <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod jest fragment przykład pokazany na <xref:System.Windows.Forms.ApplicationContext> Przegląd klasy. Kod nie jest wyświetlana wyłącznie w celu skrócenia. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji użytkownika.</summary>
        <value>A <see cref="T:Microsoft.Win32.RegistryKey" /> reprezentujący klucza rejestru dla określonych danych aplikacji użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, jest on tworzony w następującym formacie:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Dane przechowywane w tym kluczu jest częścią profilu użytkownika, który jest włączony dla mobilnych. Działa użytkowników mobilnych na wiele komputerów w sieci. Profil użytkownika mobilnego użytkownika jest przechowywany na serwerze w sieci i jest ładowany do systemu, gdy użytkownik loguje się. Dla profilu użytkownika to zostać uwzględnione podczas roamingu system operacyjny musi obsługiwać profilów mobilnych i musi być włączona.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy kursor oczekiwania ma być używana dla wszystkich otwartych formularzy aplikacji.</summary>
        <value>
          <see langword="true" /> jest kursora oczekiwania jest używany dla wszystkich otwartych formularzy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest skonfigurowana `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> będzie mieć ustawioną właściwość form wszystkich otwartych w aplikacji `true`. To wywołanie nie zwróci, dopóki ta właściwość została ustawiona na wszystkich formularzy. Tej właściwości należy użyć, gdy masz długotrwałej operacji, a aby wskazać w wszystkich formularzy aplikacji nadal przetwarza operację.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą sposób visual style są stosowane do aplikacji systemu windows.</summary>
        <value>Bitowe połączenie <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Windows.Forms.Application.VisualStyleState%2A> właściwość określa, czy style wizualne są włączone w klienta lub nieklienckim obszarami aplikacji systemu windows. Ogólnie rzecz biorąc, można ustawić tej właściwości w formularzu głównym konstruktora lub <xref:System.Windows.Forms.Form.Load> obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy kod przykładzie <xref:System.Windows.Forms.Application.VisualStyleState%2A> jedną z właściwości <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> wartości w ramach <xref:System.Windows.Forms.Control.Click> programu obsługi zdarzeń dla <xref:System.Windows.Forms.Button> formantu. Ten przykładowy kod jest częścią większego przykładu udostępnionego dla <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> wyliczenia.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
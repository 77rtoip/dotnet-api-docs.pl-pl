<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="420c344be15a7d293ef3f0c34716bbb02b40d867" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69196528" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zapewnia <see langword="static" /> metody i właściwości do zarządzania aplikacją, takie jak metody uruchamiania i zatrzymywania aplikacji, przetwarzanie komunikatów systemu Windows oraz właściwości w celu uzyskania informacji o aplikacji. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> Klasa ma metody uruchamiania i zatrzymywania aplikacji i wątków oraz do przetwarzania komunikatów systemu Windows w następujący sposób:  
  
-   <xref:System.Windows.Forms.Application.Run%2A>uruchamia pętlę komunikatów aplikacji w bieżącym wątku i, opcjonalnie, sprawia, że formularz jest widoczny.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A>lub <xref:System.Windows.Forms.Application.ExitThread%2A> przerywa pętlę komunikatów.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A>przetwarza komunikaty, gdy program jest w pętli.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A>dodaje do pompy komunikatów aplikacji filtr komunikatów służący do monitorowania komunikatów systemu Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter>pozwala zatrzymać wywoływanie zdarzenia lub wykonać specjalne operacje przed wywołaniem programu obsługi zdarzeń.  
  
 Ta klasa ma <xref:System.Windows.Forms.Application.CurrentCulture%2A> i <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> właściwości, aby uzyskać lub ustawić informacje o kulturze dla bieżącego wątku.  
  
 Nie można utworzyć wystąpienia tej klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Za każdym razem, `button1`gdy klikniesz, aplikacja dodaje kolejną liczbę do listy.  
  
 Metoda wywołuje <xref:System.Windows.Forms.Application.Run%2A> , aby uruchomić aplikację, `listBox1` która tworzy formularz i `button1`. `Main` Gdy użytkownik kliknie `button1` `button1_Click` , Metoda wyświetla <xref:System.Windows.Forms.MessageBox>. Jeśli użytkownik kliknie `No` <xref:System.Windows.Forms.MessageBox>, `button1_Click` Metoda dodaje numer do listy. Jeśli użytkownik kliknie `Yes`, aplikacja wywoła <xref:System.Windows.Forms.Application.Exit%2A> wszystkie pozostałe komunikaty w kolejce, a następnie zakończy działanie.  
  
> [!NOTE]
>  Wywołanie <xref:System.Windows.Forms.Application.Exit%2A> zakończy się niepowodzeniem w częściowej relacji zaufania.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> interfejsu, który chcesz zainstalować.</param>
        <summary>Dodaje filtr komunikatów do monitorowania komunikatów systemu Windows, gdy są one kierowane do ich miejsc docelowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Filtr komunikatów służy do zapobiegania wywoływaniu określonych zdarzeń lub wykonywania specjalnych operacji dla zdarzenia przed przekazaniem go do programu obsługi zdarzeń. Filtry komunikatów są unikatowe dla określonego wątku.  
  
 Aby zapobiec wysyłaniu komunikatów, `value` wystąpienie parametru przekazane do tej metody musi <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> przesłaniać metodę z kodem, który będzie obsługiwał komunikat. Metoda musi zwracać `false`.  
  
> [!CAUTION]
>  Dodanie filtrów komunikatów do pompy komunikatów dla aplikacji może obniżyć wydajność.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy filtr komunikatów o nazwie `TestMessageFilter`. Ten filtr blokuje wszystkie komunikaty powiązane z lewym przyciskiem myszy. Aby można było użyć filtru komunikatów, należy podać implementację <xref:System.Windows.Forms.IMessageFilter> interfejsu.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt wywołujący może zamknąć tę aplikację.</summary>
        <value><see langword="true" />Jeśli obiekt wywołujący może zamknąć tę aplikację; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `false` wartość, jeśli jest wywoływana <xref:System.Windows.Forms.Control> z hosta w przeglądarce internetowej. W tym celu <xref:System.Windows.Forms.Application>niemożnazamknąć <xref:System.Windows.Forms.Control> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zostanie zamknięta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy dołączyć procedury obsługi `ApplicationExit` zdarzeń do zdarzenia, aby wykonać nieobsłużone, wymagane zadania przed zatrzymaniem działania aplikacji. Można zamknąć pliki otwarte przez tę aplikację lub usunąć obiekty, które nie odzyskał odzyskiwania pamięci.  
  
 Ponieważ jest to zdarzenie statyczne, należy odłączyć wszystkie programy obsługi zdarzeń dołączone do tego zdarzenia w `ApplicationExit` samej procedurze obsługi zdarzeń. Jeśli nie odłączysz tych programów obsługi, pozostaną one dołączone do zdarzenia i nadal zużywają pamięć.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i opuszcza aplikację po zamknięciu obu formularzy. Gdy aplikacja zostanie uruchomiona i zostanie zakończona, pozycja każdego formularza zostanie zapamiętana. W tym przykładzie pokazano, `ApplicationExit` jak użyć zdarzenia, aby wiedzieć, kiedy pozycje formularza mają być utrwalane w pliku, `FileStream` i kiedy powinno być zamknięte.  
  
 Klasa `MyApplicationContext` dziedziczy z <xref:System.Windows.Forms.ApplicationContext> i śledzi, gdy każdy formularz jest zamknięty, i zamyka bieżący wątek, gdy oba są. Klasa zapamiętuje położenie każdego formularza po jego zamknięciu. Gdy wystąpi `ApplicationExit` zdarzenie, Klasa zapisuje pozycje każdego dla użytkownika do pliku. Dane dotyczące pozycji formularza są przechowywane w pliku zatytułowanym `appdata.txt` , który jest tworzony w lokalizacji określonej przez. <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Metoda wywołuje `Application.Run(context)` metodę<xref:System.Windows.Forms.ApplicationContext>uruchomieniaaplikacji. `Main`  
  
 Ten kod jest fragmentem z przykładu przedstawionego w <xref:System.Windows.Forms.ApplicationContext> przeglądzie klasy. Zobacz <xref:System.Windows.Forms.ApplicationContext> , aby uzyskać pełną listę kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do danych aplikacji, które są współużytkowane przez wszystkich użytkowników.</summary>
        <value>Ścieżka do danych aplikacji, które są współużytkowane przez wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, zostanie utworzona w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>najpierw sprawdza, czy zestaw zawierający główny plik wykonywalny ma `AssemblyInformationalVersion` atrybut. Jeśli ten atrybut istnieje, jest używany dla obu <xref:System.Windows.Forms.Application.ProductVersion%2A> i. <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> Jeśli ten atrybut nie istnieje, obie właściwości używają zamiast tego wersji pliku wykonywalnego.  
  
 Ścieżka będzie się różnić w zależności od tego, czy aplikacja Windows Forms jest wdrożona [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]przy użyciu. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]aplikacje są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w katalogu C:\Documents\\and Settings*username* . Aby uzyskać więcej informacji, zobacz [Uzyskiwanie dostępu do danych lokalnych i zdalnych w aplikacjach ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji, które są współużytkowane przez wszystkich użytkowników.</summary>
        <value><see cref="T:Microsoft.Win32.RegistryKey" /> Reprezentujący klucz rejestru zawierający dane aplikacji, które są współużytkowane przez wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, jest tworzony w następującym formacie:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę firmy skojarzoną z aplikacją.</summary>
        <value>Nazwa firmy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje o kulturze dla bieżącego wątku.</summary>
        <value><see cref="T:System.Globalization.CultureInfo" /> Reprezentujący informacje o kulturze dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby ustawić tę właściwość. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący język dla bieżącego wątku.</summary>
        <value><see cref="T:System.Windows.Forms.InputLanguage" /> Reprezentujący bieżący język dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przetwarza wszystkie komunikaty systemu Windows znajdujące się obecnie w kolejce komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu formularza systemu Windows tworzony jest nowy formularz, który następnie czeka na obsługę zdarzeń. Za każdym razem, gdy formularz obsługuje zdarzenie, przetwarza cały kod skojarzony z tym zdarzeniem. Wszystkie inne zdarzenia oczekują w kolejce. Chociaż kod obsługuje zdarzenie, aplikacja nie odpowiada. Na przykład okno nie jest odświeżane, jeśli na górze zostało przeciągnięte inne okno.  
  
 Jeśli wywołasz <xref:System.Windows.Forms.Application.DoEvents%2A> w kodzie, aplikacja może obsłużyć inne zdarzenia. Na przykład, jeśli masz formularz, który dodaje dane do <xref:System.Windows.Forms.ListBox> kodu i dodajesz <xref:System.Windows.Forms.Application.DoEvents%2A> go, formularz jest odświeżany po przeciągnięciu innego okna. Jeśli usuniesz <xref:System.Windows.Forms.Application.DoEvents%2A> z kodu, formularz nie zostanie ododświeżany do momentu zakończenia obsługi zdarzeń kliknięcia przycisku. Aby uzyskać więcej informacji na temat komunikatów, zobacz [dane wejściowe użytkownika w Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 W przeciwieństwie do Visual Basic 6,0 <xref:System.Windows.Forms.Application.DoEvents%2A> Metoda nie <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> wywołuje metody.  
  
 Zazwyczaj ta metoda jest używana w pętli do przetwarzania komunikatów.  
  
> [!CAUTION]
>  Wywołanie tej metody powoduje zawieszenie bieżącego wątku podczas przetwarzania wszystkich komunikatów oczekujących w oknie. Jeśli komunikat spowoduje wyzwolenie zdarzenia, mogą zostać wykonane inne obszary kodu aplikacji. Może to spowodować, że aplikacja będzie mieć nieoczekiwane zachowania, które trudno debugować. W przypadku wykonywania operacji lub obliczeń, które potrwają dużo czasu, często zaleca się wykonanie tych operacji na nowym wątku. Aby uzyskać więcej informacji o programowaniu asynchronicznym, zobacz [asynchroniczny model programowania (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.Application.DoEvents%2A> metody. Po uruchomieniu przykładu użytkownik może wybrać pliki graficzne z <xref:System.Windows.Forms.OpenFileDialog>. Wybrane pliki są wyświetlane w formularzu. <xref:System.Windows.Forms.Application.DoEvents%2A> Metoda wymusza odświeżenie formularza dla każdego otwartego pliku graficznego. Aby uruchomić ten przykład, wklej następujący kod w postaci zawierającej <xref:System.Windows.Forms.PictureBox> nazwę `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> nazwę `OpenFileDialog1`i przycisk o nazwie `fileButton`. Wywołaj metody `InitializeOpenFileDialog` `Load` i z konstruktora lub metody formularza. `InitializePictureBox`  
  
> [!NOTE]
>  W programie Visual Studio, jeśli dodasz <xref:System.Windows.Forms.OpenFileDialog> do formularza przy użyciu operacji przeciągania, należy zmodyfikować następującą `InitializeOpenFileDialog` metodę, usuwając wiersz, który <xref:System.Windows.Forms.OpenFileDialog>tworzy nowe wystąpienie.  
  
 Przykład wymaga również, <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> aby zdarzenie <xref:System.Windows.Forms.Button> kontrolki <xref:System.Windows.Forms.OpenFileDialog> i <xref:System.Windows.Forms.FileDialog.FileOk> zdarzenia były połączone z programami obsługi zdarzeń zdefiniowanymi w tym przykładzie. Gdy jest uruchomiony ten przykład, Wyświetl okno dialogowe, klikając przycisk.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Włącza style wizualne dla aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia włączenie stylów wizualnych dla aplikacji. Style wizualne to kolory, czcionki i inne elementy wizualne, które tworzą motyw systemu operacyjnego. Kontrolki będą rysowane przy użyciu stylów wizualnych, jeśli obsługują ją formant i system operacyjny. Aby mieć efekt, <xref:System.Windows.Forms.Application.EnableVisualStyles> musi zostać wywołana przed utworzeniem jakichkolwiek kontrolek w aplikacji; <xref:System.Windows.Forms.Application.EnableVisualStyles> zazwyczaj jest to pierwszy wiersz w `Main` funkcji. Oddzielny manifest nie jest wymagany do włączania stylów wizualnych podczas wywoływania <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Przed .NET Framework 2,0, `FlatStyle` Właściwość niektórych kontrolek, takich jak kontrolki, które pochodzą z <xref:System.Windows.Forms.ButtonBase>, musiała być ustawiona na <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> tak, aby formanty były rysowane przy użyciu stylów wizualnych. W aplikacjach utworzonych w .NET Framework 2,0 nie jest to już konieczne.  
  
> [!NOTE]
>  Ta metoda nie będzie miała wpływu na formanty hostowane w programie Internet Explorer.  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje wywoływanie <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> `Main` funkcji w celu włączenia stylów wizualnych dla aplikacji.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zostanie przejdzie w stan modalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do Windows Forms i upewnij się, że program obsługi zdarzeń jest skojarzony ze <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> uprawnień do nasłuchiwania zdarzenia.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do pliku wykonywalnego, który uruchomił aplikację, łącznie z nazwą pliku wykonywalnego.</summary>
        <value>Ścieżka i nazwa pliku wykonywalnego, który uruchomił aplikację.  
  
Ta ścieżka będzie się różnić w zależności od tego, czy aplikacja Windows Forms jest wdrożona przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]aplikacje są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w katalogu C:\Documents\\and Settings*username* . Aby uzyskać więcej informacji, zobacz [Uzyskiwanie dostępu do danych lokalnych i zdalnych w aplikacjach ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania ścieżki. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informuje wszystkie pompy komunikatów, że muszą się zakończyć, a następnie zamyka wszystkie okna aplikacji po przetworzeniu komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informuje wszystkie pompy komunikatów, że muszą się zakończyć, a następnie zamyka wszystkie okna aplikacji po przetworzeniu komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> Metoda przerywa wszystkie uruchomione pętle komunikatów we wszystkich wątkach i zamyka wszystkie okna aplikacji. Ta metoda niekoniecznie wymusza zakończenie działania aplikacji. Metoda jest zazwyczaj wywoływana z wewnątrz pętli komunikatów i zmusza <xref:System.Windows.Forms.Application.Run%2A> do zwrócenia. <xref:System.Windows.Forms.Application.Exit%2A> Aby zamknąć pętlę komunikatów dla bieżącego wątku, wywołaj <xref:System.Windows.Forms.Application.ExitThread%2A>polecenie.  
  
 <xref:System.Windows.Forms.Application.Exit%2A>wywołuje następujące zdarzenia i wykonuje powiązane akcje warunkowe:  
  
-   Zdarzenie jest zgłaszane dla każdego formularza reprezentowanego <xref:System.Windows.Forms.Application.OpenForms%2A> przez właściwość. <xref:System.Windows.Forms.Form.FormClosing> To zdarzenie można anulować przez ustawienie <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwości ich <xref:System.Windows.Forms.FormClosingEventArgs> parametru na `true`.  
  
-   Jeśli jeden z kilku programów obsługi anuluje zdarzenie, następnie <xref:System.Windows.Forms.Application.Exit%2A> zwraca bez dalszych akcji. W przeciwnym razie zdarzenie jest zgłaszane dla każdego otwartego formularza, a wszystkie uruchomione pętle komunikatów i formularze są zamknięte. <xref:System.Windows.Forms.Form.FormClosed>  
  
> [!NOTE]
>  Metoda nie <xref:System.Windows.Forms.Form.Closing> zgłasza zdarzeń [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]i, które nie są przestarzałe w programie. <xref:System.Windows.Forms.Form.Closed> <xref:System.Windows.Forms.Application.Exit%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Za każdym razem, `button1`gdy klikniesz, aplikacja dodaje kolejną liczbę do listy.  
  
 Metoda wywołuje <xref:System.Windows.Forms.Application.Run%2A> , aby uruchomić aplikację, która tworzy formularz, `listBox1`i `button1`. `Main` Gdy użytkownik kliknie `button1` `button1_Click` , Metoda dodaje cyfry od 1 do 3 do <xref:System.Windows.Forms.MessageBox>pola listy i wyświetla. Jeśli użytkownik kliknie przycisk **nie** w <xref:System.Windows.Forms.MessageBox>, `button1_Click` Metoda dodaje kolejny numer do listy. Jeśli użytkownik kliknie przycisk **tak**, aplikacja wywoła <xref:System.Windows.Forms.Application.Exit%2A>, aby przetworzyć wszystkie pozostałe komunikaty w kolejce, a następnie zamknąć.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały utworzone i umieszczone w formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Zwraca czy <see cref="T:System.Windows.Forms.Form" /> w aplikacji anulowano zakończenie.</param>
        <summary>Informuje wszystkie pompy komunikatów, że muszą się zakończyć, a następnie zamyka wszystkie okna aplikacji po przetworzeniu komunikatów.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">Dla uprawnienia do kończenia działającego wątku aplikacji. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka pętlę komunikatów w bieżącym wątku i zamyka wszystkie okna w wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody, aby wyjść z pętli komunikatów bieżącego wątku. Ta metoda powoduje zwrócenie wywołania <xref:System.Windows.Forms.Application.Run%2A> dla bieżącego wątku. Aby wyjść z całej aplikacji, wywołaj <xref:System.Windows.Forms.Application.Exit%2A>polecenie.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołanie kodu niezarządzanego. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat zdarzenia systemu Windows do filtrowania.</param>
        <summary>Uruchamia wszystkie filtry w komunikacie okna i zwraca kopię zmodyfikowanego komunikatu.</summary>
        <returns><see langword="true" />Jeśli filtry zostały przetworzone; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący tryb wysokiej rozdzielczości DPI dla aplikacji.</summary>
        <value>Jedna z wartości wyliczenia, która wskazuje tryb wysokiej rozdzielczości DPI.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zakończy przetwarzanie i wkrótce wprowadzi stan bezczynności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli masz zadania, które należy wykonać, zanim wątek stanie się bezczynny, Dołącz je do tego zdarzenia.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Application.Idle> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do formularza systemu Windows i upewnij się, że program obsługi zdarzeń jest skojarzony ze <xref:System.Windows.Forms.Application.Idle> zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja ma opuścić stan modalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do Windows Forms i upewnij się, że program obsługi zdarzeń jest skojarzony ze <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do danych aplikacji lokalnego, niemobilnego użytkownika.</summary>
        <value>Ścieżka do danych aplikacji lokalnego, niemobilnego użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik lokalny jest tym, którego profil użytkownika jest przechowywany w systemie, w którym użytkownik jest zalogowany. Jeśli ścieżka nie istnieje, zostanie utworzona w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Typową ścieżką podstawową jest c:\Dokumenty i\\ustawienia*nazwa_użytkownika*\Ustawienia lokalne\Dane dane. Jeśli jednak aplikacja Windows Forms zostanie wdrożona przy użyciu programu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], ta ścieżka będzie inna. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]tworzy własny katalog danych aplikacji, który jest odizolowany od wszystkich innych aplikacji. Aby uzyskać więcej informacji, zobacz [Uzyskiwanie dostępu do danych lokalnych i zdalnych w aplikacjach ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i opuszcza aplikację po zamknięciu obu formularzy. Gdy aplikacja zostanie uruchomiona i zostanie zakończona, pozycja każdego formularza zostanie zapamiętana. Chociaż w <xref:System.Windows.Forms.Application.UserAppDataPath%2A> <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> tym przykładzie pokazano, jak używać właściwości do przechowywania danych aplikacji dla użytkownika, można użyć zamiast tego.  
  
 Klasa dziedziczy z <xref:System.Windows.Forms.ApplicationContext> i śledzi, gdy każdy formularz jest zamknięty, i zamyka bieżący wątek, gdy oba są. `MyApplicationContext` Klasa przechowuje pozycje poszczególnych formularzy dla użytkownika. Dane dotyczące pozycji formularza są przechowywane w pliku zatytułowanym `Appdata.txt` , który jest tworzony w lokalizacji określonej przez. <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Metoda wywołuje `Application.Run(context)` metodę<xref:System.Windows.Forms.ApplicationContext>uruchomieniaaplikacji. `Main`  
  
 Ten kod jest fragmentem z przykładu przedstawionego w <xref:System.Windows.Forms.ApplicationContext> przeglądzie klasy. Kod nie jest pokazywany na potrzeby zwięzłości. Zobacz <xref:System.Windows.Forms.ApplicationContext> , aby uzyskać pełną listę kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy w tym wątku istnieje pętla komunikatów.</summary>
        <value><see langword="true" />Jeśli istnieje pętla komunikatów; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku hostowania Windows Forms w innych środowiskach, takich jak aplikacje niezarządzane, ta właściwość zawsze `false`będzie zwracana. Użyj <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> polecenia, aby polecić Windows Forms, jeśli środowisko hostingu nadal ma aktywną pętlę komunikatów.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje OLE w bieżącym wątku.</summary>
        <returns>Jedna z <see cref="T:System.Threading.ApartmentState" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj tę metodę przed wywołaniem dowolnej `Microsoft.Win32` metody, która wymaga OLE. <xref:System.Windows.Forms.Application.OleRequired%2A>najpierw sprawdza, czy obiekt OLE został zainicjowany w bieżącym wątku. W przeciwnym razie inicjuje wątek dla OLE.  
  
> [!NOTE]
>  Jeśli wątek nie wywołuje bezpośrednio metod OLE, nie trzeba wywoływać tej metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t"><see cref="T:System.Exception" /> Reprezentuje wyjątek, który został zgłoszony.</param>
        <summary><see cref="E:System.Windows.Forms.Application.ThreadException" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.Application.OnThreadException%2A> , aby zgłosić wyjątek, który zatrzyma przetwarzanie aplikacji.  
  
 <xref:System.Windows.Forms.Application> Klasa<xref:System.Windows.Forms.Application.ThreadException> ma zdarzenie. Można dołączyć procedurę obsługi zdarzeń do tego zdarzenia, aby wykonać dowolne niestandardowe przetwarzanie, które jest potrzebne dla nieobsłużonych wyjątków. Jeśli nie dołączysz programu obsługi zdarzeń, <xref:System.Windows.Forms.Application.OnThreadException%2A> program wykona zachowanie domyślne, które polega na wyświetleniu okna dialogowego z informacją o tym, że wystąpił błąd.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A>implementuje tylko domyślne zachowanie wyjątków dla nieobsłużonych wyjątków, które występują w wątkach należących do Windows Forms. Nieobsłużone wyjątki w innych wątkach są obsługiwane przez <xref:System.AppDomain.UnhandledException> zdarzenie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję otwartych formularzy należących do aplikacji.</summary>
        <value>A <see cref="T:System.Windows.Forms.FormCollection" /> zawiera wszystkie otwarte formularze należące do tej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> Właściwość reprezentuje kolekcję formularzy będących własnością aplikacji. Ta kolekcja może być przeszukiwana według położenia indeksu lub <xref:System.Windows.Forms.Control.Name%2A> przez <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Obiekt wywołujący musi mieć uprawnienia dostępu do wszystkich okien, zgodnie z <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> definicją <see cref="T:System.Security.Permissions.UIPermissionWindow" /> w wyliczeniu.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę produktu skojarzoną z tą aplikacją.</summary>
        <value>Nazwa produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName`jest pobierany z metadanych zestawu zawierającego główny formularz bieżącej aplikacji. Można ją ustawić, ustawiając <xref:System.Reflection.AssemblyProductAttribute> wewnątrz manifestu zestawu. Aby uzyskać więcej informacji, zobacz [manifest zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję produktu skojarzoną z tą aplikacją.</summary>
        <value>Wersja produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj numer wersji jest wyświetlany jako *numer główny*. *numer pomocniczy*. *numer kompilacji*. *Numer części prywatnej*. Można ustawić ją jawnie przez ustawienie wersji zestawu w manifeście zestawu. Aby uzyskać więcej informacji, zobacz [manifest zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>najpierw sprawdza, czy zestaw zawierający główny plik wykonywalny ma `AssemblyInformationalVersion` atrybut. Jeśli ten atrybut istnieje, jest używany dla obu <xref:System.Windows.Forms.Application.ProductVersion%2A> i. <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> Jeśli ten atrybut nie istnieje, obie właściwości używają zamiast tego wersji pliku wykonywalnego.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">Obiekty do przekazania <see cref="E:System.Windows.Forms.Application.Idle" /> do zdarzenia. <see cref="T:System.EventArgs" /></param>
        <summary><see cref="E:System.Windows.Forms.Application.Idle" /> Podnosi zdarzenie w hostowanych scenariuszach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas hostowania Windows Forms w innym środowisku, takim jak niezarządzana aplikacja. Należy wywołać <xref:System.Windows.Forms.Application.RaiseIdle%2A> , gdy aplikacja hostingu przejdzie w stan bezczynności. Dzięki temu niektóre kontrolki Windows Forms i składniki mogą wykonywać ważne działania w tle, gdy użytkownik nie współdziała z aplikacją.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda wywoływana, gdy Windows Forms musi sprawdzić, czy środowisko hostingu nadal wysyła komunikaty.</param>
        <summary>Rejestruje wywołanie zwrotne do sprawdzenia, czy pętla komunikatów działa w środowiskach hostowanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana podczas hostowania Windows Forms w innym środowisku, takim jak niezarządzana aplikacja. W środowiskach hostowanych <xref:System.Windows.Forms.Application.MessageLoop%2A> Właściwość zawsze zwraca wartość false, jeśli Windows Forms nie przetwarza komunikatów. Użyj tego wywołania zwrotnego, aby poinformować Windows Forms, czy środowisko hostingu nadal przetwarza komunikaty.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> do usunięcia z aplikacji.</param>
        <summary>Usuwa filtr komunikatów z pompy komunikatów aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz usunąć filtr komunikatów, gdy nie chcesz już przechwytywać komunikatów systemu Windows przed ich wysłaniem.  
  
   
  
## Examples  
 Aby można było użyć filtru komunikatów, należy podać implementację <xref:System.Windows.Forms.IMessageFilter> interfejsu. W poniższej klasie jest tworzony filtr komunikatów o `TestMessageFilter`nazwie. Ten filtr blokuje wszystkie komunikaty powiązane z lewym przyciskiem myszy.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy bieżąca aplikacja rysuje kontrolki przy użyciu stylów wizualnych.</summary>
        <value><see langword="true" />Jeśli style wizualizacji są włączone dla kontrolek w obszarze klienta okna aplikacji; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli rysujesz kontrolkę niestandardową, Użyj tej właściwości, aby zdecydować, czy należy narysować kontrolkę z lub bez stylów wizualnych, aby jej wygląd był zgodny z innymi kontrolkami w aplikacji.  
  
 W poniższej tabeli przedstawiono cztery warunki, które muszą istnieć <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> , aby można było zwrócić. `true`  
  
|Warunek|Opis|  
|---------------|-----------------|  
|System operacyjny obsługuje style wizualne|Aby sprawdzić ten warunek oddzielnie, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> właściwości <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Użytkownik włączył style wizualne w systemie operacyjnym|Aby sprawdzić ten warunek oddzielnie, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> właściwości <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Style wizualizacji są włączone w aplikacji|Style wizualne można włączyć w aplikacji przez wywołanie <xref:System.Windows.Forms.Application.EnableVisualStyles> metody lub przy użyciu manifestu aplikacji, który określa, że comctl32. dll w wersji 6 lub nowszej zostanie użyta do rysowania kontrolek.|  
|Style wizualizacji są używane do rysowania obszaru klienta systemu Windows|Aby sprawdzić ten warunek oddzielnie, <xref:System.Windows.Forms.Application.VisualStyleState%2A> Użyj właściwości <xref:System.Windows.Forms.Application> klasy i sprawdź, czy ma ona wartość <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> lub <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację i natychmiast uruchamia nowe wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najczęstszym powodem wywołania `Restart` jest rozpoczęcie nowej wersji aplikacji [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] pobranej przy użyciu `Update` metody lub `UpdateAsync` .  
  
 Aplikacje są ponownie uruchamiane w kontekście, w którym zostały początkowo uruchomione. Jeśli aplikacja została uruchomiona przy użyciu adresu URL wskazującego bezpośrednio na główny plik wykonywalny aplikacji, zostanie ponownie uruchomiona przy użyciu tego samego adresu URL. Jeśli aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacją, zostanie uruchomiona ponownie przy użyciu polecenia [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Jeśli aplikacja została pierwotnie dostarczona opcjami wiersza polecenia podczas pierwszego uruchomienia, <xref:System.Windows.Forms.Application.Restart%2A> program uruchomi aplikację ponownie z tymi samymi opcjami.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Twój kod nie jest aplikacją Windows Forms. Nie można wywołać tej metody w tym kontekście.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> uprawnienia.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna uruchamianie standardowej pętli komunikatów aplikacji w bieżącym wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna uruchamianie standardowej pętli komunikatów aplikacji w bieżącym wątku bez formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W aplikacji opartej na Win32 lub Windows Forms pętla komunikatów to procedura w kodzie, która przetwarza zdarzenia użytkownika, takie jak kliknięcia myszą i pociągnięcia klawiatury. Wszystkie uruchomione aplikacje oparte na systemie Windows wymagają aktywnej pętli komunikatów zwanej pętlą głównego komunikatu. Gdy pętla głównego komunikatu zostanie ZAMKNIĘTA, aplikacja zostanie zakończona. W Windows Forms ta pętla jest zamykana, <xref:System.Windows.Forms.Application.Exit%2A> gdy metoda jest wywoływana, lub <xref:System.Windows.Forms.Application.ExitThread%2A> gdy metoda jest wywoływana w wątku, w którym działa główna pętla komunikatów.  
  
 Większość Windows Forms deweloperzy nie będą musieli korzystać z tej wersji metody. Należy użyć <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> przeciążenia, aby uruchomić aplikację z formularzem głównym, dzięki czemu aplikacja kończy działanie, gdy formularz główny zostanie zamknięty. Dla wszystkich innych sytuacji należy użyć <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> przeciążenia, które obsługuje dostarczanie <xref:System.Windows.Forms.ApplicationContext> obiektu w celu uzyskania lepszej kontroli nad okresem istnienia aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla komunikatów jest już uruchomiona w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">, <see cref="T:System.Windows.Forms.ApplicationContext" /> W którym jest uruchamiana aplikacja.</param>
        <summary>Rozpoczyna uruchamianie standardowej pętli komunikatów aplikacji w bieżącym wątku przy użyciu <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pętla komunikatów jest uruchamiana do momentu <xref:System.Windows.Forms.Application.Exit%2A> wywołania <xref:System.Windows.Forms.Application.ThreadExit> lub <xref:System.Windows.Forms.Application.ExitThread%2A> jest wywoływana lub zdarzenie jest zgłaszane dla obiektu kontekstu.  
  
   
  
## Examples  
 W przykładzie pokazano dwa formularze i opuszcza aplikację po zamknięciu obu formularzy. Gdy aplikacja zostanie uruchomiona i zostanie zakończona, pozycja każdego formularza zostanie zapamiętana. W tym przykładzie pokazano <xref:System.Windows.Forms.ApplicationContext>, jak używać metody, a `Application.Run(context)` także do wyświetlania wielu formularzy podczas uruchamiania aplikacji.  
  
 Klasa `MyApplicationContext` dziedziczy z <xref:System.Windows.Forms.ApplicationContext> i śledzi, gdy każdy formularz jest zamknięty, i zamyka bieżący wątek, gdy oba są. Klasa przechowuje pozycje poszczególnych formularzy dla użytkownika. Dane dotyczące pozycji formularza są przechowywane w pliku zatytułowanym `Appdata.txt` , który jest tworzony w lokalizacji określonej przez. <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Metoda wywołuje `Application.Run(context)` metodę<xref:System.Windows.Forms.ApplicationContext>uruchomieniaaplikacji. `Main`  
  
 Kod dla `AppForm1` formularzy i `AppForm2` nie jest pokazywany na potrzeby zwięzłości. Zapoznaj <xref:System.Windows.Forms.ApplicationContext> się z omówieniem klasy dla całej listy kodu.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla komunikatów jest już uruchomiona w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">Reprezentujący formularz <see cref="T:System.Windows.Forms.Form" /> , który ma być widoczny.</param>
        <summary>Rozpoczyna uruchamianie standardowej pętli komunikatów aplikacji w bieżącym wątku i sprawia, że określony formularz jest widoczny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj główną funkcją aplikacji jest wywołanie tej metody i przekazanie jej do głównego okna aplikacji.  
  
 Ta metoda dodaje procedurę obsługi zdarzeń do `mainForm` parametru <xref:System.Windows.Forms.Form.Closed> zdarzenia. Program obsługi zdarzeń wywołuje <xref:System.Windows.Forms.Application.ExitThread%2A> czyszczenie aplikacji.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A> Metoda<xref:System.Windows.Forms.Form> klasy zostanie wywołana przed zwróceniem tej metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Za każdym razem, `button1`gdy klikniesz, aplikacja dodaje kolejną liczbę do listy.  
  
 Metoda wywołuje <xref:System.Windows.Forms.Application.Run%2A> , aby uruchomić aplikację, która tworzy formularz, `listBox1`i `button1`. `Main` Gdy użytkownik kliknie `button1` `button1_Click` , Metoda dodaje cyfry od 1 do 3 do <xref:System.Windows.Forms.MessageBox>pola listy i wyświetla. Jeśli użytkownik kliknie przycisk **nie** w <xref:System.Windows.Forms.MessageBox>, `button1_Click` Metoda dodaje kolejny numer do listy. Jeśli użytkownik kliknie przycisk **tak**, aplikacja wywoła <xref:System.Windows.Forms.Application.Exit%2A> wszystkie pozostałe komunikaty w kolejce, a następnie zakończy działanie.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały utworzone i umieszczone w formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla komunikatów jest już uruchomiona w bieżącym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg formatu, który ma zostać zastosowany do nagłówków okna najwyższego poziomu, gdy są one wyświetlane ze transparentem ostrzegawczym.</summary>
        <value>Ciąg formatu, który ma zostać zastosowany do napisów okna najwyższego poziomu.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby ustawić tę właściwość. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna, która ma być używana dla nowych kontrolek. Jeśli <see langword="true" />nowe kontrolki obsługujące <c></c> [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] UseCompatibleTextRendering używają klasy bazującej [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <see cref="T:System.Drawing.Graphics" /> na potrzeby renderowania tekstu; <see langword="false" />Jeśli nowe kontrolki używają klasy <see cref="T:System.Windows.Forms.TextRenderer" /> bazującej.</param>
        <summary>Ustawia wartość domyślną dla całej aplikacji dla właściwości <c>UseCompatibleTextRendering</c> zdefiniowanej w niektórych kontrolkach.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre formanty Windows Forms mogą renderować swój <xref:System.Windows.Forms.TextRenderer> tekst za pomocą klasy, która jest oparta [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] na bibliotece <xref:System.Drawing.Graphics> grafiki lub klasy, która jest oparta na [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] bibliotece grafiki. Ta zmiana została wprowadzona w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] wyniku problemów z wydajnością i lokalizacją w programie. [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] Użyj <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> , aby ustawić wartość `UseCompatibleTextRendering` domyślną właściwości dla formantów, które je obsługują.  
  
 Właściwość jest przeznaczona do zapewnienia zgodności wizualnej między kontrolkami Windows Forms, które renderują <xref:System.Windows.Forms.TextRenderer> tekst przy [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] użyciu [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] klasy i aplikacji, które wykonują niestandardowe renderowanie tekstu przy użyciu `UseCompatibleTextRendering` <xref:System.Drawing.Graphics>Klasa. W większości przypadków, jeśli aplikacja nie [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] jest uaktualniana z lub [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], zaleca się pozostawienie `UseCompatibleTextRendering` ustawionej wartości `false`domyślnej.  
  
 Klasa bazowa została<xref:System.Windows.Forms.TextRenderer> wprowadzona w celuzwiększeniawydajności,zwiększeniawyglądutekstuipoprawyobsługiczcionekmiędzynarodowych.[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] We wcześniejszych wersjach [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]programu [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] , Klasa oparta <xref:System.Drawing.Graphics> została użyta do wykonania całego renderowania tekstu. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]oblicza odstępy między znakami i zawijanie wyrazów inaczej niż [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. W aplikacji Windows Forms, która używa <xref:System.Drawing.Graphics> klasy do renderowania tekstu, może to spowodować, że tekst dla kontrolek, które używają <xref:System.Windows.Forms.TextRenderer> , różni się od drugiego tekstu w aplikacji. Aby rozwiązać tę niezgodność, można ustawić `UseCompatibleTextRendering` właściwość na. `true` Aby ustawić `UseCompatibleTextRendering` `true` dla wszystkich obsługiwanych kontrolek w aplikacji, wywołaj <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> metodę z parametrem `true`.  
  
 Nigdy nie należy wywoływać tej metody, jeśli kod Windows Forms jest hostowany w innej aplikacji, takiej jak program Internet Explorer. Metodę należy wywoływać tylko w autonomicznych aplikacjach Windows Forms.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Aby ustawić wartość `UseCompatibleTextRendering` domyślną w programie [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] lub nowszym, zobacz <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 W [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] programie lub nowszym <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> wywołanie jest generowane automatycznie w pliku program.cs. Aby zmienić ustawienie domyślne renderowania tekstu, zmodyfikuj wygenerowany kod.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tę metodę można wywołać tylko przed utworzeniem pierwszego okna przez aplikację Windows Forms.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">Jedna z wartości wyliczenia, która określa tryb wysokiej rozdzielczości DPI do ustawienia.</param>
        <summary>Ustawia tryb wysokiej rozdzielczości DPI procesu.</summary>
        <returns><see langword="true" />Jeśli ustawiono tryb wysokiej rozdzielczości DPI; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Windows.Forms.PowerState" /> Wskazujący tryb działania z mocą, do którego ma zostać przeniesiona.</param>
        <param name="force"><see langword="true" />Aby natychmiast wymusić tryb zawieszenia; <see langword="false" /> aby spowodować, że system Windows wyśle żądanie wstrzymania do każdej aplikacji.</param>
        <param name="disableWakeEvent"><see langword="true" />Aby wyłączyć Przywracanie stanu mocy systemu do aktywnego w zdarzeniu wznawiania, <see langword="false" /> aby włączyć przywracanie stanu mocy systemu do aktywnego w zdarzeniu wznawiania.</param>
        <summary>Wstrzymuje lub hibernacj system albo żąda wstrzymania lub hibernacji systemu.</summary>
        <returns><see langword="true" />Jeśli system jest zawieszony, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja nie odpowiada na żądanie wstrzymania w ciągu 20 sekund, system Windows ustali, że jest w stanie innym niż odpowiada, i że aplikacja może zostać umieszczona w trybie uśpienia lub zakończona. Gdy aplikacja odpowie na żądanie wstrzymania, może to potrwać bez względu na konieczność czyszczenia zasobów i zamknięcia aktywnych procesów.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Powoduje, że aplikacja reaguje na Nieobsłużone wyjątki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia procedury obsługi zdarzeń dla wyjątków, które występują na Windows Forms wątkach i wyjątkach, które występują w innych wątkach. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> je tak, aby wszystkie wyjątki były obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracji użytkownika aplikacji. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia do obsługi wyjątków wątków interfejsu użytkownika <xref:System.AppDomain.UnhandledException> i zdarzenia do obsługi wyjątków wątków innych niż interfejs użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie można zapobiec zakończeniu działania aplikacji, przykład po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem.  
  
 W tym przykładzie przyjęto założenie, <xref:System.Windows.Forms.Button> że zdefiniowano `button2`dwie `button1` kontrolki <xref:System.Windows.Forms.Form> i, w klasie.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Wartość opisująca, w jaki sposób aplikacja powinna działać, jeśli wyjątek jest zgłaszany bez przechwyconych.</param>
        <summary>Powoduje, że aplikacja reaguje na Nieobsłużone wyjątki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest często możliwe przechwycenie wszystkich wyjątków zgłoszonych przez Windows Forms. Korzystając z tej metody, można poinstruować aplikację, czy należy wychwycić wszystkie Nieobsłużone wyjątki zgłoszone przez składniki Windows Forms i kontynuować działanie, czy też należy je uwidocznić użytkownikowi i zatrzymać wykonywanie.  
  
 Wywołaj <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpieniem głównej formy aplikacji <xref:System.Windows.Forms.Application.Run%2A> przy użyciu metody.  
  
 Aby przechwytywać Wyjątki występujące w wątkach, które nie są tworzone i należą <xref:System.AppDomain.UnhandledException> do Windows Forms, użyj procedury obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia procedury obsługi zdarzeń dla wyjątków, które występują na Windows Forms wątkach i wyjątkach, które występują w innych wątkach. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> je tak, aby wszystkie wyjątki były obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracji użytkownika aplikacji. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia do obsługi wyjątków wątków interfejsu użytkownika <xref:System.AppDomain.UnhandledException> i zdarzenia do obsługi wyjątków wątków innych niż interfejs użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie można zapobiec zakończeniu działania aplikacji, przykład po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem.  
  
 W tym przykładzie przyjęto założenie, <xref:System.Windows.Forms.Button> że zdefiniowano `button2`dwie `button1` kontrolki <xref:System.Windows.Forms.Form> i, w klasie.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątku po utworzeniu pierwszego okna przez aplikację.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Wartość opisująca, w jaki sposób aplikacja powinna działać, jeśli wyjątek jest zgłaszany bez przechwyconych.</param>
        <param name="threadScope"><see langword="true" />Aby ustawić tryb wyjątku wątku; w przeciwnym razie. <see langword="false" /></param>
        <summary>Powoduje, że aplikacja reaguje na Nieobsłużone wyjątki, opcjonalnie stosując zachowanie specyficzne dla wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest często możliwe przechwycenie wszystkich wyjątków zgłoszonych przez Windows Forms. Korzystając z tej metody, można poinstruować aplikację, czy należy wychwycić wszystkie Nieobsłużone wyjątki zgłoszone przez składniki Windows Forms i kontynuować działanie, czy też należy je uwidocznić użytkownikowi i zatrzymać wykonywanie.  
  
 Wywołaj <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpieniem głównej formy aplikacji <xref:System.Windows.Forms.Application.Run%2A> przy użyciu metody.  
  
 Gdy `threadScope` ma`true`wartość, jest ustawiony tryb wyjątku wątku. Tryb wyjątku wątku zastępuje tryb wyjątków aplikacji, jeśli `mode` nie jest ustawiony na. <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>  
  
 Gdy `threadScope` ma`false`wartość, jest ustawiany tryb wyjątków aplikacji. Tryb wyjątku aplikacji jest używany dla wszystkich wątków, które mają <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> tryb. Ustawienie trybu wyjątku aplikacji nie ma wpływu na ustawienie bieżącego wątku.  
  
 Aby przechwytywać Wyjątki występujące w wątkach, które nie są tworzone i należą <xref:System.AppDomain.UnhandledException> do Windows Forms, użyj procedury obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia procedury obsługi zdarzeń dla wyjątków, które występują na Windows Forms wątkach i wyjątkach, które występują w innych wątkach. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> je tak, aby wszystkie wyjątki były obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracji użytkownika aplikacji. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia do obsługi wyjątków wątków interfejsu użytkownika <xref:System.AppDomain.UnhandledException> i zdarzenia do obsługi wyjątków wątków innych niż interfejs użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie można zapobiec zakończeniu działania aplikacji, przykład po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem.  
  
 W tym przykładzie przyjęto założenie, <xref:System.Windows.Forms.Button> że zdefiniowano `button2`dwie `button1` kontrolki <xref:System.Windows.Forms.Form> i, w klasie.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątku po utworzeniu pierwszego okna przez aplikację.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę do pliku wykonywalnego, który uruchomił aplikację, a nie nazwę pliku wykonywalnego.</summary>
        <value>Ścieżka do pliku wykonywalnego, który uruchomił aplikację.  
  
Ta ścieżka będzie się różnić w zależności od tego, czy aplikacja Windows Forms jest wdrożona przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]aplikacje są przechowywane w pamięci podręcznej aplikacji dla poszczególnych użytkowników w katalogu C:\Documents\\and Settings*username* . Aby uzyskać więcej informacji, zobacz [Uzyskiwanie dostępu do danych lokalnych i zdalnych w aplikacjach ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pobiera tę właściwość i wyświetla jej wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania ścieżki. Skojarzone Wyliczenie:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie zgłoszony wyjątek niepułapki wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie pozwala aplikacji Windows Forms obsługiwać Nieobsłużone wyjątki, które występują w wątkach Windows Forms. Dołącz do <xref:System.Windows.Forms.Application.ThreadException> zdarzenia programy obsługi zdarzeń, aby zaradzić sobie z tymi wyjątkami, co spowoduje pozostawienie aplikacji w nieznanym stanie. Jeśli to możliwe, wyjątki powinny być obsługiwane przez blok obsługi wyjątków strukturalnych.  
  
 Można zmienić, czy to wywołanie zwrotne jest używane dla nieobsłużonych wyjątków wątku Windows Forms <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>przez ustawienie. Aby przechwytywać Wyjątki występujące w wątkach, które nie są tworzone i należą <xref:System.AppDomain.UnhandledException> do Windows Forms, użyj procedury obsługi zdarzeń.  
  
> [!NOTE]
>  Aby zagwarantować, że żadne aktywacje tego zdarzenia nie zostaną pominięte, musisz dołączyć procedurę obsługi przed wywołaniem <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia procedury obsługi zdarzeń dla wyjątków, które występują na Windows Forms wątkach i wyjątkach, które występują w innych wątkach. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> je tak, aby wszystkie wyjątki były obsługiwane przez aplikację, niezależnie od ustawień w pliku konfiguracji użytkownika aplikacji. Używa <xref:System.Windows.Forms.Application.ThreadException> zdarzenia do obsługi wyjątków wątków interfejsu użytkownika <xref:System.AppDomain.UnhandledException> i zdarzenia do obsługi wyjątków wątków innych niż interfejs użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie można zapobiec zakończeniu działania aplikacji, przykład po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem.  
  
 W tym przykładzie przyjęto założenie, <xref:System.Windows.Forms.Button> że zdefiniowano `button2`dwie `button1` kontrolki <xref:System.Windows.Forms.Form> i, w klasie.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">dla bezpośredniego wywołującego wywołuje kod niezarządzany podczas dodawania procedury obsługi do tego zdarzenia. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wątek zostanie zamknięty. Gdy główny wątek aplikacji zostanie zamknięty, to zdarzenie jest zgłaszane jako pierwsze, po którym następuje <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wykonać wszystkie nieobsłużone, wymagane zadania <xref:System.Windows.Forms.Application.ThreadExit> przed zatrzymaniem wątku, należy dołączyć procedury obsługi zdarzeń do zdarzenia. Zamknij pliki otwarte przez ten wątek lub Usuń obiekty, które nie odzyskał modułu zbierającego elementy bezużyteczne.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzenie statyczne, należy odłączyć programy obsługi zdarzeń po usunięciu aplikacji lub wycieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.Application.ThreadExit> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do Windows Forms i upewnij się, że program obsługi zdarzeń jest skojarzony ze <xref:System.Windows.Forms.Application.ThreadExit> zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyrejestrowuje wywołanie zwrotne pętli komunikatów wykonane z <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji użytkownika.</summary>
        <value>Ścieżka do danych aplikacji użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, zostanie utworzona w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Dane przechowywane w tej ścieżce są częścią profilu użytkownika, który jest włączony dla roamingu. Użytkownik mobilny działa na więcej niż jednym komputerze w sieci. Profil użytkownika dla użytkownika mobilnego jest przechowywany na serwerze w sieci i ładowany do systemu, gdy użytkownik się zaloguje. Aby profil użytkownika był brany pod uwagę podczas roamingu, system operacyjny musi obsługiwać profile roamingu i musi być włączony.  
  
 Typową ścieżką podstawową jest c:\Dokumenty i\\ustawienia*username*\Dane dane. Jeśli jednak aplikacja Windows Forms zostanie wdrożona przy użyciu programu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)], ta ścieżka będzie inna. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]tworzy własny katalog danych aplikacji, który jest odizolowany od wszystkich innych aplikacji. Aby uzyskać więcej informacji, zobacz [Uzyskiwanie dostępu do danych lokalnych i zdalnych w aplikacjach ClickOnce](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i opuszcza aplikację po zamknięciu obu formularzy. Gdy aplikacja zostanie uruchomiona i zostanie zakończona, pozycja każdego formularza zostanie zapamiętana. Ten przykład ilustruje użycie <xref:System.Windows.Forms.Application.UserAppDataPath%2A> właściwości do przechowywania danych aplikacji dla użytkownika.  
  
 Klasa `MyApplicationContext` dziedziczy z <xref:System.Windows.Forms.ApplicationContext> i śledzi, gdy każdy formularz jest zamknięty, i zamyka bieżący wątek, gdy oba są. Klasa przechowuje pozycje poszczególnych formularzy dla użytkownika. Dane dotyczące pozycji formularza są przechowywane w pliku zatytułowanym `Appdata.txt` , który jest tworzony w lokalizacji określonej przez. <xref:System.Windows.Forms.Application.UserAppDataPath%2A> Metoda wywołuje `Application.Run(context)` metodę<xref:System.Windows.Forms.ApplicationContext>uruchomieniaaplikacji. `Main`  
  
 Ten kod jest fragmentem z przykładu przedstawionego w <xref:System.Windows.Forms.ApplicationContext> przeglądzie klasy. Kod nie jest pokazywany na potrzeby zwięzłości. Zobacz <xref:System.Windows.Forms.ApplicationContext> , aby uzyskać pełną listę kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji użytkownika.</summary>
        <value><see cref="T:Microsoft.Win32.RegistryKey" /> Reprezentujący klucz rejestru dla danych aplikacji specyficznych dla użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, jest tworzony w następującym formacie:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Dane przechowywane w tym kluczu są częścią profilu użytkownika, który jest włączony dla roamingu. Użytkownik mobilny działa na więcej niż jednym komputerze w sieci. Profil użytkownika dla użytkownika mobilnego jest przechowywany na serwerze w sieci i ładowany do systemu, gdy użytkownik się zaloguje. Aby profil użytkownika był brany pod uwagę podczas roamingu, system operacyjny musi obsługiwać profile roamingu i musi być włączony.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy style wizualizacji są włączone dla aplikacji.</summary>
        <value><see langword="true" />Jeśli style wizualizacji są włączone; w przeciwnym razie. <see langword="false" /></value>
         <remarks>
           <format type="text/markdown"><![CDATA[

## Remarks

Style wizualizacji można włączyć, wywołując <xref:System.Windows.Forms.Application.EnableVisualStyles>metodę.

Style wizualizacji nie zostaną włączone, jeśli system operacyjny ich nie obsługuje lub wyłączono je na poziomie systemu operacyjnego.

           ]]></format>
         </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy kursor oczekiwania jest używany dla wszystkich otwartych formularzy aplikacji.</summary>
        <value><see langword="true" />czy kursor oczekiwania jest używany dla wszystkich otwartych formularzy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy ta właściwość jest ustawiona na `true` <xref:System.Windows.Forms.Control.UseWaitCursor%2A> , właściwość wszystkich otwartych formularzy w aplikacji zostanie ustawiona na `true`wartość. To wywołanie nie zostanie zwrócone, dopóki ta właściwość nie zostanie ustawiona we wszystkich formularzach. Użyj tej właściwości, jeśli masz długotrwałą operację i chcesz wskazać we wszystkich formularzach aplikacji, że operacja jest nadal przetwarzana.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą sposób stosowania stylów wizualnych do okna aplikacji.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta <xref:System.Windows.Forms.Application.VisualStyleState%2A> Właściwość określa, czy style wizualizacji są włączone w obszarach klienta lub w obszarach nieklienta okien aplikacji. Ogólnie rzecz biorąc, ta właściwość powinna być ustawiona w konstruktorze lub <xref:System.Windows.Forms.Form.Load> programie obsługi zdarzeń głównego formularza.  
  
   
  
## Examples  
 <xref:System.Windows.Forms.Application.VisualStyleState%2A> Poniższy przykład kodu ustawia właściwość na jedną <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> z wartości w ramach <xref:System.Windows.Forms.Control.Click> programu obsługi zdarzeń dla <xref:System.Windows.Forms.Button> formantu. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> wyliczenia.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>

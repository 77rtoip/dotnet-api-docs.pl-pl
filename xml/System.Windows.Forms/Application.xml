<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e0f8ee34f05ce1cd10a6b6d926a14e622d5a322" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53514402" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Udostępnia <see langword="static" /> metody i właściwości, aby zarządzać aplikacją, takich jak metody, aby uruchomić i zatrzymać aplikację do przetwarzania komunikatów Windows i właściwości, aby uzyskać informacje na temat aplikacji. Klasa ta nie może być dziedziczona.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application> Klasa zawiera metody do uruchamiania i zatrzymywania aplikacji i wątków i przetwarzanie komunikatów Windows, w następujący sposób:  
  
-   <xref:System.Windows.Forms.Application.Run%2A> Uruchamia pętli komunikatów dla aplikacji w bieżącym wątku i opcjonalnie sprawia, że formularz widoczna.  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> lub <xref:System.Windows.Forms.Application.ExitThread%2A> zatrzymuje pętli komunikatów.  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> przetwarza wiadomości, gdy program działa w pętli.  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Dodaje filtr komunikatu do pompy komunikatów aplikacji do monitorowania komunikatów między Windows.  
  
-   <xref:System.Windows.Forms.IMessageFilter> Umożliwia zatrzymanie zdarzenie z zgłaszanych lub wykonywać operacje specjalne przed wywołaniem programu obsługi zdarzeń.  
  
 Ta klasa ma <xref:System.Windows.Forms.Application.CurrentCulture%2A> i <xref:System.Windows.Forms.Application.CurrentInputLanguage%2A> właściwości, aby pobrać lub ustawić kulturze informacji dla bieżącego wątku.  
  
 Nie można utworzyć wystąpienia tej klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każde kliknięcie `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikację, która tworzy formularz, `listBox1` i `button1`. Kiedy użytkownik kliknie `button1`, `button1_Click` metoda Wyświetla <xref:System.Windows.Forms.MessageBox>. Jeśli użytkownik kliknie `No` na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metoda dodaje numer do listy. Jeśli użytkownik kliknie `Yes`, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A> przetworzyć wszystkie pozostałe komunikaty w kolejce i następnie, aby zakończyć.  
  
> [!NOTE]
>  Wywołanie <xref:System.Windows.Forms.Application.Exit%2A> zakończy się niepowodzeniem w częściowej relacji zaufania.  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> interfejsu, którą chcesz zainstalować.</param>
        <summary>Dodaje filtr komunikatu do monitorowania komunikatów wysyłanych z Windows, ponieważ są one kierowane do miejsc docelowych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystanie z filtra komunikatów, aby zapobiec określonych zdarzeń zgłaszanych lub wykonywać operacje specjalne dla zdarzenia, zanim zostanie on przekazany do procedury obsługi zdarzeń. Filtry komunikatów są unikatowe dla określonego wątku.  
  
 Aby zapobiec wiadomości wysyłane, `value` wystąpienia parametru, który jest przekazywany do tej metody należy zastąpić <xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A> metody z kodu, by obsłużyć komunikat. Metoda musi zwracać `false`.  
  
> [!CAUTION]
>  Dodawanie filtrów komunikatu do "pompy komunikatów" dla aplikacji może obniżyć wydajność.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy filtr komunikatu, wywołuje `TestMessageFilter`. Ten filtr blokuje wszystkie wiadomości dotyczące lewego przycisku myszy. Zanim użyjesz filtrowania wiadomości, musi dostarczyć implementację <xref:System.Windows.Forms.IMessageFilter> interfejsu.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do bezpośredniego obiektu wywołującego można wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy obiekt wywołujący może zakończyć tę aplikację.</summary>
        <value><see langword="true" /> Jeśli obiekt wywołujący może zakończyć tej aplikacji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zwraca `false` Jeśli jest wywoływana z <xref:System.Windows.Forms.Control> hostowany w przeglądarce sieci Web. W efekcie <xref:System.Windows.Forms.Control> nie można zakończyć <xref:System.Windows.Forms.Application>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zostanie zamknięta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy dołączyć programów obsługi zdarzeń do <xref:System.Windows.Forms.Application.Exit%2A> zdarzenia w celu wykonania nieobsługiwany, wymagane zadania, zanim aplikacja przestaje działać. Możesz zamknąć pliki otwarte przez tej aplikacji lub usuwania obiektów, wyrzucanie elementów bezużytecznych odzyskania.  
  
 Ponieważ jest to zdarzeń statycznych, należy odłączyć wszystkie procedury obsługi zdarzeń, dołączony do tego zdarzenia w <xref:System.Windows.Forms.Application.ApplicationExit> programu obsługi zdarzeń, sam. Jeśli nie możesz odłączyć te programy obsługi, będą zostanie dołączony do zdarzenia i kontynuować korzystanie z pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i kończy działanie aplikacji, gdy obie formy są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, zapamiętywane jest pozycja każdego formularza. Ten przykład demonstruje użycie <xref:System.Windows.Forms.Application.ApplicationExit> zdarzeń należy wiedzieć podczas położenie formularza powinien zostać utrwalona, do pliku i `FileStream` powinno zostać zamknięte.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi każdego formularza jest zamknięty, gdy kończy działanie bieżącego wątku, gdy są one obu. Klasa pamięta położenie każdego formularza po jego zamknięciu. Gdy <xref:System.Windows.Forms.Application.ApplicationExit> wystąpi zdarzenie, klasa zapisuje położenia każdego użytkownika w pliku. Dane położenie formularza są przechowywane w pliku o nazwie `appdata.txt` utworzonego w lokalizacji ustalany na podstawie <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` Aby uruchomić aplikację, biorąc pod uwagę <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod znajduje się fragment z przykładu w <xref:System.Windows.Forms.ApplicationContext> klasa — Przegląd. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji, które są współużytkowane przez wszystkich użytkowników.</summary>
        <value>Ścieżka dla danych aplikacji, który jest współużytkowany przez wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> wygląda pierwszy, aby sprawdzić, czy zestaw zawierający głównego pliku wykonywalnego `AssemblyInformationalVersion` atrybutu na nim. Jeśli ten atrybut istnieje, jest używany zarówno <xref:System.Windows.Forms.Application.ProductVersion%2A> i <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Jeśli ten atrybut nie istnieje, obie właściwości zamiast niej użyj wersji pliku wykonywalnego.  
  
 Ścieżka będzie się różnić w zależności od tego, czy aplikacji Windows Forms jest wdrażany za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacje są przechowywane w pamięci podręcznej aplikacji na użytkownika w folderze C:\Documents and Settings\\*username* katalogu. Aby uzyskać więcej informacji, zobacz [Accessing Local and Remote Data in ClickOnce Applications](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji, który jest współużytkowany przez wszystkich użytkowników.</summary>
        <value>A <see cref="T:Microsoft.Win32.RegistryKey" /> reprezentujących klucz rejestru danych aplikacji, który jest współużytkowany przez wszystkich użytkowników.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, zostanie utworzony w następującym formacie:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę firmy, powiązane z daną aplikacją.</summary>
        <value>Nazwa firmy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dotyczące kultury bieżącego wątku.</summary>
        <value>A <see cref="T:System.Globalization.CultureInfo" /> reprezentujący informacji o kulturze dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący język dla bieżącego wątku.</summary>
        <value><see cref="T:System.Windows.Forms.InputLanguage" /> Reprezentujący bieżącego języka dla bieżącego wątku.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do bezpośredniego obiektu wywołującego można wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przetwarza wszystkie komunikaty Windows obecnie w kolejce komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po uruchomieniu formularza Windows tworzy nowy formularz następnie czeka na zatwierdzenie zdarzenia do obsługi. Każdym formularzu obsługuje zdarzenie przetwarza cały kod skojarzony z tym zdarzeniem. Inne zdarzenia oczekiwać w kolejce. Gdy kod obsługuje wydarzenie, aplikacja nie odpowiada. Na przykład jeśli inne okno zostanie przeciągnięty u góry okna repaint nie.  
  
 Jeśli wywołasz <xref:System.Windows.Forms.Application.DoEvents%2A> w kodzie, aplikacja może obsłużyć inne zdarzenia. Na przykład, jeśli masz formularz, który dodaje dane do <xref:System.Windows.Forms.ListBox> i Dodaj <xref:System.Windows.Forms.Application.DoEvents%2A> w kodzie, odświeża inne okno jest przeciągany nad nim formularza. Jeśli usuniesz <xref:System.Windows.Forms.Application.DoEvents%2A> z Twojego kodu formularza nie spowoduje odświeżenia dopiero po zakończeniu program obsługi zdarzeń kliknięcie przycisku wykonywania. Aby uzyskać więcej informacji na temat obsługi komunikatów, zobacz [dane wejściowe użytkownika w formularzach Windows Forms](~/docs/framework/winforms/user-input-in-windows-forms.md).  
  
 W przeciwieństwie do języka Visual Basic 6.0 <xref:System.Windows.Forms.Application.DoEvents%2A> metody nie mogą wywoływać <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> metody.  
  
 Zwykle Użyj tej metody w pętli do przetwarzania komunikatów.  
  
> [!CAUTION]
>  Wywołanie tej metody powoduje, że bieżący wątek zawieszone, gdy są przetwarzane wszystkie komunikaty okna oczekiwania. Jeśli komunikat powoduje wyzwolenie zdarzenia, może być wykonywane innych obszarów kodu aplikacji. Może to spowodować wykazują nieoczekiwane zachowania, które są trudne do debugowania aplikacji. Jeśli jakieś operacje lub obliczenia, które zająć dużo czasu, często zaleca się wykonywać te operacje na nowy wątek. Aby uzyskać więcej informacji na temat programowania asynchronicznego, zobacz [modelu programowania asynchronicznego (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób użycia <xref:System.Windows.Forms.Application.DoEvents%2A> metody. Po uruchomieniu przykładzie użytkownik może wybrać pliki grafiki z <xref:System.Windows.Forms.OpenFileDialog>. Wybrane pliki są wyświetlane w formularzu. <xref:System.Windows.Forms.Application.DoEvents%2A> Metoda wymusza repaint formularz dla każdego pliku grafiki otwarty. Aby uruchomić ten przykład, wklej następujący kod w zawierający formularz <xref:System.Windows.Forms.PictureBox> o nazwie `PictureBox1`, <xref:System.Windows.Forms.OpenFileDialog> o nazwie `OpenFileDialog1`i przycisk o nazwie `fileButton`. Wywołaj `InitializePictureBox` i `InitializeOpenFileDialog` metody z konstruktora formularza lub `Load` metody.  
  
> [!NOTE]
>  W programie Visual Studio, jeśli dodasz <xref:System.Windows.Forms.OpenFileDialog> do formularza przy użyciu operacji przeciągania, trzeba będzie zmodyfikować następujące `InitializeOpenFileDialog` metody, usuwając wiersza, który tworzy nowe wystąpienie klasy <xref:System.Windows.Forms.OpenFileDialog>.  
  
 Przykład wymaga również, aby <xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType> zdarzenia <xref:System.Windows.Forms.Button> kontroli i <xref:System.Windows.Forms.FileDialog.FileOk> zdarzenia <xref:System.Windows.Forms.OpenFileDialog> są podłączone do obsługi zdarzeń zdefiniowanych w przykładzie. Po uruchomieniu przykładu, zostanie wyświetlone okno dialogowe, klikając przycisk.  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia stylów wizualnych dla aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia stylów wizualnych dla aplikacji. Style wizualne są kolory, czcionki i inne elementy wizualne, które tworzą motywu systemu operacyjnego. Formanty będzie narysuj przy użyciu stylów wizualnych, jeśli formant i system operacyjny obsługuje go. Moc <xref:System.Windows.Forms.Application.EnableVisualStyles> musi zostać wywołana przed utworzeniem jakichkolwiek formantów w aplikacji; zazwyczaj <xref:System.Windows.Forms.Application.EnableVisualStyles> jest to pierwszy wiersz w `Main` funkcji. Oddzielne manifest nie jest konieczne Włączanie stylów wizualnych podczas wywoływania <xref:System.Windows.Forms.Application.EnableVisualStyles>.  
  
> [!NOTE]
>  Przed programu .NET Framework 2.0 `FlatStyle` właściwość niektóre formanty, takie jak formanty, które wynikają z <xref:System.Windows.Forms.ButtonBase>, musiała być równa <xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> w kolejności dla formantów do narysowania przy użyciu stylów wizualnych. W aplikacjach napisanych przy użyciu programu .NET Framework 2.0 to nie jest już konieczne.  
  
> [!NOTE]
>  Ta metoda nie odniesie skutku dla formantów hostowanych w programie Internet Explorer.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje wywołanie <xref:System.Windows.Forms.Application.EnableVisualStyles%2A> w `Main` funkcję, aby włączyć style visual w aplikacji.  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja ma wprowadzić stanu modalnego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do formularzy Windows i upewnić się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.EnterThreadModal> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" /> uprawnienie do nasłuchiwania na zdarzenie.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla pliku wykonywalnego, który uruchomił aplikację, łącznie z nazwą pliku wykonywalnego.</summary>
        <value>Nazwa ścieżki i plik wykonywalny plik wykonywalny, który uruchomił aplikację.  
  
Ta ścieżka będzie różna w zależności od tego, czy aplikacji Windows Forms jest wdrażany za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacje są przechowywane w pamięci podręcznej aplikacji na użytkownika w folderze C:\Documents and Settings\\*username* katalogu. Aby uzyskać więcej informacji, zobacz [Accessing Local and Remote Data in ClickOnce Applications](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania ścieżki. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informuje o wszystkich pompy komunikatów, ich musi kończyć się, a następnie zamyka wszystkie okna aplikacji, po przetworzeniu komunikaty.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Informuje o wszystkich pompy komunikatów, ich musi kończyć się, a następnie zamyka wszystkie okna aplikacji, po przetworzeniu komunikaty.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A> Metoda zatrzymuje pętli komunikatów działającą na wszystkich wątkach i zamyka wszystkie okna aplikacji. Ta metoda nie wymusza niekoniecznie wyjścia z aplikacji. <xref:System.Windows.Forms.Application.Exit%2A> Metoda jest zazwyczaj wywoływana z w obrębie pętli komunikatów i wymusza <xref:System.Windows.Forms.Application.Run%2A> do zwrócenia. Aby wyjść z pętli komunikatów dla bieżącego wątku, należy wywołać <xref:System.Windows.Forms.Application.ExitThread%2A>.  
  
 <xref:System.Windows.Forms.Application.Exit%2A> podnosi następujących zdarzeń i wykonuje skojarzonych z nimi działań warunkowego:  
  
-   A <xref:System.Windows.Forms.Form.FormClosing> zdarzenie jest wywoływane dla każdego formularza, reprezentowane przez <xref:System.Windows.Forms.Application.OpenForms%2A> właściwości. To zdarzenie może być anulowane przez ustawienie <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> właściwość ich <xref:System.Windows.Forms.FormClosingEventArgs> parametr `true`.  
  
-   Jeśli zdarzenie, jednego lub więcej programów obsługi anuluje następnie <xref:System.Windows.Forms.Application.Exit%2A> jest zwracane bez dalszych działań. W przeciwnym razie <xref:System.Windows.Forms.Form.FormClosed> zdarzenie jest wywoływane dla każdego Otwórz formularz, a następnie wszystkie uruchomione pętli komunikatów i formularze są zamknięte.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A> Metoda zgłaszała <xref:System.Windows.Forms.Form.Closed> i <xref:System.Windows.Forms.Form.Closing> zdarzenia, które są przestarzałe, począwszy od programu [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każde kliknięcie `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikację, która tworzy formularz, `listBox1`, i `button1`. Kiedy użytkownik kliknie `button1`, `button1_Click` metoda dodaje liczby jednego do trzech do pola listy, a następnie wyświetla <xref:System.Windows.Forms.MessageBox>. Jeśli użytkownik kliknie **nie** na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metoda dodaje inny numer do listy. Jeśli użytkownik kliknie **tak**, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A>, aby przetwarzać wszystkie pozostałe komunikaty w kolejce i następnie, aby zakończyć.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały tworzone i umieszczane na formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do bezpośredniego obiektu wywołującego można wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Zwraca czy <see cref="T:System.Windows.Forms.Form" /> anulowana wyjścia, w ramach aplikacji.</param>
        <summary>Informuje o wszystkich pompy komunikatów, ich musi kończyć się, a następnie zamyka wszystkie okna aplikacji, po przetworzeniu komunikaty.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">O zezwolenie na zakończenie uruchamiania wątku aplikacji. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy działanie pętli komunikatów dla bieżącego wątku i zamknięcie wszystkich okien w wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia wyjście z pętli komunikatów bieżącego wątku. Ta metoda powoduje wywołanie <xref:System.Windows.Forms.Application.Run%2A> dla bieżącego wątku do zwrócenia. Aby zakończyć działanie całej aplikacji, należy wywołać <xref:System.Windows.Forms.Application.Exit%2A>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do bezpośredniego obiektu wywołującego można wywoływać kod niezarządzany. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="message">Komunikat zdarzenia Windows do filtrowania.</param>
        <summary>Uruchamiana żadnych filtrów komunikatów okien i zwraca kopię wiadomości zmodyfikowane.</summary>
        <returns><see langword="true" /> Jeśli filtry zostały przetworzone; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja zakończy przetwarzanie i ma wejść w stan bezczynności.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku zadań, które należy wykonać przed wątek staje się nieaktywna, dołącz je do tego zdarzenia.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.Application.Idle> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do postaci Windows i upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.Idle> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy aplikacja ma opuścić stan modalny.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do formularzy Windows i upewnić się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.LeaveThreadModal> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji użytkownika lokalnego, roamingu.</summary>
        <value>Ścieżka dla danych aplikacji użytkownika lokalnego, roamingu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użytkownik lokalny jest jednym profilu użytkownika, których są przechowywane w systemie, na którym użytkownik jest zalogowany. Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Typowe ścieżki podstawowej jest C:\Documents and Settings\\*username*\Local Settings\Application danych. Ta ścieżka może się różnić, jednak w przypadku wdrażania aplikacji Windows Forms przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Tworzy swój własny katalog danych aplikacji, która jest odizolowana od innych aplikacji. Aby uzyskać więcej informacji, zobacz [Accessing Local and Remote Data in ClickOnce Applications](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i kończy działanie aplikacji, gdy obie formy są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, zapamiętywane jest pozycja każdego formularza. Chociaż ten przykład demonstruje użycie <xref:System.Windows.Forms.Application.UserAppDataPath%2A> właściwość do przechowywania danych aplikacji użytkownika, <xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> mogą być używane zamiast tego.  
  
 `MyApplicationContext` Klasa dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi każdego formularza jest zamknięty, gdy kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdy formularz dla użytkownika. Dane położenie formularza są przechowywane w pliku o nazwie `Appdata.txt` utworzonego w lokalizacji ustalany na podstawie <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` Aby uruchomić aplikację, biorąc pod uwagę <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod znajduje się fragment z przykładu w <xref:System.Windows.Forms.ApplicationContext> klasa — Przegląd. Kod nie jest wyświetlany w celu skrócenia programu. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy pętlę komunikatów istnieje w tym wątku.</summary>
        <value><see langword="true" /> Jeśli istnieje pętla wiadomości w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W przypadku hostowania Windows Forms w innych środowiskach, takich jak niezarządzanych aplikacji ta właściwość zawsze zwraca `false`. Użyj <xref:System.Windows.Forms.Application.RegisterMessageLoop%2A> nakazać Windows Forms, jeśli środowisko hostingu środki, nieopłacone pętlę aktywne wiadomości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje OLE w bieżącym wątku.</summary>
        <returns>Jedną z <see cref="T:System.Threading.ApartmentState" /> wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę należy wywołać przed wywołaniem dowolnej `Microsoft.Win32` metodę, która wymaga OLE. <xref:System.Windows.Forms.Application.OleRequired%2A> najpierw sprawdza, jeśli został zainicjowany OLE w bieżącym wątku. W przeciwnym razie inicjuje wątku dla mechanizmu OLE.  
  
> [!NOTE]
>  Jeśli wątek wywołuje metody OLE bezpośrednio, nie musisz wywołać tę metodę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t"><see cref="T:System.Exception" /> Reprezentujący wyjątek, który został wygenerowany.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Application.ThreadException" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.Application.OnThreadException%2A> Aby zgłosić wyjątek, który spowoduje zatrzymanie przetwarzania aplikacji.  
  
 <xref:System.Windows.Forms.Application> Klasa ma <xref:System.Windows.Forms.Application.ThreadException> zdarzeń. Program obsługi zdarzeń można dołączyć do tego zdarzenia w celu przetwarzania niestandardowego należy dla nieobsłużonych wyjątków. Jeśli program obsługi zdarzeń, nie dołączaj <xref:System.Windows.Forms.Application.OnThreadException%2A> wykona domyślne zachowanie, które obejmuje wyświetlanie okna dialogowego, aby poinformować użytkownika, że wystąpił błąd.  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> tylko implementuje domyślne zachowanie wyjątek dla nieobsłużonych wyjątków, które występują w wątkach należące do formularzy Windows. Nieobsługiwane wyjątki na inne wątki są obsługiwane przez <xref:System.AppDomain.UnhandledException> zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję otwartych formularzy należące do aplikacji.</summary>
        <value>Element <see cref="T:System.Windows.Forms.FormCollection" /> zawierający wszystkie aktualnie otwarte formularze należące do tej aplikacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A> Właściwość reprezentuje kolekcję tylko do odczytu form należące do aplikacji. Ta kolekcja można wyszukiwać według pozycji indeksu lub <xref:System.Windows.Forms.Control.Name%2A> z <xref:System.Windows.Forms.Form>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Obiekt wywołujący musi mieć uprawnienia dostępu do wszystkich okien, zgodnie z definicją <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> wartość <see cref="T:System.Security.Permissions.UIPermissionWindow" /> wyliczenia.</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę produktu, skojarzonych z tą aplikacją.</summary>
        <value>Nazwa produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` jest pobierana z metadanych zestawu zawierającego formularza głównego bieżącej aplikacji. Jest on ustawiany przez ustawienie <xref:System.Reflection.AssemblyProductAttribute> w manifeście zestawu. Aby uzyskać więcej informacji, zobacz [manifestu zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję produktu, skojarzonych z tą aplikacją.</summary>
        <value>Wersja produktu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj numer wersji jest wyświetlany jako *główny numer*. *pomocnicza liczba*. *numer kompilacji*. *prywatny numer*. Możesz ustawić go jawnie, ustawiając wersji zestawu w manifeście zestawu. Aby uzyskać więcej informacji, zobacz [manifestu zestawu](~/docs/framework/app-domains/assembly-manifest.md).  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> wygląda pierwszy, aby sprawdzić, czy zestaw zawierający głównego pliku wykonywalnego `AssemblyInformationalVersion` atrybutu na nim. Jeśli ten atrybut istnieje, jest używany zarówno <xref:System.Windows.Forms.Application.ProductVersion%2A> i <xref:System.Windows.Forms.Application.CommonAppDataPath%2A>. Jeśli ten atrybut nie istnieje, obie właściwości zamiast niej użyj wersji pliku wykonywalnego.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Obiekty do przekazania do <see cref="E:System.Windows.Forms.Application.Idle" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Application.Idle" /> zdarzeń w scenariuszach hostowanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana w przypadku hostowania Windows Forms w innym środowisku, takie jak niezarządzanej aplikacji. Należy wywołać <xref:System.Windows.Forms.Application.RaiseIdle%2A> aplikacji macierzystej wejścia w stanie bezczynności. Dzięki temu niektórych kontrolek formularzy Windows Forms i składników do wykonania pracy tła ważne, gdy użytkownik nie prowadzi interakcję z aplikacją.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Metoda do wywołania po Windows Forms musi sprawdzić, jeśli środowisko hostingu jest nadal wysyła wiadomości.</param>
        <summary>Rejestruje wywołanie zwrotne do sprawdzania, czy pętli komunikatów działa w środowiskach hostowanych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana w przypadku hostowania Windows Forms w innym środowisku, takie jak niezarządzanej aplikacji. W środowiskach hostowanych <xref:System.Windows.Forms.Application.MessageLoop%2A> właściwość zawsze zwraca wartość false, jeśli formularze Windows nie przetwarza komunikatów. Umożliwia to wywołanie zwrotne Poinformuj Windows Forms, jeśli środowisko hostingu jest nadal przetwarza wiadomości.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">Implementacja <see cref="T:System.Windows.Forms.IMessageFilter" /> do usunięcia z aplikacji.</param>
        <summary>Usuwa filtr komunikatu z pompy komunikatów aplikacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz usunąć filtr komunikatu, gdy nie chcesz przechwycić Windows komunikatów przed ich wysłaniem.  
  
   
  
## Examples  
 Zanim użyjesz filtrowania wiadomości, musi dostarczyć implementację <xref:System.Windows.Forms.IMessageFilter> interfejsu. Następujące klasy tworzy filtr komunikatu, wywołuje `TestMessageFilter`. Ten filtr blokuje wszystkie wiadomości dotyczące lewego przycisku myszy.  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą, czy bieżącej aplikacji rysowania formantów przy użyciu stylów wizualnych.</summary>
        <value><see langword="true" /> Włączenie funkcji stylów wizualnych dla formantów w obszaru klienckiego aplikacji systemu windows; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli czerpią formant niestandardowy, należy użyć tej właściwości do określenia, czy narysuj kontrolkę z lub bez stylów wizualnych, aby jej wygląd jest zgodny z innych formantów w aplikacji.  
  
 W poniższej tabeli przedstawiono cztery warunki, które musi istnieć przez <xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> do zwrócenia `true`.  
  
|Warunek|Opis|  
|---------------|-----------------|  
|System operacyjny obsługuje stylów wizualnych|Aby sprawdzić ten warunek oddzielnie, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> właściwość <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Użytkownik włączył stylów wizualnych w systemie operacyjnym|Aby sprawdzić ten warunek oddzielnie, użyj <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> właściwość <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> klasy.|  
|Style wizualne są włączone w aplikacji|Można włączyć style wizualne w aplikacji, wywołując <xref:System.Windows.Forms.Application.EnableVisualStyles> metody lub za pomocą aplikacji manifest, który określa, że wersja pliku ComCtl32.dll 6 lub nowszej będzie używany do rysowania formantów.|  
|Style wizualne są używane do rysowania obszaru klienckiego aplikacji systemu windows|Aby sprawdzić ten warunek oddzielnie, użyj <xref:System.Windows.Forms.Application.VisualStyleState%2A> właściwość <xref:System.Windows.Forms.Application> klasy i sprawdź, czy wartość <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> lub <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka aplikację, a następnie natychmiast uruchamia nowe wystąpienie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Najbardziej typową przyczyną do wywoływania `Restart` jest rozpoczęcie nowej wersji aplikacji, która zostały pobrane za pośrednictwem [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] przy użyciu `Update` lub `UpdateAsync` metody.  
  
 Aplikacje zostaną ponownie uruchomione w kontekście, w którym początkowo zostały uruchomione. Jeśli aplikacja została uruchomiona z użyciem adres URL wskazujący bezpośrednio do głównego pliku wykonywalnego aplikacji, zostanie ono uruchomione przy użyciu tego samego adresu URL. Jeśli aplikacja jest [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacji, zostanie ono uruchomione przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)].  
  
 Jeśli aplikacja została pierwotnie podane opcje wiersza polecenia, po pierwszym wykonaniu, <xref:System.Windows.Forms.Application.Restart%2A> uruchomi ją ponownie, podając te same opcje.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Twój kod nie jest aplikacją Windows Forms. Nie można wywołać tej metody, w tym kontekście.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Wymaga <see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" /> uprawnień.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Rozpoczyna, wykonywanie pętli komunikatów standardowej aplikacji w bieżącym wątku.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna, wykonywanie pętli komunikatów standardowej aplikacji w bieżącym wątku, bez formularza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W formularzu Windows lub Win32-na podstawie aplikacji, pętlę komunikatów jest procedury w kodzie, który przetwarza zdarzenia użytkownika, takich jak kliknięcia myszy i klawiatury pociągnięć. Co uruchomionej aplikacji systemu Windows wymaga pętlę aktywne wiadomości o nazwie główna pętla wiadomości. Aplikacja kończy działanie po zamknięciu główna pętla wiadomości. W formularzach Windows Forms, ta pętla jest zamknięte, kiedy <xref:System.Windows.Forms.Application.Exit%2A> metoda jest wywoływana, lub gdy <xref:System.Windows.Forms.Application.ExitThread%2A> metoda jest wywoływana w wątku, który jest uruchomiony główna pętla wiadomości.  
  
 Większość deweloperów Windows Forms, nie będą musieli używać tej wersji metody. Należy używać <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29> przeciążenia do uruchomienia aplikacji z formularzem głównym, tak, aby aplikacja kończy się po zamknięciu formularza głównego. W przypadku wszystkich innych przypadkach użyj <xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29> przeciążenia, które obsługuje dostarczanie <xref:System.Windows.Forms.ApplicationContext> obiektu lepszą kontrolę nad okresem istnienia aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla wiadomości jest już uruchomione w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context"><see cref="T:System.Windows.Forms.ApplicationContext" /> w uruchamiania aplikacji.</param>
        <summary>Rozpoczyna wykonywanie pętli komunikatów standardowej aplikacji w bieżącym wątku, przy użyciu <see cref="T:System.Windows.Forms.ApplicationContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pętli komunikatów działa aż do <xref:System.Windows.Forms.Application.Exit%2A> lub <xref:System.Windows.Forms.Application.ExitThread%2A> nosi nazwę lub <xref:System.Windows.Forms.Application.ThreadExit> zdarzenie jest zgłaszane w obiekcie kontekstu.  
  
   
  
## Examples  
 Przykład przedstawia dwa formularze i kończy działanie aplikacji, gdy obie formy są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, zapamiętywane jest pozycja każdego formularza. W tym przykładzie przedstawiono sposób użycia <xref:System.Windows.Forms.ApplicationContext>, wraz z `Application.Run(context)` metody, aby wyświetlić wiele form, podczas uruchamiania aplikacji.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi każdego formularza jest zamknięty, gdy kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdy formularz dla użytkownika. Dane położenie formularza są przechowywane w pliku o nazwie `Appdata.txt` utworzonego w lokalizacji ustalany na podstawie <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` Aby uruchomić aplikację, biorąc pod uwagę <xref:System.Windows.Forms.ApplicationContext>.  
  
 Kod `AppForm1` i `AppForm2` formularzy nie jest wyświetlany w celu skrócenia programu. Zobacz <xref:System.Windows.Forms.ApplicationContext> klasa — Przegląd listę całego kodu.  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla wiadomości jest już uruchomione w tym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">A <see cref="T:System.Windows.Forms.Form" /> reprezentujący formularza, aby były widoczne.</param>
        <summary>Rozpoczyna wykonywanie pętli komunikatów standardowej aplikacji w bieżącym wątku i sprawia, że określony formularz jest widoczna.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj główna funkcja aplikacji wywołuje tę metodę i przekazuje do niego głównego okna aplikacji.  
  
 Ta metoda dodaje procedurę obsługi zdarzeń do `mainForm` parametr <xref:System.Windows.Forms.Form.Closed> zdarzeń. Program obsługi zdarzeń wywołuje zdarzenia <xref:System.Windows.Forms.Application.ExitThread%2A> czyszczenie aplikacji.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A> Metody <xref:System.Windows.Forms.Form> klasa zostanie wywołana przed zwracany przez tę metodę.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla listę liczb w polu listy w formularzu. Każde kliknięcie `button1`, aplikacja dodaje inny numer do listy.  
  
 `Main` Wywołania metody <xref:System.Windows.Forms.Application.Run%2A> można uruchomić aplikację, która tworzy formularz, `listBox1`, i `button1`. Kiedy użytkownik kliknie `button1`, `button1_Click` metoda dodaje liczby jednego do trzech do pola listy, a następnie wyświetla <xref:System.Windows.Forms.MessageBox>. Jeśli użytkownik kliknie **nie** na <xref:System.Windows.Forms.MessageBox>, `button1_Click` metoda dodaje inny numer do listy. Jeśli użytkownik kliknie **tak**, wywołania aplikacji <xref:System.Windows.Forms.Application.Exit%2A> przetworzyć wszystkie pozostałe komunikaty w kolejce i następnie, aby zakończyć.  
  
 Przykład wymaga, aby `listBox1` i `button1` zostały utworzone i umieszczane na formularzu.  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Główna pętla wiadomości jest już uruchomione w bieżącym wątku.</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg formatu do zastosowania do najwyższego poziomu okna transkrypcji, gdy są one wyświetlane przy użyciu transparent ostrzeżenie.</summary>
        <value>Ciąg formatu, aby zastosować do najwyższego poziomu okna transkrypcji.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Wartość domyślna dla nowych kontrolek. Jeśli <see langword="true" />, nowe Określa, które obsługują <c>UseCompatibleTextRendering</c> użyj [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] na podstawie <see cref="T:System.Drawing.Graphics" /> klasy do renderowania tekstu; Jeśli <see langword="false" />, nowe steruje użyciem [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] na podstawie <see cref="T:System.Windows.Forms.TextRenderer" />klasy.</param>
        <summary>Ustawia domyślną całej aplikacji <c>UseCompatibleTextRendering</c> właściwości zdefiniowane w niektórych kontrolek.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre formanty Windows Forms można renderować ich tekst za pomocą <xref:System.Windows.Forms.TextRenderer> klasy, która opiera się na [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] biblioteki funkcji graficznych, lub <xref:System.Drawing.Graphics> klasy, która opiera się na [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] biblioteki funkcji graficznych. Ta zmiana została wprowadzona w [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] ze względu na wydajność i lokalizacja problemy związane z [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. Użyj <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> można ustawić wartość domyślną `UseCompatibleTextRendering` właściwość dla formantów, które go obsługują.  
  
 `UseCompatibleTextRendering` Właściwość jest przeznaczona do zapewnia wizualne zgodności kontrolek formularzy Windows Forms, renderowanie tekstu przy użyciu <xref:System.Windows.Forms.TextRenderer> klasy i [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] i [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)] aplikacje, które wykonują renderowania niestandardowego tekstu przy użyciu <xref:System.Drawing.Graphics>klasy. W większości przypadków, jeśli aplikacja nie jest uaktualniany z [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] lub [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], zaleca się pozostawienie `UseCompatibleTextRendering` ustawioną wartość domyślną `false`.  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] Na podstawie <xref:System.Windows.Forms.TextRenderer> klasa została wprowadzona w systemie [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)] Ustawianie dla tekstu, lepsze i lepszą obsługę międzynarodowe czcionki w celu poprawy wydajności. We wcześniejszych wersjach programu [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] na podstawie <xref:System.Drawing.Graphics> klasa została użyta do wykonania wszystkich renderowanie tekstu. [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] oblicza odstępów i zawijania inaczej od wyrazów [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]. W aplikacji Windows Forms, która używa <xref:System.Drawing.Graphics> klasy do renderowania tekstu, może to spowodować tekst dla kontrolki używające <xref:System.Windows.Forms.TextRenderer> się różni się od innych tekstu w aplikacji. Aby rozwiązać ten niezgodności, można ustawić `UseCompatibleTextRendering` właściwość `true`. Aby ustawić `UseCompatibleTextRendering` do `true` dla wszystkich obsługiwanych kontrolek w aplikacji, należy wywołać <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> metody z parametrem `true`.  
  
 Nigdy nie powinna wywołać tę metodę, jeśli kod formularzy Windows znajduje się w innej aplikacji, takich jak program Internet Explorer. Tę metodę można wywołać tylko w aplikacji Windows Forms autonomicznych.  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  Aby ustawić wartość domyślną dla `UseCompatibleTextRendering` w [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)] lub nowszej, adresem <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>.  
  
 W [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] lub później, po wywołaniu <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> jest automatycznie generowany w pliku Program.cs. Aby zmienić domyślne renderowanie tekstu, należy zmodyfikować wygenerowany kod.  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Tę metodę można wywołać tylko w przypadku, zanim pierwsze okno jest tworzone przez testowaną aplikację Windows Forms.</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" />
        <Parameter Name="force" Type="System.Boolean" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="state">A <see cref="T:System.Windows.Forms.PowerState" /> wskazujący tryb działania zasilania, do której przejście.</param>
        <param name="force"><see langword="true" /> Aby wymusić natychmiastowe; tryb wstrzymania <see langword="false" /> spowodować Windows wysłać żądanie wstrzymania do każdej aplikacji.</param>
        <param name="disableWakeEvent"><see langword="true" /> można wyłączyć, Przywracanie stanu zasilania systemu aktywne zdarzenie wznawiania <see langword="false" /> umożliwiające przywracanie stanu zasilania systemu na aktywny dla zdarzenia wznowienia.</param>
        <summary>Wstrzymuje przechodzi w stan hibernacji systemu lub żąda zawieszone lub hibernacji systemu.</summary>
        <returns><see langword="true" /> Jeśli system jest wstrzymana, w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli aplikacja nie odpowiada na żądania wstrzymania w ciągu 20 sekund, Windows określa, jest w stanie przestanie odpowiadać i że aplikacja może być przełączenia w tryb uśpienia lub zakończone. Gdy aplikacja reaguje na żądanie wstrzymania, jednak może potrwać niezależnie od czasu należy go wyczyścić zasoby i zamknij aktywne procesy.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Instruuje aplikację jak reagować na nieobsługiwanych wyjątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Ustawia programy obsługi zdarzeń dla wyjątków występujących wątków Windows Forms i wyjątków występujących na innych wątków. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawienia w pliku konfiguracji użytkownika aplikacji. Używa ona <xref:System.Windows.Forms.Application.ThreadException> zdarzenie, aby obsłużyć wyjątki wątku interfejsu użytkownika, a <xref:System.AppDomain.UnhandledException> zdarzenie, aby obsłużyć wyjątki wątek bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie może uniemożliwić aplikacji z przerywa, przykład po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie założono, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> kontrolek `button1` i `button2`na Twoje <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Opisujące, jak powinny zachowywać się aplikacja, jeśli wyjątek jest generowany bez wciągnięcia wartość.</param>
        <summary>Instruuje aplikację jak reagować na nieobsługiwanych wyjątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Często nie jest to możliwe, aby przechwytywać wszystkie wyjątki generowane przez Windows Forms. Za pomocą tej metody, można nakazać aplikacja powinna catch wszystkie nieobsługiwane wyjątki rzucane przez składniki formularzy Windows i kontynuowania działania, czy tego, czy należy udostępnić je do użytkownika i zatrzymuje wykonywanie.  
  
 Wywołaj <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpienia swojej aplikacji za pomocą formularza głównego <xref:System.Windows.Forms.Application.Run%2A> metody.  
  
 Przechwytywać wyjątków, które występują w wątkach, które nie zostały utworzone i należące do formularzy Windows używania <xref:System.AppDomain.UnhandledException> programu obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu Ustawia programy obsługi zdarzeń dla wyjątków występujących wątków Windows Forms i wyjątków występujących na innych wątków. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawienia w pliku konfiguracji użytkownika aplikacji. Używa ona <xref:System.Windows.Forms.Application.ThreadException> zdarzenie, aby obsłużyć wyjątki wątku interfejsu użytkownika, a <xref:System.AppDomain.UnhandledException> zdarzenie, aby obsłużyć wyjątki wątek bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie może uniemożliwić aplikacji z przerywa, przykład po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie założono, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> kontrolek `button1` i `button2`na Twoje <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątków, po jej utworzeniu jego pierwszym oknie.</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" />
        <Parameter Name="threadScope" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> Opisujące, jak powinny zachowywać się aplikacja, jeśli wyjątek jest generowany bez wciągnięcia wartość.</param>
        <param name="threadScope"><see langword="true" /> Aby ustawić tryb wyjątek wątku; w przeciwnym razie <see langword="false" />.</param>
        <summary>Instruuje aplikację jak reagować na nieobsłużone wyjątki, opcjonalnie stosowanie zachowanie właściwe dla wątków.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Często nie jest to możliwe, aby przechwytywać wszystkie wyjątki generowane przez Windows Forms. Za pomocą tej metody, można nakazać aplikacja powinna catch wszystkie nieobsługiwane wyjątki rzucane przez składniki formularzy Windows i kontynuowania działania, czy tego, czy należy udostępnić je do użytkownika i zatrzymuje wykonywanie.  
  
 Wywołaj <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> przed wystąpienia swojej aplikacji za pomocą formularza głównego <xref:System.Windows.Forms.Application.Run%2A> metody.  
  
 Gdy `threadScope` jest `true`, tryb wyjątek wątku został ustawiony. Tryb wyjątku wątku zastępuje trybu wyjątków aplikacji, jeśli `mode` nie jest ustawiony na <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>.  
  
 Gdy `threadScope` jest `false`, tryb wyjątków aplikacji jest ustawiony. Tryb wyjątku aplikacji jest używany dla wszystkich wątków, które mają <xref:System.Windows.Forms.UnhandledExceptionMode.Automatic> trybu. Ustawienie trybu wyjątków aplikacji nie ma wpływu na ustawienie bieżącego wątku.  
  
 Przechwytywać wyjątków, które występują w wątkach, które nie zostały utworzone i należące do formularzy Windows używania <xref:System.AppDomain.UnhandledException> programu obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu Ustawia programy obsługi zdarzeń dla wyjątków występujących wątków Windows Forms i wyjątków występujących na innych wątków. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawienia w pliku konfiguracji użytkownika aplikacji. Używa ona <xref:System.Windows.Forms.Application.ThreadException> zdarzenie, aby obsłużyć wyjątki wątku interfejsu użytkownika, a <xref:System.AppDomain.UnhandledException> zdarzenie, aby obsłużyć wyjątki wątek bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie może uniemożliwić aplikacji z przerywa, przykład po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie założono, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> kontrolek `button1` i `button2`na Twoje <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić trybu wyjątków, po jej utworzeniu jego pierwszym oknie.</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla pliku wykonywalnego, który uruchomił aplikację, nie wliczając nazwę pliku wykonywalnego.</summary>
        <value>Ścieżka do pliku wykonywalnego, który uruchomił aplikację.  
  
Ta ścieżka będzie różna w zależności od tego, czy aplikacji Windows Forms jest wdrażany za pomocą [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] aplikacje są przechowywane w pamięci podręcznej aplikacji na użytkownika w folderze C:\Documents and Settings\\*username* katalogu. Aby uzyskać więcej informacji, zobacz [Accessing Local and Remote Data in ClickOnce Applications](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod pobiera tę właściwość i wyświetla jego wartość w polu tekstowym. Przykład wymaga, aby `textBox1` został umieszczony w formularzu.  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">w celu uzyskania ścieżki. Wyliczenie skojarzone: <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zostanie zgłoszony wyjątek untrapped wątku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie umożliwia aplikacji Windows Forms do uchwytu, w przeciwnym razie braku obsługi wyjątków, które występują w Windows Forms wątków. Dołącz swoje programów obsługi zdarzeń do <xref:System.Windows.Forms.Application.ThreadException> zdarzeń, aby poradzić sobie z uwzględnieniem poniższych wyjątków, które spowoduje, że aplikacja w nieznanym stanie. Jeśli to możliwe, wyjątki powinny być obsługiwane przez bloku obsługi wyjątków strukturalnych.  
  
 Można określić, czy to wywołanie zwrotne jest używany dla nieobsłużonych wyjątków wątku Windows Forms, ustawiając <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>. Przechwytywać wyjątków, które występują w wątkach, które nie zostały utworzone i należące do formularzy Windows używania <xref:System.AppDomain.UnhandledException> programu obsługi zdarzeń.  
  
> [!NOTE]
>  Aby zagwarantować, że nie aktywacji tego zdarzenia zostaną pominięte, należy dołączyć program obsługi, przed wywołaniem <xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu Ustawia programy obsługi zdarzeń dla wyjątków występujących wątków Windows Forms i wyjątków występujących na innych wątków. Ustawia <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A> tak, aby wszystkie wyjątki są obsługiwane przez aplikację, niezależnie od ustawienia w pliku konfiguracji użytkownika aplikacji. Używa ona <xref:System.Windows.Forms.Application.ThreadException> zdarzenie, aby obsłużyć wyjątki wątku interfejsu użytkownika, a <xref:System.AppDomain.UnhandledException> zdarzenie, aby obsłużyć wyjątki wątek bez interfejsu użytkownika. Ponieważ <xref:System.AppDomain.UnhandledException> nie może uniemożliwić aplikacji z przerywa, przykład po po prostu rejestruje błąd w dzienniku zdarzeń aplikacji przed zakończeniem działania.  
  
 W tym przykładzie założono, że zostały zdefiniowane dwie <xref:System.Windows.Forms.Button> kontrolek `button1` i `button2`na Twoje <xref:System.Windows.Forms.Form> klasy.  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">do bezpośredniego obiektu wywołującego można wywoływać kod niezarządzany, podczas dodawania programu obsługi do tego zdarzenia. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wątek zostanie zamknięta. Gdy wątku głównego aplikacji ma zostać wyłączony, to zdarzenie jest zgłaszane w najpierw następuje <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy dołączyć programów obsługi zdarzeń do <xref:System.Windows.Forms.Application.ThreadExit> zdarzenie, aby wykonać dowolne obsłużony, wymagane zadania, zanim wątek przestaje działać. Zamknij pliki otwarte przez ten wątek lub usuwania obiektów, które moduł garbage collector odzyskania.  
  
> [!CAUTION]
>  Ponieważ jest to zdarzeń statycznych, należy odłączyć inne programy obsługi zdarzeń, po usunięciu aplikacji lub będą powodować przecieki pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.Application.ThreadExit> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do formularzy Windows i upewnić się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.Application.ThreadExit> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyrejestrowuje zwrotnego pętli komunikatu z <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera ścieżkę dla danych aplikacji użytkownika.</summary>
        <value>Ścieżka dla danych aplikacji użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ścieżka nie istnieje, utworzony w następującym formacie:  
  
 *Ścieżka podstawowa*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 Dane przechowywane w tej ścieżce jest częścią profilu użytkownika, który jest włączony dla mobilnych. Użytkownika mobilnego działa na więcej niż jednym komputerze w sieci. Profil użytkownika mobilnego użytkownika jest przechowywana na serwerze w sieci i jest ładowany do systemu, gdy użytkownik loguje się. Dla profilu użytkownika zostały uznane za mobilnych system operacyjny musi obsługiwać profilów mobilnych i musi być włączona.  
  
 Typowe ścieżki podstawowej jest C:\Documents and Settings\\*username*\Application. Ta ścieżka może się różnić, jednak w przypadku wdrażania aplikacji Windows Forms przy użyciu [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]. [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] Tworzy swój własny katalog danych aplikacji, która jest odizolowana od innych aplikacji. Aby uzyskać więcej informacji, zobacz [Accessing Local and Remote Data in ClickOnce Applications](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d).  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla dwa formularze i kończy działanie aplikacji, gdy obie formy są zamknięte. Gdy aplikacja rozpoczyna się i kończy działanie, zapamiętywane jest pozycja każdego formularza. Ten przykład demonstruje użycie <xref:System.Windows.Forms.Application.UserAppDataPath%2A> właściwość do przechowywania danych aplikacji dla użytkownika.  
  
 Klasa `MyApplicationContext` dziedziczy <xref:System.Windows.Forms.ApplicationContext> i śledzi każdego formularza jest zamknięty, gdy kończy działanie bieżącego wątku, gdy są one obu. Klasa przechowuje pozycji każdy formularz dla użytkownika. Dane położenie formularza są przechowywane w pliku o nazwie `Appdata.txt` utworzonego w lokalizacji ustalany na podstawie <xref:System.Windows.Forms.Application.UserAppDataPath%2A>. `Main` Wywołania metody `Application.Run(context)` Aby uruchomić aplikację, biorąc pod uwagę <xref:System.Windows.Forms.ApplicationContext>.  
  
 Ten kod znajduje się fragment z przykładu w <xref:System.Windows.Forms.ApplicationContext> klasa — Przegląd. Kod nie jest wyświetlany w celu skrócenia programu. Zobacz <xref:System.Windows.Forms.ApplicationContext> listę całego kodu.  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klucz rejestru dla danych aplikacji użytkownika.</summary>
        <value>A <see cref="T:Microsoft.Win32.RegistryKey" /> reprezentujący klucz rejestru dla określonych danych aplikacji użytkownika.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli klucz nie istnieje, zostanie utworzony w następującym formacie:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 Dane przechowywane w ten klucz jest częścią profilu użytkownika, który jest włączony dla mobilnych. Użytkownika mobilnego działa na więcej niż jednym komputerze w sieci. Profil użytkownika mobilnego użytkownika jest przechowywana na serwerze w sieci i jest ładowany do systemu, gdy użytkownik loguje się. Dla profilu użytkownika zostały uznane za mobilnych system operacyjny musi obsługiwać profilów mobilnych i musi być włączona.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy ma być używana przez kursor oczekiwania dla wszystkich otwartych formularzy aplikacji.</summary>
        <value><see langword="true" /> czy kursor oczekiwania jest używany dla wszystkich otwartych formularzy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest równa `true`, <xref:System.Windows.Forms.Control.UseWaitCursor%2A> właściwość form wszystkich otwartych w aplikacji zostanie ustawiona `true`. To wywołanie nie będzie zwracać, dopóki ta właściwość została ustawiona we wszystkich formularzach. Po operacji długotrwałych oraz aby wskazać wszystkich formularzach aplikacji nadal przetwarza operację, należy użyć tej właściwości.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość określającą sposób w jaki visual style są stosowane do aplikacji systemu windows.</summary>
        <value>Bitowa kombinacja <see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To <xref:System.Windows.Forms.Application.VisualStyleState%2A> właściwość określa, czy style wizualne są włączone w klienta lub nieklienckim obszarami aplikacji systemu windows. Ogólnie rzecz biorąc, należy ustawić tę właściwość w formularzu głównym konstruktora lub <xref:System.Windows.Forms.Form.Load> programu obsługi zdarzeń.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.Application.VisualStyleState%2A> jedną z właściwości <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> wartości w ramach <xref:System.Windows.Forms.Control.Click> program obsługi zdarzeń dla <xref:System.Windows.Forms.Button> kontroli. Ten przykład kodu jest częścią większego przykładu przewidzianego dla <xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType> wyliczenia.  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
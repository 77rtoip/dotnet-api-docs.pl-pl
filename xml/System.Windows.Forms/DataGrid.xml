<Type Name="DataGrid" FullName="System.Windows.Forms.DataGrid">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ebff780c0a748543494f3f939a8fc2fb7ed4055e" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65015992" /></Metadata><TypeSignature Language="C#" Value="public class DataGrid : System.Windows.Forms.Control, System.ComponentModel.ISupportInitialize, System.Windows.Forms.IDataGridEditingService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DataGrid extends System.Windows.Forms.Control implements class System.ComponentModel.ISupportInitialize, class System.Windows.Forms.IDataGridEditingService" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.DataGrid" />
  <TypeSignature Language="VB.NET" Value="Public Class DataGrid&#xA;Inherits Control&#xA;Implements IDataGridEditingService, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class DataGrid : System::Windows::Forms::Control, System::ComponentModel::ISupportInitialize, System::Windows::Forms::IDataGridEditingService" />
  <TypeSignature Language="F#" Value="type DataGrid = class&#xA;    inherit Control&#xA;    interface ISupportInitialize&#xA;    interface IDataGridEditingService" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDataGridEditingService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Navigate")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.DataGridDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.DataGridDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.DataGridDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Wyświetla dane ADO.NET w siatce, którą można przewijać. <see cref="T:System.Windows.Forms.DataGridView" /> Kontroli zastępuje i dodaje funkcjonalność do <see cref="T:System.Windows.Forms.DataGrid" /> kontrolować; jednak <see cref="T:System.Windows.Forms.DataGrid" /> kontrolki została zachowana na potrzeby zgodności z poprzednimi wersjami i użycia w przyszłości, jeśli wybierzesz.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> Wyświetla tabele podrzędne łączy stylu sieci Web. Możesz kliknąć link, aby przejść do tabeli podrzędnej. Po wyświetleniu tabeli podrzędnej w podpisie, który można kliknąć, aby przejść z powrotem do tabeli nadrzędnej pojawi się przycisk Wstecz. Dane z wierszy nadrzędnych jest wyświetlany poniżej podpis i powyżej nagłówków kolumn. Można ukryć informacje wiersza nadrzędne, klikając przycisk po prawej stronie przycisku Wstecz.  
  
 Aby wyświetlić tabelę w <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> w czasie wykonywania, użyj <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metodę, aby ustawić <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości w celu poprawnego źródła danych. Następujące źródła danych są prawidłowe:  
  
-   A <xref:System.Data.DataTable>  
  
-   A <xref:System.Data.DataView>  
  
-   A <xref:System.Data.DataSet>  
  
-   A <xref:System.Data.DataViewManager>  
  
-   Tablicy jednowymiarowej  
  
-   Dowolny składnik, który implementuje <xref:System.ComponentModel.IListSource> interfejsu  
  
-   Dowolny składnik, który implementuje <xref:System.Collections.IList> interfejsu  
  
 Aby uzyskać więcej informacji na temat <xref:System.Data.DataSet> klasy, zobacz [DataSet, DataTable i DataView](~/docs/framework/data/adonet/dataset-datatable-dataview/index.md).  
  
 Można utworzyć siatki, która umożliwia użytkownikom edytowanie danych, ale uniemożliwia dodanie nowych wierszy przy użyciu <xref:System.Data.DataView> jako źródła danych i ustawienie <xref:System.Data.DataView.AllowNew%2A> właściwość `false`.  
  
 Dodatkowo zarządza źródłami danych <xref:System.Windows.Forms.BindingManagerBase> obiektów. Dla każdej tabeli w źródle danych <xref:System.Windows.Forms.BindingManagerBase> mogą być zwracane z poziomu formularza <xref:System.Windows.Forms.BindingContext>. Na przykład można określić liczbę wierszy zawartych przez źródło danych, zwracając skojarzonego <xref:System.Windows.Forms.BindingManagerBase> obiektu <xref:System.Windows.Forms.BindingManagerBase.Count%2A> właściwości.  
  
 Aby sprawdzić poprawność danych, użyj obiekty podstawowe, które reprezentują danych i ich zdarzeń. Na przykład, jeśli dane pochodzą z <xref:System.Data.DataTable> w <xref:System.Data.DataSet>, użyj <xref:System.Data.DataTable.ColumnChanging> i <xref:System.Data.DataTable.RowChanging> zdarzenia.  
  
> [!NOTE]
>  Ponieważ liczba kolumn można dostosować (przez dodanie lub usunięcie elementów członkowskich <xref:System.Windows.Forms.GridColumnStylesCollection>) i wiersze można sortować według kolumny, <xref:System.Windows.Forms.DataGridCell.RowNumber%2A> i <xref:System.Windows.Forms.DataGridCell.ColumnNumber%2A> wartości właściwości nie można zagwarantować odpowiadają <xref:System.Data.DataRow> i <xref:System.Data.DataColumn>indeksy w <xref:System.Data.DataTable>. W związku z tym należy unikać używania tych właściwości w <xref:System.Windows.Forms.Control.Validating> zdarzenie, aby sprawdzić poprawność danych.  
  
 Aby określić, która komórka jest zaznaczone, użyj <xref:System.Windows.Forms.DataGrid.CurrentCell%2A> właściwości. Zmień wartość dowolną komórkę przy użyciu <xref:System.Windows.Forms.DataGrid.Item%2A> właściwość, która może potrwać indeksy wierszy i kolumn w komórce lub pojedynczej <xref:System.Windows.Forms.DataGridCell>. Monitor <xref:System.Windows.Forms.DataGrid.CurrentCellChanged> zdarzenie, aby wykryć, kiedy użytkownik wybierze inną komórkę.  
  
 Aby określić, która część formantu użytkownik kliknął element, należy użyć <xref:System.Windows.Forms.DataGrid.HitTest%2A> method in Class metoda <xref:System.Windows.Forms.Control.MouseDown> zdarzeń. <xref:System.Windows.Forms.DataGrid.HitTest%2A> Metoda zwraca <xref:System.Windows.Forms.DataGrid.HitTestInfo> obiekt, który zawiera wiersza i kolumny kliknięto obszaru.  
  
 Aby zarządzać wygląd formantu w czasie wykonywania, kilka właściwości do ustawiania atrybutów koloru i podpis są dostępne, w tym <xref:System.Windows.Forms.DataGrid.CaptionForeColor%2A>, <xref:System.Windows.Forms.DataGrid.CaptionBackColor%2A>, <xref:System.Windows.Forms.DataGrid.CaptionFont%2A>i tak dalej.  
  
 Wygląd wyświetlanych siatki (lub siatkach) można dodatkowo zmodyfikować, tworząc <xref:System.Windows.Forms.DataGridTableStyle> obiektów oraz dodać je do <xref:System.Windows.Forms.GridTableStylesCollection>, który jest dostępny za pośrednictwem <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwości. Na przykład jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> ustawiono <xref:System.Data.DataSet> zawierający trzy <xref:System.Data.DataTable> obiektów, można dodać trzy <xref:System.Windows.Forms.DataGridTableStyle> obiekty do kolekcji, po jednym dla każdej tabeli. Aby zsynchronizować każdy <xref:System.Windows.Forms.DataGridTableStyle> obiekt z <xref:System.Data.DataTable>ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> z <xref:System.Windows.Forms.DataGridTableStyle> do <xref:System.Data.DataTable.TableName%2A> z <xref:System.Data.DataTable>. Aby uzyskać więcej informacji na temat tworzenia powiązań z tablicy obiektów, zobacz <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A?displayProperty=nameWithType> właściwości.  
  
 Aby utworzyć dostosowany widok tabeli, Utwórz wystąpienie obiektu <xref:System.Windows.Forms.DataGridTextBoxColumn> lub <xref:System.Windows.Forms.DataGridBoolColumn> klasy i dodać obiekt do <xref:System.Windows.Forms.GridTableStylesCollection> dostępne za pośrednictwem <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwości. Zarówno klasy dziedziczą <xref:System.Windows.Forms.DataGridColumnStyle>. Dla każdego stylu kolumny zestawu <xref:System.Windows.Forms.DataGridColumnStyle.MappingName%2A> do <xref:System.Data.DataColumn.ColumnName%2A> kolumn, które mają być wyświetlane w siatce. Aby ukryć kolumnę, ustaw jego <xref:System.Windows.Forms.DataGridColumnStyle.MappingName%2A> na coś innego niż jest to prawidłowy <xref:System.Data.DataColumn.ColumnName%2A>.  
  
 Aby sformatować tekst kolumny, należy ustawić <xref:System.Windows.Forms.DataGridTextBoxColumn.Format%2A> właściwość <xref:System.Windows.Forms.DataGridTextBoxColumn> do jednej z wartości znajdujących się w [typy formatowania](~/docs/standard/base-types/formatting-types.md) i [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
 Aby powiązać <xref:System.Windows.Forms.DataGrid> silnie typizowaną tablicę obiektów, typ obiektu musi zawierać właściwości publiczne. Aby utworzyć <xref:System.Windows.Forms.DataGridTableStyle> wyświetlającą tablicy, ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A?displayProperty=nameWithType> właściwości `typename[]` gdzie `typename` zostaje zastąpiona przez nazwę typu obiektu. Należy również zauważyć, że <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> właściwości jest rozróżniana wielkość liter; nazwa typu musi dokładnie pasować. Zobacz <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> właściwości, na przykład.  
  
 Możesz również powiązać <xref:System.Windows.Forms.DataGrid> do <xref:System.Collections.ArrayList>. Funkcja <xref:System.Collections.ArrayList> jest, że może ono zawierać wiele typów obiektów, ale <xref:System.Windows.Forms.DataGrid> można powiązać tylko z takiego wykazu, gdy wszystkie elementy na liście są tego samego typu jako pierwszy element. Oznacza to, że wszystkie obiekty muszą być tego samego typu lub musi dziedziczyć tej samej klasy jako pierwszy element na liście. Na przykład, jeśli pierwsza pozycja na liście jest <xref:System.Windows.Forms.Control>, drugi element może być <xref:System.Windows.Forms.TextBox> (który dziedziczy z <xref:System.Windows.Forms.Control>). Jeśli z drugiej strony, pierwszy element jest <xref:System.Windows.Forms.TextBox>, drugi obiekt nie może być <xref:System.Windows.Forms.Control>. Dodatkowo <xref:System.Collections.ArrayList> musi mieć elementy w nim, gdy jest ona powiązana. Pusta <xref:System.Collections.ArrayList> spowoduje pustą siatkę. Ponadto obiekty w <xref:System.Collections.ArrayList> musi zawierać właściwości publiczne. Podczas tworzenia wiązania do <xref:System.Collections.ArrayList>ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> z <xref:System.Windows.Forms.DataGridTableStyle> do "ArrayList" (nazwa typu).  
  
 Dla każdego <xref:System.Windows.Forms.DataGridTableStyle>, można ustawić kolor i podpis atrybuty, które zastępują ustawienia dla <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli. Jeśli nie ustawiono tych właściwości, ustawienia dla formantu są używane domyślnie. Następujące właściwości mogą być zastąpione przez <xref:System.Windows.Forms.DataGridTableStyle> właściwości:  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.AllowSorting%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.AlternatingBackColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.BackColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.ColumnHeadersVisible%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.ForeColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.GridLineColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.GridLineStyle%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.HeaderBackColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.HeaderFont%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.HeaderForeColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.LinkColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.PreferredColumnWidth%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.PreferredRowHeight%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.ReadOnly%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.RowHeadersVisible%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.RowHeaderWidth%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.SelectionBackColor%2A>  
  
-   <xref:System.Windows.Forms.DataGridTableStyle.SelectionForeColor%2A>  
  
 Aby dostosować wygląd poszczególnych kolumn, należy dodać <xref:System.Windows.Forms.DataGridColumnStyle> obiekty do <xref:System.Windows.Forms.GridColumnStylesCollection>, który jest dostępny za pośrednictwem <xref:System.Windows.Forms.DataGridTableStyle.GridColumnStyles%2A> właściwości każdego <xref:System.Windows.Forms.DataGridTableStyle>. Aby zsynchronizować każdy <xref:System.Windows.Forms.DataGridColumnStyle> z <xref:System.Data.DataColumn> w <xref:System.Data.DataTable>ustaw <xref:System.Windows.Forms.DataGridColumnStyle.MappingName%2A> do <xref:System.Data.DataColumn.ColumnName%2A> z <xref:System.Data.DataColumn>. Podczas tworzenia <xref:System.Windows.Forms.DataGridColumnStyle>, można również ustawić ciąg formatowania, który określa sposób wyświetlania danych w kolumnie. Na przykład można określić, czy kolumna użyć formatu daty krótkiej na potrzeby wyświetlania dat zawarte w tabeli.  
  
> [!CAUTION]
>  Zawsze twórz <xref:System.Windows.Forms.DataGridColumnStyle> obiektów i dodaj je do <xref:System.Windows.Forms.GridColumnStylesCollection> przed dodaniem <xref:System.Windows.Forms.DataGridTableStyle> obiekty do <xref:System.Windows.Forms.GridTableStylesCollection>. Po dodaniu pustą <xref:System.Windows.Forms.DataGridTableStyle> przy użyciu prawidłowego <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> wartości do kolekcji, <xref:System.Windows.Forms.DataGridColumnStyle> obiekty są generowane automatycznie. W związku z tym, zostanie zgłoszony wyjątek, Jeśli spróbujesz dodać nowe <xref:System.Windows.Forms.DataGridColumnStyle> obiekty ze zduplikowanymi <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> wartości <xref:System.Windows.Forms.GridColumnStylesCollection>.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.DataGridView> Kontroli zastępuje i dodaje funkcjonalność do <xref:System.Windows.Forms.DataGrid> kontrolować; jednak <xref:System.Windows.Forms.DataGrid> kontrolki została zachowana na potrzeby zgodności z poprzednimi wersjami i użycia w przyszłości, jeśli wybierzesz. Aby uzyskać więcej informacji, zobacz [różnice między Windows Forms formantami DataGridView i DataGrid](~/docs/framework/winforms/controls/differences-between-the-windows-forms-datagridview-and-datagrid-controls.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy formularz Windows <xref:System.Data.DataSet> zawierający dwa <xref:System.Data.DataTable> obiekty i <xref:System.Data.DataRelation> który łączy dwie tabele. Aby wyświetlić dane, <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontrolka następnie jest powiązana z <xref:System.Data.DataSet> za pośrednictwem <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metody. Przycisk na formularzu zmienia wygląd siatki, tworząc dwie <xref:System.Windows.Forms.DataGridTableStyle> obiekty i ustawienia <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> każdego obiektu do <xref:System.Data.DataTable.TableName%2A> jednego z <xref:System.Data.DataTable> obiektów. Przykład zawiera również kod w <xref:System.Windows.Forms.Control.MouseUp> zdarzeń, który używa <xref:System.Windows.Forms.DataGrid.HitTest%2A> metodę, aby wydrukować kolumny, wierszy i części siatki, który został kliknięty.  
  
 [!code-cpp[Classic DataGrid Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Data.DataSet" />
    <altmember cref="T:System.Data.DataView" />
    <altmember cref="T:System.Data.DataTable" />
    <altmember cref="T:System.Data.DataRow" />
    <related type="Article" href="~/docs/framework/data/adonet/index.md">ADO.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DataGrid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DataGrid();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.DataGrid" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby wypełnić w nowo utworzonej <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> , ustaw <xref:System.Windows.Forms.DataGrid.DataSource%2A> właściwość prawidłowego źródła, takich jak <xref:System.Data.DataView>, <xref:System.Data.DataSet>, lub <xref:System.Data.DataViewManager>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> i używa <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metodę, aby ustawić <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.DataGrid Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.DataGrid Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumnCollection" />
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="P:System.Windows.Forms.DataGrid.DataMember" />
        <altmember cref="T:System.Data.DataView" />
        <altmember cref="T:System.Data.DataTable" />
        <altmember cref="T:System.Windows.Forms.GridTableStylesCollection" />
      </Docs>
    </Member>
    <Member MemberName="AllowNavigation">
      <MemberSignature Language="C#" Value="public bool AllowNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.AllowNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowNavigation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowNavigation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowNavigation : bool with get, set" Usage="System.Windows.Forms.DataGrid.AllowNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy jest dozwolone nawigacji.</summary>
        <value><see langword="true" /> Jeśli nawigacji jest dozwolony; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli ta właściwość jest ustawiona `false`, łącza do tabele podrzędne nie są wyświetlane.  
  
   
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.AllowNavigation%2A> właściwości między `true` i `false`.  
  
 [!code-cpp[DataGrid_AllowNavigationChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CPP/mydatagrid_allownavigationchanged.cpp#1)]
 [!code-csharp[DataGrid_AllowNavigationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CS/mydatagrid_allownavigationchanged.cs#1)]
 [!code-vb[DataGrid_AllowNavigationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/VB/mydatagrid_allownavigationchanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNavigationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AllowNavigationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AllowNavigationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.AllowNavigationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AllowNavigationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AllowNavigationChanged;" />
      <MemberSignature Language="F#" Value="member this.AllowNavigationChanged : EventHandler " Usage="member this.AllowNavigationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.AllowNavigation" /> właściwości została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.DataGrid.AllowNavigation%2A> właściwość jest ustawiona na `false`, a następnie są pokazywane żadne linki do podrzędnych tabel.  
  
   
  
## Examples  
 Poniższy kod przykładowy resetuje <xref:System.Windows.Forms.DataGrid.AllowNavigation%2A> właściwości i zgłasza <xref:System.Windows.Forms.DataGrid.AllowNavigationChanged> zdarzeń.  
  
 [!code-cpp[DataGrid_AllowNavigationChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CPP/mydatagrid_allownavigationchanged.cpp#1)]
 [!code-csharp[DataGrid_AllowNavigationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CS/mydatagrid_allownavigationchanged.cs#1)]
 [!code-vb[DataGrid_AllowNavigationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/VB/mydatagrid_allownavigationchanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowSorting">
      <MemberSignature Language="C#" Value="public bool AllowSorting { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.AllowSorting" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowSorting { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowSorting : bool with get, set" Usage="System.Windows.Forms.DataGrid.AllowSorting" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy siatka mogą mieć zastosowanie przez kliknięcie nagłówka kolumny.</summary>
        <value><see langword="true" /> Jeśli można sortować kolumny; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta wartość zostanie zastąpiona przez <xref:System.Windows.Forms.DataGridTableStyle.AllowSorting%2A?displayProperty=nameWithType> właściwość, jeśli istnieje <xref:System.Windows.Forms.DataGridTableStyle> aktualnie obowiązujących dla formantu.  
  
 Jeśli sortowanie jest dozwolone, klikając nagłówek kolumny zostanie sortować dane w tabeli według tej kolumny.  
  
 Można również sortować przy użyciu wyrażenia dla <xref:System.Data.DataColumn>. Zobacz <xref:System.Data.DataColumn.Expression%2A> szczegółowe informacje o tworzeniu wyrażenie sortowania.  
  
 Jeśli <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> jest powiązany z <xref:System.Data.DataView>, można ustawić sortowanie niestandardowe dla tabeli przy użyciu <xref:System.Data.DataView> klasy <xref:System.Data.DataView.Sort%2A> właściwości. Podobnie jeśli <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> jest powiązany z <xref:System.Data.DataViewManager>, każda tabela w <xref:System.Data.DataViewManager> może mieć niestandardowej sortowania, ustawiając <xref:System.Data.DataViewManager.DataViewSettings%2A> klasy <xref:System.Data.DataViewSetting.Sort%2A> właściwości.  
  
   
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.AllowSorting%2A> właściwości.  
  
 [!code-cpp[Classic DataGrid.AllowSorting Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.AllowSorting Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.AllowSorting Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.AllowSorting Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.AllowSorting Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.AllowSorting Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataColumn.Expression" />
        <altmember cref="P:System.Data.DataView.Sort" />
        <altmember cref="P:System.Data.DataViewSetting.Sort" />
        <altmember cref="T:System.Windows.Forms.DataGridTableStyle" />
        <altmember cref="P:System.Windows.Forms.DataGridTableStyle.AllowSorting" />
      </Docs>
    </Member>
    <Member MemberName="AlternatingBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color AlternatingBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color AlternatingBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.AlternatingBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property AlternatingBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color AlternatingBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.AlternatingBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.AlternatingBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła wierszy nieparzystych siatki.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący przemienne kolor tła. Wartość domyślna to kolor systemu windows (<see cref="P:System.Drawing.SystemColors.Window" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnie zarówno <xref:System.Windows.Forms.DataGrid.BackColor%2A> i <xref:System.Windows.Forms.DataGrid.AlternatingBackColor%2A> właściwości są ustawione na ten sam kolor. Ustawienie <xref:System.Windows.Forms.DataGrid.BackColor%2A> właściwość dotyczy tylko wierszy parzystych podczas ustawienie <xref:System.Windows.Forms.DataGrid.AlternatingBackColor%2A> dotyczy tylko nieparzystą wierszy.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.AlternatingBackColor%2A> do <xref:System.Drawing.Color> wartości.  
  
 [!code-vb[Classic DataGrid.AlternatingBackColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.AlternatingBackColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackButtonClick">
      <MemberSignature Language="C#" Value="public event EventHandler BackButtonClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackButtonClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.BackButtonClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackButtonClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackButtonClick;" />
      <MemberSignature Language="F#" Value="member this.BackButtonClick : EventHandler " Usage="member this.BackButtonClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see langword="Back" /> kliknięto przycisk w tabeli podrzędnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Back` Przycisk staje się widoczny, gdy jest wyświetlana tabeli podrzędnej. Kliknięcie przycisku spowoduje, że siatki wyświetlić tabelę nadrzędną.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje program obsługi zdarzeń dla <xref:System.Windows.Forms.DataGrid.BackButtonClick> zdarzeń.  
  
 [!code-cpp[DataGrid_BackgroundColorChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/CPP/mydatagrid_backgroundcolorchanged.cpp#1)]
 [!code-csharp[DataGrid_BackgroundColorChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/CS/mydatagrid_backgroundcolorchanged.cs#1)]
 [!code-vb[DataGrid_BackgroundColorChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/VB/mydatagrid_backgroundcolorchanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.AllowNavigation" />
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła wierszy parzystych siatki.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor wierszy w siatce. Wartość domyślna to kolor systemu windows (<see cref="P:System.Drawing.SystemColors.Window" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Natomiast <xref:System.Windows.Forms.DataGrid.BackColor%2A> właściwość określa kolor wierszy w siatce, <xref:System.Windows.Forms.DataGrid.BackgroundColor%2A> Określa kolor obszar nonrow, który jest widoczna tylko siatki jest przewijane do dolnej lub tylko kilka wierszy są zawarte w siatce.  
  
 Domyślnie zarówno <xref:System.Windows.Forms.DataGrid.BackColor%2A> i <xref:System.Windows.Forms.DataGrid.AlternatingBackColor%2A> właściwości są ustawione na ten sam kolor. Ustawienie <xref:System.Windows.Forms.DataGrid.BackColor%2A> właściwość dotyczy tylko wierszy parzystych podczas ustawienie <xref:System.Windows.Forms.DataGrid.AlternatingBackColor%2A> dotyczy tylko nieparzystą wierszy.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia zarówno <xref:System.Windows.Forms.DataGrid.BackColor%2A> i <xref:System.Windows.Forms.DataGrid.BackgroundColor%2A> właściwości różne wartości.  
  
 [!code-cpp[Classic DataGrid.BackColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.BackColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.BackColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.BackColor Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.BackColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.BackColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.BackgroundColor" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackgroundColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackgroundColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.BackgroundColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor obszaru bez wiersza siatki.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor tła siatki. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.AppWorkspace" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.BackgroundColor%2A> Określa kolor obszaru nonrow siatki, w którym jest widoczny tylko wtedy, gdy tabela nie jest wyświetlany przez <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub jeśli siatki jest przewijane do dolnej lub jeśli tylko kilka wierszy są zawarte w siatce.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.BackColor%2A>, i <xref:System.Windows.Forms.DataGrid.BackgroundColor%2A> właściwości.  
  
 [!code-cpp[Classic DataGrid.BackgroundColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.BackgroundColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.BackgroundColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.BackgroundColor Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.BackgroundColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.BackgroundColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.BackgroundColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundColorChanged : EventHandler " Usage="member this.BackgroundColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.BackgroundColor" /> został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy zmiany <xref:System.Windows.Forms.DataGrid.BackgroundColor%2A> wartość właściwości z żółty czerwony i zgłasza <xref:System.Windows.Forms.DataGrid.BackgroundColorChanged> zdarzeń.  
  
 [!code-cpp[DataGrid_BackgroundColorChanged#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/CPP/mydatagrid_backgroundcolorchanged.cpp#2)]
 [!code-csharp[DataGrid_BackgroundColorChanged#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/CS/mydatagrid_backgroundcolorchanged.cs#2)]
 [!code-vb[DataGrid_BackgroundColorChanged#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_BackgroundColorChanged/VB/mydatagrid_backgroundcolorchanged.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.DataGrid.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski nie jest zrozumiały dla tego formantu.</summary>
        <value>Obraz tła skojarzonego z kontrolką.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Forms.DataGrid.BackgroundImage" /> zmiany właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.BackgroundImage%2A> Właściwość nie jest zrozumiały dla tej kontrolki, mimo że można zmienić jego wartość, a także obsługiwać <xref:System.Windows.Forms.DataGrid.BackgroundImageChanged> zdarzenie, aby wykryć zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.DataGrid.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski nie jest zrozumiały dla tego formantu.</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> Wartość.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Forms.DataGrid.BackgroundImageLayout" /> zmiany właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.BackgroundImageLayout%2A> Właściwość nie jest zrozumiały dla tej kontrolki, mimo że można zmienić jego wartość, a także obsługiwać <xref:System.Windows.Forms.DataGrid.BackgroundImageLayoutChanged> zdarzenie, aby wykryć zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginEdit">
      <MemberSignature Language="C#" Value="public bool BeginEdit (System.Windows.Forms.DataGridColumnStyle gridColumn, int rowNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool BeginEdit(class System.Windows.Forms.DataGridColumnStyle gridColumn, int32 rowNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.BeginEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginEdit (gridColumn As DataGridColumnStyle, rowNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool BeginEdit(System::Windows::Forms::DataGridColumnStyle ^ gridColumn, int rowNumber);" />
      <MemberSignature Language="F#" Value="abstract member BeginEdit : System.Windows.Forms.DataGridColumnStyle * int -&gt; bool&#xA;override this.BeginEdit : System.Windows.Forms.DataGridColumnStyle * int -&gt; bool" Usage="dataGrid.BeginEdit (gridColumn, rowNumber)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDataGridEditingService.BeginEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gridColumn" Type="System.Windows.Forms.DataGridColumnStyle" />
        <Parameter Name="rowNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="gridColumn">A <see cref="T:System.Windows.Forms.DataGridColumnStyle" /> do edycji.</param>
        <param name="rowNumber">Liczba wierszy do edycji.</param>
        <summary>Próbuje umieścić siatki w stanie, w którym edytowanie w Internecie jest niedozwolone.</summary>
        <returns><see langword="true" /> Jeśli metoda się powiedzie; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Siatki będą odrzucać żądania edycji, jeśli użytkownik już rozpoczęte, wpisując w komórce. W takim przypadku <xref:System.Windows.Forms.DataGrid.BeginEdit%2A> metoda zwróci `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.BeginEdit%2A> metodę, aby sprawdzić, czy do edycji jest możliwe, przed zmianą określonej kolumny i wiersza.  
  
 [!code-cpp[Classic DataGrid.BeginEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.BeginEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.BeginEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.BeginEdit Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.BeginEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.BeginEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.EndEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="dataGrid.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Rozpoczyna się inicjowanie <see cref="T:System.Windows.Forms.DataGrid" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisku projektowym programu Visual Studio używa tej metody, aby rozpocząć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Windows.Forms.DataGrid.EndInit%2A> Metoda kończy się inicjowanie. Za pomocą <xref:System.Windows.Forms.DataGrid.BeginInit%2A> i <xref:System.Windows.Forms.DataGrid.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.BorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property BorderStyle As BorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::BorderStyle BorderStyle { System::Windows::Forms::BorderStyle get(); void set(System::Windows::Forms::BorderStyle value); };" />
      <MemberSignature Language="F#" Value="member this.BorderStyle : System.Windows.Forms.BorderStyle with get, set" Usage="System.Windows.Forms.DataGrid.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl obramowania siatki.</summary>
        <value>Jedną z <see cref="T:System.Windows.Forms.BorderStyle" /> wartości wyliczenia. Wartość domyślna to <see langword="FixedSingle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia styl obramowania siatki.  
  
 [!code-vb[Classic DataGrid.BorderStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.BorderStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BorderStyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BorderStyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.BorderStyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BorderStyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BorderStyleChanged;" />
      <MemberSignature Language="F#" Value="member this.BorderStyleChanged : EventHandler " Usage="member this.BorderStyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.BorderStyle" /> został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możliwe wartości to `None`, `FixedSingle`, i `Fixed3D`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.DataGrid.BorderStyleChanged> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.DataGrid> o nazwie `DataGrid1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.DataGrid.BorderStyleChanged> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#194](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#194)]
 [!code-vb[System.Windows.Forms.EventExamples#194](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#194)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelEditing">
      <MemberSignature Language="C#" Value="protected virtual void CancelEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CancelEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.CancelEditing" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CancelEditing ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CancelEditing();" />
      <MemberSignature Language="F#" Value="abstract member CancelEditing : unit -&gt; unit&#xA;override this.CancelEditing : unit -&gt; unit" Usage="dataGrid.CancelEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje bieżącą operację edycji i wycofanie wszystkich zmian.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color CaptionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color CaptionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CaptionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property CaptionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color CaptionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.CaptionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.CaptionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła obszaru podpis.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący podpis kolor tła. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.ActiveCaption" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.CaptionBackColor%2A> właściwość <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-vb[Classic DataGrid.CaptionBackColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CaptionBackColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionForeColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionFont" />
      </Docs>
    </Member>
    <Member MemberName="CaptionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font CaptionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font CaptionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CaptionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property CaptionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ CaptionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaptionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.DataGrid.CaptionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę podpis siatki.</summary>
        <value>A <see cref="T:System.Drawing.Font" /> reprezentujący czcionki podpis.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Drawing.Font> hermetyzuje czcionkę Windows i dostarcza metody do manipulowania czcionki.  
  
   
  
## Examples  
 Poniższy przykład kodu Ustawia czcionkę podpis przy użyciu <xref:System.Drawing.Font> obiektu.  
  
 [!code-vb[Classic DataGrid.CaptionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CaptionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionBackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionForeColor" />
      </Docs>
    </Member>
    <Member MemberName="CaptionForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color CaptionForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color CaptionForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CaptionForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property CaptionForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color CaptionForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.CaptionForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.CaptionForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu w obszarze podpis.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor pierwszego planu w obszarze podpis. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.ActiveCaptionText" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.CaptionForeColor%2A> właściwość <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-vb[Classic DataGrid.CaptionForeColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CaptionForeColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionBackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionFont" />
      </Docs>
    </Member>
    <Member MemberName="CaptionText">
      <MemberSignature Language="C#" Value="public string CaptionText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CaptionText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CaptionText" />
      <MemberSignature Language="VB.NET" Value="Public Property CaptionText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CaptionText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CaptionText : string with get, set" Usage="System.Windows.Forms.DataGrid.CaptionText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst tytuł okna siatki.</summary>
        <value>Ciąg, który będzie wyświetlany jako tytuł okna siatki. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Ustawia podpis <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic DataGrid.CaptionText Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.CaptionText Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.CaptionText Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.CaptionText Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.CaptionText Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CaptionText Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionVisible" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionForeColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionFont" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionBackColor" />
      </Docs>
    </Member>
    <Member MemberName="CaptionVisible">
      <MemberSignature Language="C#" Value="public bool CaptionVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CaptionVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CaptionVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property CaptionVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CaptionVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CaptionVisible : bool with get, set" Usage="System.Windows.Forms.DataGrid.CaptionVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy podpis siatki jest widoczny.</summary>
        <value><see langword="true" /> Jeśli podpis jest widoczny; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.DataGrid.CaptionVisible%2A> jest `false`, **ponownie** przycisku **ParentRow** przycisk, a podpis nie będą widoczne. Ponieważ nawigacji jest ograniczona, łącza do tabele podrzędne również nie będzie widoczny i <xref:System.Windows.Forms.DataGrid.AllowNavigation%2A> zostanie ustawiony na `None`.  
  
   
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.CaptionVisible%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.CaptionVisible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CaptionVisible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptionVisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CaptionVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CaptionVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.CaptionVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CaptionVisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CaptionVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.CaptionVisibleChanged : EventHandler " Usage="member this.CaptionVisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.CaptionVisible" /> właściwości została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego zdarzenia.  
  
 [!code-cpp[DataGrid_CaptionVisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CPP/mydatagrid_captionvisiblechanged.cpp#1)]
 [!code-csharp[DataGrid_CaptionVisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CS/mydatagrid_captionvisiblechanged.cs#1)]
 [!code-vb[DataGrid_CaptionVisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/VB/mydatagrid_captionvisiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collapse">
      <MemberSignature Language="C#" Value="public void Collapse (int row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Collapse(int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.Collapse(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Collapse (row As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Collapse(int row);" />
      <MemberSignature Language="F#" Value="member this.Collapse : int -&gt; unit" Usage="dataGrid.Collapse row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Liczba wierszy, aby zwinąć. Jeśli ustawiona na wartość -1, wszystkie wiersze, są zwinięte.</param>
        <summary>Zwija relacji podrzędnej, jeśli takie istnieją we wszystkich wierszach lub dla określonego wiersza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.DataGrid.IsExpanded%2A> metodę, aby określić, jeśli wiersz jest rozwinięty.  
  
   
  
## Examples  
 Poniższy przykład kodu Zwija wszystkie wiersze w <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-vb[Classic DataGrid.Collapse Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.Collapse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.IsExpanded(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ColumnHeadersVisible">
      <MemberSignature Language="C#" Value="public bool ColumnHeadersVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ColumnHeadersVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ColumnHeadersVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property ColumnHeadersVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ColumnHeadersVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ColumnHeadersVisible : bool with get, set" Usage="System.Windows.Forms.DataGrid.ColumnHeadersVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy nagłówki kolumn w tabeli są widoczne.</summary>
        <value><see langword="true" /> nagłówki kolumn są widoczne; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.ColumnHeadersVisible%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.ColumnHeadersVisible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ColumnHeadersVisible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridColumnStyle" />
        <altmember cref="T:System.Windows.Forms.GridColumnStylesCollection" />
        <altmember cref="P:System.Windows.Forms.DataGrid.RowHeadersVisible" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleColumnCount" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleRowCount" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ColumnStartedEditing">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Informuje <see cref="T:System.Windows.Forms.DataGrid" /> formantu, że użytkownik rozpoczął edycję kolumny.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ColumnStartedEditing">
      <MemberSignature Language="C#" Value="protected internal virtual void ColumnStartedEditing (System.Drawing.Rectangle bounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ColumnStartedEditing(valuetype System.Drawing.Rectangle bounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ColumnStartedEditing(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ColumnStartedEditing (bounds As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ColumnStartedEditing(System::Drawing::Rectangle bounds);" />
      <MemberSignature Language="F#" Value="abstract member ColumnStartedEditing : System.Drawing.Rectangle -&gt; unit&#xA;override this.ColumnStartedEditing : System.Drawing.Rectangle -&gt; unit" Usage="dataGrid.ColumnStartedEditing bounds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bounds"><see cref="T:System.Drawing.Rectangle" /> Definiujący lokalizacji edytowanych kolumny.</param>
        <summary>Informuje <see cref="T:System.Windows.Forms.DataGrid" /> kontroli, gdy użytkownik rozpoczyna edycję kolumny w podanej lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Windows.Forms.IDataGridColumnStyleEditingNotificationService.ColumnStartedEditing%2A> metoda umożliwia <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontrolki ołówka w nagłówku wiersza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ColumnStartedEditing">
      <MemberSignature Language="C#" Value="protected internal virtual void ColumnStartedEditing (System.Windows.Forms.Control editingControl);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ColumnStartedEditing(class System.Windows.Forms.Control editingControl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ColumnStartedEditing(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ColumnStartedEditing (editingControl As Control)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ColumnStartedEditing(System::Windows::Forms::Control ^ editingControl);" />
      <MemberSignature Language="F#" Value="abstract member ColumnStartedEditing : System.Windows.Forms.Control -&gt; unit&#xA;override this.ColumnStartedEditing : System.Windows.Forms.Control -&gt; unit" Usage="dataGrid.ColumnStartedEditing editingControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="editingControl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="editingControl"><see cref="T:System.Windows.Forms.Control" /> Używane do edycji w kolumnie.</param>
        <summary>Informuje <see cref="T:System.Windows.Forms.DataGrid" /> kontroli, gdy użytkownik rozpoczyna edycję kolumny przy użyciu określonego formantu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Windows.Forms.IDataGridColumnStyleEditingNotificationService.ColumnStartedEditing%2A> metoda umożliwia <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontrolki ołówka w nagłówku wiersza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="dataGrid.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nowe wystąpienie obiektu ułatwień dostępu dla tego formantu.</summary>
        <returns><see cref="T:System.Windows.Forms.Control.ControlAccessibleObject" /> Dla tego formantu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasy pochodne nie powinien wywoływać klasę bazową <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> metody.  
  
 Tylko następujące właściwości <xref:System.Windows.Forms.AccessibleObject> powinna być ustawiona:  
  
-   <xref:System.Windows.Forms.AccessibleObject.Role%2A>  
  
-   <xref:System.Windows.Forms.AccessibleObject.Description%2A>  
  
-   <xref:System.Windows.Forms.AccessibleObject.Name%2A>  
  
 Wszystkie pozostałe właściwości są obsługiwane przez <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> sam.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGridColumn">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Windows.Forms.DataGridColumnStyle" /> który został dodany do formantu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGridColumn">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.DataGridColumnStyle CreateGridColumn (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.DataGridColumnStyle CreateGridColumn(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.CreateGridColumn(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateGridColumn (prop As PropertyDescriptor) As DataGridColumnStyle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::DataGridColumnStyle ^ CreateGridColumn(System::ComponentModel::PropertyDescriptor ^ prop);" />
      <MemberSignature Language="F#" Value="abstract member CreateGridColumn : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Forms.DataGridColumnStyle&#xA;override this.CreateGridColumn : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Forms.DataGridColumnStyle" Usage="dataGrid.CreateGridColumn prop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridColumnStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop"><see cref="T:System.ComponentModel.PropertyDescriptor" /> Służące do tworzenia styl kolumny siatki.</param>
        <summary>Tworzy nową <see cref="T:System.Windows.Forms.DataGridColumnStyle" /> z określonym <see cref="T:System.ComponentModel.PropertyDescriptor" />.</summary>
        <returns>Nowy <see cref="T:System.Windows.Forms.DataGridColumnStyle" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateGridColumn">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.DataGridColumnStyle CreateGridColumn (System.ComponentModel.PropertyDescriptor prop, bool isDefault);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.DataGridColumnStyle CreateGridColumn(class System.ComponentModel.PropertyDescriptor prop, bool isDefault) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.CreateGridColumn(System.ComponentModel.PropertyDescriptor,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateGridColumn (prop As PropertyDescriptor, isDefault As Boolean) As DataGridColumnStyle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::DataGridColumnStyle ^ CreateGridColumn(System::ComponentModel::PropertyDescriptor ^ prop, bool isDefault);" />
      <MemberSignature Language="F#" Value="abstract member CreateGridColumn : System.ComponentModel.PropertyDescriptor * bool -&gt; System.Windows.Forms.DataGridColumnStyle&#xA;override this.CreateGridColumn : System.ComponentModel.PropertyDescriptor * bool -&gt; System.Windows.Forms.DataGridColumnStyle" Usage="dataGrid.CreateGridColumn (prop, isDefault)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridColumnStyle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="isDefault" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="prop"><see cref="T:System.ComponentModel.PropertyDescriptor" /> Służące do tworzenia styl kolumny siatki.</param>
        <param name="isDefault"><see langword="true" /> Aby ustawić styl kolumny jako domyślny; w przeciwnym razie <see langword="false" />.</param>
        <summary>Tworzy <see cref="T:System.Windows.Forms.DataGridColumnStyle" /> przy użyciu określonego <see cref="T:System.ComponentModel.PropertyDescriptor" />.</summary>
        <returns>Nowy <see cref="T:System.Windows.Forms.DataGridColumnStyle" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.DataGridColumnStyle" />
        <altmember cref="T:System.Windows.Forms.GridColumnStylesCollection" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCell">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridCell CurrentCell { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DataGridCell CurrentCell" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CurrentCell" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCell As DataGridCell" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridCell CurrentCell { System::Windows::Forms::DataGridCell get(); void set(System::Windows::Forms::DataGridCell value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCell : System.Windows.Forms.DataGridCell with get, set" Usage="System.Windows.Forms.DataGrid.CurrentCell" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridCell</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia komórki, która ma fokus. Nie są dostępne w czasie projektowania.</summary>
        <value><see cref="T:System.Windows.Forms.DataGridCell" /> z fokusem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Windows.Forms.DataGrid.CurrentCell%2A> właściwość spowoduje, że siatkę, aby przewijać i Pokaż komórki, jeśli nie jest już widoczna.  
  
   
  
## Examples  
 W poniższym przykładzie kodu pokazano, jak ustawiać i pobierać bieżącej komórki.  
  
 [!code-cpp[Classic DataGrid.CurrentCell Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.CurrentCell Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.CurrentCell Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.CurrentCell Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.CurrentCell Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CurrentCell Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.DataGridCell" />
        <altmember cref="P:System.Windows.Forms.DataGrid.FirstVisibleColumn" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCellChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentCellChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentCellChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.CurrentCellChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentCellChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentCellChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentCellChanged : EventHandler " Usage="member this.CurrentCellChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.CurrentCell" /> właściwości została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby określić bieżącej komórki, użyj <xref:System.Windows.Forms.DataGrid.CurrentCell%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_CaptionVisibleChanged#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CPP/mydatagrid_captionvisiblechanged.cpp#2)]
 [!code-csharp[DataGrid_CaptionVisibleChanged#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CS/mydatagrid_captionvisiblechanged.cs#2)]
 [!code-vb[DataGrid_CaptionVisibleChanged#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/VB/mydatagrid_captionvisiblechanged.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentRowIndex">
      <MemberSignature Language="C#" Value="public int CurrentRowIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentRowIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.CurrentRowIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentRowIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentRowIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentRowIndex : int with get, set" Usage="System.Windows.Forms.DataGrid.CurrentRowIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks wiersza, który aktualnie ma fokus.</summary>
        <value>Liczony od zera indeks bieżącego wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Windows.Forms.DataGrid.CurrentRowIndex%2A> właściwości na wartość inną niż jej bieżącą wartość Przewija kontrolkę tak, aby określony wiersz w widoku.  
  
 <xref:System.Windows.Forms.DataGrid.CurrentRowIndex%2A> Właściwość umożliwia iteracyjne przeglądanie wiersze tabeli nadrzędnej, nawet jeśli wyświetlasz wiersze tabeli podrzędnej. Na przykład, jeśli wyświetlasz tabeli podrzędnej zwiększanie <xref:System.Windows.Forms.DataGrid.CurrentRowIndex%2A> spowoduje, że <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> Aby wyświetlić następny zestaw rekordów w tabeli podrzędnej, które są połączone z tabeli nadrzędnej.  
  
 Jeśli użytkownik jest wyświetlanie tabeli nadrzędnej lub tabeli, przy użyciu nie relacji podrzędnej, właściwość ta zwraca liczony od zera indeks bieżącego wiersza.  
  
   
  
## Examples  
 Poniższy kod zwraca przykład <xref:System.Windows.Forms.DataGrid.CurrentRowIndex%2A>.  
  
 [!code-cpp[Classic DataGrid.CurrentRowIndex Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.CurrentRowIndex Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.CurrentRowIndex Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.CurrentRowIndex Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.CurrentRowIndex Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.CurrentRowIndex Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Istnieje nie <see cref="T:System.Windows.Forms.CurrencyManager" />.</exception>
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.DataGrid.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski nie jest zrozumiały dla tego formantu.</summary>
        <value>Typ kursora do wyświetlenia jako wskaźnik myszy przesuwa się nad obiekt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Forms.DataGrid.Cursor" /> zmiany właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.Cursor%2A> Właściwość nie jest zrozumiały dla tej kontrolki, mimo że można zmienić jego wartość, a także obsługiwać <xref:System.Windows.Forms.DataGrid.CursorChanged> zdarzenie, aby wykryć zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataMember : string with get, set" Usage="System.Windows.Forms.DataGrid.DataMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia konkretnej listy w <see cref="P:System.Windows.Forms.DataGrid.DataSource" /> dla którego <see cref="T:System.Windows.Forms.DataGrid" /> kontrolka Wyświetla siatkę.</summary>
        <value>Na liście <see cref="P:System.Windows.Forms.DataGrid.DataSource" />. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> zawiera wiele źródeł danych, należy ustawić <xref:System.Windows.Forms.DataGrid.DataMember%2A> do jednego ze źródeł. Na przykład jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> jest <xref:System.Data.DataSet> lub <xref:System.Data.DataViewManager> zawierający trzy tabele o nazwie `Customers`, `Orders`, i `OrderDetails`, należy określić jedną z tabel, które można powiązać. Jeśli <xref:System.Data.DataSet> lub <xref:System.Data.DataViewManager> zawiera tylko jeden <xref:System.Data.DataTable>, należy ustawić <xref:System.Windows.Forms.DataGrid.DataMember%2A> do <xref:System.Data.DataTable.TableName%2A> tego <xref:System.Data.DataTable>.  
  
 Jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> ustawiono <xref:System.Data.DataSet> zawierający <xref:System.Data.DataRelation> obiektów, tabele będą wyświetlane ze znakiem plus (+) w nagłówku każdego wiersza. Kliknij znak plus powoduje, że węzeł informacją, który zawiera łącza do tabele podrzędne. Na przykład jeśli <xref:System.Data.DataSet> zawiera dwa <xref:System.Data.DataTable> obiektów o nazwie `Customers` i `Orders`, ustawiając <xref:System.Windows.Forms.DataGrid.DataMember%2A> do `Customers` tabeli powoduje, że <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> do wyświetlenia tabeli nadrzędnej ze znakiem plus widocznych w każdym wierszu Nagłówek. Jeśli <xref:System.Windows.Forms.DataGrid.DataMember%2A> ustawiono `Orders`, jednak nagłówki wierszy jest puste.  
  
 Jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> jest <xref:System.Data.DataTable>, <xref:System.Data.DataView>, kolekcji lub tablicy, ustawienie <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwość zgłasza wyjątek.  
  
> [!NOTE]
>  W czasie wykonywania, należy użyć <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metodę, aby zresetować <xref:System.Windows.Forms.DataGrid.DataSource%2A> właściwości. Jednak <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwość samodzielnie, można zresetować w dowolnym momencie Nieprawidłowa nazwa tabeli.  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-cpp[Classic DataGrid.DataMember Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.DataMember Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.DataMember Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.DataMember Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.DataMember Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.DataMember Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.DataSource" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataViewManager" />
        <altmember cref="M:System.Windows.Forms.DataGrid.SetDataBinding(System.Object,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : obj with get, set" Usage="System.Windows.Forms.DataGrid.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Forms.Design.DataSourceConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia źródło danych, które siatki są wyświetlane dane.</summary>
        <value>Obiekt, który działa jako źródło danych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W czasie wykonywania, użyj <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metodę, aby ustawić <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości.  
  
 Następujące źródła danych są prawidłowe:  
  
-   A <xref:System.Data.DataTable>  
  
-   A <xref:System.Data.DataView>  
  
-   A <xref:System.Data.DataSet>  
  
-   A <xref:System.Data.DataViewManager>  
  
-   Dowolny składnik, który implementuje <xref:System.ComponentModel.IListSource> interfejsu  
  
-   Dowolny składnik, który implementuje <xref:System.Collections.IList> interfejsu  
  
 Zobacz <xref:System.Windows.Forms.Binding> klasa — Przegląd, aby uzyskać więcej informacji na temat źródeł danych.  
  
 Jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> odwołania zawiera więcej niż jednej tabeli, należy ustawić <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości typu ciąg, który określa tabelę, aby powiązać. Na przykład jeśli <xref:System.Windows.Forms.DataGrid.DataSource%2A> jest <xref:System.Data.DataSet> lub <xref:System.Data.DataViewManager> zawierający trzy tabele o nazwie `Customers`, `Orders`, i `OrderDetails`, należy określić tabelę można powiązać.  
  
 Ustawienie <xref:System.Windows.Forms.DataGrid.DataSource%2A> do obiektu, który nie implementuje <xref:System.Collections.IList> interfejsu lub <xref:System.ComponentModel.IListSource> spowoduje, że siatkę, aby zgłosić wyjątek.  
  
 Można utworzyć siatki, która umożliwia użytkownikom edytowanie danych, ale uniemożliwia dodanie nowych wierszy przy użyciu <xref:System.Data.DataView> jako źródła danych i ustawienie <xref:System.Data.DataView.AddNew%2A> właściwość `false`.  
  
 Aby powiązać <xref:System.Windows.Forms.DataGrid> silnie typizowaną tablicę obiektów, typ obiektu musi zawierać właściwości publiczne. Aby utworzyć <xref:System.Windows.Forms.DataGridTableStyle> wyświetlającą tablicy, ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A?displayProperty=nameWithType> właściwości `typename` gdzie `typename` zostaje zastąpiona przez nazwę typu obiektu. Należy również zauważyć, że <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> właściwości jest rozróżniana wielkość liter; nazwa typu musi dokładnie pasować. Zobacz <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> właściwości, na przykład.  
  
 Możesz również powiązać <xref:System.Windows.Forms.DataGrid> do <xref:System.Collections.ArrayList>. Funkcja <xref:System.Collections.ArrayList> jest, że może ono zawierać wiele typów obiektów, ale <xref:System.Windows.Forms.DataGrid> można powiązać tylko z takiego wykazu, gdy wszystkie elementy na liście są tego samego typu jako pierwszy element. Oznacza to, że wszystkie obiekty muszą być tego samego typu lub musi dziedziczyć tej samej klasy jako pierwszy element na liście. Na przykład, jeśli pierwsza pozycja na liście jest <xref:System.Windows.Forms.Control>, drugi element może być <xref:System.Windows.Forms.TextBox> (który dziedziczy z <xref:System.Windows.Forms.Control>). Jeśli z drugiej strony, pierwszy element jest <xref:System.Windows.Forms.TextBox>, drugi obiekt nie może być <xref:System.Windows.Forms.Control>. Dodatkowo <xref:System.Collections.ArrayList> musi mieć elementy w nim, gdy jest ona powiązana. Pusta <xref:System.Collections.ArrayList> spowoduje pustą siatkę. Ponadto obiekty w <xref:System.Collections.ArrayList> musi zawierać właściwości publiczne. Podczas tworzenia wiązania do <xref:System.Collections.ArrayList>ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> z <xref:System.Windows.Forms.DataGridTableStyle> do "ArrayList" (nazwa typu).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak ustawić <xref:System.Windows.Forms.DataGrid.DataSource%2A>i w razie potrzeby, <xref:System.Windows.Forms.DataGrid.DataMember%2A>, aby powiązać <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> zarówno <xref:System.Data.DataView> i <xref:System.Data.DataSet>. W przykładzie pokazano również sposób zwracania źródła danych z <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 [!code-cpp[Classic DataGrid.DataSource Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.DataSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.DataSource Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.DataSource Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.DataSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.DataSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.DataMember" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataViewManager" />
        <altmember cref="T:System.Data.DataView" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberSignature Language="F#" Value="member this.DataSourceChanged : EventHandler " Usage="member this.DataSourceChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.DataSource" /> wartość właściwości została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.DataSourceChanged> Wystąpi zdarzenie po <xref:System.Windows.Forms.DataGrid.DataMember%2A> wartość zmiany, lub gdy <xref:System.Windows.Forms.BindingContext> z <xref:System.Windows.Forms.DataGrid> zmiany.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[Classic DataGrid.DataSourceChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.DataSourceChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.DataSourceChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.DataSourceChanged Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.DataSourceChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.DataSourceChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.SetDataBinding(System.Object,System.String)" />
        <altmember cref="P:System.Windows.Forms.DataGrid.DataSource" />
        <altmember cref="P:System.Windows.Forms.DataGrid.DataMember" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.DataGrid.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera domyślny rozmiar kontrolki.</summary>
        <value>Domyślny rozmiar kontrolki.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="dataGrid.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używane przez <see cref="T:System.Windows.Forms.DataGrid" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.DataGrid.Dispose%2A> po zakończeniu przy użyciu <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. <xref:System.Windows.Forms.DataGrid.Dispose%2A> Pozostawia metoda <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Windows.Forms.DataGrid.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> , dzięki czemu można odzyskać pamięć zajmowaną przez jej przez wyrzucanie elementów bezużytecznych.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.Dispose%2A> metodę, aby zwolnić zasoby.  
  
 [!code-vb[Classic DataGrid.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.Dispose Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public bool EndEdit (System.Windows.Forms.DataGridColumnStyle gridColumn, int rowNumber, bool shouldAbort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool EndEdit(class System.Windows.Forms.DataGridColumnStyle gridColumn, int32 rowNumber, bool shouldAbort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.EndEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndEdit (gridColumn As DataGridColumnStyle, rowNumber As Integer, shouldAbort As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool EndEdit(System::Windows::Forms::DataGridColumnStyle ^ gridColumn, int rowNumber, bool shouldAbort);" />
      <MemberSignature Language="F#" Value="abstract member EndEdit : System.Windows.Forms.DataGridColumnStyle * int * bool -&gt; bool&#xA;override this.EndEdit : System.Windows.Forms.DataGridColumnStyle * int * bool -&gt; bool" Usage="dataGrid.EndEdit (gridColumn, rowNumber, shouldAbort)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDataGridEditingService.EndEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gridColumn" Type="System.Windows.Forms.DataGridColumnStyle" />
        <Parameter Name="rowNumber" Type="System.Int32" />
        <Parameter Name="shouldAbort" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="gridColumn"><see cref="T:System.Windows.Forms.DataGridColumnStyle" /> Zaprzestania edycji.</param>
        <param name="rowNumber">Liczba wierszy zaprzestania edycji.</param>
        <param name="shouldAbort">Ustaw <see langword="true" /> Jeśli bieżąca operacja powinna zostać zatrzymana.</param>
        <summary>Żądań koniec operacji edycji zachodzące na <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <returns><see langword="true" /> Jeśli zakończenie operacji edycji; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.EndEdit%2A> Metoda zwraca `false` Jeśli użytkownik nie jest edytowany (wpisując) komórki.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.BeginEdit%2A> i <xref:System.Windows.Forms.DataGrid.EndEdit%2A> metody do edycji wartości w siatce, wyświetlane przez <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-cpp[Classic DataGrid.EndEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.EndEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.EndEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.EndEdit Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.EndEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.EndEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.BeginEdit(System.Windows.Forms.DataGridColumnStyle,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="dataGrid.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy się inicjowanie <see cref="T:System.Windows.Forms.DataGrid" /> który jest używany w formularzu lub używany przez inny składnik. Inicjowanie odbywa się w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Środowisko projektowania programu Visual Studio używa tej metody, aby zakończyć inicjowanie składnik, który jest używany w formularzu lub używany przez inny składnik. <xref:System.Windows.Forms.DataGrid.BeginInit%2A> Metoda uruchamia inicjowania. Za pomocą <xref:System.Windows.Forms.DataGrid.BeginInit%2A> i <xref:System.Windows.Forms.DataGrid.EndInit%2A> metody zapobiega używana przed pełnym zainicjowaniem formantu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Expand">
      <MemberSignature Language="C#" Value="public void Expand (int row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Expand(int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.Expand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Expand (row As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Expand(int row);" />
      <MemberSignature Language="F#" Value="member this.Expand : int -&gt; unit" Usage="dataGrid.Expand row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Liczba wierszy, aby rozwinąć. Jeśli ustawiona na wartość -1, wszystkie wiersze zostaną rozwinięte.</param>
        <summary>Wyświetla relacji podrzędnej, jeśli istnieją, dla wszystkich wierszy lub konkretnego wiersza.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-vb[Classic DataGrid.Expand Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.Expand Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.Expand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="FirstVisibleColumn">
      <MemberSignature Language="C#" Value="public int FirstVisibleColumn { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FirstVisibleColumn" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.FirstVisibleColumn" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstVisibleColumn As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int FirstVisibleColumn { int get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstVisibleColumn : int" Usage="System.Windows.Forms.DataGrid.FirstVisibleColumn" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera indeks pierwszej kolumny widocznych w siatce.</summary>
        <value>Indeks <see cref="T:System.Windows.Forms.DataGridColumnStyle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolumny jest uznawany za widoczne, nawet wtedy, gdy jest częściowo zasłonięte.  
  
 Jeśli dana kolumna nie jest widoczny, ustaw <xref:System.Windows.Forms.DataGrid.CurrentCell%2A> właściwości komórki, które mają być widoczne.  
  
   
  
## Examples  
 Poniższy przykład kodu Przewija siatki, jeśli pierwszy widocznej kolumny jest większa niż 5.  
  
 [!code-vb[Classic DataGrid.FirstVisibleColumn Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.FirstVisibleColumn Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CurrentCell" />
      </Docs>
    </Member>
    <Member MemberName="FlatMode">
      <MemberSignature Language="C#" Value="public bool FlatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FlatMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.FlatMode" />
      <MemberSignature Language="VB.NET" Value="Public Property FlatMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool FlatMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.FlatMode : bool with get, set" Usage="System.Windows.Forms.DataGrid.FlatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy są wyświetlane w siatce trybem prostego.</summary>
        <value><see langword="true" /> Jeśli siatki jest wyświetlany płaskie; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu sprawdza, czy <xref:System.Windows.Forms.DataGrid.FlatMode%2A> właściwości i powiadamia użytkownika o jego stan.  
  
 [!code-cpp[MyDataGridClass_FlatMode_ReadOnly#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CPP/mydatagridclass_flatmode_readonly.cpp#1)]
 [!code-csharp[MyDataGridClass_FlatMode_ReadOnly#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CS/mydatagridclass_flatmode_readonly.cs#1)]
 [!code-vb[MyDataGridClass_FlatMode_ReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/VB/mydatagridclass_flatmode_readonly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlatModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FlatModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FlatModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.FlatModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FlatModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FlatModeChanged;" />
      <MemberSignature Language="F#" Value="member this.FlatModeChanged : EventHandler " Usage="member this.FlatModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.FlatMode" /> został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CPP/mydatagridclass_flatmode_readonly.cpp#2)]
 [!code-csharp[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CS/mydatagridclass_flatmode_readonly.cs#2)]
 [!code-vb[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/VB/mydatagridclass_flatmode_readonly.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.FlatMode" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia właściwość kolor (zazwyczaj tekstu) pierwszego planu <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor pierwszego planu. Wartość domyślna to <see cref="P:System.Drawing.SystemBrushes.WindowText" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCellBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera <see cref="T:System.Drawing.Rectangle" /> określający dowiedzą o komórki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCellBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetCellBounds (System.Windows.Forms.DataGridCell dgc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetCellBounds(valuetype System.Windows.Forms.DataGridCell dgc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GetCellBounds(System.Windows.Forms.DataGridCell)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCellBounds (dgc As DataGridCell) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetCellBounds(System::Windows::Forms::DataGridCell dgc);" />
      <MemberSignature Language="F#" Value="member this.GetCellBounds : System.Windows.Forms.DataGridCell -&gt; System.Drawing.Rectangle" Usage="dataGrid.GetCellBounds dgc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgc" Type="System.Windows.Forms.DataGridCell" />
      </Parameters>
      <Docs>
        <param name="dgc"><see cref="T:System.Windows.Forms.DataGridCell" /> Do wyszukania.</param>
        <summary>Pobiera <see cref="T:System.Drawing.Rectangle" /> komórki, określony przez <see cref="T:System.Windows.Forms.DataGridCell" />.</summary>
        <returns>A <see cref="T:System.Drawing.Rectangle" /> definiujący rogów bieżącej komórki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.GetCellBounds%2A> metodę, aby zwrócić <xref:System.Drawing.Rectangle> określonego komórki.  
  
 [!code-cpp[Classic DataGrid.GetCellBounds1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.GetCellBounds1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds1 Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.GetCellBounds1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.GetCurrentCellBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetCellBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetCellBounds (int row, int col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetCellBounds(int32 row, int32 col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GetCellBounds(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCellBounds (row As Integer, col As Integer) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetCellBounds(int row, int col);" />
      <MemberSignature Language="F#" Value="member this.GetCellBounds : int * int -&gt; System.Drawing.Rectangle" Usage="dataGrid.GetCellBounds (row, col)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
        <Parameter Name="col" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Liczba wierszy komórki.</param>
        <param name="col">Numer kolumny komórki.</param>
        <summary>Pobiera <see cref="T:System.Drawing.Rectangle" /> komórki, określony przez numer wiersza i kolumny.</summary>
        <returns>A <see cref="T:System.Drawing.Rectangle" /> definiujący rogów bieżącej komórki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pobrać granice komórki dla aktualnie zaznaczonej komórki, użyj <xref:System.Windows.Forms.DataGrid.GetCurrentCellBounds%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.GetCellBounds%2A> metodę, aby zwrócić <xref:System.Drawing.Rectangle> określonego komórki.  
  
 [!code-cpp[Classic DataGrid.GetCellBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.GetCellBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.GetCellBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.GetCellBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.GetCurrentCellBounds" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CurrentCell" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentCellBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle GetCurrentCellBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle GetCurrentCellBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GetCurrentCellBounds" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentCellBounds () As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle GetCurrentCellBounds();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentCellBounds : unit -&gt; System.Drawing.Rectangle" Usage="dataGrid.GetCurrentCellBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera <see cref="T:System.Drawing.Rectangle" /> określający dowiedzą o zaznaczonej komórki.</summary>
        <returns>A <see cref="T:System.Drawing.Rectangle" /> definiujący rogów bieżącej komórki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby pobrać granice komórki dla innej niż bieżąca komórka, użyj <xref:System.Windows.Forms.DataGrid.GetCellBounds%2A>.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład <xref:System.Drawing.Rectangle> zaznaczonej komórki.  
  
 [!code-cpp[Classic DataGrid.GetCurrentCellBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.GetCurrentCellBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.GetCurrentCellBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.GetCurrentCellBounds Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.GetCurrentCellBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.GetCurrentCellBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.GetCellBounds(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetOutputTextDelimiter">
      <MemberSignature Language="C#" Value="protected virtual string GetOutputTextDelimiter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string GetOutputTextDelimiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GetOutputTextDelimiter" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetOutputTextDelimiter () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ GetOutputTextDelimiter();" />
      <MemberSignature Language="F#" Value="abstract member GetOutputTextDelimiter : unit -&gt; string&#xA;override this.GetOutputTextDelimiter : unit -&gt; string" Usage="dataGrid.GetOutputTextDelimiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ciąg, który jest separator kolumn, gdy zawartość wiersza są kopiowane do Schowka.</summary>
        <returns>Wartość ciągu "\t", który reprezentuje kartę, używany do rozdzielania kolumn w wierszu.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GridHScrolled">
      <MemberSignature Language="C#" Value="protected virtual void GridHScrolled (object sender, System.Windows.Forms.ScrollEventArgs se);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GridHScrolled(object sender, class System.Windows.Forms.ScrollEventArgs se) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GridHScrolled(System.Object,System.Windows.Forms.ScrollEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GridHScrolled (sender As Object, se As ScrollEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GridHScrolled(System::Object ^ sender, System::Windows::Forms::ScrollEventArgs ^ se);" />
      <MemberSignature Language="F#" Value="abstract member GridHScrolled : obj * System.Windows.Forms.ScrollEventArgs -&gt; unit&#xA;override this.GridHScrolled : obj * System.Windows.Forms.ScrollEventArgs -&gt; unit" Usage="dataGrid.GridHScrolled (sender, se)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="se" Type="System.Windows.Forms.ScrollEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender"><see cref="T:System.Object" /> Zawierający dane dotyczące kontrolki.</param>
        <param name="se">Element <see cref="T:System.Windows.Forms.ScrollEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Nasłuchuje zdarzeń przewijania poziomego paska przewijania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GridLineColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color GridLineColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color GridLineColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.GridLineColor" />
      <MemberSignature Language="VB.NET" Value="Public Property GridLineColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color GridLineColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.GridLineColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.GridLineColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor linii siatki.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor linii siatki. Wartość domyślna to kolor systemu dla formantów (<see cref="P:System.Drawing.SystemColors.Control" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Żadna linia siatki jest wyświetlana, jeśli <xref:System.Windows.Forms.DataGrid.GridLineStyle%2A> właściwość jest ustawiona na `DataGridLineStyle.None`.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia kolor linii siatki, przy użyciu wartości przekazywany do metody.  
  
 [!code-cpp[Classic DataGrid.GridLineColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.GridLineColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.GridLineColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.GridLineColor Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.GridLineColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.GridLineColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nie ustawiono wartości.</exception>
        <altmember cref="P:System.Windows.Forms.DataGrid.GridLineStyle" />
      </Docs>
    </Member>
    <Member MemberName="GridLineStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridLineStyle GridLineStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DataGridLineStyle GridLineStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.GridLineStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property GridLineStyle As DataGridLineStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridLineStyle GridLineStyle { System::Windows::Forms::DataGridLineStyle get(); void set(System::Windows::Forms::DataGridLineStyle value); };" />
      <MemberSignature Language="F#" Value="member this.GridLineStyle : System.Windows.Forms.DataGridLineStyle with get, set" Usage="System.Windows.Forms.DataGrid.GridLineStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridLineStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia styl linii siatki.</summary>
        <value>Jedną z <see cref="T:System.Windows.Forms.DataGridLineStyle" /> wartości. Wartość domyślna to <see langword="Solid" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy zmiany <xref:System.Windows.Forms.DataGrid.GridLineStyle%2A> właściwość żadnych wierszy.  
  
 [!code-vb[Classic DataGrid.GridLineStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.GridLineStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.GridLineColor" />
      </Docs>
    </Member>
    <Member MemberName="GridVScrolled">
      <MemberSignature Language="C#" Value="protected virtual void GridVScrolled (object sender, System.Windows.Forms.ScrollEventArgs se);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GridVScrolled(object sender, class System.Windows.Forms.ScrollEventArgs se) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.GridVScrolled(System.Object,System.Windows.Forms.ScrollEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GridVScrolled (sender As Object, se As ScrollEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GridVScrolled(System::Object ^ sender, System::Windows::Forms::ScrollEventArgs ^ se);" />
      <MemberSignature Language="F#" Value="abstract member GridVScrolled : obj * System.Windows.Forms.ScrollEventArgs -&gt; unit&#xA;override this.GridVScrolled : obj * System.Windows.Forms.ScrollEventArgs -&gt; unit" Usage="dataGrid.GridVScrolled (sender, se)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="se" Type="System.Windows.Forms.ScrollEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender"><see cref="T:System.Object" /> Zawierający dane dotyczące kontrolki.</param>
        <param name="se">Element <see cref="T:System.Windows.Forms.ScrollEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Nasłuchuje zdarzeń przewijania pionowego paska przewijania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color HeaderBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color HeaderBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.HeaderBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color HeaderBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.HeaderBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła wszystkich nagłówków wierszy i kolumn.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor tła w nagłówkach wierszy i kolumn. Wartość domyślna to kolor systemu w przypadku kontrolek <see cref="P:System.Drawing.SystemColors.Control" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia kolor tła nagłówków kolumn przy użyciu wartości przekazywany do metody.  
  
 [!code-vb[Classic DataGrid.HeaderBackColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.HeaderBackColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Podczas próby ustawienia właściwości <see langword="Color.Empty" /> został przekazany.</exception>
        <altmember cref="P:System.Windows.Forms.DataGrid.HeaderForeColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.FlatMode" />
      </Docs>
    </Member>
    <Member MemberName="HeaderFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font HeaderFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font HeaderFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.HeaderFont" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ HeaderFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.DataGrid.HeaderFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia czcionkę dla nagłówków kolumn.</summary>
        <value><see cref="T:System.Drawing.Font" /> Reprezentujący tekst nagłówka.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color HeaderForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color HeaderForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.HeaderForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color HeaderForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.HeaderForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.HeaderForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu nagłówków.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor pierwszego planu, nagłówków kolumn siatki, w tym tekst nagłówka kolumny i plus/minus symbole. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.ControlText" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu ustawia kolor pierwszego planu nagłówków kolumn siatki.  
  
 [!code-vb[Classic DataGrid.HeaderForeColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.HeaderForeColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.FlatMode" />
        <altmember cref="P:System.Windows.Forms.DataGrid.HeaderBackColor" />
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTest">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera informacje <see cref="T:System.Windows.Forms.DataGrid" /> kontroli w określonym momencie na ekranie.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGrid.HitTestInfo HitTest (System.Drawing.Point position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.DataGrid/HitTestInfo HitTest(valuetype System.Drawing.Point position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.HitTest(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function HitTest (position As Point) As DataGrid.HitTestInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DataGrid::HitTestInfo ^ HitTest(System::Drawing::Point position);" />
      <MemberSignature Language="F#" Value="member this.HitTest : System.Drawing.Point -&gt; System.Windows.Forms.DataGrid.HitTestInfo" Usage="dataGrid.HitTest position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGrid+HitTestInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="position">A <see cref="T:System.Drawing.Point" /> reprezentujący pojedynczego x współrzędną y.</param>
        <summary>Pobiera informacje, takie jak numer wiersza i kolumny kliknięto punktu na siatce o siatki za pomocą określonego <see cref="T:System.Drawing.Point" />.</summary>
        <returns>Element <see cref="T:System.Windows.Forms.DataGrid.HitTestInfo" /> zawierający szczegółowe informacje na temat siatki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.HitTestInfo>, W połączeniu z <xref:System.Windows.Forms.DataGrid.HitTest%2A> metody <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> sterowania, służy do określania, która część <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> po kliknięciu formantu. <xref:System.Windows.Forms.DataGrid.HitTestInfo> Zawiera wierszy, kolumny i części siatki, który został kliknięty. Ponadto <xref:System.Windows.Forms.DataGrid.HitTestInfo.Type%2A> właściwość zwraca <xref:System.Windows.Forms.DataGrid.HitTestType> wyliczenia.  
  
 <xref:System.Windows.Forms.DataGrid.HitTest%2A> Metoda przyjmuje x i y pochodzącego z argumentem <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontrolki <xref:System.Windows.Forms.Control.DragDrop>, <xref:System.Windows.Forms.Control.DragEnter>, <xref:System.Windows.Forms.Control.DragOver>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, <xref:System.Windows.Forms.Control.MouseUp> i <xref:System.Windows.Forms.Control.MouseWheel> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.HitTest%2A> method in Class metoda występuje, gdy użytkownik kliknie na siatce.  
  
 [!code-vb[Classic DataGrid.HitTest1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.HitTest1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGrid.HitTestInfo HitTest (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.DataGrid/HitTestInfo HitTest(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.HitTest(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function HitTest (x As Integer, y As Integer) As DataGrid.HitTestInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DataGrid::HitTestInfo ^ HitTest(int x, int y);" />
      <MemberSignature Language="F#" Value="member this.HitTest : int * int -&gt; System.Windows.Forms.DataGrid.HitTestInfo" Usage="dataGrid.HitTest (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGrid+HitTestInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Poziome położenie współrzędnych.</param>
        <param name="y">Położenie w pionie współrzędnych.</param>
        <summary>Pobiera informacje, takie jak numer wiersza i kolumny kliknięto punktu na siatkę, przy użyciu x i y współrzędnych przekazywany do metody.</summary>
        <returns>A <see cref="T:System.Windows.Forms.DataGrid.HitTestInfo" /> zawierająca informacje o kliknięto części siatki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.HitTestInfo>, W połączeniu z <xref:System.Windows.Forms.DataGrid.HitTest%2A> metody <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> sterowania, służy do określania, która część <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> po kliknięciu formantu. <xref:System.Windows.Forms.DataGrid.HitTestInfo> Zawiera wierszy, kolumny i części siatki, który został kliknięty. Ponadto <xref:System.Windows.Forms.DataGrid.HitTestInfo.Type%2A> właściwość zwraca <xref:System.Windows.Forms.DataGrid.HitTestType> wyliczenia.  
  
 <xref:System.Windows.Forms.DataGrid.HitTest%2A> Metoda przyjmuje x i y pochodzącego z argumentem <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontrolki <xref:System.Windows.Forms.Control.DragDrop>, <xref:System.Windows.Forms.Control.DragEnter>, <xref:System.Windows.Forms.Control.DragOver>, <xref:System.Windows.Forms.Control.MouseDown>, <xref:System.Windows.Forms.Control.MouseMove>, <xref:System.Windows.Forms.Control.MouseUp> i <xref:System.Windows.Forms.Control.MouseWheel> zdarzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.DataGrid.HitTest%2A> metoda zdarzenia, gdy użytkownik kliknie w siatce.  
  
 [!code-vb[Classic DataGrid.HitTest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.HitTest Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="HorizScrollBar">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.ScrollBar HorizScrollBar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ScrollBar HorizScrollBar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.HorizScrollBar" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property HorizScrollBar As ScrollBar" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Forms::ScrollBar ^ HorizScrollBar { System::Windows::Forms::ScrollBar ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.HorizScrollBar : System.Windows.Forms.ScrollBar" Usage="System.Windows.Forms.DataGrid.HorizScrollBar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollBar</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera poziomych pasków przewijania w siatce.</summary>
        <value><see cref="T:System.Windows.Forms.ScrollBar" /> Siatki.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.VertScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="IsExpanded">
      <MemberSignature Language="C#" Value="public bool IsExpanded (int rowNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsExpanded(int32 rowNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.IsExpanded(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsExpanded (rowNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsExpanded(int rowNumber);" />
      <MemberSignature Language="F#" Value="member this.IsExpanded : int -&gt; bool" Usage="dataGrid.IsExpanded rowNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowNumber">Liczba w danym wierszu.</param>
        <summary>Pobiera wartość wskazującą, czy węzeł określony wiersz jest rozwinięta czy zwinięta.</summary>
        <returns><see langword="true" /> Jeśli węzeł jest rozwinięty; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu sprawdza każdy wiersz w siatce i drukuje numer wiersza, rozwinięty wierszy.  
  
 [!code-cpp[Classic DataGrid.IsExpanded Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.IsExpanded Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.IsExpanded Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.IsExpanded Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.IsExpanded Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.IsExpanded Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.Collapse(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="IsSelected">
      <MemberSignature Language="C#" Value="public bool IsSelected (int row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsSelected(int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.IsSelected(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSelected (row As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSelected(int row);" />
      <MemberSignature Language="F#" Value="member this.IsSelected : int -&gt; bool" Usage="dataGrid.IsSelected row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Numer wiersza, który Cię interesuje.</param>
        <summary>Pobiera wartość wskazującą, czy określony wiersz jest zaznaczone.</summary>
        <returns><see langword="true" /> Jeśli wiersz jest zaznaczone. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody za pomocą <xref:System.Windows.Forms.DataGrid.Select%2A>, <xref:System.Windows.Forms.DataGrid.UnSelect%2A>, i <xref:System.Windows.Forms.DataGrid.ResetSelection%2A> metody do manipulowania stan zaznaczenia określonego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#5](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#5)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#5](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#5)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera lub ustawia wartość określonego komórki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[System.Windows.Forms.DataGridCell cell] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(valuetype System.Windows.Forms.DataGridCell)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.Item(System.Windows.Forms.DataGridCell)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(cell As DataGridCell) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Windows::Forms::DataGridCell] { System::Object ^ get(System::Windows::Forms::DataGridCell cell); void set(System::Windows::Forms::DataGridCell cell, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(System.Windows.Forms.DataGridCell) : obj with get, set" Usage="System.Windows.Forms.DataGrid.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="System.Windows.Forms.DataGridCell" />
      </Parameters>
      <Docs>
        <param name="cell">A <see cref="T:System.Windows.Forms.DataGridCell" /> reprezentujący komórkę w siatce.</param>
        <summary>Pobiera lub ustawia wartość określonego <see cref="T:System.Windows.Forms.DataGridCell" />.</summary>
        <value>Wartość wpisana jako <see cref="T:System.Object" />, komórki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości zmienia pozycję <xref:System.Data.DataView> do określonego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia i pobiera wartość komórki przez zadeklarowanie <xref:System.Windows.Forms.DataGridCell> zmiennej i ustawienie jej <xref:System.Windows.Forms.DataGridCell.RowNumber%2A> i <xref:System.Windows.Forms.DataGridCell.ColumnNumber%2A> wartości, najpierw zmiany, a następnie zwrócenie wartości dana komórka.  
  
 [!code-cpp[Classic DataGrid.this1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.this1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.this1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.this1 Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.this1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.this1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.CurrentCell" />
        <altmember cref="T:System.Windows.Forms.DataGridCell" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[int rowIndex, int columnIndex] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32, int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.Item(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(rowIndex As Integer, columnIndex As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[int, int] { System::Object ^ get(int rowIndex, int columnIndex); void set(int rowIndex, int columnIndex, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int * int) : obj with get, set" Usage="System.Windows.Forms.DataGrid.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowIndex" Type="System.Int32" />
        <Parameter Name="columnIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rowIndex">Liczony od zera indeks wiersza zawierającego wartość.</param>
        <param name="columnIndex">Liczony od zera indeks kolumny zawierającej wartość.</param>
        <summary>Pobiera lub ustawia wartość komórki od określonego wiersza i kolumny.</summary>
        <value>Wartość wpisana jako <see cref="T:System.Object" />, komórki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie tej właściwości zmienia pozycję <xref:System.Data.DataView> do określonego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu drukuje wartość zawierana przez komórki w określonych wiersza i indeksu.  
  
 [!code-cpp[Classic DataGrid.this Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.this Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.this Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.this Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.this Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.this Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Podczas pobierania lub ustawienie <paramref name="rowIndex" /> znajduje się poza zakresem.  
  
Podczas pobierania lub ustawienie <paramref name="columnIndex" /> znajduje się poza zakresem.</exception>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.LinkColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tekstu, który można kliknąć, aby przejść do tabeli podrzędnej.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor tekstu, który zostanie kliknięty, aby przejść do tabeli podrzędnej. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.HotTrack" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.LinkColor" />
      </Docs>
    </Member>
    <Member MemberName="LinkHoverColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkHoverColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkHoverColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.LinkHoverColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkHoverColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkHoverColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.LinkHoverColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.LinkHoverColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski nie jest zrozumiały dla tego formantu.</summary>
        <value>Kolor wyświetlany po umieszczeniu wskaźnika myszy nad tekstem łącza.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ListManager">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Forms.CurrencyManager ListManager { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager ListManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ListManager" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property ListManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Forms::CurrencyManager ^ ListManager { System::Windows::Forms::CurrencyManager ^ get(); void set(System::Windows::Forms::CurrencyManager ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ListManager : System.Windows.Forms.CurrencyManager with get, set" Usage="System.Windows.Forms.DataGrid.ListManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.CurrencyManager" /> tego <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <value><see cref="T:System.Windows.Forms.CurrencyManager" /> Tego <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.NavigateEventHandler Navigate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.NavigateEventHandler Navigate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.Navigate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigate As NavigateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::NavigateEventHandler ^ Navigate;" />
      <MemberSignature Language="F#" Value="member this.Navigate : System.Windows.Forms.NavigateEventHandler " Usage="member this.Navigate : System.Windows.Forms.NavigateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NavigateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przechodzi do nowej tabeli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.DataGrid.Navigate> zdarzenie, aby zresetować właściwości poszczególnych kolumn, takich jak szerokość odpowiednio do tabeli.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_AllowNavigationChanged#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CPP/mydatagrid_allownavigationchanged.cpp#2)]
 [!code-csharp[DataGrid_AllowNavigationChanged#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/CS/mydatagrid_allownavigationchanged.cs#2)]
 [!code-vb[DataGrid_AllowNavigationChanged#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_AllowNavigationChanged/VB/mydatagrid_allownavigationchanged.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigateBack">
      <MemberSignature Language="C#" Value="public void NavigateBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.NavigateBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateBack();" />
      <MemberSignature Language="F#" Value="member this.NavigateBack : unit -&gt; unit" Usage="dataGrid.NavigateBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje przejście do tabeli wcześniej wyświetlane w siatce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli siatki nie posiada nadrzędnej wierszy, wystąpi bez zmian.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-vb[Classic DataGrid.NavigateBack Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.NavigateBack Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NavigateTo">
      <MemberSignature Language="C#" Value="public void NavigateTo (int rowNumber, string relationName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NavigateTo(int32 rowNumber, string relationName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.NavigateTo(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NavigateTo (rowNumber As Integer, relationName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NavigateTo(int rowNumber, System::String ^ relationName);" />
      <MemberSignature Language="F#" Value="member this.NavigateTo : int * string -&gt; unit" Usage="dataGrid.NavigateTo (rowNumber, relationName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rowNumber" Type="System.Int32" />
        <Parameter Name="relationName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rowNumber">Liczba wierszy, aby przejść do.</param>
        <param name="relationName">Nazwa relacji podrzędnej, aby przejść do.</param>
        <summary>Powoduje przejście do tabeli, określonego przez nazwę wierszy i relacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod powoduje przejście do numer określony wiersz w tabeli, określonego przez nazwę relacji podrzędnej.  
  
 [!code-csharp[Classic DataGrid.NavigateTo Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.NavigateTo Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.NavigateTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.NavigateTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.NavigateBack" />
      </Docs>
    </Member>
    <Member MemberName="OnAllowNavigationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAllowNavigationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAllowNavigationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnAllowNavigationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAllowNavigationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAllowNavigationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAllowNavigationChanged : EventArgs -&gt; unit&#xA;override this.OnAllowNavigationChanged : EventArgs -&gt; unit" Usage="dataGrid.OnAllowNavigationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.AllowNavigationChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackButtonClicked">
      <MemberSignature Language="C#" Value="protected void OnBackButtonClicked (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnBackButtonClicked(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnBackButtonClicked(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnBackButtonClicked (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnBackButtonClicked(System::Object ^ sender, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnBackButtonClicked : obj * EventArgs -&gt; unit" Usage="dataGrid.OnBackButtonClicked (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender"><see cref="T:System.Object" /> Zawierający dane dotyczące kontrolki.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane o zdarzeniu.</param>
        <summary>Nasłuchuje napis na przycisku Wstecz kliknął zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="dataGrid.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnBackColorChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnBackColorChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnBackColorChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnBackgroundColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundColorChanged : EventArgs -&gt; unit" Usage="dataGrid.OnBackgroundColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.BackgroundColorChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected override void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="dataGrid.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnBindingContextChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnBindingContextChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnBindingContextChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBorderStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBorderStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBorderStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnBorderStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBorderStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBorderStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBorderStyleChanged : EventArgs -&gt; unit&#xA;override this.OnBorderStyleChanged : EventArgs -&gt; unit" Usage="dataGrid.OnBorderStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.BorderStyleChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCaptionVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCaptionVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCaptionVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnCaptionVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCaptionVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCaptionVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCaptionVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnCaptionVisibleChanged : EventArgs -&gt; unit" Usage="dataGrid.OnCaptionVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.CaptionVisibleChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentCellChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentCellChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentCellChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnCurrentCellChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentCellChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentCellChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentCellChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentCellChanged : EventArgs -&gt; unit" Usage="dataGrid.OnCurrentCellChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.CurrentCellChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataSourceChanged : EventArgs -&gt; unit&#xA;override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="dataGrid.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.DataSourceChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnDataSourceChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnDataSourceChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnDataSourceChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnEnter : EventArgs -&gt; unit" Usage="dataGrid.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.Enter" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFlatModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFlatModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFlatModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnFlatModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFlatModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFlatModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFlatModeChanged : EventArgs -&gt; unit&#xA;override this.OnFlatModeChanged : EventArgs -&gt; unit" Usage="dataGrid.OnFlatModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.FlatModeChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnFontChanged : EventArgs -&gt; unit" Usage="dataGrid.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.FontChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnFontChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnFontChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnFontChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="dataGrid.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnForeColorChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnForeColorChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnForeColorChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="dataGrid.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="M:System.Windows.Forms.Control.CreateHandle" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnHandleCreated%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnHandleCreated(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnHandleCreated(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="dataGrid.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="M:System.Windows.Forms.Control.DestroyHandle" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnHandleDestroyed%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnHandleDestroyed(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnHandleDestroyed(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Forms.KeyEventArgs ke);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs ke) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (ke As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ ke);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="dataGrid.OnKeyDown ke" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ke" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="ke">A <see cref="T:System.Windows.Forms.KeyEventArgs" /> udostępniające dane na temat <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.KeyDown" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnKeyDown%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected override void OnKeyPress (System.Windows.Forms.KeyPressEventArgs kpe);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs kpe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyPress (kpe As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ kpe);" />
      <MemberSignature Language="F#" Value="override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="dataGrid.OnKeyPress kpe" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="kpe" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="kpe">A <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> zdarzeń</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.KeyPress" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnKeyPress%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="dataGrid.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Element <see cref="T:System.Windows.Forms.LayoutEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.Layout" /> zdarzenie, które powoduje przeniesienie kontrolki i aktualizuje paski przewijania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnLayout%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnLayout(System.Windows.Forms.LayoutEventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected override void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnLeave : EventArgs -&gt; unit" Usage="dataGrid.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.Leave" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnLeave%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnLeave(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnLeave(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected override void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="dataGrid.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.MouseDown" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid.OnMouseDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid.OnMouseDown/CPP/overridemousedown.cpp#1)]
 [!code-csharp[DataGrid.OnMouseDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid.OnMouseDown/CS/overridemousedown.cs#1)]
 [!code-vb[DataGrid.OnMouseDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid.OnMouseDown/VB/overridemousedown.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseLeave : EventArgs -&gt; unit" Usage="dataGrid.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> zdarzeń.</param>
        <summary>Tworzy <see cref="E:System.Windows.Forms.Control.MouseLeave" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnMouseLeave(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnMouseLeave(System.EventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected override void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="dataGrid.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.MouseMove" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected override void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="dataGrid.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.MouseUp" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected override void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="dataGrid.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.MouseEventArgs" /> zawierający dane dotyczące <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> zdarzeń.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.MouseWheel" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnNavigate">
      <MemberSignature Language="C#" Value="protected void OnNavigate (System.Windows.Forms.NavigateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnNavigate(class System.Windows.Forms.NavigateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnNavigate(System.Windows.Forms.NavigateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnNavigate (e As NavigateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnNavigate(System::Windows::Forms::NavigateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnNavigate : System.Windows.Forms.NavigateEventArgs -&gt; unit" Usage="dataGrid.OnNavigate e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.NavigateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Element <see cref="T:System.Windows.Forms.NavigateEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.Navigate" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs pe);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs pe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (pe As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ pe);" />
      <MemberSignature Language="F#" Value="override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="dataGrid.OnPaint pe" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pe" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pe">A <see cref="T:System.Windows.Forms.PaintEventArgs" /> który zawiera dane o zdarzeniu.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.Paint" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnPaint(System.Windows.Forms.PaintEventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnPaint(System.Windows.Forms.PaintEventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected override void OnPaintBackground (System.Windows.Forms.PaintEventArgs ebe);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs ebe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaintBackground (ebe As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ ebe);" />
      <MemberSignature Language="F#" Value="override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="dataGrid.OnPaintBackground ebe" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ebe" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="ebe">Element <see cref="T:System.Windows.Forms.PaintEventArgs" /> zawierający informacje o kontrolce do malowania.</param>
        <summary>Zastępuje <see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" /> zapobiegające malowanie tła <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ponieważ <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> jest kontrolką złożoną to zastąpienie zaimplementowany, aby mieć żadnej akcji. W związku z tym wywołanie tej metody nie odniesie skutku.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnParentRowsLabelStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRowsLabelStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRowsLabelStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnParentRowsLabelStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRowsLabelStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRowsLabelStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRowsLabelStyleChanged : EventArgs -&gt; unit&#xA;override this.OnParentRowsLabelStyleChanged : EventArgs -&gt; unit" Usage="dataGrid.OnParentRowsLabelStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.ParentRowsLabelStyleChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnParentRowsLabelStyleChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnParentRowsLabelStyleChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnParentRowsLabelStyleChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentRowsVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRowsVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRowsVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnParentRowsVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRowsVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRowsVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRowsVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentRowsVisibleChanged : EventArgs -&gt; unit" Usage="dataGrid.OnParentRowsVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.ParentRowsVisibleChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnReadOnlyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnReadOnlyChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnReadOnlyChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnReadOnlyChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnReadOnlyChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnReadOnlyChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnReadOnlyChanged : EventArgs -&gt; unit&#xA;override this.OnReadOnlyChanged : EventArgs -&gt; unit" Usage="dataGrid.OnReadOnlyChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.ReadOnlyChanged" /> zdarzeń</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.DataGrid.OnReadOnlyChanged%2A> Metoda umożliwia również klasy pochodne obsłużyć zdarzenie bez dołączając delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnReadOnlyChanged(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnReadOnlyChanged(System.EventArgs)" /> metody, która zarejestrowana delegaci otrzymają zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnResize : EventArgs -&gt; unit" Usage="dataGrid.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.Control.Resize" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać przegląd, zobacz [Handling and Raising Events](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.DataGrid.OnResize(System.EventArgs)" /> w klasie pochodnej, pamiętaj wywołać klasy bazowej <see cref="M:System.Windows.Forms.DataGrid.OnResize(System.EventArgs)" /> metody.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRowHeaderClick">
      <MemberSignature Language="C#" Value="protected void OnRowHeaderClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnRowHeaderClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnRowHeaderClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnRowHeaderClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnRowHeaderClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnRowHeaderClick : EventArgs -&gt; unit" Usage="dataGrid.OnRowHeaderClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.RowHeaderClick" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Konieczne jest posiadanie <see cref="T:System.Security.Permissions.UIPermission" /> dla bezpiecznych okien podrzędnych ustawić tę właściwość.</permission>
      </Docs>
    </Member>
    <Member MemberName="OnScroll">
      <MemberSignature Language="C#" Value="protected void OnScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnScroll : EventArgs -&gt; unit" Usage="dataGrid.OnScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.Scroll" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnShowParentDetailsButtonClicked">
      <MemberSignature Language="C#" Value="protected void OnShowParentDetailsButtonClicked (object sender, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnShowParentDetailsButtonClicked(object sender, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.OnShowParentDetailsButtonClicked(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnShowParentDetailsButtonClicked (sender As Object, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnShowParentDetailsButtonClicked(System::Object ^ sender, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnShowParentDetailsButtonClicked : obj * EventArgs -&gt; unit" Usage="dataGrid.OnShowParentDetailsButtonClicked (sender, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Źródło zdarzenia.</param>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Wywołuje <see cref="E:System.Windows.Forms.DataGrid.ShowParentDetailsButtonClick" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRowsBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ParentRowsBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ParentRowsBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ParentRowsBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ParentRowsBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ParentRowsBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ParentRowsBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.ParentRowsBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła wierszy nadrzędnych.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor wierszy nadrzędnej. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.Control" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.ParentRowsBackColor%2A> właściwość nowy kolor.  
  
 [!code-vb[Classic DataGrid.ParentRowsBackColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ParentRowsBackColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRowsForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ParentRowsForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ParentRowsForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ParentRowsForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ParentRowsForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ParentRowsForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ParentRowsForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.ParentRowsForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu wierszy nadrzędnych.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor pierwszego planu wierszy nadrzędnych. Wartość domyślna to <see cref="P:System.Drawing.SystemColors.WindowText" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.ParentRowsForeColor%2A> właściwość nowy kolor.  
  
 [!code-vb[Classic DataGrid.ParentRowsForeColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ParentRowsForeColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRowsLabelStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DataGridParentRowsLabelStyle ParentRowsLabelStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DataGridParentRowsLabelStyle ParentRowsLabelStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ParentRowsLabelStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property ParentRowsLabelStyle As DataGridParentRowsLabelStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DataGridParentRowsLabelStyle ParentRowsLabelStyle { System::Windows::Forms::DataGridParentRowsLabelStyle get(); void set(System::Windows::Forms::DataGridParentRowsLabelStyle value); };" />
      <MemberSignature Language="F#" Value="member this.ParentRowsLabelStyle : System.Windows.Forms.DataGridParentRowsLabelStyle with get, set" Usage="System.Windows.Forms.DataGrid.ParentRowsLabelStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DataGridParentRowsLabelStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia sposób wyświetlania etykiety wierszy nadrzędnej.</summary>
        <value>Jedną z <see cref="T:System.Windows.Forms.DataGridParentRowsLabelStyle" /> wartości. Wartość domyślna to <see langword="Both" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod cykle przykład za pośrednictwem możliwych wartości dla <xref:System.Windows.Forms.DataGrid.ParentRowsLabelStyle%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.ParentRowsLabelStyle Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ParentRowsLabelStyle Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Moduł wyliczający jest nieprawidłowa.</exception>
        <altmember cref="P:System.Windows.Forms.DataGrid.AllowNavigation" />
        <altmember cref="P:System.Windows.Forms.DataGrid.ParentRowsForeColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.ParentRowsBackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.ParentRowsVisible" />
      </Docs>
    </Member>
    <Member MemberName="ParentRowsLabelStyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentRowsLabelStyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentRowsLabelStyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.ParentRowsLabelStyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentRowsLabelStyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentRowsLabelStyleChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentRowsLabelStyleChanged : EventHandler " Usage="member this.ParentRowsLabelStyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy styl etykiety wiersza nadrzędnego zostanie zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ParentRowsLabelStyleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/CPP/datagrid_parentrowslabelstylechanged.cpp#1)]
 [!code-csharp[DataGrid_ParentRowsLabelStyleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/CS/datagrid_parentrowslabelstylechanged.cs#1)]
 [!code-vb[DataGrid_ParentRowsLabelStyleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/VB/datagrid_parentrowslabelstylechanged.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRowsVisible">
      <MemberSignature Language="C#" Value="public bool ParentRowsVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ParentRowsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ParentRowsVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property ParentRowsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ParentRowsVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ParentRowsVisible : bool with get, set" Usage="System.Windows.Forms.DataGrid.ParentRowsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiersze nadrzędną tabeli są widoczne.</summary>
        <value><see langword="true" /> Jeśli wiersze nadrzędne są widoczne; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.ParentRowsVisible%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.ParentRowsVisible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ParentRowsVisible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentRowsVisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentRowsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentRowsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.ParentRowsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentRowsVisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentRowsVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentRowsVisibleChanged : EventHandler " Usage="member this.ParentRowsVisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.ParentRowsVisible" /> zmiany wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ParentRowsLabelStyleChanged#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/CPP/datagrid_parentrowslabelstylechanged.cpp#2)]
 [!code-csharp[DataGrid_ParentRowsLabelStyleChanged#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/CS/datagrid_parentrowslabelstylechanged.cs#2)]
 [!code-vb[DataGrid_ParentRowsLabelStyleChanged#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ParentRowsLabelStyleChanged/VB/datagrid_parentrowslabelstylechanged.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreferredColumnWidth">
      <MemberSignature Language="C#" Value="public int PreferredColumnWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredColumnWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.PreferredColumnWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property PreferredColumnWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredColumnWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.PreferredColumnWidth : int with get, set" Usage="System.Windows.Forms.DataGrid.PreferredColumnWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(75)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.DataGridPreferredColumnWidthTypeConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia domyślną szerokość kolumn siatki w pikselach.</summary>
        <value>Domyślna szerokość (w pikselach) kolumny w siatce.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość przed zresetowaniem <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości (albo oddzielnie, lub za pomocą <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metoda), lub właściwość nie odniesie żadnego skutku.  
  
 Nie można ustawić właściwość na wartość mniejszą niż 0.  
  
   
  
## Examples  
 Poniższy przykład kodu ustawia domyślną szerokość kolumn kontrolki na wartość przekazywany do metody.  
  
 [!code-vb[Classic DataGrid.PreferredColumnWidth Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.PreferredColumnWidth Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość właściwości jest mniejszy niż 0.</exception>
        <altmember cref="M:System.Windows.Forms.DataGridColumnStyle.GetPreferredSize(System.Drawing.Graphics,System.Object)" />
        <altmember cref="P:System.Windows.Forms.DataGrid.PreferredRowHeight" />
      </Docs>
    </Member>
    <Member MemberName="PreferredRowHeight">
      <MemberSignature Language="C#" Value="public int PreferredRowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PreferredRowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.PreferredRowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property PreferredRowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PreferredRowHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.PreferredRowHeight : int with get, set" Usage="System.Windows.Forms.DataGrid.PreferredRowHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia preferowany wysokość <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <value>Wysokość wiersza.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustaw tę właściwość przed zresetowaniem <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> właściwości (albo oddzielnie, lub za pomocą <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metoda), lub właściwość nie odniesie żadnego skutku.  
  
   
  
## Examples  
 Poniższy przykładowy kod najpierw Ustawia czcionkę nowych i ustawia <xref:System.Windows.Forms.DataGrid.PreferredRowHeight%2A> do wysokości nowej czcionki.  
  
 [!code-cpp[Classic DataGrid.PreferredRowHeight Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.PreferredRowHeight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.PreferredRowHeight Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.PreferredRowHeight Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.PreferredRowHeight Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.PreferredRowHeight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGridColumnStyle.GetPreferredHeight(System.Drawing.Graphics,System.Object)" />
        <altmember cref="P:System.Windows.Forms.DataGrid.PreferredColumnWidth" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="dataGrid.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Element <see cref="T:System.Windows.Forms.Keys" /> zawierający dane dotyczące po naciśnięciu klawisza.</param>
        <summary>Pobiera lub ustawia wartość wskazującą, czy klucz powinien być dalej przetwarzane.</summary>
        <returns><see langword="true" />, powinny zostać przetworzone klucz; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zastępuje metodę <xref:System.Windows.Forms.Control.ProcessDialogKey%2A> metody do zaimplementowania nawigacji za pomocą klawiatury siatki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessGridKey">
      <MemberSignature Language="C#" Value="protected bool ProcessGridKey (System.Windows.Forms.KeyEventArgs ke);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool ProcessGridKey(class System.Windows.Forms.KeyEventArgs ke) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ProcessGridKey(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Function ProcessGridKey (ke As KeyEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool ProcessGridKey(System::Windows::Forms::KeyEventArgs ^ ke);" />
      <MemberSignature Language="F#" Value="member this.ProcessGridKey : System.Windows.Forms.KeyEventArgs -&gt; bool" Usage="dataGrid.ProcessGridKey ke" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ke" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="ke">Element <see cref="T:System.Windows.Forms.KeyEventArgs" /> zawierający dane dotyczące klucza w górę lub klucza w dół do zdarzenia.</param>
        <summary>Przetwarza klucze nawigacyjne siatki.</summary>
        <returns><see langword="true" />, jeśli klucz został przetworzony; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.ProcessKeyPreview :  -&gt; bool" Usage="dataGrid.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Element <see cref="T:System.Windows.Forms.Message" /> zawierający dane o zdarzeniu. Parametr jest przekazywany przez odwołanie.</param>
        <summary>Wyświetla podgląd komunikatu z klawiatury i zwraca wartość wskazującą, jeśli klucz został wykorzystany.</summary>
        <returns><see langword="true" />, jeśli klucz został wykorzystany; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez kontrolki podrzędnej, gdy kontrolka podrzędna odbierze komunikatu z klawiatury. Kontrolka podrzędna wywołuje tę metodę, przed wygenerowaniem wszelkie zdarzenia klawiatury dla wiadomości. Jeśli ta metoda zwraca `true`, kontrolę rodzicielską uwzględnia komunikat używane i nie generuje żadnych zdarzeń klawiatury.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected bool ProcessTabKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool ProcessTabKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ProcessTabKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Function ProcessTabKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool ProcessTabKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="member this.ProcessTabKey : System.Windows.Forms.Keys -&gt; bool" Usage="dataGrid.ProcessTabKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Element <see cref="T:System.Windows.Forms.Keys" /> zawierający dane o tym, które po naciśnięciu klawisza.</param>
        <summary>Pobiera wartość wskazującą, czy mają być przetwarzane klawisz Tab.</summary>
        <returns><see langword="true" /> Jeśli klawisz TAB, powinny zostać przetworzone; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby uzyskać rysunkowe interfejsu użytkownika. Powiązane wartość typu wyliczeniowego: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool with get, set" Usage="System.Windows.Forms.DataGrid.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy siatka jest w trybie tylko do odczytu.</summary>
        <value><see langword="true" /> Jeśli siatka jest w trybie tylko do odczytu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W trybie tylko do odczytu, może być przewijane siatki, węzły mogą być rozwinięta czy zwinięta, i tak dalej. Jednak nie dodatki, edycje lub usuwa może mieć miejsce.  
  
 <xref:System.Windows.Forms.DataGridColumnStyle> Ma również <xref:System.Windows.Forms.DataGridColumnStyle.ReadOnly%2A> właściwość, która może być ustawiona na true, aby uniemożliwić edytowanym, na podstawie kolumny według kolumny danych.  
  
 <xref:System.Windows.Forms.DataGrid.ReadOnly%2A> Można ustawić na wartość true, jeśli chcesz uniemożliwić użytkownikowi edytowanie danych bezpośrednio w <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Na przykład możesz chcieć umożliwić użytkownikom, aby wyświetlić wszystkie kolumny w tabeli, ale mogą edytować określonych pól tylko za pośrednictwem <xref:System.Windows.Forms.TextBox> kontrolek w formularzu różne.  
  
   
  
## Examples  
 Poniższy kod przykładowy Włącza lub wyłącza <xref:System.Windows.Forms.DataGrid.ReadOnly%2A> właściwości.  
  
 [!code-vb[Classic DataGrid.ReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.ReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Data.DataColumn.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ReadOnlyChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ReadOnlyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ReadOnlyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.ReadOnlyChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReadOnlyChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ReadOnlyChanged;" />
      <MemberSignature Language="F#" Value="member this.ReadOnlyChanged : EventHandler " Usage="member this.ReadOnlyChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.DataGrid.ReadOnly" /> zmiany wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CPP/mydatagridclass_flatmode_readonly.cpp#2)]
 [!code-csharp[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/CS/mydatagridclass_flatmode_readonly.cs#2)]
 [!code-vb[MyDataGridClass_FlatMode_ReadOnly#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_FlatMode_ReadOnly/VB/mydatagridclass_flatmode_readonly.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.ReadOnly" />
      </Docs>
    </Member>
    <Member MemberName="ResetAlternatingBackColor">
      <MemberSignature Language="C#" Value="public void ResetAlternatingBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetAlternatingBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetAlternatingBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetAlternatingBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetAlternatingBackColor();" />
      <MemberSignature Language="F#" Value="member this.ResetAlternatingBackColor : unit -&gt; unit" Usage="dataGrid.ResetAlternatingBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.AlternatingBackColor" /> właściwość jej domyślny kolor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeAlternatingBackColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.AlternatingBackColor" />
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public override void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetBackColor();" />
      <MemberSignature Language="F#" Value="override this.ResetBackColor : unit -&gt; unit" Usage="dataGrid.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.BackColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public override void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResetForeColor();" />
      <MemberSignature Language="F#" Value="override this.ResetForeColor : unit -&gt; unit" Usage="dataGrid.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.ForeColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.AlternatingBackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.BackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionBackColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.CaptionForeColor" />
        <altmember cref="P:System.Windows.Forms.DataGrid.ForeColor" />
        <altmember cref="M:System.Windows.Forms.DataGrid.ResetAlternatingBackColor" />
      </Docs>
    </Member>
    <Member MemberName="ResetGridLineColor">
      <MemberSignature Language="C#" Value="public void ResetGridLineColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetGridLineColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetGridLineColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetGridLineColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetGridLineColor();" />
      <MemberSignature Language="F#" Value="member this.ResetGridLineColor : unit -&gt; unit" Usage="dataGrid.ResetGridLineColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.GridLineColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeGridLineColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetHeaderBackColor">
      <MemberSignature Language="C#" Value="public void ResetHeaderBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetHeaderBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetHeaderBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetHeaderBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetHeaderBackColor();" />
      <MemberSignature Language="F#" Value="member this.ResetHeaderBackColor : unit -&gt; unit" Usage="dataGrid.ResetHeaderBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.HeaderBackColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeHeaderBackColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#1)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#1)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetHeaderFont">
      <MemberSignature Language="C#" Value="public void ResetHeaderFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetHeaderFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetHeaderFont" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetHeaderFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetHeaderFont();" />
      <MemberSignature Language="F#" Value="member this.ResetHeaderFont : unit -&gt; unit" Usage="dataGrid.ResetHeaderFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.HeaderFont" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeHeaderFont%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#3](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#3)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#3](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#3)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetHeaderForeColor">
      <MemberSignature Language="C#" Value="public void ResetHeaderForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetHeaderForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetHeaderForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetHeaderForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetHeaderForeColor();" />
      <MemberSignature Language="F#" Value="member this.ResetHeaderForeColor : unit -&gt; unit" Usage="dataGrid.ResetHeaderForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.HeaderForeColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeHeaderForeColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#2](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#2)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#2](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#2)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetLinkColor">
      <MemberSignature Language="C#" Value="public void ResetLinkColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetLinkColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetLinkColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetLinkColor();" />
      <MemberSignature Language="F#" Value="member this.ResetLinkColor : unit -&gt; unit" Usage="dataGrid.ResetLinkColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.LinkColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetLinkHoverColor">
      <MemberSignature Language="C#" Value="public void ResetLinkHoverColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetLinkHoverColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetLinkHoverColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetLinkHoverColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetLinkHoverColor();" />
      <MemberSignature Language="F#" Value="member this.ResetLinkHoverColor : unit -&gt; unit" Usage="dataGrid.ResetLinkHoverColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.LinkHoverColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeLinkHoverColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetSelection">
      <MemberSignature Language="C#" Value="protected void ResetSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetSelection" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetSelection ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetSelection();" />
      <MemberSignature Language="F#" Value="member this.ResetSelection : unit -&gt; unit" Usage="dataGrid.ResetSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyłącza funkcję wyboru cech dla wszystkich wierszy, które są wybrane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody za pomocą <xref:System.Windows.Forms.DataGrid.IsSelected%2A>, <xref:System.Windows.Forms.DataGrid.Select%2A>, i <xref:System.Windows.Forms.DataGrid.UnSelect%2A> metody do manipulowania stan zaznaczenia określonego wiersza.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetSelectionBackColor">
      <MemberSignature Language="C#" Value="public void ResetSelectionBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetSelectionBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetSelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetSelectionBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetSelectionBackColor();" />
      <MemberSignature Language="F#" Value="member this.ResetSelectionBackColor : unit -&gt; unit" Usage="dataGrid.ResetSelectionBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.SelectionBackColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeSelectionBackColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetSelectionForeColor">
      <MemberSignature Language="C#" Value="public void ResetSelectionForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetSelectionForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ResetSelectionForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetSelectionForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetSelectionForeColor();" />
      <MemberSignature Language="F#" Value="member this.ResetSelectionForeColor : unit -&gt; unit" Usage="dataGrid.ResetSelectionForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje <see cref="P:System.Windows.Forms.DataGrid.SelectionForeColor" /> właściwości do wartości domyślnej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>. Możesz użyć <xref:System.Windows.Forms.DataGrid.ShouldSerializeSelectionForeColor%2A> metodę pozwala ustalić, czy wartość właściwości została zmieniona z domyślnego.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RowHeaderClick">
      <MemberSignature Language="C#" Value="protected event EventHandler RowHeaderClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RowHeaderClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.RowHeaderClick" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event RowHeaderClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler ^ RowHeaderClick;" />
      <MemberSignature Language="F#" Value="member this.RowHeaderClick : EventHandler " Usage="member this.RowHeaderClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po kliknięciu na nagłówek wiersza.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RowHeadersVisible">
      <MemberSignature Language="C#" Value="public bool RowHeadersVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RowHeadersVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.RowHeadersVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property RowHeadersVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RowHeadersVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RowHeadersVisible : bool with get, set" Usage="System.Windows.Forms.DataGrid.RowHeadersVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy nagłówki wierszy są widoczne.</summary>
        <value><see langword="true" /> nagłówki wierszy są widoczne; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.ParentRowsVisible" />
        <altmember cref="P:System.Windows.Forms.DataGrid.RowHeaderWidth" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleRowCount" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleColumnCount" />
      </Docs>
    </Member>
    <Member MemberName="RowHeaderWidth">
      <MemberSignature Language="C#" Value="public int RowHeaderWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RowHeaderWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.RowHeaderWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property RowHeaderWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RowHeaderWidth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RowHeaderWidth : int with get, set" Usage="System.Windows.Forms.DataGrid.RowHeaderWidth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(35)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia szerokość nagłówków wiersza.</summary>
        <value>Szerokość nagłówki wierszy w <see cref="T:System.Windows.Forms.DataGrid" />. Wartością domyślną jest 35.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#6](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#6)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#6](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#6)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scroll">
      <MemberSignature Language="C#" Value="public event EventHandler Scroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Scroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.Scroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Scroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Scroll;" />
      <MemberSignature Language="F#" Value="member this.Scroll : EventHandler " Usage="member this.Scroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przewija widok <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_CaptionVisibleChanged#3](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CPP/mydatagrid_captionvisiblechanged.cpp#3)]
 [!code-csharp[DataGrid_CaptionVisibleChanged#3](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/CS/mydatagrid_captionvisiblechanged.cs#3)]
 [!code-vb[DataGrid_CaptionVisibleChanged#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_CaptionVisibleChanged/VB/mydatagrid_captionvisiblechanged.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select (int row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select(int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.Select(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select (row As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select(int row);" />
      <MemberSignature Language="F#" Value="override this.Select : int -&gt; unit" Usage="dataGrid.Select row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Indeks wiersza, aby wybrać.</param>
        <summary>Wybiera określony wiersz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody za pomocą <xref:System.Windows.Forms.DataGrid.IsSelected%2A>, <xref:System.Windows.Forms.DataGrid.UnSelect%2A>, i <xref:System.Windows.Forms.DataGrid.ResetSelection%2A> metody do manipulowania stan zaznaczenia określonego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[MyDataGridClass_ResetHeaderBackColor#4](~/samples/snippets/cpp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CPP/mydatagridclass_resetheaderbackcolor.cpp#4)]
 [!code-csharp[MyDataGridClass_ResetHeaderBackColor#4](~/samples/snippets/csharp/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/CS/mydatagridclass_resetheaderbackcolor.cs#4)]
 [!code-vb[MyDataGridClass_ResetHeaderBackColor#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MyDataGridClass_ResetHeaderBackColor/VB/mydatagridclass_resetheaderbackcolor.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor tła wybranego wierszy.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor tła wybranego wierszy. Wartość domyślna to <see cref="P:System.Drawing.SystemBrushes.ActiveCaption" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.SelectionForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.DataGrid.SelectionForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolor pierwszego planu zaznaczone wiersze.</summary>
        <value>A <see cref="T:System.Drawing.Color" /> reprezentujący kolor pierwszego planu zaznaczone wiersze. Wartość domyślna to <see cref="P:System.Drawing.SystemBrushes.ActiveCaptionText" /> kolorów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ColorMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ColorMembers/CPP/datagrid_10.cpp#2)]
 [!code-csharp[DataGrid_ColorMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ColorMembers/CS/datagrid_10.cs#2)]
 [!code-vb[DataGrid_ColorMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ColorMembers/VB/datagrid_10.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDataBinding">
      <MemberSignature Language="C#" Value="public void SetDataBinding (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDataBinding(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.SetDataBinding(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDataBinding (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDataBinding(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="member this.SetDataBinding : obj * string -&gt; unit" Usage="dataGrid.SetDataBinding (dataSource, dataMember)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Źródło danych dla <see cref="T:System.Windows.Forms.DataGrid" /> kontroli.</param>
        <param name="dataMember"><see cref="P:System.Windows.Forms.DataGrid.DataMember" /> Ciąg, który określa tabelę, aby powiązać w obiekcie zwracanym przez <see cref="P:System.Windows.Forms.DataGrid.DataSource" /> właściwości.</param>
        <summary>Zestawy <see cref="P:System.Windows.Forms.DataGrid.DataSource" /> i <see cref="P:System.Windows.Forms.DataGrid.DataMember" /> właściwości w czasie wykonywania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy użyć <xref:System.Windows.Forms.DataGrid.SetDataBinding%2A> metody w czasie wykonywania, aby zresetować <xref:System.Windows.Forms.DataGrid.DataSource%2A> właściwości.  
  
 Zobacz <xref:System.Windows.Forms.DataGrid.DataSource%2A> właściwości, aby uzyskać więcej informacji na temat ustawiania poprawnego źródła danych.  
  
 Można utworzyć siatki, która umożliwia użytkownikom edytowanie danych, ale uniemożliwia dodanie nowych wierszy przy użyciu <xref:System.Data.DataView> jako źródła danych i ustawienie <xref:System.Data.DataView.AllowNew%2A> właściwość `false`. Gdy <xref:System.Windows.Forms.DataGrid.DataSource%2A> jest <xref:System.Data.DataView> lub <xref:System.Data.DataTable>ustaw <xref:System.Windows.Forms.DataGrid.DataMember%2A> ciąg pusty ("").  
  
   
  
## Examples  
 Poniższy kod ustawia przykład <xref:System.Windows.Forms.DataGrid.DataSource%2A> i <xref:System.Windows.Forms.DataGrid.DataMember%2A> do <xref:System.Data.DataSet>, a <xref:System.Data.DataTable> w <xref:System.Data.DataSet>, odpowiednio.  
  
 [!code-cpp[Classic DataGrid.SetDataBinding Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.SetDataBinding Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.SetDataBinding Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.SetDataBinding Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.SetDataBinding Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.SetDataBinding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Co najmniej jeden z argumentów są nieprawidłowe.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="dataSource" /> Argument jest <see langword="null" />.</exception>
        <altmember cref="P:System.Windows.Forms.DataGrid.DataMember" />
        <altmember cref="P:System.Windows.Forms.DataGrid.DataSource" />
        <altmember cref="T:System.Data.DataSet" />
        <altmember cref="T:System.Data.DataView" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeAlternatingBackColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeAlternatingBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeAlternatingBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeAlternatingBackColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeAlternatingBackColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeAlternatingBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeAlternatingBackColor : unit -&gt; bool&#xA;override this.ShouldSerializeAlternatingBackColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeAlternatingBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.AlternatingBackColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeBackgroundColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeBackgroundColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeBackgroundColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeBackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeBackgroundColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeBackgroundColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeBackgroundColor : unit -&gt; bool&#xA;override this.ShouldSerializeBackgroundColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeBackgroundColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.BackgroundColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCaptionBackColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeCaptionBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeCaptionBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeCaptionBackColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeCaptionBackColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeCaptionBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeCaptionBackColor : unit -&gt; bool&#xA;override this.ShouldSerializeCaptionBackColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeCaptionBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="P:System.Windows.Forms.DataGrid.CaptionBackColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCaptionForeColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeCaptionForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeCaptionForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeCaptionForeColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeCaptionForeColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeCaptionForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeCaptionForeColor : unit -&gt; bool&#xA;override this.ShouldSerializeCaptionForeColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeCaptionForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="P:System.Windows.Forms.DataGrid.CaptionForeColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeGridLineColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeGridLineColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeGridLineColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeGridLineColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeGridLineColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeGridLineColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeGridLineColor : unit -&gt; bool&#xA;override this.ShouldSerializeGridLineColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeGridLineColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.GridLineColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeHeaderBackColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeHeaderBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeHeaderBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeHeaderBackColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeHeaderBackColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeHeaderBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeHeaderBackColor : unit -&gt; bool&#xA;override this.ShouldSerializeHeaderBackColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeHeaderBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.HeaderBackColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeHeaderFont">
      <MemberSignature Language="C#" Value="protected bool ShouldSerializeHeaderFont ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool ShouldSerializeHeaderFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeHeaderFont" />
      <MemberSignature Language="VB.NET" Value="Protected Function ShouldSerializeHeaderFont () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool ShouldSerializeHeaderFont();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeHeaderFont : unit -&gt; bool" Usage="dataGrid.ShouldSerializeHeaderFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.HeaderFont" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeHeaderForeColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeHeaderForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeHeaderForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeHeaderForeColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeHeaderForeColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeHeaderForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeHeaderForeColor : unit -&gt; bool&#xA;override this.ShouldSerializeHeaderForeColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeHeaderForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.HeaderForeColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeLinkHoverColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeLinkHoverColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeLinkHoverColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeLinkHoverColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeLinkHoverColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeLinkHoverColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeLinkHoverColor : unit -&gt; bool&#xA;override this.ShouldSerializeLinkHoverColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeLinkHoverColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.LinkHoverColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.DataGrid.ResetLinkHoverColor" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeParentRowsBackColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeParentRowsBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeParentRowsBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeParentRowsBackColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeParentRowsBackColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeParentRowsBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeParentRowsBackColor : unit -&gt; bool&#xA;override this.ShouldSerializeParentRowsBackColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeParentRowsBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.ParentRowsBackColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeParentRowsForeColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeParentRowsForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeParentRowsForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeParentRowsForeColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeParentRowsForeColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeParentRowsForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeParentRowsForeColor : unit -&gt; bool&#xA;override this.ShouldSerializeParentRowsForeColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeParentRowsForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.ParentRowsForeColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda tylko wtedy, gdy tworzysz albo projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>, lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializePreferredRowHeight">
      <MemberSignature Language="C#" Value="protected bool ShouldSerializePreferredRowHeight ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool ShouldSerializePreferredRowHeight() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializePreferredRowHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Function ShouldSerializePreferredRowHeight () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool ShouldSerializePreferredRowHeight();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializePreferredRowHeight : unit -&gt; bool" Usage="dataGrid.ShouldSerializePreferredRowHeight " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.PreferredRowHeight" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSelectionBackColor">
      <MemberSignature Language="C#" Value="protected bool ShouldSerializeSelectionBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool ShouldSerializeSelectionBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeSelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Protected Function ShouldSerializeSelectionBackColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool ShouldSerializeSelectionBackColor();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeSelectionBackColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeSelectionBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.SelectionBackColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeSelectionForeColor">
      <MemberSignature Language="C#" Value="protected virtual bool ShouldSerializeSelectionForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ShouldSerializeSelectionForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.ShouldSerializeSelectionForeColor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ShouldSerializeSelectionForeColor () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ShouldSerializeSelectionForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ShouldSerializeSelectionForeColor : unit -&gt; bool&#xA;override this.ShouldSerializeSelectionForeColor : unit -&gt; bool" Usage="dataGrid.ShouldSerializeSelectionForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wskazuje, czy <see cref="P:System.Windows.Forms.DataGrid.SelectionForeColor" /> właściwości powinny zostać utrwalone.</summary>
        <returns><see langword="true" /> Jeśli wartość właściwości została zmieniona z domyślnego; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj ta metoda albo w przypadku tworzenia projektanta na potrzeby <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> lub tworząc własne kontrolki dołączanie <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowParentDetailsButtonClick">
      <MemberSignature Language="C#" Value="public event EventHandler ShowParentDetailsButtonClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ShowParentDetailsButtonClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.ShowParentDetailsButtonClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ShowParentDetailsButtonClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ShowParentDetailsButtonClick;" />
      <MemberSignature Language="F#" Value="member this.ShowParentDetailsButtonClick : EventHandler " Usage="member this.ShowParentDetailsButtonClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see langword="ShowParentDetails" /> przycisku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_ShowParentDetailsButtonClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_ShowParentDetailsButtonClick/CPP/datagrid_showparentdetailsbuttonclick.cpp#1)]
 [!code-csharp[DataGrid_ShowParentDetailsButtonClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_ShowParentDetailsButtonClick/CS/datagrid_showparentdetailsbuttonclick.cs#1)]
 [!code-vb[DataGrid_ShowParentDetailsButtonClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_ShowParentDetailsButtonClick/VB/datagrid_showparentdetailsbuttonclick.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.DataGrid.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokacja formantu.</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> Skojarzone z kontrolki, jeśli istnieją.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Site" />
      </Docs>
    </Member>
    <Member MemberName="SubObjectsSiteChange">
      <MemberSignature Language="C#" Value="public void SubObjectsSiteChange (bool site);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SubObjectsSiteChange(bool site) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.SubObjectsSiteChange(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SubObjectsSiteChange (site As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SubObjectsSiteChange(bool site);" />
      <MemberSignature Language="F#" Value="member this.SubObjectsSiteChange : bool -&gt; unit" Usage="dataGrid.SubObjectsSiteChange site" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="site" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="site"><see langword="true" /> Aby dodać <see cref="T:System.Windows.Forms.DataGridTableStyle" /> obiektów kontenera; <see langword="false" /> je usunąć.</param>
        <summary>Dodaje lub usuwa <see cref="T:System.Windows.Forms.DataGridTableStyle" /> obiektów z kontenera, który jest skojarzony z <see cref="T:System.Windows.Forms.DataGrid" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TableStyles">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.GridTableStylesCollection TableStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.GridTableStylesCollection TableStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.TableStyles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TableStyles As GridTableStylesCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::GridTableStylesCollection ^ TableStyles { System::Windows::Forms::GridTableStylesCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TableStyles : System.Windows.Forms.GridTableStylesCollection" Usage="System.Windows.Forms.DataGrid.TableStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GridTableStylesCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję <see cref="T:System.Windows.Forms.DataGridTableStyle" /> obiekty do siatki.</summary>
        <value>A <see cref="T:System.Windows.Forms.GridTableStylesCollection" /> reprezentujący kolekcję <see cref="T:System.Windows.Forms.DataGridTableStyle" /> obiektów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.GridTableStylesCollection> pobierane w drodze <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwość, aby tworzyć widoki niestandardowe w każdej tabeli wyświetlane przez <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 Domyślnie kolekcja zwracane przez <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwości nie zawiera żadnych <xref:System.Windows.Forms.DataGridTableStyle> obiektów. Aby utworzyć zbiór niestandardowych widoków:  
  
1.  Utwórz <xref:System.Windows.Forms.DataGridTableStyle>.  
  
2.  Ustaw <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> obiektu tabeli siatki <xref:System.Data.DataTable.TableName%2A> z <xref:System.Data.DataTable>.  
  
3.  Dodaj <xref:System.Windows.Forms.DataGridColumnStyle> obiektów, po jednym dla każdej kolumny siatki, które mają być wyświetlane na <xref:System.Windows.Forms.GridColumnStylesCollection> zwrócone przez <xref:System.Windows.Forms.DataGridTableStyle.GridColumnStyles%2A> właściwości.  
  
4.  Ustaw <xref:System.Windows.Forms.DataGridColumnStyle.MappingName%2A> każdego <xref:System.Windows.Forms.DataGridColumnStyle> do <xref:System.Data.DataColumn.ColumnName%2A> z <xref:System.Data.DataColumn>.  
  
5.  Dodaj <xref:System.Windows.Forms.DataGridTableStyle> obiektu do kolekcji zwróconej przez <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwości.  
  
> [!CAUTION]
>  Zawsze twórz <xref:System.Windows.Forms.DataGridColumnStyle> obiektów i dodaj je do <xref:System.Windows.Forms.GridColumnStylesCollection> przed dodaniem <xref:System.Windows.Forms.DataGridTableStyle> obiekty do <xref:System.Windows.Forms.GridTableStylesCollection>. Po dodaniu pustą <xref:System.Windows.Forms.DataGridTableStyle> przy użyciu prawidłowego <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> wartości do kolekcji, <xref:System.Windows.Forms.DataGridColumnStyle> obiekty są generowane automatycznie. W związku z tym, zostanie zgłoszony wyjątek, Jeśli spróbujesz dodać nowe <xref:System.Windows.Forms.DataGridColumnStyle> obiekty ze zduplikowanymi <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> wartości <xref:System.Windows.Forms.GridColumnStylesCollection>.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy jeden <xref:System.Windows.Forms.DataGridTableStyle> dla każdego <xref:System.Data.DataTable> w <xref:System.Data.DataSet>i ustawia <xref:System.Windows.Forms.DataGridTableStyle.MappingName%2A> z <xref:System.Windows.Forms.DataGridTableStyle> do <xref:System.Data.DataTable.TableName%2A> z <xref:System.Data.DataTable>. <xref:System.Windows.Forms.DataGridTableStyle> Jest dodawane do <xref:System.Windows.Forms.GridTableStylesCollection> zwrócone przez <xref:System.Windows.Forms.DataGrid.TableStyles%2A> właściwości. Przykład drukuje również <xref:System.Windows.Forms.DataGridColumnStyle.MappingName%2A> każdego <xref:System.Windows.Forms.DataGridColumnStyle> w <xref:System.Windows.Forms.GridColumnStylesCollection> zwrócone przez <xref:System.Windows.Forms.DataGridTableStyle.GridColumnStyles%2A> właściwości każdego <xref:System.Windows.Forms.DataGridTableStyle> w <xref:System.Windows.Forms.GridTableStylesCollection>.  
  
 [!code-cpp[Classic DataGrid.TableStyles Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic DataGrid.TableStyles Example/CPP/source.cpp#1)]
 [!code-csharp[Classic DataGrid.TableStyles Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic DataGrid.TableStyles Example/CS/source.cs#1)]
 [!code-vb[Classic DataGrid.TableStyles Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.TableStyles Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataColumn" />
        <altmember cref="T:System.Data.DataTable" />
        <altmember cref="T:System.Windows.Forms.DataGridTableStyle" />
        <altmember cref="T:System.Windows.Forms.GridTableStylesCollection" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.DataGrid.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ten element członkowski nie jest zrozumiały dla tego formantu.</summary>
        <value>Tekst skojarzony z tego formantu.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.DataGrid.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Forms.DataGrid.Text" /> zmiany właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DataGrid.Text%2A> Właściwość nie jest zrozumiały dla tej kontrolki, mimo że można zmienić jego wartość, a także obsługiwać <xref:System.Windows.Forms.DataGrid.TextChanged> zdarzenie, aby wykryć zmiany.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnSelect">
      <MemberSignature Language="C#" Value="public void UnSelect (int row);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnSelect(int32 row) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.DataGrid.UnSelect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnSelect (row As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnSelect(int row);" />
      <MemberSignature Language="F#" Value="member this.UnSelect : int -&gt; unit" Usage="dataGrid.UnSelect row" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="row" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="row">Indeks wiersza, aby usunąć zaznaczenie.</param>
        <summary>Usuwa określony wiersz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tej metody za pomocą <xref:System.Windows.Forms.DataGrid.IsSelected%2A>, <xref:System.Windows.Forms.DataGrid.Select%2A>, i <xref:System.Windows.Forms.DataGrid.ResetSelection%2A> metody do manipulowania stan zaznaczenia określonego wiersza.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego.  
  
 [!code-cpp[DataGrid_UnSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/DataGrid_UnSelect/CPP/datagrid_unselect.cpp#1)]
 [!code-csharp[DataGrid_UnSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/DataGrid_UnSelect/CS/datagrid_unselect.cs#1)]
 [!code-vb[DataGrid_UnSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/DataGrid_UnSelect/VB/datagrid_unselect.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VertScrollBar">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.ScrollBar VertScrollBar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ScrollBar VertScrollBar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.VertScrollBar" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VertScrollBar As ScrollBar" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Forms::ScrollBar ^ VertScrollBar { System::Windows::Forms::ScrollBar ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.VertScrollBar : System.Windows.Forms.ScrollBar" Usage="System.Windows.Forms.DataGrid.VertScrollBar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ScrollBar</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera pionowy pasek przewijania formantu.</summary>
        <value>Pionowe <see cref="T:System.Windows.Forms.ScrollBar" /> siatki.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.HorizScrollBar" />
      </Docs>
    </Member>
    <Member MemberName="VisibleColumnCount">
      <MemberSignature Language="C#" Value="public int VisibleColumnCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisibleColumnCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.VisibleColumnCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleColumnCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VisibleColumnCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleColumnCount : int" Usage="System.Windows.Forms.DataGrid.VisibleColumnCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę widocznych kolumn.</summary>
        <value>Liczba kolumn, które są widoczne w okienku ekranu. Okienko ekranu jest prostokątny obszar za pomocą których siatka jest widoczna. Rozmiar okienka ekranu zależy od rozmiaru <see cref="T:System.Windows.Forms.DataGrid" /> formant; Jeśli zezwolisz użytkownikom na zmienianie rozmiaru formantów, również będzie zmienione okienka ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba widocznych kolumn można zmienić w zależności od ich szerokości. Na przykład jeśli ustawiono domyślnej szerokości dla wszystkich kolumn, ale szerokość nową kolumnę ustawiono dwukrotnie tak dużej, liczbę widocznych kolumn można zmniejszyć przez co najmniej jedną.  
  
   
  
## Examples  
 Poniższy kod zwraca liczbę widocznych kolumn.  
  
 [!code-vb[Classic DataGrid.VisibleColumnCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.VisibleColumnCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGrid.FirstVisibleColumn" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleRowCount" />
      </Docs>
    </Member>
    <Member MemberName="VisibleRowCount">
      <MemberSignature Language="C#" Value="public int VisibleRowCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisibleRowCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.DataGrid.VisibleRowCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VisibleRowCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VisibleRowCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisibleRowCount : int" Usage="System.Windows.Forms.DataGrid.VisibleRowCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę wierszy jest widoczny.</summary>
        <value>Liczba wierszy widocznych w okienku ekranu. Okienko ekranu jest prostokątny obszar za pomocą których siatka jest widoczna. Rozmiar okienka ekranu zależy od rozmiaru <see cref="T:System.Windows.Forms.DataGrid" /> formant; Jeśli zezwolisz użytkownikom na zmienianie rozmiaru formantów, również będzie zmienione okienka ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Liczba widocznych wierszy może go zmienić w czasie wykonywania, jeśli użytkownik może zmienić rozmiaru <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
   
  
## Examples  
 Poniższy kod zwraca liczbę wierszy widocznych w <xref:System.Windows.Forms.DataGrid?displayProperty=nameWithType> kontroli.  
  
 [!code-vb[Classic DataGrid.VisibleRowCount Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic DataGrid.VisibleRowCount Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.DataGridTableStyle.RowHeadersVisible" />
        <altmember cref="P:System.Windows.Forms.DataGrid.VisibleColumnCount" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="CurrencyManager" FullName="System.Windows.Forms.CurrencyManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="422e723168d87108e21aa8c478d92c1e9a7270f9" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30703676" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CurrencyManager : System.Windows.Forms.BindingManagerBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CurrencyManager extends System.Windows.Forms.BindingManagerBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.CurrencyManager" />
  <TypeSignature Language="VB.NET" Value="Public Class CurrencyManager&#xA;Inherits BindingManagerBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class CurrencyManager : System::Windows::Forms::BindingManagerBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.BindingManagerBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza listą <see cref="T:System.Windows.Forms.Binding" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager> Pochodną <xref:System.Windows.Forms.BindingManagerBase> klasy. Użyj <xref:System.Windows.Forms.BindingContext> do zwrócenia albo <xref:System.Windows.Forms.CurrencyManager> lub <xref:System.Windows.Forms.PropertyManager>. Rzeczywistego obiektu zwróconego zależy od źródła danych i element członkowski danych przekazany do <xref:System.Windows.Forms.BindingContext.Item%2A> właściwość <xref:System.Windows.Forms.BindingContext>. Jeśli źródło danych jest obiekt, który może zwracać tylko jedną właściwość (zamiast listy obiektów), jest typu <xref:System.Windows.Forms.PropertyManager>. Na przykład jeśli określisz <xref:System.Windows.Forms.TextBox> jako źródło danych <xref:System.Windows.Forms.PropertyManager> zostaną zwrócone. Jeśli z drugiej strony, źródło danych jest obiekt, który implementuje <xref:System.Collections.IList>, <xref:System.ComponentModel.IListSource>, lub <xref:System.ComponentModel.IBindingList> interfejsu <xref:System.Windows.Forms.CurrencyManager> zostaną zwrócone.  
  
 <xref:System.Windows.Forms.BindingManagerBase.Current%2A> Właściwość zwraca bieżący element na liście podstawowej. Aby zmienić bieżącego elementu, ustaw <xref:System.Windows.Forms.BindingManagerBase.Position%2A> właściwości na nową wartość. Wartość musi być większa niż 0 i musi być mniejsza niż wartość <xref:System.Windows.Forms.BindingManagerBase.Count%2A> właściwości.  
  
 Jeśli implementuje źródło danych <xref:System.ComponentModel.IBindingList> interfejsu i <xref:System.ComponentModel.IBindingList.AllowNew%2A> właściwość jest ustawiona na `true`, można użyć <xref:System.Windows.Forms.CurrencyManager.AddNew%2A> metody.  
  
   
  
## Examples  
 Poniższy kod przykładowy wiązania <xref:System.Windows.Forms.TextBox> kontroli z kolumną w <xref:System.Data.DataTable>, pobiera <xref:System.Windows.Forms.CurrencyManager> dla tego powiązania i ustawia jej położenie.  
  
 [!code-cpp[Classic CurrencyManager Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
    <altmember cref="T:System.Windows.Forms.BindingContext" />
    <altmember cref="T:System.Windows.Forms.Binding" />
  </Docs>
  <Members>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public override void AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddNew();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nowy element do listy źródłowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy źródło danych implementuje <xref:System.ComponentModel.IBindingList> interfejsu i źródło danych umożliwia dodawanie wierszy (<xref:System.ComponentModel.IBindingList.AllowNew%2A> jest `true`).  
  
> [!NOTE]
>  Ta właściwość zaprojektowano tak, aby umożliwić formanty powiązane z złożonych, takie jak <xref:System.Windows.Forms.DataGrid> sterowania do dodawania nowych elementów do listy.  
  
 Zwykle ta właściwość jest używana tylko w przypadku tworzenia własnego formantu, która będzie zawierała <xref:System.Windows.Forms.CurrencyManager>. W przeciwnym razie do dodawania elementów, jeśli źródło danych jest <xref:System.Data.DataView>, użyj <xref:System.Data.DataView.AddNew%2A?displayProperty=nameWithType> metody <xref:System.Data.DataView> klasy. Jeśli źródło danych jest <xref:System.Data.DataTable>, użyj <xref:System.Data.DataTable.NewRow%2A> — metoda i dodać wiersz do <xref:System.Data.DataRowCollection>.  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje nowy element do listy z <xref:System.Windows.Forms.CurrencyManager.AddNew%2A> metody.  
  
 [!code-cpp[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Źródła danych nie implementuje <see cref="T:System.ComponentModel.IBindingList" />, lub źródło danych zgłosił wyjątek, ponieważ użytkownik próbował dodać wiersz do tylko do odczytu lub stałym rozmiarze <see cref="T:System.Data.DataView" />.</exception>
        <altmember cref="P:System.ComponentModel.IBindingList.AllowNew" />
        <altmember cref="M:System.Data.DataView.AddNew" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <Member MemberName="CancelCurrentEdit">
      <MemberSignature Language="C#" Value="public override void CancelCurrentEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CancelCurrentEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.CancelCurrentEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CancelCurrentEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CancelCurrentEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie bieżącej operacji edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy obiekty zawarte źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejsu. Jeśli obiektów zawartych w źródle danych nie implementuje <xref:System.ComponentModel.IEditableObject> interfejsu, zmiany wprowadzone dane nie zostaną odrzucone.  
  
> [!NOTE]
>  Ta właściwość została zaprojektowana do użycia przez złożonych kontrolek powiązanych z danymi, takich jak <xref:System.Windows.Forms.DataGrid> sterowania, aby anulować edycję. Na przykład, gdy użytkownik naciśnie klawisz ESC <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> wywoływana jest metoda <xref:System.Windows.Forms.CurrencyManager> dla <xref:System.Windows.Forms.DataGrid>. Jeśli tworzysz formant, który wymaga tej samej funkcji, nie należy używać tej metody. Zamiast tego należy użyć <xref:System.Data.DataRowView.CancelEdit%2A> metody <xref:System.Data.DataRowView> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> po naciśnięciu klawisza ESC.  
  
 [!code-cpp[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.EndCurrentEdit" />
      </Docs>
    </Member>
    <Member MemberName="CheckEmpty">
      <MemberSignature Language="C#" Value="protected void CheckEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CheckEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.CheckEmpty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CheckEmpty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CheckEmpty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek, jeśli nie są znane lub lista jest pusta.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Exception">Nie są znane, lub lista jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public override int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów na liście.</summary>
        <value>Liczba elementów na liście.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość liczba służy do określenia, kiedy osiągnięto koniec listy. Ponieważ <xref:System.Windows.Forms.CurrencyManager> przechowuje 0 tablicę elementów, koniec listy jest zawsze <xref:System.Windows.Forms.CurrencyManager.Count%2A> minus jeden.  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje po liście do końcowego elementu ustalona przez <xref:System.Windows.Forms.CurrencyManager.Count%2A> właściwości, który limit zostanie osiągnięty.  
  
 [!code-cpp[Classic CurrencyManager.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public override object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Current" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element na liście.</summary>
        <value>Element listy typu <see cref="T:System.Object" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać bieżącego elementu, aby można było ją poprawnie rzutowania trzeba znać jego typu danych. Na przykład, jeśli źródło danych jest <xref:System.Data.DataView> lub <xref:System.Data.DataTable>, należy rzutować bieżącego elementu jako <xref:System.Data.DataRowView> obiektu.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.CurrencyManager.Current%2A> właściwość do wydrukowania `ContactName` dla bieżącego elementu na liście pole.  
  
 [!code-cpp[Classic CurrencyManager.Current Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Current Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Current Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataRowView" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="EndCurrentEdit">
      <MemberSignature Language="C#" Value="public override void EndCurrentEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndCurrentEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.EndCurrentEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndCurrentEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndCurrentEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kończy operację edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy obiekty zawarte źródło danych implementuje <xref:System.ComponentModel.IEditableObject> lub <xref:System.ComponentModel.ICancelAddNew> interfejsów.  
  
> [!NOTE]
>  Ta właściwość została zaprojektowana do użycia przez złożonych kontrolek powiązanych z danymi, takich jak <xref:System.Windows.Forms.DataGridView> formantu. Jeśli tworzysz formant, który wymaga tej samej funkcji, nie należy używać tej metody. Zamiast tego Jeśli źródło danych <xref:System.Data.DataView> lub <xref:System.Data.DataTable>, użyj <xref:System.Data.DataRowView.EndEdit%2A> metody <xref:System.Data.DataRowView> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Windows.Forms.CurrencyManager.EndCurrentEdit%2A> metody.  
  
 [!code-cpp[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.CancelCurrentEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="T:System.ComponentModel.ICancelAddNew" />
      </Docs>
    </Member>
    <Member MemberName="finalType">
      <MemberSignature Language="C#" Value="protected Type finalType;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type finalType" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.CurrencyManager.finalType" />
      <MemberSignature Language="VB.NET" Value="Protected finalType As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ finalType;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa typ danych listy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.PropertyDescriptorCollection GetItemProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetItemProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję deskryptora właściwości listy źródłowej.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla listy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptorCollection> Dla <xref:System.Windows.Forms.CurrencyManager> służy do określania kolumny na liście.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.CurrencyManager.GetItemProperties%2A> metodę, aby zwrócić <xref:System.ComponentModel.PropertyDescriptorCollection> dla <xref:System.Windows.Forms.BindingManagerBase>. Przykład następnie do drukowania <xref:System.ComponentModel.MemberDescriptor.Name%2A> i <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A> każdego <xref:System.ComponentModel.PropertyDescriptor> w kolekcji.  
  
 [!code-cpp[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetListName(System.Collections.ArrayList)" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="protected internal override string GetListName (System.Collections.ArrayList listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance string GetListName(class System.Collections.ArrayList listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.GetListName(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetListName (listAccessors As ArrayList) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::String ^ GetListName(System::Collections::ArrayList ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="listAccessors">
          <see cref="T:System.Collections.ArrayList" /> Właściwości można znaleźć w źródle danych.</param>
        <summary>Pobiera nazwę listy dostarczająca dane przy użyciu określonego zestawu powiązanych właściwości powiązania.</summary>
        <returns>W przypadku powodzenia <see cref="T:System.String" /> zawierający nazwę listy dostarczająca dane dla powiązania; w przeciwnym razie <see cref="F:System.String.Empty" /> ciągu.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać <xref:System.Windows.Forms.CurrencyManager.GetListName%2A> metody było pomyślne, lista podstawowa musi być typu <xref:System.ComponentModel.ITypedList>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      </Docs>
    </Member>
    <Member MemberName="ItemChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ItemChangedEventHandler ItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ItemChangedEventHandler ItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ItemChanged As ItemChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ItemChangedEventHandler ^ ItemChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ItemChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy bieżący element został zmieniony.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.ItemChanged> Zdarzenie wystąpi, gdy użytkownik wywołuje <xref:System.Windows.Forms.BindingManagerBase.ResumeBinding%2A> lub <xref:System.Windows.Forms.BindingManagerBase.SuspendBinding%2A> metody.  
  
 <xref:System.Windows.Forms.CurrencyManager.ItemChanged> Zdarzenie, tylko gdy elementu została zmieniona w jakikolwiek sposób. Na przykład jeśli wartość elementu zostanie zmieniona od 10 do 42, zdarzenie zostanie przeprowadzona. To nie należy mylić z <xref:System.Windows.Forms.BindingManagerBase.PositionChanged> zdarzeń, w którym element został zmieniony na nowy element.  
  
 Zdarzenie wystąpi także w przypadku zmiany danych. Na przykład w przypadku zmiany wartości <xref:System.Data.DataRowView>, <xref:System.Windows.Forms.CurrencyManager.ItemChanged> wystąpi zdarzenie.  
  
> [!NOTE]
>  W przypadku tworzenia własnego formantu, który używa <xref:System.Windows.Forms.CurrencyManager>, należy użyć <xref:System.ComponentModel.IBindingList.ListChanged?displayProperty=nameWithType> zamiast <xref:System.Windows.Forms.CurrencyManager.ItemChanged?displayProperty=nameWithType> zdarzeń. <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType%2A> Właściwość <xref:System.ComponentModel.ListChangedEventArgs> umożliwia określenie typu akcji, który wystąpił.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje obsługę zdarzeń <xref:System.Windows.Forms.CurrencyManager.ItemChanged> i <xref:System.Windows.Forms.BindingManagerBase.PositionChanged> zdarzenia.  
  
 [!code-cpp[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę dla tego <see cref="T:System.Windows.Forms.CurrencyManager" />.</summary>
        <value>
          <see cref="T:System.Collections.IList" /> Zawierający listę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony przez <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwości mogą być rzutowane na dowolnego typu, który implementuje <xref:System.Collections.IList> interfejsu. Będzie często używany, gdy wiesz typu listy źródłowej. Na przykład, jeśli użytkownik jest powiązany z danymi <xref:System.Data.DataSet>, jest lista podstawowa <xref:System.Data.DataView> (które implementuje <xref:System.Collections.IList>). Inne klasy, które implementują interfejs (nie jest to pełna lista) obejmują <xref:System.Array>, <xref:System.Collections.ArrayList>, i <xref:System.Collections.CollectionBase>.  
  
 Jak używać <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwość zależy od klasy, która implementuje <xref:System.Collections.IList> interfejsu. Na przykład można użyć <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwości można ustalić nazwy wykazu. Jeśli źródło danych implementuje <xref:System.ComponentModel.ITypedList> interfejsu, można użyć <xref:System.ComponentModel.ITypedList.GetListName%2A> metodę, aby zwrócić nazwę bieżącej tabeli. Przedstawiono to w języku C# poniższy kod:  
  
```csharp  
private void PrintCurrentListName(DataGrid myDataGrid){   
   CurrencyManager myCM = (CurrencyManager)   
   BindingContext[myDataGrid.DataSource, myDataGrid.DataMember];   
   IList myList = myCM.List;   
   ITypedList thisList = (ITypedList) myList;   
   Console.WriteLine(thisList.GetListName(null));   
}  
```  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikom edytowanie zestawu rekordów, ale nie dodawać nowych użytkowników. W <xref:System.Windows.Forms.DataGrid.Navigate> zdarzenie <xref:System.Windows.Forms.DataGrid> kontroli, <xref:System.Collections.IList> zwrócony przez <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwości jest rzutowane na <xref:System.Data.DataView> zmiennej. <xref:System.Data.DataView.AllowNew%2A> Właściwość <xref:System.Data.DataView> ma ustawioną wartość `false`.  
  
 [!code-cpp[CurrencyManager.List Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CurrencyManager.List Example/CPP/list.cpp#1)]
 [!code-csharp[CurrencyManager.List Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CurrencyManager.List Example/CS/list.cs#1)]
 [!code-vb[CurrencyManager.List Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CurrencyManager.List Example/VB/list.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy lista zmian lub element listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.ListChanged> Zdarzeń jest generowany przez <xref:System.Windows.Forms.CurrencyManager> klasy, gdy element zmiany przy użyciu metod, takich jak <xref:System.Windows.Forms.CurrencyManager.EndCurrentEdit%2A>, <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A>, i <xref:System.Windows.Forms.CurrencyManager.Refresh%2A>. To zdarzenie może również wystąpić, gdy źródło danych jest edytowany bezpośrednio, jeśli implementuje <xref:System.ComponentModel.IBindingListView> interfejsu.  
  
 Skojarzony `OnListChanged` metoda jest metodą prywatnych w tej klasie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.CurrencyManager> o nazwie `CurrencyManager1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#192](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#192)]
 [!code-vb[System.Windows.Forms.EventExamples#192](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#192)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="listposition">
      <MemberSignature Language="C#" Value="protected int listposition;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 listposition" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.CurrencyManager.listposition" />
      <MemberSignature Language="VB.NET" Value="Protected listposition As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int listposition;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa bieżące położenie <see cref="T:System.Windows.Forms.CurrencyManager" /> na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Windows.Forms.CurrencyManager.Count%2A> właściwości jest większa niż 0, <xref:System.Windows.Forms.CurrencyManager.listposition> pole jest liczbą z zakresu od 0 i <xref:System.Windows.Forms.CurrencyManager.Count%2A> pomniejszonej o 1. Jeśli <xref:System.Windows.Forms.CurrencyManager.Count%2A> ma wartość 0, <xref:System.Windows.Forms.CurrencyManager.listposition> wynosi -1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
      </Docs>
    </Member>
    <Member MemberName="MetaDataChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MetaDataChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MetaDataChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.MetaDataChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MetaDataChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MetaDataChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy metadane <see cref="P:System.Windows.Forms.CurrencyManager.List" /> została zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane <xref:System.Windows.Forms.CurrencyManager.List%2A> składa się z schematu podstawowych <xref:System.Windows.Forms.Binding.DataSource%2A?displayProperty=nameWithType>. <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> Zdarzenie jest wywoływane po zmianie tego schematu. Na przykład <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> zdarzenie jest zgłaszane, gdy <xref:System.Data.DataColumn> dodać programistycznie do <xref:System.Data.DataTable>.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.CurrencyManager> o nazwie `CurrencyManager1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#193](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#193)]
 [!code-vb[System.Windows.Forms.EventExamples#193](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#193)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnCurrentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingManagerBase.CurrentItemChanged" /> zdarzeń.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemChanged (System.Windows.Forms.ItemChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemChanged(class System.Windows.Forms.ItemChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemChanged (e As ItemChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemChanged(System::Windows::Forms::ItemChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ItemChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.Windows.Forms.ItemChangedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.CurrencyManager.OnItemChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMetaDataChanged">
      <MemberSignature Language="C#" Value="protected internal void OnMetaDataChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void OnMetaDataChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub OnMetaDataChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void OnMetaDataChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.CurrencyManager.MetaDataChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.CurrencyManager.OnMetaDataChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.CurrencyManager.OnPositionChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Position { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie jest na liście.</summary>
        <value>Liczbą z zakresu od 0 i <see cref="P:System.Windows.Forms.CurrencyManager.Count" /> pomniejszonej o 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ważną właściwością <xref:System.Windows.Forms.CurrencyManager> jest klasa <xref:System.Windows.Forms.CurrencyManager.Position%2A> właściwości. Na liście elementów można wyświetlić tylko jeden element z listy całego. Aby ustalić, który jest wyświetlany, ustaw <xref:System.Windows.Forms.CurrencyManager.Position%2A> do liczbą z zakresu od 0 (początku listy) i <xref:System.Windows.Forms.CurrencyManager.Count%2A> minus 1 (koniec listy).  
  
 W związku z tym <xref:System.Windows.Forms.CurrencyManager.Position%2A> określa walutowych lub miejsce na liście wszystkich kontrolek powiązanych do tej samej <xref:System.Windows.Forms.CurrencyManager>. Załóżmy na przykład listę składającą się z dwóch kolumn o nazwie "Imię" i "Nazwisko". Dwa <xref:System.Windows.Forms.TextBox> formantów powiązanych z tej samej listy; pierwszego kontrolka jest powiązana z pierwszej kolumny, a drugi kontrolka jest powiązana z drugiej kolumny. Gdy <xref:System.Windows.Forms.CurrencyManager.Position%2A> typowe <xref:System.Windows.Forms.CurrencyManager> jest ustawiony do położenia trzeci oba formanty wyświetlić odpowiednie wartości dla tej pozycji na liście. Innymi słowy Jeśli element na pozycji trzech składa się z "Jan" imię i nazwisko "Smith", formanty powiązane wyświetli "Jan" i "Smith".  
  
   
  
## Examples  
 Poniższy kod przykłady użycia <xref:System.Windows.Forms.CurrencyManager.Position%2A> właściwości, aby umożliwić przeglądanie za pomocą listy.  
  
 [!code-cpp[Classic CurrencyManager.Position Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Position Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Position Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymuszenie odnowienia populacji listy powiązane z danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.CurrencyManager.Refresh%2A> metody, gdy źródło danych nie obsługuje powiadomienie, gdy jest zmieniana (na przykład, jeśli jest <xref:System.Array>).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę i wiąże go do <xref:System.Windows.Forms.TextBox> sterowania, a następnie zmiany jedną wartość. <xref:System.Windows.Forms.CurrencyManager.Refresh%2A> Można wywołać metody, aby zaktualizować wartości wyświetlanej przez <xref:System.Windows.Forms.TextBox> formantu.  
  
 [!code-cpp[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public override void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu do usunięcia z listy.</param>
        <summary>Usuwa element pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.RemoveAt%2A> — Metoda zaprojektowano tak, aby umożliwić formantów złożonych, takie jak <xref:System.Windows.Forms.DataGrid> sterowania, aby usunąć elementy z listy. Nie należy używać tej metody można usuwać elementów. Zamiast tego należy użyć <xref:System.Data.DataView.Delete%2A> metody <xref:System.Data.DataView> klasę, aby usunąć elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.CurrencyManager.RemoveAt%2A> metodę, aby usunąć element na pozycji 0 na liście.  
  
 [!code-cpp[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Brak wiersza w określonym <paramref name="index" />.</exception>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.AddNew" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public override void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResumeBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia wiązania z danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> i <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> przy użyciu dwóch metod umożliwiających tymczasowe zawieszenia i wznowienia scenariusz wiązania proste danych. Powiązanie danych będzie zazwyczaj zawiesić, jeśli użytkownik musi mieć możliwość dokonaj edycji kilka do pola danych, zanim nastąpi jego poprawności. Na przykład jeśli jedno pole musi zostać zmieniona zgodnie z drugiej, ale sprawdzanie poprawności pierwsze pole spowodowałoby drugie pole jest błędny.  
  
> [!NOTE]
>  Przy użyciu <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> uniemożliwia przekazywanej do źródła danych do czasu zmiany <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> zostaje wywołany, ale nie uniemożliwia zmian w źródle danych mające wpływ na formanty powiązane. Formanty używające złożone powiązanie danych, takich jak <xref:System.Windows.Forms.DataGridView> kontrolować, zaktualizuj swoje wartości oparte na zdarzenia zmiany, takie jak <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń. Wywołanie tej metody nie uniemożliwi tych zdarzeń występujących. Z tego powodu <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> i <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> są przeznaczone do użytku z formantów powiązanych z prostego, takich jak <xref:System.Windows.Forms.TextBox>. Możesz też użyć tych metod w scenariuszu złożone powiązanie Jeśli można pominąć <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia przez ustawienie <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwości `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> metody.  
  
 [!code-cpp[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/cpp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CPP/bindingmanagerbase_suspend_resume_binding.cpp#2)]
 [!code-csharp[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/csharp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CS/bindingmanagerbase_suspend_resume_binding.cs#2)]
 [!code-vb[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/VB/bindingmanagerbase_suspend_resume_binding.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.BindingComplete" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.UpdateIsBinding" />
        <altmember cref="P:System.Windows.Forms.BindingManagerBase.Bindings" />
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public override void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SuspendBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje powiązania uniemożliwia zmiany aktualizowanie źródła danych powiązania danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> metody umożliwiają tymczasowego zawieszenia i wznowienia powiązanie danych w scenariuszu proste powiązanie. Powiązanie danych będzie zazwyczaj zawiesić, jeśli użytkownik przed należy wykonać kilka zmian do pól danych sprawdzanie poprawności jest wykonywane. Na przykład jeśli jedno pole musi zostać zmieniona zgodnie z drugiej, ale sprawdzanie poprawności pierwsze pole spowodowałoby drugie pole jest błędny.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> Zapobiega są stosowane do źródła danych do czasu zmiany <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> jest wywoływana, ale nie faktycznie zapobiega zdarzeń występujących. Formanty używające złożone powiązanie danych, takich jak <xref:System.Windows.Forms.DataGridView> sterowania, aby zaktualizować ich na podstawie zmiany zdarzeń, takich jak <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń. W związku z tym wywołaniem <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> nie uniemożliwi formanty powiązane z złożone odbieranie zdarzeń do aktualizowania źródła danych. Z tego powodu <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użytku z formantów powiązanych z prostego, takich jak <xref:System.Windows.Forms.TextBox> formantu. Możesz też użyć tych metod w scenariuszu złożone powiązanie Jeśli można pominąć <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia przez ustawienie <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwości `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> metody.  
  
 [!code-cpp[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/cpp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CPP/bindingmanagerbase_suspend_resume_binding.cpp#1)]
 [!code-csharp[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/csharp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CS/bindingmanagerbase_suspend_resume_binding.cs#1)]
 [!code-vb[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/VB/bindingmanagerbase_suspend_resume_binding.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.BindingComplete" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.UpdateIsBinding" />
        <altmember cref="P:System.Windows.Forms.BindingManagerBase.Bindings" />
      </Docs>
    </Member>
    <Member MemberName="UpdateIsBinding">
      <MemberSignature Language="C#" Value="protected override void UpdateIsBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateIsBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.UpdateIsBinding" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateIsBinding ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateIsBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualizuje stan powiązania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
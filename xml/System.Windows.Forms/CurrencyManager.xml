<Type Name="CurrencyManager" FullName="System.Windows.Forms.CurrencyManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="69713937ad98d9549f0f3de3ee8e5d682c1c083f" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69194306" /></Metadata><TypeSignature Language="C#" Value="public class CurrencyManager : System.Windows.Forms.BindingManagerBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CurrencyManager extends System.Windows.Forms.BindingManagerBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.CurrencyManager" />
  <TypeSignature Language="VB.NET" Value="Public Class CurrencyManager&#xA;Inherits BindingManagerBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class CurrencyManager : System::Windows::Forms::BindingManagerBase" />
  <TypeSignature Language="F#" Value="type CurrencyManager = class&#xA;    inherit BindingManagerBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.BindingManagerBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Zarządza listą <see cref="T:System.Windows.Forms.Binding" /> obiektów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager> Dziedziczy<xref:System.Windows.Forms.BindingManagerBase> z klasy. Użyj, <xref:System.Windows.Forms.BindingContext> aby zwrócić <xref:System.Windows.Forms.CurrencyManager> albo lub <xref:System.Windows.Forms.PropertyManager>. Rzeczywisty zwrócony obiekt zależy od źródła danych i elementu członkowskiego danych przekazana do <xref:System.Windows.Forms.BindingContext.Item%2A> właściwości. <xref:System.Windows.Forms.BindingContext> Jeśli źródło danych jest obiektem, który może zwrócić tylko jedną właściwość (zamiast listy obiektów), typ będzie <xref:System.Windows.Forms.PropertyManager>. Na przykład, jeśli określisz <xref:System.Windows.Forms.TextBox> jako źródło danych <xref:System.Windows.Forms.PropertyManager> , zostanie zwrócone. Jeśli z drugiej strony, źródło <xref:System.Collections.IList>danych jest obiektem, który implementuje interfejs, <xref:System.ComponentModel.IListSource> <xref:System.Windows.Forms.CurrencyManager> , lub <xref:System.ComponentModel.IBindingList> , zostanie zwrócony.  
  
 <xref:System.Windows.Forms.BindingManagerBase.Current%2A> Właściwość zwraca bieżący element na liście podstawowej. Aby zmienić bieżący element, należy ustawić <xref:System.Windows.Forms.BindingManagerBase.Position%2A> nową wartość właściwości. Wartość musi być większa niż 0 i musi być mniejsza niż wartość <xref:System.Windows.Forms.BindingManagerBase.Count%2A> właściwości.  
  
 Jeśli bazowe <xref:System.ComponentModel.IBindingList> źródło danych implementuje interfejs, <xref:System.ComponentModel.IBindingList.AllowNew%2A> a właściwość jest ustawiona na `true`, można użyć <xref:System.Windows.Forms.CurrencyManager.AddNew%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wiąże <xref:System.Windows.Forms.TextBox> formant z kolumną <xref:System.Data.DataTable>w, pobiera <xref:System.Windows.Forms.CurrencyManager> dla powiązania i ustawia jego pozycję.  
  
 [!code-cpp[Classic CurrencyManager Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingsCollection" />
    <altmember cref="T:System.Windows.Forms.BindingContext" />
    <altmember cref="T:System.Windows.Forms.Binding" />
  </Docs>
  <Members>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public override void AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub AddNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void AddNew();" />
      <MemberSignature Language="F#" Value="override this.AddNew : unit -&gt; unit" Usage="currencyManager.AddNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nowy element do listy podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy źródło danych implementuje <xref:System.ComponentModel.IBindingList> interfejs, a źródło danych umożliwia dodawanie wierszy (<xref:System.ComponentModel.IBindingList.AllowNew%2A> is `true`).  
  
> [!NOTE]
>  Ta właściwość została zaprojektowana tak, aby umożliwiała złożone kontrolki <xref:System.Windows.Forms.DataGrid> , takie jak kontrolka, dodawanie nowych elementów do listy.  
  
 Ta właściwość jest zazwyczaj używana tylko wtedy, gdy tworzysz własny formant, który obejmuje <xref:System.Windows.Forms.CurrencyManager>. W przeciwnym razie aby dodać elementy <xref:System.Data.DataView>, jeśli źródło danych jest, <xref:System.Data.DataView.AddNew%2A?displayProperty=nameWithType> Użyj metody <xref:System.Data.DataView> klasy. Jeśli źródło danych to <xref:System.Data.DataTable>, <xref:System.Data.DataTable.NewRow%2A> Użyj metody i <xref:System.Data.DataRowCollection>Dodaj wiersz do.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nowy element do listy za pomocą <xref:System.Windows.Forms.CurrencyManager.AddNew%2A> metody.  
  
 [!code-cpp[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.AddNew Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.AddNew Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Bazowe źródło danych nie implementuje <see cref="T:System.ComponentModel.IBindingList" />programu lub źródło danych zgłosiło wyjątek, ponieważ użytkownik próbował dodać wiersz do tylko do odczytu lub o stałym rozmiarze. <see cref="T:System.Data.DataView" /></exception>
        <altmember cref="P:System.ComponentModel.IBindingList.AllowNew" />
        <altmember cref="M:System.Data.DataView.AddNew" />
        <altmember cref="M:System.Data.DataTable.NewRow" />
      </Docs>
    </Member>
    <Member MemberName="CancelCurrentEdit">
      <MemberSignature Language="C#" Value="public override void CancelCurrentEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void CancelCurrentEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.CancelCurrentEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub CancelCurrentEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void CancelCurrentEdit();" />
      <MemberSignature Language="F#" Value="override this.CancelCurrentEdit : unit -&gt; unit" Usage="currencyManager.CancelCurrentEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje bieżącą operację edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy obiekty zawarte w źródle danych implementują <xref:System.ComponentModel.IEditableObject> interfejs. Jeśli obiekty zawarte w źródle danych nie implementują <xref:System.ComponentModel.IEditableObject> interfejsu, zmiany wprowadzone w danych nie zostaną odrzucone.  
  
> [!NOTE]
>  Ta właściwość została zaprojektowana do użycia przez złożone kontrolki powiązane z danymi, takie <xref:System.Windows.Forms.DataGrid> jak kontrolka, aby anulować edycję. Na przykład po naciśnięciu klawisza ESC <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> przez użytkownika Metoda jest wywoływana <xref:System.Windows.Forms.CurrencyManager> dla elementu <xref:System.Windows.Forms.DataGrid>. Nie należy używać tej metody, chyba że tworzysz kontrolkę wymagającą tych samych funkcji. Zamiast tego należy użyć <xref:System.Data.DataRowView.CancelEdit%2A> metody <xref:System.Data.DataRowView> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu używa, <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> gdy użytkownik naciśnie klawisz ESC.  
  
 [!code-cpp[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.CancelCurrentEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.CancelCurrentEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.EndCurrentEdit" />
      </Docs>
    </Member>
    <Member MemberName="CheckEmpty">
      <MemberSignature Language="C#" Value="protected void CheckEmpty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CheckEmpty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.CheckEmpty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CheckEmpty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CheckEmpty();" />
      <MemberSignature Language="F#" Value="member this.CheckEmpty : unit -&gt; unit" Usage="currencyManager.CheckEmpty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zgłasza wyjątek, jeśli nie ma listy lub lista jest pusta.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Exception">Nie ma listy lub lista jest pusta.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public override int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Forms.CurrencyManager.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera liczbę elementów na liście.</summary>
        <value>Liczba elementów na liście.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości count, aby określić, kiedy zostanie osiągnięty koniec listy. Ponieważ utrzymuje tablicę elementów na podstawie 0, koniec listy jest zawsze <xref:System.Windows.Forms.CurrencyManager.Count%2A> pomniejszony o jeden. <xref:System.Windows.Forms.CurrencyManager>  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje przez listę do momentu, aż końcowy element, określony przez <xref:System.Windows.Forms.CurrencyManager.Count%2A> właściwość, zostanie osiągnięty.  
  
 [!code-cpp[Classic CurrencyManager.Count Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Count Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Count Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Count Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public override object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Current" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : obj" Usage="System.Windows.Forms.CurrencyManager.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element z listy.</summary>
        <value>Element listy typu <see cref="T:System.Object" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać bieżący element, musisz znać jego typ danych w celu poprawnego rzutowania. Na przykład, jeśli źródło danych to <xref:System.Data.DataView> lub <xref:System.Data.DataTable>, należy rzutować bieżący element jako <xref:System.Data.DataRowView> obiekt.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.CurrencyManager.Current%2A> właściwości do `ContactName` drukowania pola dla bieżącego elementu na liście.  
  
 [!code-cpp[Classic CurrencyManager.Current Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Current Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Current Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Current Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Data.DataRowView" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="EndCurrentEdit">
      <MemberSignature Language="C#" Value="public override void EndCurrentEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndCurrentEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.EndCurrentEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub EndCurrentEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void EndCurrentEdit();" />
      <MemberSignature Language="F#" Value="override this.EndCurrentEdit : unit -&gt; unit" Usage="currencyManager.EndCurrentEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zamyka bieżącą operację edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest obsługiwana tylko wtedy, gdy obiekty zawarte w źródle danych implementują <xref:System.ComponentModel.IEditableObject> interfejsy <xref:System.ComponentModel.ICancelAddNew> lub.  
  
> [!NOTE]
>  Ta właściwość została zaprojektowana tak, aby była używana przez złożone kontrolki powiązane z <xref:System.Windows.Forms.DataGridView> danymi, takie jak kontrolka. Nie należy używać tej metody, chyba że tworzysz kontrolkę wymagającą tych samych funkcji. Zamiast tego, jeśli <xref:System.Data.DataView> źródło danych jest albo lub <xref:System.Data.DataTable>, <xref:System.Data.DataRowView> Użyj <xref:System.Data.DataRowView.EndEdit%2A> metody klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.CurrencyManager.EndCurrentEdit%2A> metody.  
  
 [!code-cpp[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.EndCurrentEdit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.EndCurrentEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.CancelCurrentEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="T:System.ComponentModel.ICancelAddNew" />
      </Docs>
    </Member>
    <Member MemberName="finalType">
      <MemberSignature Language="C#" Value="protected Type finalType;" />
      <MemberSignature Language="ILAsm" Value=".field family class System.Type finalType" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.CurrencyManager.finalType" />
      <MemberSignature Language="VB.NET" Value="Protected finalType As Type " />
      <MemberSignature Language="C++ CLI" Value="protected: Type ^ finalType;" />
      <MemberSignature Language="F#" Value="val mutable finalType : Type" Usage="System.Windows.Forms.CurrencyManager.finalType" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa typ danych listy.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.PropertyDescriptorCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.PropertyDescriptorCollection GetItemProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetItemProperties () As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties();" />
      <MemberSignature Language="F#" Value="override this.GetItemProperties : unit -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="currencyManager.GetItemProperties " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kolekcję deskryptora właściwości dla listy podstawowej.</summary>
        <returns>A <see cref="T:System.ComponentModel.PropertyDescriptorCollection" /> dla listy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.PropertyDescriptorCollection> Dlaelementusłużydo<xref:System.Windows.Forms.CurrencyManager> określenia kolumny na liście.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.CurrencyManager.GetItemProperties%2A> metody do <xref:System.ComponentModel.PropertyDescriptorCollection> zwrócenia dla a <xref:System.Windows.Forms.BindingManagerBase>. Przykład następnie drukuje <xref:System.ComponentModel.MemberDescriptor.Name%2A> i <xref:System.ComponentModel.PropertyDescriptor.PropertyType%2A> każdego z nich <xref:System.ComponentModel.PropertyDescriptor> w kolekcji.  
  
 [!code-cpp[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.GetItemProperties Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.GetItemProperties Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetListName(System.Collections.ArrayList)" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="protected internal override string GetListName (System.Collections.ArrayList listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance string GetListName(class System.Collections.ArrayList listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.GetListName(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetListName (listAccessors As ArrayList) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::String ^ GetListName(System::Collections::ArrayList ^ listAccessors);" />
      <MemberSignature Language="F#" Value="override this.GetListName : System.Collections.ArrayList -&gt; string" Usage="currencyManager.GetListName listAccessors" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="listAccessors"><see cref="T:System.Collections.ArrayList" /> Właściwości, które mają zostać znalezione w źródle danych.</param>
        <summary>Pobiera nazwę listy dostarczającej dane dla powiązania przy użyciu określonego zestawu właściwości powiązanych.</summary>
        <returns>Jeśli to <see cref="T:System.String" /> się powiedzie, zawierająca nazwę listy dostarczającej dane dla powiązania; w przeciwnym razie <see cref="F:System.String.Empty" /> ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby Metoda zakończyła się pomyślnie, podstawowa lista musi być typu <xref:System.ComponentModel.ITypedList>. <xref:System.Windows.Forms.CurrencyManager.GetListName%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.GetItemProperties" />
      </Docs>
    </Member>
    <Member MemberName="ItemChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ItemChangedEventHandler ItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ItemChangedEventHandler ItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ItemChanged As ItemChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ItemChangedEventHandler ^ ItemChanged;" />
      <MemberSignature Language="F#" Value="member this.ItemChanged : System.Windows.Forms.ItemChangedEventHandler " Usage="member this.ItemChanged : System.Windows.Forms.ItemChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ItemChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie pojawi się, gdy użytkownik <xref:System.Windows.Forms.BindingManagerBase.ResumeBinding%2A> wywoła metodę lub <xref:System.Windows.Forms.BindingManagerBase.SuspendBinding%2A>. <xref:System.Windows.Forms.CurrencyManager.ItemChanged>  
  
 <xref:System.Windows.Forms.CurrencyManager.ItemChanged> Zdarzenie występuje tylko wtedy, gdy sam element został zmieniony w jakiś sposób. Na przykład jeśli wartość elementu jest zmieniana z 10 na 42, zdarzenie zostanie wykonane. Nie należy mylić tego <xref:System.Windows.Forms.BindingManagerBase.PositionChanged> zdarzenia ze zdarzeniem, w którym element został zmieniony na nowy element.  
  
 To zdarzenie również będzie miało miejsce, jeśli dane bazowe zmienią się. Na przykład jeśli zmienisz wartość a <xref:System.Data.DataRowView> <xref:System.Windows.Forms.CurrencyManager.ItemChanged> , zdarzenie zostanie wykonane.  
  
> [!NOTE]
>  Jeśli tworzysz własny formant, który używa <xref:System.Windows.Forms.CurrencyManager>, należy <xref:System.ComponentModel.IBindingList.ListChanged?displayProperty=nameWithType> użyć zamiast <xref:System.Windows.Forms.CurrencyManager.ItemChanged?displayProperty=nameWithType> niego zdarzenia. <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType%2A> Właściwość w<xref:System.ComponentModel.ListChangedEventArgs> programie umożliwia określenie typu akcji, która wystąpiła.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje obsługę zdarzeń dla <xref:System.Windows.Forms.CurrencyManager.ItemChanged> zdarzeń i. <xref:System.Windows.Forms.BindingManagerBase.PositionChanged>  
  
 [!code-cpp[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.ItemChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.ItemChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.List : System.Collections.IList" Usage="System.Windows.Forms.CurrencyManager.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę dla tego <see cref="T:System.Windows.Forms.CurrencyManager" />elementu.</summary>
        <value><see cref="T:System.Collections.IList" /> Zawierający listę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obiekt zwrócony przez <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwość może być rzutowany do dowolnego typu, który <xref:System.Collections.IList> implementuje interfejs. Ta wartość będzie często używana w przypadku poznania typu podstawowej listy. Na przykład jeśli dane są powiązane z <xref:System.Data.DataSet>, podstawową listą <xref:System.Data.DataView> jest (która implementuje <xref:System.Collections.IList>). Inne klasy implementujące interfejs (nie jest to kompletna lista) obejmują <xref:System.Array>, <xref:System.Collections.ArrayList>, i <xref:System.Collections.CollectionBase>.  
  
 Sposób użycia <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwości zależy od klasy, która <xref:System.Collections.IList> implementuje interfejs. Na przykład można użyć <xref:System.Windows.Forms.CurrencyManager.List%2A> właściwości, aby określić nazwę listy. Jeśli źródło danych implementuje <xref:System.ComponentModel.ITypedList> interfejs, można <xref:System.ComponentModel.ITypedList.GetListName%2A> użyć metody, aby zwrócić nazwę bieżącej tabeli. Pokazano to w poniższym C# kodzie:  
  
```csharp  
private void PrintCurrentListName(DataGrid myDataGrid){   
   CurrencyManager myCM = (CurrencyManager)   
   BindingContext[myDataGrid.DataSource, myDataGrid.DataMember];   
   IList myList = myCM.List;   
   ITypedList thisList = (ITypedList) myList;   
   Console.WriteLine(thisList.GetListName(null));   
}  
```  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia użytkownikom edytowanie zestawu rekordów, ale nie dodaje żadnych nowych. <xref:System.Windows.Forms.DataGrid.Navigate> W przypadku <xref:System.Windows.Forms.DataGrid> kontrolki <xref:System.Collections.IList> zwracanyprzez<xref:System.Windows.Forms.CurrencyManager.List%2A> właściwość jest rzutowany na zmienną.<xref:System.Data.DataView> Właściwość obiektu ma ustawioną wartość `false`. <xref:System.Data.DataView.AllowNew%2A> <xref:System.Data.DataView>  
  
 [!code-cpp[CurrencyManager.List Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CurrencyManager.List Example/CPP/list.cpp#1)]
 [!code-csharp[CurrencyManager.List Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CurrencyManager.List Example/CS/list.cs#1)]
 [!code-vb[CurrencyManager.List Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CurrencyManager.List Example/VB/list.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberSignature Language="F#" Value="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " Usage="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmieni się lista lub element na liście ulegnie zmianie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager> <xref:System.Windows.Forms.CurrencyManager.EndCurrentEdit%2A> <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A>Zdarzenie jest zgłaszane przez klasę po wprowadzeniu zmian w elemencie przy użyciu metod takich jak,, i <xref:System.Windows.Forms.CurrencyManager.Refresh%2A>. <xref:System.Windows.Forms.CurrencyManager.ListChanged> To zdarzenie może również wystąpić, gdy źródło danych jest edytowane bezpośrednio, jeśli implementuje <xref:System.ComponentModel.IBindingListView> interfejs.  
  
 Skojarzona `OnListChanged` Metoda jest metodą prywatną w tej klasie.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.CurrencyManager> o nazwie. `CurrencyManager1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.CurrencyManager.ListChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#192](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#192)]
 [!code-vb[System.Windows.Forms.EventExamples#192](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#192)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="listposition">
      <MemberSignature Language="C#" Value="protected int listposition;" />
      <MemberSignature Language="ILAsm" Value=".field family int32 listposition" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Forms.CurrencyManager.listposition" />
      <MemberSignature Language="VB.NET" Value="Protected listposition As Integer " />
      <MemberSignature Language="C++ CLI" Value="protected: int listposition;" />
      <MemberSignature Language="F#" Value="val mutable listposition : int" Usage="System.Windows.Forms.CurrencyManager.listposition" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa bieżącą pozycję <see cref="T:System.Windows.Forms.CurrencyManager" /> na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli wartość <xref:System.Windows.Forms.CurrencyManager.Count%2A> właściwości jest większa od 0 <xref:System.Windows.Forms.CurrencyManager.listposition> , pole jest liczbą z zakresu od 0 do <xref:System.Windows.Forms.CurrencyManager.Count%2A> minus 1. Jeśli <xref:System.Windows.Forms.CurrencyManager.Count%2A> jest równa <xref:System.Windows.Forms.CurrencyManager.listposition> 0, wynosi-1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Position" />
      </Docs>
    </Member>
    <Member MemberName="MetaDataChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MetaDataChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MetaDataChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.CurrencyManager.MetaDataChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MetaDataChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MetaDataChanged;" />
      <MemberSignature Language="F#" Value="member this.MetaDataChanged : EventHandler " Usage="member this.MetaDataChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy metadane <see cref="P:System.Windows.Forms.CurrencyManager.List" /> programu uległy zmianie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metadane <xref:System.Windows.Forms.CurrencyManager.List%2A> składają się ze schematu bazowego <xref:System.Windows.Forms.Binding.DataSource%2A?displayProperty=nameWithType>. <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> Zdarzenie jest zgłaszane, gdy ten schemat został zmieniony. Na przykład <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> zdarzenie jest zgłaszane, <xref:System.Data.DataColumn> gdy program <xref:System.Data.DataTable>jest programowo dodawany do.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.CurrencyManager> o nazwie. `CurrencyManager1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.CurrencyManager.MetaDataChanged> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#193](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#193)]
 [!code-vb[System.Windows.Forms.EventExamples#193](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#193)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnCurrentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnCurrentChanged : EventArgs -&gt; unit" Usage="currencyManager.OnCurrentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnCurrentItemChanged : EventArgs -&gt; unit" Usage="currencyManager.OnCurrentItemChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingManagerBase.CurrentItemChanged" /> Podnosi zdarzenie.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnItemChanged (System.Windows.Forms.ItemChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemChanged(class System.Windows.Forms.ItemChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnItemChanged (e As ItemChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnItemChanged(System::Windows::Forms::ItemChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnItemChanged : System.Windows.Forms.ItemChangedEventArgs -&gt; unit&#xA;override this.OnItemChanged : System.Windows.Forms.ItemChangedEventArgs -&gt; unit" Usage="currencyManager.OnItemChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ItemChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.Windows.Forms.ItemChangedEventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.CurrencyManager.OnItemChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.CurrencyManager.OnItemChanged(System.Windows.Forms.ItemChangedEventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.CurrencyManager.ItemChanged" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnMetaDataChanged">
      <MemberSignature Language="C#" Value="protected internal void OnMetaDataChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void OnMetaDataChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub OnMetaDataChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void OnMetaDataChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.OnMetaDataChanged : EventArgs -&gt; unit" Usage="currencyManager.OnMetaDataChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.CurrencyManager.MetaDataChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.CurrencyManager.OnMetaDataChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.CurrencyManager.OnMetaDataChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPositionChanged : EventArgs -&gt; unit&#xA;override this.OnPositionChanged : EventArgs -&gt; unit" Usage="currencyManager.OnPositionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.CurrencyManager.OnPositionChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani pełnomocnicy otrzymywali zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.PositionChanged" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnPositionChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.CurrencyManager.Position" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Position { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int with get, set" Usage="System.Windows.Forms.CurrencyManager.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia pozycję, która znajduje się na liście.</summary>
        <value>Liczba z zakresu od 0 <see cref="P:System.Windows.Forms.CurrencyManager.Count" /> do minus 1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ważną właściwością <xref:System.Windows.Forms.CurrencyManager> klasy <xref:System.Windows.Forms.CurrencyManager.Position%2A> jest właściwość. Na liście elementów można wyświetlić tylko jeden element z całej listy. Aby określić, który element jest wyświetlany, ustaw <xref:System.Windows.Forms.CurrencyManager.Position%2A> wartość na liczbę z zakresu od 0 (początek listy) i <xref:System.Windows.Forms.CurrencyManager.Count%2A> minus 1 (koniec listy).  
  
 W związku z tym <xref:System.Windows.Forms.CurrencyManager> określawalutęlubmiejscenaliściewszystkichformantówpowiązanychztymsamym.<xref:System.Windows.Forms.CurrencyManager.Position%2A> Załóżmy na przykład, że Wyobraź sobie listę składającą się z dwóch kolumn o nazwie "FirstName" i "LastName". Dwie <xref:System.Windows.Forms.TextBox> kontrolki są powiązane z tą samą listą; pierwszy formant jest powiązany z pierwszą kolumną, a drugi formant jest powiązany z drugą kolumną. Gdy wartość Wspólna <xref:System.Windows.Forms.CurrencyManager> jest ustawiona na trzecią pozycję, obie kontrolki wyświetlają odpowiednie wartości dla tej pozycji na liście. <xref:System.Windows.Forms.CurrencyManager.Position%2A> Innymi słowy, jeśli element na pozycji trzy składa się z pierwszej nazwy "Jan" i nazwiska "Smith", formanty powiązane będą wyświetlać "Jan" i "Kowalski".  
  
   
  
## Examples  
 Poniższe przykłady kodu używają właściwości, <xref:System.Windows.Forms.CurrencyManager.Position%2A> aby umożliwić nawigację za pomocą listy.  
  
 [!code-cpp[Classic CurrencyManager.Position Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Position Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Position Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Position Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Current" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="currencyManager.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wymusza ponowne wypełnianie listy powiązanej z danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj metody <xref:System.Windows.Forms.CurrencyManager.Refresh%2A> , gdy źródło danych nie obsługuje powiadomień w przypadku zmiany (na przykład jeśli <xref:System.Array>jest to).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy tablicę i wiąże ją z <xref:System.Windows.Forms.TextBox> kontrolką, a następnie zmienia jedną wartość. Metodę można wywołać, aby zaktualizować wartość wyświetlaną <xref:System.Windows.Forms.TextBox> przez formant. <xref:System.Windows.Forms.CurrencyManager.Refresh%2A>  
  
 [!code-cpp[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.Refresh Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.Refresh Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.CurrencyManager.List" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public override void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="override this.RemoveAt : int -&gt; unit" Usage="currencyManager.RemoveAt index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks elementu, który ma zostać usunięty z listy.</param>
        <summary>Usuwa element o określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda została zaprojektowana tak, aby umożliwiała złożone kontrolki, takie <xref:System.Windows.Forms.DataGrid> jak kontrolka, aby usunąć elementy z listy. <xref:System.Windows.Forms.CurrencyManager.RemoveAt%2A> Tej metody nie należy używać do rzeczywistego usuwania elementów. Zamiast tego należy użyć <xref:System.Data.DataView.Delete%2A> metody <xref:System.Data.DataView> klasy, aby usunąć elementy.  
  
   
  
## Examples  
 Poniższy przykład kodu używa metody, <xref:System.Windows.Forms.CurrencyManager.RemoveAt%2A> aby usunąć element na pozycji 0 na liście.  
  
 [!code-cpp[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/CPP/source.cpp#1)]
 [!code-csharp[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/CS/source.cs#1)]
 [!code-vb[Classic CurrencyManager.RemoveAt Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic CurrencyManager.RemoveAt Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">Nie ma żadnego wiersza w określonym <paramref name="index" />.</exception>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.AddNew" />
        <altmember cref="P:System.Windows.Forms.CurrencyManager.Count" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public override void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResumeBinding();" />
      <MemberSignature Language="F#" Value="override this.ResumeBinding : unit -&gt; unit" Usage="currencyManager.ResumeBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia powiązanie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A>i <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> są dwie metody, które umożliwiają tymczasowe zawieszenie i wznowienie działania w prostym scenariuszu powiązania danych. Zazwyczaj można wstrzymać powiązanie danych, jeśli użytkownik musi być uprawniony do wprowadzania kilku zmian w polach danych przed rozpoczęciem walidacji. Na przykład, jeśli jedno pole musi zostać zmienione zgodnie z drugim, ale gdzie sprawdzanie poprawności pierwszego pola spowodowałoby wystąpienie błędu drugiego pola.  
  
> [!NOTE]
>  Użycie <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> uniemożliwia wypychanie zmian do źródła danych, dopóki <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> nie zostanie wywołana, ale nie uniemożliwi zmiany w źródle danych wpływające na kontrolki powiązane. Kontrolki używające złożonego powiązania danych, takie <xref:System.Windows.Forms.DataGridView> jak kontrolka, aktualizują wartości na podstawie zdarzeń zmiany, <xref:System.Windows.Forms.CurrencyManager.ListChanged> takich jak zdarzenie. Wywołanie tej metody nie uniemożliwi wystąpienia tych zdarzeń. Z tego powodu <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> i <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> są przeznaczone do użycia z prostymi <xref:System.Windows.Forms.TextBox>kontrolkami, takimi jak. Alternatywnie można użyć tych metod w złożonym scenariuszu powiązania w przypadku pomijania <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń przez <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> ustawienie właściwości na `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.CurrencyManager.ResumeBinding%2A> metody.  
  
 [!code-cpp[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/cpp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CPP/bindingmanagerbase_suspend_resume_binding.cpp#2)]
 [!code-csharp[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/csharp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CS/bindingmanagerbase_suspend_resume_binding.cs#2)]
 [!code-vb[BindingManagerBase_Suspend_Resume_Binding#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/VB/bindingmanagerbase_suspend_resume_binding.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.BindingComplete" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.UpdateIsBinding" />
        <altmember cref="P:System.Windows.Forms.BindingManagerBase.Bindings" />
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public override void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void SuspendBinding();" />
      <MemberSignature Language="F#" Value="override this.SuspendBinding : unit -&gt; unit" Usage="currencyManager.SuspendBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje powiązanie danych, aby zapobiegać zmianom aktualizacji powiązanego źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> i<xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> umożliwiają tymczasowe zawieszenie i wznowienie powiązania danych w prostym scenariuszu powiązania. Zazwyczaj można wstrzymać powiązanie danych, jeśli użytkownik musi wprowadzić kilka zmian w polach danych przed rozpoczęciem walidacji. Na przykład, jeśli jedno pole musi zostać zmienione zgodnie z drugim, ale gdzie sprawdzanie poprawności pierwszego pola spowodowałoby wystąpienie błędu drugiego pola.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A>uniemożliwia stosowanie zmian do źródła danych, dopóki <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> nie zostanie wywołana, ale w rzeczywistości nie uniemożliwia wystąpienia zdarzeń. Kontrolki używające złożonego powiązania danych, takie <xref:System.Windows.Forms.DataGridView> jak kontrolka, aktualizują wartości na podstawie zdarzeń zmiany, takich <xref:System.Windows.Forms.CurrencyManager.ListChanged> jak zdarzenie. W związku z <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> tym wywołanie nie zapobiega otrzymywaniu przez nie zdarzeń złożonych formantów do aktualizowania źródła danych. Z tego powodu <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użycia z prostymi <xref:System.Windows.Forms.TextBox> kontrolkami, takimi jak formant. Alternatywnie można użyć tych metod w złożonym scenariuszu powiązania w przypadku pomijania <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń przez <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> ustawienie właściwości na `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.CurrencyManager.SuspendBinding%2A> metody.  
  
 [!code-cpp[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/cpp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CPP/bindingmanagerbase_suspend_resume_binding.cpp#1)]
 [!code-csharp[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/csharp/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/CS/bindingmanagerbase_suspend_resume_binding.cs#1)]
 [!code-vb[BindingManagerBase_Suspend_Resume_Binding#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/BindingManagerBase_Suspend_Resume_Binding/VB/bindingmanagerbase_suspend_resume_binding.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.BindingComplete" />
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
        <altmember cref="M:System.Windows.Forms.BindingManagerBase.UpdateIsBinding" />
        <altmember cref="P:System.Windows.Forms.BindingManagerBase.Bindings" />
      </Docs>
    </Member>
    <Member MemberName="UpdateIsBinding">
      <MemberSignature Language="C#" Value="protected override void UpdateIsBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateIsBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.CurrencyManager.UpdateIsBinding" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateIsBinding ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateIsBinding();" />
      <MemberSignature Language="F#" Value="override this.UpdateIsBinding : unit -&gt; unit" Usage="currencyManager.UpdateIsBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktualizuje stan powiązania.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e8cf468bc493a426f0c909ac5571fe37cd37eb18" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30703646" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obraz używany do rysowania wskaźnik myszy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor jest mały obraz, którego lokalizację na ekranie jest kontrolowany za pomocą urządzenia wskazującego, takie jak mysz, Pióro lub urządzenia wskazującego. Gdy użytkownik przesuwa urządzenia wskazującego, system operacyjny odpowiednio przenosi kursor.  
  
 Kształty inny kursor są używane do poinformowania użytkownika o operacji, jakie ma myszy. Na przykład podczas edytowania lub Zaznaczanie tekstu <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> kursora jest zwykle wyświetlany. Kursor oczekiwania jest najczęściej używany do informuje użytkownika, że proces jest uruchomiony. Przykłady procesów, poczekaj, aż użytkownik może mieć są Otwieranie pliku, zapisanie pliku lub takich jak wypełnianie formantu <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> lub <xref:System.Windows.Forms.TreeView> z dużą ilością danych.  
  
 Wszystkie formanty, które pochodzą z <xref:System.Windows.Forms.Control> klasa ma <xref:System.Windows.Forms.Control.Cursor%2A> właściwości. Aby zmienić kursor wyświetlany przez wskaźnik myszy, gdy znajduje się w granicach formantu, Przypisz <xref:System.Windows.Forms.Cursor> do <xref:System.Windows.Forms.Control.Cursor%2A> właściwości formantu. Można również wyświetlać kursory na poziomie aplikacji, przypisując <xref:System.Windows.Forms.Cursor> do <xref:System.Windows.Forms.Cursor.Current%2A> właściwości. Na przykład jeśli aplikacja ma na celu Edytuj plik tekstowy, można ustawić <xref:System.Windows.Forms.Cursor.Current%2A> właściwości <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> do wyświetlenia kursora oczekiwania przez aplikację podczas plik ładuje lub zapisuje aby zapobiec przetwarzania zdarzeń myszy. Po zakończeniu procesu ustawić <xref:System.Windows.Forms.Cursor.Current%2A> właściwości <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> dla aplikacji, aby wyświetlić odpowiednie kursor nad każdym — typ formantu.  
  
> [!NOTE]
>  Jeśli należy wywołać <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> przed zresetowaniem <xref:System.Windows.Forms.Cursor.Current%2A> właściwości z powrotem do <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> kursora, aplikacja zostanie wznowiona nasłuchiwanie zdarzeń myszy i wznowi wyświetlanie odpowiednie <xref:System.Windows.Forms.Cursor> dla każdego formantu w aplikacji.  
  
 Kursor obiekty mogą być tworzone z różnych źródeł, takich jak dojście istniejącego <xref:System.Windows.Forms.Cursor>, standard <xref:System.Windows.Forms.Cursor> pliku, zasobu lub strumienia danych.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Cursor> Klasa nie obsługuje animowanych kursorów (.ani pliki) lub kursory z kolorami innego niż biały czarny.  
  
 Jeśli obraz jest używany jako kursora jest za mały, możesz użyć <xref:System.Windows.Forms.Cursor.DrawStretched%2A> metodę wymuszania obrazu w celu wypełnienia granice kursora. Można ukryć kursor przez wywołanie metody <xref:System.Windows.Forms.Cursor.Hide%2A> metody i przywrócenie go przez wywołanie metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
 Począwszy od programu .NET Framework 4.5.2, <xref:System.Windows.Forms.Cursor> będzie zmieniany na podstawie ustawienia systemowego DPI w pliku app.config zawiera następujący wpis:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia formularz, który demonstruje użycie niestandardowego kursora. Niestandardowa <xref:System.Windows.Forms.Cursor> jest osadzony w pliku zasobów aplikacji. Przykład wymaga kursora zawarte w pliku kursora o nazwie `MyCursor.cur`. Aby skompilować w tym przykładzie przy użyciu wiersza polecenia, obejmują następujące flagi: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 Poniższy przykładowy kod przedstawia informacje o klientach w <xref:System.Windows.Forms.TreeView> formantu. Węzły drzewa głównego wyświetlane nazwy klienta, a węzły drzewa podrzędnego wyświetlić numery przypisane do każdego klienta. W tym przykładzie 1000 klientów są wyświetlane z 15 zleceń. Odświeżenie <xref:System.Windows.Forms.TreeView> jest pomijana przy użyciu <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> metody i oczekiwania <xref:System.Windows.Forms.Cursor> jest wyświetlany podczas <xref:System.Windows.Forms.TreeView> tworzy i maluje <xref:System.Windows.Forms.TreeNode> obiektów. W tym przykładzie wymaga pliku kursora o nazwie `MyWait.cur` w katalogu aplikacji. Wymagany jest również `Customer` obiektu, który może przechowywać Kolekcja `Order` obiektów i że utworzono wystąpienie <xref:System.Windows.Forms.TreeView> kontrolować na <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <see cref="T:System.IntPtr" /> Reprezentujący uchwytów okien kursora do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego dojścia systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zwolnić obsługi kursora, gdy wszystko będzie gotowe z nim. Aby uzyskać więcej informacji na temat usuwania zasobów, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia jego położenie i prostokątny wycinek. Wynik jest kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest podczas wykonywania kodu. Ponadto Prostokątny wycinek kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień danych, aby załadować <see cref="T:System.Windows.Forms.Cursor" /> z.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy ze strumienia określone dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strumień danych, określonej przez `stream` musi zawierać plik kursora (.cur).  
  
> [!NOTE]
>  Kursory animowane (pliki .ani) nie są obsługiwane przez <xref:System.Windows.Forms.Cursor> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje kursora z <xref:System.IO.Stream> utworzone przez <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A> metody <xref:System.Windows.Forms.OpenFileDialog>. Po wywołaniu metody <xref:System.Windows.Forms.OpenFileDialog> jest wyświetlany użytkownikowi, gdy. Wybrano plik WALUTA i zamknąć okno dialogowe, plik jest otwarty i <xref:System.IO.Stream> zwrócił służy do tworzenia <xref:System.Windows.Forms.Cursor>.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik kursora do załadowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` Parametru musi odwoływać się plik kursora standardowe (.cur).  
  
> [!NOTE]
>  Kursory animowane (pliki .ani) nie są obsługiwane przez <xref:System.Windows.Forms.Cursor> klasy.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia informacje o klientach w <xref:System.Windows.Forms.TreeView> formantu. Węzły drzewa głównego wyświetlane nazwy klienta, a węzły drzewa podrzędnego wyświetlić numery przypisane do każdego klienta. W tym przykładzie 1000 klientów są wyświetlane z 15 zleceń. Odświeżenie <xref:System.Windows.Forms.TreeView> jest pomijana przy użyciu <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> metody i oczekiwania <xref:System.Windows.Forms.Cursor> jest wyświetlany podczas <xref:System.Windows.Forms.TreeView> tworzy i maluje <xref:System.Windows.Forms.TreeNode> obiektów. W tym przykładzie wymaga `Customer` obiektu, który może przechowywać Kolekcja `Order` obiektów. Wymagany jest również utworzono wystąpienie <xref:System.Windows.Forms.TreeView> kontrolować na <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Zasób <see cref="T:System.Type" />.</param>
        <param name="resource">Nazwa zasobu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego zasobu z określonego typu zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oto przykładowy sposób osadzić kursora jako zasób w aplikacji. Aby osadzić zasób, należy odwoływać się do nazwy zasobów następuje przecinkami, a następnie jego ścieżki pełnego zestawu. Zobacz sekcję przykładowy sposób załadować kursora z zasobu osadzonego.  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  Odwołanie do zasobu w przypadku kompilowania kodu, a także podczas odwoływania się do kodu, jest rozróżniana wielkość liter, dla Kompilatory języka C# i Visual Basic.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia formularz, który demonstruje przy użyciu niestandardowych kursorów <xref:System.Windows.Forms.Cursor.%23ctor%2A> konstruktora. Niestandardowa <xref:System.Windows.Forms.Cursor> jest osadzony w pliku zasobów aplikacji. Przykład wymaga kursora zawarte w pliku kursora o nazwie `MyCursor.cur`. Aby skompilować w tym przykładzie przy użyciu wiersza polecenia, obejmują następujące flagi: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia granice, które reprezentują Prostokątny wycinek dla kursora.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący Prostokątny wycinek dla <see cref="T:System.Windows.Forms.Cursor" />w współrzędne ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor przyciętą może przenieść tylko w obrębie jej Prostokątny wycinek. Ogólnie rzecz biorąc system zezwala na to tylko wtedy, gdy wskaźnik myszy jest aktualnie przechwycony. Jeśli obecnie nie jest przycinana kursora, wynikowy prostokąt zawiera wymiary cały ekran.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia jego położenie i prostokątny wycinek. Wynik jest kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest podczas wykonywania kodu. Ponadto Prostokątny wycinek kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">we wszystkich oknach ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje dojście to <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>
          <see cref="T:System.IntPtr" /> Reprezentujący obsługi kursora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście utworzone w wyniku wywołaniem tej metody należy usunąć z po zakończeniu z nim ponieważ go nie zostanie usunięte z przez moduł garbage collector.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt kursor, który reprezentuje wskaźnik myszy.</summary>
        <value>A <see cref="T:System.Windows.Forms.Cursor" /> reprezentujący kursora myszy. Wartość domyślna to <see langword="null" /> Jeśli kursor myszy nie jest widoczna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Windows.Forms.Cursor.Current%2A> aktualnie wyświetlany kursor zmiany właściwości. Aplikacja może lub nie może kontynuować do nasłuchiwania zdarzeń myszy. Która sygnalizuje, że aplikacja nie powinno odpowiedzieć na zdarzenia myszy podczas długotrwałej operacji, użyj <xref:System.Windows.Forms.Application.UseWaitCursor%2A> właściwości. W większości przypadków jednak warto użycie wątku w tle do zarządzania długotrwałej operacji i pozostawić interfejsu użytkownika dostępne dla użytkownika. Aby uzyskać więcej informacji na łatwe wykonania zadania w tle, zobacz <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla bezpiecznej subwindows ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Windows.Forms.Cursor.Dispose%2A> po zakończeniu przy użyciu <xref:System.Windows.Forms.Cursor>. `Dispose` Pozostawia metody <xref:System.Windows.Forms.Cursor> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Windows.Forms.Cursor.Dispose%2A>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Windows.Forms.Cursor> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć który <xref:System.Windows.Forms.Cursor> klasy. Aby uzyskać więcej informacji, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Wywoływanie zawsze <xref:System.Windows.Forms.Cursor.Dispose%2A> przed zwolnieniem ostatniego odwołania do <xref:System.Windows.Forms.Cursor>. W przeciwnym razie zasoby, które używa nie zostanie zwolniona, dopóki nie pozwala na moduł garbage collector.  
  
   
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Powierzchni, na którym ma zostać narysowany <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Rysuje kursor na powierzchni określonej w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi na powierzchni grafiki reprezentowany przez `g` parametru, ale <xref:System.Drawing.Graphics> nie zawiera informacji o sposobie renderowania danego obrazu, więc przekazuje wywołanie <xref:System.Windows.Forms.Cursor>. <xref:System.Windows.Forms.Cursor.Draw%2A> Metoda Przycina obraz do danego wymiarów i pozwala na określenie <xref:System.Drawing.Rectangle> w ramach którego ma zostać narysowany <xref:System.Windows.Forms.Cursor>. Ta metoda jest zwykle używana, jeśli chcesz narysować kursor na powierzchni grafiki. Na przykład może być okna dialogowego, które umożliwia użytkownikowi wybranie kursory z <xref:System.Windows.Forms.ListBox> kontroli lub grupy <xref:System.Windows.Forms.RadioButton> kontrolki.  
  
   
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiektu do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Powierzchni, na którym ma zostać narysowany <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Rysuje kursor w formacie rozciągnięty na powierzchni określonej w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi na powierzchni grafiki reprezentowany przez `g` parametru, ale <xref:System.Drawing.Graphics> obiekt nie zawiera informacji o sposobie renderowania danego obrazu, więc przekazuje wywołanie <xref:System.Windows.Forms.Cursor> obiektu. <xref:System.Windows.Forms.Cursor.DrawStretched%2A> Metody rozciąga się obrazu w celu wypełnienia określonego <xref:System.Drawing.Rectangle> gdy kursor jest rysowane.  
  
   
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiektu do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.Forms.Cursor" /> Do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy ten kursor jest równa określonej <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ten kursor jest równe określonej <see cref="T:System.Windows.Forms.Cursor" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia jego położenie i prostokątny wycinek. Wynik jest kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest podczas wykonywania kodu. Ponadto Prostokątny wycinek kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu, próby zwolnienia zasobów i wykonywać inne operacje oczyszczania, przed jego jest odzyskana przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera dojście kursora.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Reprezentujący obsługi kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To nie jest kopię dojście; Nie usuwaj go.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia jego położenie i prostokątny wycinek. Wynik jest kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest podczas wykonywania kodu. Ponadto Prostokątny wycinek kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Wartość uchwytu <see cref="F:System.IntPtr.Zero" />.</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukrywa kursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Show%2A> i <xref:System.Windows.Forms.Cursor.Hide%2A> musi uwzględniać wywołania metody. Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> musi być do odpowiedniego wywołania metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursora, gdy wskaźnik myszy zostanie umieszczony obszaru klienckiego przycisku. Podobnie gdy wskaźnik myszy opuści obszaru klienckiego przycisku, gdy kursor jest wyświetlany ponownie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> z <xref:System.Windows.Forms.Button> o nazwie `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punktu aktywnego kursora.</summary>
        <value>A <see cref="T:System.Drawing.Point" /> reprezentujący punktu aktywnego kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.HotSpot%2A> Jest <xref:System.Drawing.Point> w kursor, który współdziała z innymi elementami na ekranie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia elementu <see cref="T:System.Windows.Forms.Cursor" /> klasy są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiektu do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia elementu <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora.</summary>
        <value>A <see cref="T:System.Drawing.Point" /> reprezentujący pozycji kursora w współrzędne ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Position%2A> Jest taka sama jak właściwość <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia jego położenie i prostokątny wycinek. Wynik jest kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest podczas wykonywania kodu. Ponadto Prostokątny wycinek kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyświetla kursora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Show%2A> i <xref:System.Windows.Forms.Cursor.Hide%2A> musi uwzględniać wywołania metody. Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> musi być do odpowiedniego wywołania metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursora, gdy wskaźnik myszy zostanie umieszczony obszaru klienckiego przycisku. Podobnie gdy wskaźnik myszy opuści obszaru klienckiego przycisku, gdy kursor jest wyświetlany ponownie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> z <xref:System.Windows.Forms.Button> o nazwie `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar obiektu kursora.</summary>
        <value>A <see cref="T:System.Drawing.Size" /> reprezentujący szerokość i wysokość <see cref="T:System.Windows.Forms.Cursor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod rysuje określonego kursora w formularzu w normalnym rozmiarze i w trybie rozciągnięty, dwukrotnie. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiektu do przekazania do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> klasy.</param>
        <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy.</param>
        <summary>Serializuje obiekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera dane o <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <value>
          <see cref="T:System.Object" /> Zawierający dane o <see cref="T:System.Windows.Forms.Cursor" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera człowieka czytelnych ciągów reprezentujących to <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>A <see cref="T:System.String" /> reprezentujący to <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
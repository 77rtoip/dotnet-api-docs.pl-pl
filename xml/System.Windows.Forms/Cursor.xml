<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2414ba4befb75f062700cc3905bb02f99a78a414" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69194375" /></Metadata><TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Cursor = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obraz używany do malowania wskaźnikiem myszy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor to mały obraz, którego lokalizacja na ekranie jest kontrolowana przez urządzenie wskazujące, takie jak mysz, pióro lub urządzenia wskazujące. Gdy użytkownik przenosi urządzenie wskazujące, system operacyjny odpowiednio przesuwa kursor.  
  
 Różne kształty kursorów są używane do informowania użytkownika o tym, jakie operacje ma dana mysz. Na przykład podczas edycji lub zaznaczania tekstu <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> kursor jest zwykle wyświetlany. Kursor oczekiwania jest często używany do informowania użytkownika o tym, że proces jest aktualnie uruchomiony. Przykłady procesów, dla których użytkownik może oczekiwać, że otwiera plik, zapisuje plik lub wypełnia kontrolkę <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> taką jak lub <xref:System.Windows.Forms.TreeView> z dużą ilością danych.  
  
 Wszystkie kontrolki, które pochodzą <xref:System.Windows.Forms.Control> z klasy, <xref:System.Windows.Forms.Control.Cursor%2A> mają właściwość. Aby zmienić kursor wyświetlany przez wskaźnik myszy, gdy znajduje się on w granicach formantu, przypisz <xref:System.Windows.Forms.Cursor> <xref:System.Windows.Forms.Control.Cursor%2A> do właściwości formantu. Alternatywnie można wyświetlać kursory na poziomie aplikacji, przypisując <xref:System.Windows.Forms.Cursor> <xref:System.Windows.Forms.Cursor.Current%2A> do właściwości. Na przykład, jeśli celem aplikacji jest edytowanie pliku tekstowego, można ustawić <xref:System.Windows.Forms.Cursor.Current%2A> właściwość na <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> tak, aby wyświetlała kursor oczekiwania aplikacji podczas ładowania lub zapisywania pliku, aby zapobiec przetwarzaniu jakichkolwiek zdarzeń myszy. Po zakończeniu procesu Ustaw <xref:System.Windows.Forms.Cursor.Current%2A> właściwość na <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> dla aplikacji, aby wyświetlić odpowiedni kursor dla każdego typu formantu.  
  
> [!NOTE]
>  Jeśli wywołasz <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> <xref:System.Windows.Forms.Cursor.Current%2A> przed zresetowaniem właściwości z powrotem do <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> kursora, aplikacja wznowi nasłuchiwanie zdarzeń myszy i spowoduje wznowienie wyświetlania odpowiednich <xref:System.Windows.Forms.Cursor> dla każdej kontrolki w aplikacji.  
  
 Obiekty kursorów można tworzyć z kilku źródeł, takich jak dojście istniejącego <xref:System.Windows.Forms.Cursor>, standardowego <xref:System.Windows.Forms.Cursor> pliku, zasobu lub strumienia danych.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Cursor> Klasa nie obsługuje animowanych kursorów (plików. ani) ani kursorów z kolorem innym niż czarny i biały.  
  
 Jeśli obraz, który jest używany jako kursor jest zbyt mały, możesz użyć metody, <xref:System.Windows.Forms.Cursor.DrawStretched%2A> aby wymusić zapełnienie obrazu granic kursora. Możesz tymczasowo ukryć kursor, wywołując <xref:System.Windows.Forms.Cursor.Hide%2A> metodę i przywracając ją przez <xref:System.Windows.Forms.Cursor.Show%2A> wywołanie metody.  
  
 Począwszy od .NET Framework 4.5.2, <xref:System.Windows.Forms.Cursor> rozmiar zostanie zmieniony na podstawie ustawienia DPI systemu, gdy plik App. config zawiera następujący wpis:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla formularz, który demonstruje użycie kursora niestandardowego. Niestandardowy <xref:System.Windows.Forms.Cursor> element jest osadzony w pliku zasobów aplikacji. Przykład wymaga kursora zawartego w pliku kursora o nazwie `MyCursor.cur`. Aby skompilować ten przykład przy użyciu wiersza polecenia, należy uwzględnić następującą flagę:`/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 Poniższy przykład kodu wyświetla informacje o klientach w <xref:System.Windows.Forms.TreeView> kontrolce. Węzły drzewa głównego wyświetlają nazwy klientów, a podrzędne węzły drzewa wyświetlają numery zamówień przypisane do każdego klienta. W tym przykładzie do 1 000 klientów są wyświetlane 15 zamówień. <xref:System.Windows.Forms.TreeView> Odświeżenie jest pomijane <xref:System.Windows.Forms.TreeView> <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> przy użyciu metod i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> , a podczas tworzenia i malowania <xref:System.Windows.Forms.TreeNode> obiektów <xref:System.Windows.Forms.Cursor> jest wyświetlany czas oczekiwania. Ten przykład wymaga, aby w katalogu aplikacji znajdował `MyWait.cur` się plik kursora o nazwie. Wymaga `Customer` również obiektu, który może zawierać `Order` kolekcję obiektów i że <xref:System.Windows.Forms.TreeView> utworzono wystąpienie kontrolki na <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : nativeint -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><see cref="T:System.IntPtr" /> Reprezentuje uchwyt systemu Windows kursora do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego dojścia systemu Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy wszystko będzie gotowe, musisz zwolnić uchwyt kursora. Aby uzyskać więcej informacji na temat usuwania zasobów, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursor od <xref:System.Windows.Forms.Cursor.Current%2A> <xref:System.Windows.Forms.Cursor.Handle%2A>kursora, zmienia jego pozycję i prostokąt przycinania. W efekcie kursor zostanie przesunięty w górę i w lewo o 50 pikseli z lokalizacji, w której jest wykonywany kod. Dodatkowo prostokąt przycinania kursora jest zmieniany na granice formularza (domyślnie jest to cały ekran użytkownika). Ten przykład wymaga, <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> aby można było wywołać ten kod, gdy zostanie kliknięty.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="handle" />jest <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : System.IO.Stream -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień danych, z którego <see cref="T:System.Windows.Forms.Cursor" /> ma zostać załadowany.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego strumienia danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strumień danych określony przez `stream` musi zawierać plik kursora (. CUR).  
  
> [!NOTE]
>  Animowane kursory (pliki. ani) nie są obsługiwane <xref:System.Windows.Forms.Cursor> przez klasę.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje kursor z elementu <xref:System.IO.Stream> utworzonego <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A> przez metodę <xref:System.Windows.Forms.OpenFileDialog>. Gdy wywoływana jest metoda, <xref:System.Windows.Forms.OpenFileDialog> jest wyświetlana użytkownikowi i gdy. Wybrano bieżący plik i zamknięto okno dialogowe, plik zostanie otwarty i <xref:System.IO.Stream> zostanie użyty do <xref:System.Windows.Forms.Cursor>utworzenia.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik kursora do załadowania.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` Parametr musi odwoływać się do standardowego pliku kursora (. CUR).  
  
> [!NOTE]
>  Animowane kursory (pliki. ani) nie są obsługiwane <xref:System.Windows.Forms.Cursor> przez klasę.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla informacje o klientach w <xref:System.Windows.Forms.TreeView> kontrolce. Węzły drzewa głównego wyświetlają nazwy klientów, a podrzędne węzły drzewa wyświetlają numery zamówień przypisane do każdego klienta. W tym przykładzie do 1 000 klientów są wyświetlane 15 zamówień. <xref:System.Windows.Forms.TreeView> Odświeżenie jest pomijane <xref:System.Windows.Forms.TreeView> <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> przy użyciu metod i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> , a podczas tworzenia i malowania <xref:System.Windows.Forms.TreeNode> obiektów <xref:System.Windows.Forms.Cursor> jest wyświetlany czas oczekiwania. Ten przykład wymaga, aby masz `Customer` obiekt, który może zawierać `Order` kolekcję obiektów. Wymaga również, aby utworzono wystąpienie <xref:System.Windows.Forms.TreeView> kontrolki <xref:System.Windows.Forms.Form>na.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : Type * string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor (type, resource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Zasób <see cref="T:System.Type" />.</param>
        <param name="resource">Nazwa zasobu.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego zasobu o określonym typie zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Poniżej znajduje się przykład sposobu osadzenia kursora jako zasobu w aplikacji. Aby osadzić zasób, odwołuje się do nazwy zasobu, a następnie przecinka, a następnie jego pełną ścieżkę zestawu. Zapoznaj się z sekcją przykładową, aby dowiedzieć się, jak załadować kursor z zasobu osadzonego.  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  Odwołanie do zasobu podczas kompilowania oraz odwoływania się do niego w kodzie, uwzględnia wielkość liter zarówno dla C# kompilatorów, jak i Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla formularz, który demonstruje użycie kursora niestandardowego przy użyciu <xref:System.Windows.Forms.Cursor.%23ctor%2A> konstruktora. Niestandardowy <xref:System.Windows.Forms.Cursor> element jest osadzony w pliku zasobów aplikacji. Przykład wymaga, aby w pliku kursora znajdował się kursor o nazwie `MyCursor.cur`. Aby skompilować ten przykład przy użyciu wiersza polecenia, należy uwzględnić następującą flagę:`/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Cursor.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia granice reprezentujące prostokąt przycinania kursora.</summary>
        <value>Reprezentuje prostokąt przycinania <see cref="T:System.Windows.Forms.Cursor" />dla, we współrzędnych ekranu. <see cref="T:System.Drawing.Rectangle" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor przycinania jest dozwolony tylko w obrębie jego prostokąta wycinka. Ogólnie rzecz biorąc, system umożliwia to tylko wtedy, gdy mysz jest aktualnie przechwycona. Jeśli kursor nie jest obecnie przycinany, prostokątny wskaźnik zawiera wymiary całego ekranu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursor od <xref:System.Windows.Forms.Cursor.Current%2A> <xref:System.Windows.Forms.Cursor.Handle%2A>kursora, zmienia jego pozycję i prostokąt przycinania. W efekcie kursor zostanie przesunięty w górę i w lewo o 50 pikseli z lokalizacji, w której jest wykonywany kod. Dodatkowo prostokąt przycinania kursora jest zmieniany na granice formularza (domyślnie jest to cały ekran użytkownika). Ten przykład wymaga, <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> aby można było wywołać ten kod, gdy zostanie kliknięty.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien, aby ustawić tę właściwość. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberSignature Language="F#" Value="member this.CopyHandle : unit -&gt; nativeint" Usage="cursor.CopyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje dojście tego <see cref="T:System.Windows.Forms.Cursor" />elementu.</summary>
        <returns><see cref="T:System.IntPtr" /> Reprezentuje uchwyt kursora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dojście utworzone w wyniku wywołania tej metody musi zostać usunięte po wykonaniu tej operacji, ponieważ nie zostanie usunięte przez moduł wyrzucania elementów bezużytecznych.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Cursor.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt kursora, który reprezentuje kursor myszy.</summary>
        <value><see cref="T:System.Windows.Forms.Cursor" /> Reprezentuje wskaźnik myszy. Wartość domyślna to <see langword="null" /> , jeśli kursor myszy nie jest widoczny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Current%2A> Ustawienie właściwości powoduje zmianę aktualnie wyświetlanego kursora. Aplikacja może lub nie może kontynuować nasłuchiwania dla zdarzeń myszy. Aby sygnalizować, że aplikacja nie powinna reagować na zdarzenia myszy podczas długotrwałej operacji, użyj <xref:System.Windows.Forms.Application.UseWaitCursor%2A> właściwości. Jednak w większości przypadków lepiej jest użyć wątku w tle do zarządzania długotrwałą operacją i pozostawienia użytkownikowi interfejsu użytkownika. Aby uzyskać więcej informacji na temat łatwego wdrażania zadania w tle <xref:System.ComponentModel.BackgroundWorker>, zobacz.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Aby ustawić tę właściwość w bezpiecznym podsystemie Windows. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cursor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Windows.Forms.Cursor" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.Cursor.Dispose%2A> po zakończeniu korzystania z <xref:System.Windows.Forms.Cursor>. `Dispose` Metoda<xref:System.Windows.Forms.Cursor> pozostawia w stanie niezdatnym do użytku. Po wywołaniu <xref:System.Windows.Forms.Cursor.Dispose%2A>należy wydać wszystkie odwołania <xref:System.Windows.Forms.Cursor> do, aby moduł wyrzucania elementów bezużytecznych mógł odwoływać pamięć <xref:System.Windows.Forms.Cursor> , którą zajmował. Aby uzyskać więcej informacji, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i implementowanie [metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Windows.Forms.Cursor.Dispose%2A> przed wydaniem ostatniego odwołania <xref:System.Windows.Forms.Cursor>do. W przeciwnym razie używane zasoby nie zostaną zwolnione do momentu zwolnienia przez moduł odzyskiwania pamięci.  
  
   
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. Ten przykład wymaga <xref:System.Windows.Forms.Form> , <xref:System.Windows.Forms.Cursor> a i a, aby przejść do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.Draw (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Powierzchnia, na której <see cref="T:System.Windows.Forms.Cursor" />narysujesz. <see cref="T:System.Drawing.Graphics" /></param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje granice <see cref="T:System.Windows.Forms.Cursor" />elementu.</param>
        <summary>Rysuje kursor na określonej powierzchni w obrębie określonych granic.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi od powierzchni graficznej reprezentowanej przez `g` parametr, <xref:System.Drawing.Graphics> ale nie zawiera informacji o sposobie renderowania danego obrazu, dlatego <xref:System.Windows.Forms.Cursor>przekazuje wywołanie do. Metoda przycina obraz do danego wymiaru i pozwala <xref:System.Drawing.Rectangle> określić, <xref:System.Windows.Forms.Cursor>w ramach którego ma zostać narysowany. <xref:System.Windows.Forms.Cursor.Draw%2A> Ta metoda jest zwykle używana, jeśli chcesz narysować kursor na powierzchni graficznej. Na przykład może istnieć okno dialogowe, które umożliwia użytkownikowi wybranie kursorów z <xref:System.Windows.Forms.ListBox> kontrolki lub <xref:System.Windows.Forms.RadioButton> grupy kontrolek.  
  
   
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. W tym przykładzie jest wymagane <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Cursor> , aby obiekt był przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawStretched : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.DrawStretched (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">Powierzchnia, na której <see cref="T:System.Windows.Forms.Cursor" />narysujesz. <see cref="T:System.Drawing.Graphics" /></param>
        <param name="targetRect"><see cref="T:System.Drawing.Rectangle" /> Reprezentuje granice <see cref="T:System.Windows.Forms.Cursor" />elementu.</param>
        <summary>Rysuje kursor w rozciągniętym formacie na określonej powierzchni w obrębie określonych granic.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi z powierzchni graficznej reprezentowanej przez `g` parametr, <xref:System.Drawing.Graphics> ale obiekt nie zawiera informacji o sposobie renderowania danego obrazu, dlatego <xref:System.Windows.Forms.Cursor> przekazuje wywołanie do obiektu. Metoda rozciąga obraz, aby wypełnić określony <xref:System.Drawing.Rectangle> czas rysowania kursora. <xref:System.Windows.Forms.Cursor.DrawStretched%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. W tym przykładzie jest wymagane <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Cursor> , aby obiekt był przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cursor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><see cref="T:System.Windows.Forms.Cursor" /> Do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy ten kursor jest równy podanemu <see cref="T:System.Windows.Forms.Cursor" />elementowi.</summary>
        <returns><see langword="true" />Jeśli ten kursor jest równy podanemu <see cref="T:System.Windows.Forms.Cursor" />elementowi; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy kursor od <xref:System.Windows.Forms.Cursor.Current%2A> <xref:System.Windows.Forms.Cursor.Handle%2A>kursora, zmienia jego pozycję i prostokąt przycinania. W efekcie kursor zostanie przesunięty w górę i w lewo o 50 pikseli z lokalizacji, w której jest wykonywany kod. Dodatkowo prostokąt przycinania kursora jest zmieniany na granice formularza (domyślnie jest to cały ekran użytkownika). Ten przykład wymaga <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> , aby wywołać ten kod, gdy zostanie kliknięty.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="cursor.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektowi podjęcie próby zwolnienia zasobów i wykonywanie innych operacji czyszczenia przed odinstalowaniem ich przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cursor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kod skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>Kod skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Cursor.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt kursora.</summary>
        <value><see cref="T:System.IntPtr" /> Reprezentuje uchwyt kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To nie jest kopia dojścia; nie usuwaj go.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursor od <xref:System.Windows.Forms.Cursor.Current%2A> <xref:System.Windows.Forms.Cursor.Handle%2A>kursora, zmienia jego pozycję i prostokąt przycinania. W efekcie kursor zostanie przesunięty w górę i w lewo o 50 pikseli z lokalizacji, w której jest wykonywany kod. Dodatkowo prostokąt przycinania kursora jest zmieniany na granice formularza (domyślnie jest to cały ekran użytkownika). Ten przykład wymaga <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> , aby wywołać ten kod, gdy zostanie kliknięty.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Wartość dojścia to <see cref="F:System.IntPtr.Zero" />.</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberSignature Language="F#" Value="static member Hide : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukrywa kursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania metody <xref:System.Windows.Forms.Cursor.Hide%2A> i muszą być zrównoważone. <xref:System.Windows.Forms.Cursor.Show%2A> Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> metody musi istnieć odpowiednie wywołanie <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursor, gdy wskaźnik myszy zostanie przesunięty w obszar klienta przycisku. Podobnie, gdy wskaźnik myszy opuszcza obszar klienta przycisku, kursor zostanie wyświetlony ponownie. Ten przykład wymaga elementu <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> z nazwą `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich wywołań systemu Windows tę metodę. Skojarzone Wyliczenie:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.HotSpot : System.Drawing.Point" Usage="System.Windows.Forms.Cursor.HotSpot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera punkt aktywny kursora.</summary>
        <value><see cref="T:System.Drawing.Point" /> Reprezentująca punkt aktywny kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.HotSpot%2A> Jest kursorem,którywspółdziałazinnymi<xref:System.Drawing.Point> elementami na ekranie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy są równe.</summary>
        <returns><see langword="true" />Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy są równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Równoważna Metoda dla tego operatora to<xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. Ten przykład wymaga <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Cursor> , aby obiekt został przekazany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="System.Windows.Forms.Cursor.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są równe.</summary>
        <returns><see langword="true" />Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są równe; w przeciwnym razie, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Równoważna Metoda dla tego operatora to<xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. Ten przykład wymaga <xref:System.Windows.Forms.Form> , <xref:System.Windows.Forms.Cursor> a i a, aby przejść do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Cursor.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia położenie kursora.</summary>
        <value><see cref="T:System.Drawing.Point" /> Reprezentujący położenie kursora we współrzędnych ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest taka sama jak <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType> właściwość. <xref:System.Windows.Forms.Cursor.Position%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursor od <xref:System.Windows.Forms.Cursor.Current%2A> <xref:System.Windows.Forms.Cursor.Handle%2A>kursora, zmienia jego pozycję i prostokąt przycinania. W efekcie kursor zostanie przesunięty w górę i w lewo o 50 pikseli z lokalizacji, w której jest wykonywany kod. Dodatkowo prostokąt przycinania kursora jest zmieniany na granice formularza (domyślnie jest to cały ekran użytkownika). Ten przykład wymaga <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> , aby wywołać ten kod, gdy zostanie kliknięty.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberSignature Language="F#" Value="static member Show : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyświetla kursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołania metody <xref:System.Windows.Forms.Cursor.Hide%2A> i muszą być zrównoważone. <xref:System.Windows.Forms.Cursor.Show%2A> Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> metody musi istnieć odpowiednie wywołanie <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursor, gdy wskaźnik myszy zostanie przesunięty w obszar klienta przycisku. Podobnie, gdy wskaźnik myszy opuszcza obszar klienta przycisku, kursor zostanie wyświetlony ponownie. Ten przykład wymaga elementu <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Button> z nazwą `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Windows.Forms.Cursor.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar obiektu kursora.</summary>
        <value>Reprezentujące szerokość i wysokość <see cref="T:System.Windows.Forms.Cursor" />. <see cref="T:System.Drawing.Size" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu Rysuje określony kursor w formularzu w normalnym rozmiarze i w trybie rozciągniętym, dwukrotnie jego rozmiar. Ten przykład wymaga <xref:System.Windows.Forms.Form> <xref:System.Windows.Forms.Cursor> , aby obiekt został przekazany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si"><see cref="T:System.Runtime.Serialization.SerializationInfo" /> Klasa.</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" /> Klasa.</param>
        <summary>Serializacja obiektu.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Cursor.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera dane o <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <value><see cref="T:System.Object" /> Zawierający dane <see cref="T:System.Windows.Forms.Cursor" />o. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cursor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ciąg czytelny dla człowieka reprezentujący to <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns><see cref="T:System.String" /> Reprezentuje to<see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>

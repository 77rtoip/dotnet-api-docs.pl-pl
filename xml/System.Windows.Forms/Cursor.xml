<Type Name="Cursor" FullName="System.Windows.Forms.Cursor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="931f5793c86367c4bcf0bc60278fc116970759b6" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37571948" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Cursor : IDisposable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit Cursor extends System.Object implements class System.IDisposable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Cursor" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Cursor&#xA;Implements IDisposable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Cursor sealed : IDisposable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Cursor = class&#xA;    interface IDisposable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Drawing.Design.CursorEditor, System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.CursorConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Reprezentuje obraz używany do rysowania wskaźnika myszy.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor jest mały obraz, którego lokalizacja na ekranie jest kontrolowane przez urządzenia wskazującego, takie jak mysz, Pióro lub urządzenia wskazującego. Gdy użytkownik przesuwa urządzenia wskazującego, system operacyjny w związku z tym przenosi kursor.  
  
 Kursor różne kształty są używane w celu poinformowania użytkownika, jakie działania myszy będzie miał. Na przykład podczas zaznaczania, lub edytowania <xref:System.Windows.Forms.Cursors.IBeam%2A?displayProperty=nameWithType> kursora jest zwykle wyświetlany. Kursor oczekiwania jest najczęściej używany do informuje użytkownika, który proces jest obecnie uruchomiony. Przykłady procesów, Niewykluczone, że użytkownik, poczekaj, aż się otwieranie pliku, zapisanie pliku lub wypełnianie kontrolki, takie jak <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.ListBox> lub <xref:System.Windows.Forms.TreeView> z dużą ilością danych.  
  
 Wszystkie formanty, które wynikają z <xref:System.Windows.Forms.Control> klasa ma <xref:System.Windows.Forms.Control.Cursor%2A> właściwości. Aby zmienić kursor wyświetlany przez wskaźnik myszy, gdy znajduje się w granicach formantu, Przypisz <xref:System.Windows.Forms.Cursor> do <xref:System.Windows.Forms.Control.Cursor%2A> właściwości formantu. Alternatywnie, możesz wyświetlić kursory na poziomie aplikacji, przypisując <xref:System.Windows.Forms.Cursor> do <xref:System.Windows.Forms.Cursor.Current%2A> właściwości. Na przykład, jeśli aplikacja ma na celu Edytuj plik tekstowy, możesz ustawić <xref:System.Windows.Forms.Cursor.Current%2A> właściwość <xref:System.Windows.Forms.Cursors.WaitCursor%2A?displayProperty=nameWithType> wyświetlany kursor oczekiwania za pośrednictwem aplikacji, podczas ładuje plik, lub zapisuje uniemożliwić Trwa przetwarzanie zdarzeń myszy. Po ukończeniu procesu ustawiony <xref:System.Windows.Forms.Cursor.Current%2A> właściwość <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> dla aplikacji wyświetlić odpowiednie kursora nad każdego typu formantu.  
  
> [!NOTE]
>  Jeśli wywołasz <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> przed zresetowaniem <xref:System.Windows.Forms.Cursor.Current%2A> właściwości z powrotem do <xref:System.Windows.Forms.Cursors.Default%2A?displayProperty=nameWithType> kursora, aplikacja zostanie wznowiona nasłuchiwanie zdarzeń myszy i wznowi wyświetlanie odpowiednie <xref:System.Windows.Forms.Cursor> dla każdego formantu w aplikacji.  
  
 Kursor obiekty można tworzyć z różnych źródeł, takich jak dojścia do istniejącego <xref:System.Windows.Forms.Cursor>, standardowy <xref:System.Windows.Forms.Cursor> pliku, zasobu lub strumienia danych.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Cursor> Klasa nie obsługuje animowane kursory (.ani pliki) lub kursory kolorów niż czarno-biały.  
  
 Jeśli obraz, której używasz jako kursora jest za mały, możesz użyć <xref:System.Windows.Forms.Cursor.DrawStretched%2A> metodę wymuszania obrazu w celu wypełnienia granice kursora. Można tymczasowo ukryć kursora, wywołując <xref:System.Windows.Forms.Cursor.Hide%2A> metodę i przywróć ją przez wywołanie metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
 Począwszy od programu .NET Framework 4.5.2, <xref:System.Windows.Forms.Cursor> rozmiar zostanie zmieniony na podstawie ustawienia systemowego DPI w pliku app.config zawiera następujący wpis:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
```  
  
   
  
## Examples  
 Poniższy przykład kodu przedstawia formularz, który demonstruje sposób użycia niestandardowego kursora. Niestandardowy <xref:System.Windows.Forms.Cursor> jest osadzony w pliku zasobów aplikacji. Przykład wymaga kursora zawarte w pliku kursora o nazwie `MyCursor.cur`. Aby skompilować ten przykład, przy użyciu wiersza polecenia, należy uwzględnić następujące flagi: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 Poniższy przykład kodu wyświetla informacje o kliencie w <xref:System.Windows.Forms.TreeView> kontroli. Węzły drzewa główne wyświetlenie nazwy klienta, a węzły drzewa podrzędnego wyświetlić numery przypisane do każdego klienta. W tym przykładzie 1000 klientów są wyświetlane z 15 zamówienia. Odświeżenie <xref:System.Windows.Forms.TreeView> jest pomijana przy użyciu <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> metody i oczekiwania <xref:System.Windows.Forms.Cursor> jest wyświetlany podczas <xref:System.Windows.Forms.TreeView> tworzy i maluje <xref:System.Windows.Forms.TreeNode> obiektów. W tym przykładzie wymaga, że masz plik kursora o nazwie `MyWait.cur` w katalogu aplikacji. Wymaga to również `Customer` obiekt, który może zawierać zbiór `Order` obiektów i utworzono wystąpienie <xref:System.Windows.Forms.TreeView> kontrolować na <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.Cursors" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(IntPtr handle);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : nativeint -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">
          <see cref="T:System.IntPtr" /> Reprezentujący dojście Windows kursora do utworzenia.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego dojścia Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Należy zwolnić uchwyt kursora, gdy są z nią zrobić. Aby uzyskać więcej informacji na temat usuwania zasobów, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia swoje położenie i prostokątny. Powoduje to, że kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest, gdy kod jest wykonywany. Ponadto prostokątnego wycinka kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga, że masz <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> jest <see cref="F:System.IntPtr.Zero" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : System.IO.Stream -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">Strumień danych, aby załadować <see cref="T:System.Windows.Forms.Cursor" /> z.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy ze strumienia określone dane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Strumień danych, określonego przez `stream` musi zawierać plik kursora (.cur).  
  
> [!NOTE]
>  Animowane kursory (pliki .ani) nie są obsługiwane przez <xref:System.Windows.Forms.Cursor> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu ładuje kursora z <xref:System.IO.Stream> utworzone przez <xref:System.Windows.Forms.OpenFileDialog.OpenFile%2A> metody <xref:System.Windows.Forms.OpenFileDialog>. Po wywołaniu metody <xref:System.Windows.Forms.OpenFileDialog> jest wyświetlany użytkownikowi i kiedy. Plików WALUTA jest zaznaczone i zamknąć okno dialogowe, plik jest otwarty i <xref:System.IO.Stream> zwrócony jest używany do tworzenia <xref:System.Windows.Forms.Cursor>.  
  
 [!code-cpp[CursorFromResource#1](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#1)]
 [!code-csharp[CursorFromResource#1](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#1)]
 [!code-vb[CursorFromResource#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.Stream" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Plik kursora do załadowania.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego pliku.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `fileName` Parametru musi odwoływać się plik standardowa kursora (.cur).  
  
> [!NOTE]
>  Animowane kursory (pliki .ani) nie są obsługiwane przez <xref:System.Windows.Forms.Cursor> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla informacje o kliencie w <xref:System.Windows.Forms.TreeView> kontroli. Węzły drzewa główne wyświetlenie nazwy klienta, a węzły drzewa podrzędnego wyświetlić numery przypisane do każdego klienta. W tym przykładzie 1000 klientów są wyświetlane z 15 zamówienia. Odświeżenie <xref:System.Windows.Forms.TreeView> jest pomijana przy użyciu <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> i <xref:System.Windows.Forms.TreeView.EndUpdate%2A> metody i oczekiwania <xref:System.Windows.Forms.Cursor> jest wyświetlany podczas <xref:System.Windows.Forms.TreeView> tworzy i maluje <xref:System.Windows.Forms.TreeNode> obiektów. W tym przykładzie wymaga, że masz `Customer` obiekt, który może zawierać zbiór `Order` obiektów. Wymaga to również, że utworzono wystąpienie <xref:System.Windows.Forms.TreeView> kontrolować na <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Cursor (Type type, string resource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type type, string resource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.#ctor(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Cursor(Type ^ type, System::String ^ resource);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Cursor : Type * string -&gt; System.Windows.Forms.Cursor" Usage="new System.Windows.Forms.Cursor (type, resource)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="resource" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Zasób <see cref="T:System.Type" />.</param>
        <param name="resource">Nazwa zasobu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.Cursor" /> klasy z określonego zasobu o typie określonego zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Oto przykład osadzania kursora jako zasób w aplikacji. Aby osadzić zasobu, odwoływać się do nazwy zasobu, a następnie przecinek, a następnie jego pełną ścieżkę do zestawu. W sekcji przykład dowiesz się, jak załadować kursora z zasobu osadzonego.  
  
```  
Using the C# compiler:  
csc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.cs  
Using the Visual Basic compiler:  
vbc /resource:"MyWaitCursor.cur","MyCursors.MyWaitCursor.cur" MyCursor.vb  
```  
  
> [!NOTE]
>  Odwołanie do zasobu podczas kompilowania kodu, a także podczas odwoływania się do kodu, jest uwzględniana wielkości liter Kompilatory języka C# i Visual Basic.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla formularz, który demonstruje sposób użycia niestandardowego kursor przy użyciu <xref:System.Windows.Forms.Cursor.%23ctor%2A> konstruktora. Niestandardowy <xref:System.Windows.Forms.Cursor> jest osadzony w pliku zasobów aplikacji. Przykład wymaga posiadania kursora zawarte w pliku kursora o nazwie `MyCursor.cur`. Aby skompilować ten przykład, przy użyciu wiersza polecenia, należy uwzględnić następujące flagi: `/res:MyCursor.Cur, CustomCursor.MyCursor.Cur`  
  
 [!code-csharp[System.Windows.Forms.Cursor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor/CS/customcursor.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor/VB/customcursor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public static System.Drawing.Rectangle Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Rectangle Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Clip As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Rectangle Clip { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Cursor.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia granice, które reprezentują Prostokątny wycinek dla kursora.</summary>
        <value>
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący Prostokątny wycinek dla <see cref="T:System.Windows.Forms.Cursor" />na współrzędne ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kursor obciętych może przenieść tylko w ramach jego prostokątny. Ogólnie rzecz biorąc system zezwala na to tylko wtedy, gdy wskaźnik myszy jest aktualnie przechwycony. Jeśli kursor nie jest obecnie przycinana, wynikowy prostokąt zawiera wymiary cały ekran.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia swoje położenie i prostokątny. Powoduje to, że kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest, gdy kod jest wykonywany. Ponadto prostokątnego wycinka kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga, że masz <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CopyHandle">
      <MemberSignature Language="C#" Value="public IntPtr CopyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int CopyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.CopyHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function CopyHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr CopyHandle();" />
      <MemberSignature Language="F#" Value="member this.CopyHandle : unit -&gt; nativeint" Usage="cursor.CopyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Kopiuje uchwyt to <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>
          <see cref="T:System.IntPtr" /> Reprezentujący uchwyt kursora.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uchwyt utworzone w wyniku wywołanie tej metody musi być usuwane po wykonaniu tych czynności z nią, ponieważ on nie zostanie usunięte z przez moduł odśmiecania pamięci.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IntPtr" />
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
        <altmember cref="T:System.GC" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Cursor Current { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Cursor Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Current As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Cursor ^ Current { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Cursor.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt kursor, który reprezentuje kursora myszy.</summary>
        <value>A <see cref="T:System.Windows.Forms.Cursor" /> reprezentujący kursora myszy. Wartość domyślna to <see langword="null" /> Jeśli kursor myszy nie jest widoczna.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie <xref:System.Windows.Forms.Cursor.Current%2A> zmienia właściwość kursora aktualnie wyświetlany. Aplikacja może lub nie może kontynuować do nasłuchiwania zdarzeń myszy. Do sygnalizowania, że aplikacja nie powinny odpowiadać na zdarzenia myszy podczas operacji długotrwałych, użyj <xref:System.Windows.Forms.Application.UseWaitCursor%2A> właściwości. W większości przypadków jednak zaleca się użycie wątku w tle do zarządzania długotrwałej operacji i pozostaw interfejsu użytkownika dostępnych dla użytkownika. Aby uzyskać więcej informacji na temat łatwe Implementowanie zadanie w tle, zobacz <xref:System.ComponentModel.BackgroundWorker>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla bezpiecznych okien podrzędnych ustawić tę właściwość. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="cursor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołaj <xref:System.Windows.Forms.Cursor.Dispose%2A> po zakończeniu przy użyciu <xref:System.Windows.Forms.Cursor>. `Dispose` Pozostawia metoda <xref:System.Windows.Forms.Cursor> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Windows.Forms.Cursor.Dispose%2A>, trzeba zwolnić wszystkie odwołania do <xref:System.Windows.Forms.Cursor> , moduł zbierający elementy bezużyteczne mógł odzyskać pamięć, <xref:System.Windows.Forms.Cursor> zajmowaną przez wystąpienie. Aby uzyskać więcej informacji, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Zawsze wywołuj <xref:System.Windows.Forms.Cursor.Dispose%2A> przed publikacją swoje ostatnie odwołanie do <xref:System.Windows.Forms.Cursor>. W przeciwnym razie zasoby, których używa nie zostanie zwolniona, dopóki moduł zbierający elementy bezużyteczne zwalnia je.  
  
   
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Draw">
      <MemberSignature Language="C#" Value="public void Draw (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Draw(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Draw (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Draw(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.Draw : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.Draw (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Powierzchni, na którym należy narysować <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Rysuje kursor na powierzchni określonej w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi na powierzchni grafiki, reprezentowane przez `g` parametru, ale <xref:System.Drawing.Graphics> nie zawiera informacji o tym, jak do renderowania danego obrazu, więc przekazuje wywołanie <xref:System.Windows.Forms.Cursor>. <xref:System.Windows.Forms.Cursor.Draw%2A> Metoda Przycina obraz danego wymiarów i pozwala na określenie <xref:System.Drawing.Rectangle> w ramach którego Rysowanie <xref:System.Windows.Forms.Cursor>. Ta metoda jest zwykle używana, jeśli chcesz narysować kursor na powierzchni grafiki. Na przykład, Niewykluczone, że okno dialogowe, które umożliwia użytkownikowi wybranie kursory z <xref:System.Windows.Forms.ListBox> formant lub grupa <xref:System.Windows.Forms.RadioButton> kontrolki.  
  
   
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga, że masz <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiekt przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="DrawStretched">
      <MemberSignature Language="C#" Value="public void DrawStretched (System.Drawing.Graphics g, System.Drawing.Rectangle targetRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawStretched(class System.Drawing.Graphics g, valuetype System.Drawing.Rectangle targetRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.DrawStretched(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DrawStretched (g As Graphics, targetRect As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawStretched(System::Drawing::Graphics ^ g, System::Drawing::Rectangle targetRect);" />
      <MemberSignature Language="F#" Value="member this.DrawStretched : System.Drawing.Graphics * System.Drawing.Rectangle -&gt; unit" Usage="cursor.DrawStretched (g, targetRect)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="g" Type="System.Drawing.Graphics" />
        <Parameter Name="targetRect" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="g">
          <see cref="T:System.Drawing.Graphics" /> Powierzchni, na którym należy narysować <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <param name="targetRect">
          <see cref="T:System.Drawing.Rectangle" /> Reprezentujący granice <see cref="T:System.Windows.Forms.Cursor" />.</param>
        <summary>Rysuje kursor w formacie rozciąganej powierzchni określonej w określonym zakresie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Polecenie rysowania pochodzi na powierzchni grafiki, reprezentowane przez `g` parametru, ale <xref:System.Drawing.Graphics> obiekt nie zawiera informacji na temat renderowania danego obrazu, więc przekazuje wywołanie <xref:System.Windows.Forms.Cursor> obiektu. <xref:System.Windows.Forms.Cursor.DrawStretched%2A> Metoda rozciąga obrazu w celu wypełnienia określonego <xref:System.Drawing.Rectangle> podczas rysowania kursora.  
  
   
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga, że masz <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiekt przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Draw(System.Drawing.Graphics,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="cursor.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.Forms.Cursor" /> Do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy ten kursor jest równa określonej <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>
          <see langword="true" /> Jeśli ten kursor jest równa określonej <see cref="T:System.Windows.Forms.Cursor" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia swoje położenie i prostokątny. Powoduje to, że kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest, gdy kod jest wykonywany. Ponadto prostokątnego wycinka kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Cursor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Cursor ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="cursor.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia obiektu spróbuj zwolnić zasoby i wykonywać inne operacje oczyszczania, zanim go jest odzyskiwane przez wyrzucanie elementów bezużytecznych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="cursor.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wartość skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Cursor.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt kursora.</summary>
        <value>
          <see cref="T:System.IntPtr" /> Reprezentujący uchwyt kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie jest to kopia uchwyt; Nie usuwaj go.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia swoje położenie i prostokątny. Powoduje to, że kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest, gdy kod jest wykonywany. Ponadto prostokątnego wycinka kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Wartość dojścia jest <see cref="F:System.IntPtr.Zero" />.</exception>
        <altmember cref="M:System.Windows.Forms.Cursor.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public static void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Hide();" />
      <MemberSignature Language="F#" Value="static member Hide : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ukrywa kursor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Show%2A> i <xref:System.Windows.Forms.Cursor.Hide%2A> musi być równoważony wywołania metody. Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> musi być odpowiedniego wywołania metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursor po umieszczeniu wskaźnika myszy obszaru klienckiego przycisku. Podobnie gdy kursor opuszcza obszar klienta przycisku, kursor ponownie jest wyświetlany. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> z <xref:System.Windows.Forms.Button> o nazwie `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">dla wszystkich okien wywołać tę metodę. Wyliczenie skojarzone: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Forms.Cursor.Show" />
      </Docs>
    </Member>
    <Member MemberName="HotSpot">
      <MemberSignature Language="C#" Value="public System.Drawing.Point HotSpot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point HotSpot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.HotSpot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HotSpot As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point HotSpot { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.HotSpot : System.Drawing.Point" Usage="System.Windows.Forms.Cursor.HotSpot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera aktywnego punktu kursora.</summary>
        <value>A <see cref="T:System.Drawing.Point" /> reprezentujący aktywnego punktu kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.HotSpot%2A> Jest <xref:System.Drawing.Point> w kursor, który współdziała z innymi elementami na ekranie.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwóch wystąpień z <see cref="T:System.Windows.Forms.Cursor" /> klasy są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiekt przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.Cursor left, System.Windows.Forms.Cursor right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.Cursor left, class System.Windows.Forms.Cursor right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.op_Inequality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Cursor, right As Cursor) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::Cursor ^ left, System::Windows::Forms::Cursor ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.Cursor * System.Windows.Forms.Cursor -&gt; bool" Usage="System.Windows.Forms.Cursor.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.Cursor" />
        <Parameter Name="right" Type="System.Windows.Forms.Cursor" />
      </Parameters>
      <Docs>
        <param name="left">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <param name="right">A <see cref="T:System.Windows.Forms.Cursor" /> do porównania.</param>
        <summary>Zwraca wartość wskazującą, czy dwóch wystąpień z <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są takie same.</summary>
        <returns>
          <see langword="true" /> Jeśli dwa wystąpienia <see cref="T:System.Windows.Forms.Cursor" /> klasy nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.Cursor.Equals%28System.Object%29?displayProperty=nameWithType>  
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.op_Equality(System.Windows.Forms.Cursor,System.Windows.Forms.Cursor)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Position" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Position As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point Position { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Position : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Cursor.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia położenie kursora.</summary>
        <value>A <see cref="T:System.Drawing.Point" /> reprezentujący pozycji kursora w współrzędne ekranu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Position%2A> Właściwości jest taka sama jak <xref:System.Windows.Forms.Control.MousePosition%2A?displayProperty=nameWithType> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kursora z <xref:System.Windows.Forms.Cursor.Current%2A> kursora <xref:System.Windows.Forms.Cursor.Handle%2A>, zmienia swoje położenie i prostokątny. Powoduje to, że kursor zostanie przesunięty w górę i po lewej stronie 50 pikseli, z którym jest, gdy kod jest wykonywany. Ponadto prostokątnego wycinka kursora jest zmieniana na granice formularza (domyślnie jest cały ekran użytkownika). W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Button> wywołać ten kod po kliknięciu.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursor Members#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#1)]
 [!code-vb[System.Windows.Forms.Cursor Members#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public static void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.Show" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Show();" />
      <MemberSignature Language="F#" Value="static member Show : unit -&gt; unit" Usage="System.Windows.Forms.Cursor.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wyświetla kursora.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Cursor.Show%2A> i <xref:System.Windows.Forms.Cursor.Hide%2A> musi być równoważony wywołania metody. Dla każdego wywołania <xref:System.Windows.Forms.Cursor.Hide%2A> musi być odpowiedniego wywołania metody <xref:System.Windows.Forms.Cursor.Show%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład kodu ukrywa kursor po umieszczeniu wskaźnika myszy obszaru klienckiego przycisku. Podobnie gdy kursor opuszcza obszar klienta przycisku, kursor ponownie jest wyświetlany. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> z <xref:System.Windows.Forms.Button> o nazwie `myButton`.  
  
 [!code-cpp[CursorFromResource#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CursorFromResource/CPP/mycursor.cpp#3)]
 [!code-csharp[CursorFromResource#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CursorFromResource/CS/mycursor.cs#3)]
 [!code-vb[CursorFromResource#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CursorFromResource/VB/mycursor.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Cursor.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Size" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size" Usage="System.Windows.Forms.Cursor.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera rozmiar obiektu kursora.</summary>
        <value>A <see cref="T:System.Drawing.Size" /> reprezentująca szerokość i wysokość <see cref="T:System.Windows.Forms.Cursor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy kod rysuje określoną kursora w formularzu w jego rozmiar Normalny, a także w trybie rozproszonym, dwa razy jego rozmiar. W tym przykładzie wymaga <xref:System.Windows.Forms.Form> i <xref:System.Windows.Forms.Cursor> obiekt przekazywany do metody, gdy jest wywoływana.  
  
 [!code-cpp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CPP/cursorstuff.cpp#2)]
 [!code-csharp[System.Windows.Forms.Cursor Members#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/CS/cursorstuff.cs#2)]
 [!code-vb[System.Windows.Forms.Cursor Members#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursor Members/VB/cursorstuff.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo si, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (si As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ si, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="si" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="si">Element <see cref="T:System.Runtime.Serialization.SerializationInfo" /> klasy.</param>
        <param name="context">Element <see cref="T:System.Runtime.Serialization.StreamingContext" /> klasy.</param>
        <summary>Serializuje obiekt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Cursor.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Cursor.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który zawiera dane o <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <value>
          <see cref="T:System.Object" /> Zawierający dane dotyczące <see cref="T:System.Windows.Forms.Cursor" />. Wartość domyślna to <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Cursor.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="cursor.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera ludzi czytelnych ciągów reprezentujących to <see cref="T:System.Windows.Forms.Cursor" />.</summary>
        <returns>A <see cref="T:System.String" /> reprezentująca to <see cref="T:System.Windows.Forms.Cursor" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <Metadata><Meta Name="ms.openlocfilehash" Value="acef322bce7f39090a371a6f921e04e98a12a700" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68392889" /></Metadata><TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingSource&#xA;Inherits Component&#xA;Implements IBindingListView, ICancelAddNew, ICurrencyManagerProvider, IList, ISupportInitializeNotification, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingSource : System::ComponentModel::Component, System::Collections::IList, System::ComponentModel::IBindingListView, System::ComponentModel::ICancelAddNew, System::ComponentModel::ISupportInitializeNotification, System::ComponentModel::ITypedList, System::Windows::Forms::ICurrencyManagerProvider" />
  <TypeSignature Language="F#" Value="type BindingSource = class&#xA;    inherit Component&#xA;    interface IBindingListView&#xA;    interface IBindingList&#xA;    interface IList&#xA;    interface ICollection&#xA;    interface IEnumerable&#xA;    interface ITypedList&#xA;    interface ICancelAddNew&#xA;    interface ISupportInitializeNotification&#xA;    interface ISupportInitialize&#xA;    interface ICurrencyManagerProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje źródło danych dla formularza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource> Składnik pełni wiele celów. Po pierwsze upraszcza kontrolki wiązania w formularzu do danych, zapewniając zarządzanie walutą, powiadamianie o zmianach i inne usługi między Windows Formsmi kontrolkami i źródłami danych. Jest to realizowane przez dołączenie <xref:System.Windows.Forms.BindingSource> składnika do źródła danych <xref:System.Windows.Forms.BindingSource.DataSource%2A> przy użyciu właściwości. W przypadku złożonych scenariuszy powiązań można opcjonalnie ustawić <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwość na określoną kolumnę lub listę w źródle danych. Następnie można powiązać kontrolki z <xref:System.Windows.Forms.BindingSource>. Wszystkie dalsze interakcje z danymi są realizowane przy użyciu wywołań do <xref:System.Windows.Forms.BindingSource> składnika. Aby zapoznać się z przykładami dotyczącymi sposobu <xref:System.Windows.Forms.BindingSource> tworzenia powiązań, zobacz [How to: Powiąż Windows Forms formantów z wartościami](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) bazy danych DBNull i [instrukcje: Obsługa błędów i wyjątków występujących podczas wiązania](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md)z danymi. Nawigacja i aktualizacja źródła danych odbywa się za pomocą metod takich jak <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, i <xref:System.Windows.Forms.BindingSource.Remove%2A>. Operacje, takie jak sortowanie i filtrowanie, są obsługiwane <xref:System.Windows.Forms.BindingSource.Sort%2A> za <xref:System.Windows.Forms.BindingSource.Filter%2A> pomocą właściwości i. Aby uzyskać więcej informacji na temat sortowania i filtrowania przy <xref:System.Windows.Forms.BindingSource>użyciu, [zobacz How to: Sortuj i Filtruj dane ADO.NET za pomocą składnika](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md)BindingSource Windows Forms.  
  
 Ponadto <xref:System.Windows.Forms.BindingSource> składnik może działać jako źródło danych o jednoznacznie określonym typie. Zazwyczaj typ bazowego źródła danych jest ustalony za pomocą jednego z następujących mechanizmów:  
  
-   Użyj metody <xref:System.Windows.Forms.BindingSource.Add%2A> , aby dodać element <xref:System.Windows.Forms.BindingSource> do składnika.  
  
-   <xref:System.Windows.Forms.BindingSource.DataSource%2A> Ustaw właściwość na listę, pojedynczy obiekt lub typ.  
  
 Oba te mechanizmy tworzą listę o jednoznacznie określonym typie. Aby uzyskać więcej informacji na temat tworzenia <xref:System.Windows.Forms.BindingSource> powiązania z typem, zobacz [How to: Powiąż formant Windows Forms z typem](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). Można również użyć, <xref:System.Windows.Forms.BindingSource> aby powiązać kontrolki z obiektem fabryki. Aby uzyskać więcej informacji o tym, jak to zrobić [, zobacz How to: Powiąż formant Windows Forms z obiektem](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md)fabryki.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.BindingSource> Ponieważ obsługiwane są proste i złożone źródła danych, terminologia jest problematyczna. W tej dokumentacji klasy termin *Lista* dotyczy kolekcji danych w hostowanym źródle danych, a *element* oznacza pojedynczy element. Podczas omawiania funkcji skojarzonych ze złożonymi źródłami danych są używane równoważne *tabele* i *wiersze* warunków.  
  
 <xref:System.Windows.Forms.BindingSource>zapewnia członkom dostęp do danych źródłowych. Bieżący element można pobrać za pomocą <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości, a cała lista może zostać pobrana <xref:System.Windows.Forms.BindingSource.List%2A> za pomocą właściwości. Operacje edycji są obsługiwane dla bieżącego elementu za pomocą <xref:System.Windows.Forms.BindingSource.Current%2A> <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>i <xref:System.Windows.Forms.BindingSource.AddNew%2A> metod, <xref:System.Windows.Forms.BindingSource.EndEdit%2A> <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> i <xref:System.Windows.Forms.BindingSource.Add%2A> . Chociaż zarządzanie walutą jest obsługiwane automatycznie dla wszystkich typów źródeł danych, ta klasa ujawnia wiele zdarzeń, takich jak <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> i <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, które umożliwiają dostosowywanie.  
  
 Źródła danych, które są powiązane <xref:System.Windows.Forms.BindingSource> ze składnikiem, można także nawigować i zarządzać nimi <xref:System.Windows.Forms.BindingNavigator> za pomocą klasy, która udostępnia interfejs użytkownika, który umożliwia nawigowanie w przypadku elementów na liście. Chociaż <xref:System.Windows.Forms.BindingNavigator> może być powiązany z dowolnym źródłem danych, został zaprojektowany do integracji <xref:System.Windows.Forms.BindingSource> ze składnikiem za pomocą jego <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> właściwości.  
  
 Właściwość <xref:System.Windows.Forms.BindingSource> domyślna klasy to <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Domyślne zdarzenie to <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Wiele elementów członkowskich <xref:System.Windows.Forms.BindingSource> klasy działa na podstawowej liście reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość i po prostu odwołuje się do swojej operacji na podstawową listę. W związku z tym <xref:System.Windows.Forms.BindingSource> , gdy jest powiązany z <xref:System.Collections.IList>implementacją niestandardową, dokładne zachowanie tych elementów może różnić się od zachowania opisanego w dokumentacji klasy. Na przykład <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> metoda wywołuje <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>metodę. Dokumentacja zawiera opis <xref:System.Collections.IList> metody z zrozumieniem, że Metodabazowajestprawidłowozaimplementowana.<xref:System.Collections.IList.RemoveAt%2A> <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> <xref:System.Windows.Forms.BindingSource>  
  
   
  
## Examples  
 Poniższy przykład kodu ilustruje <xref:System.Windows.Forms.ListBox> powiązanie <xref:System.Windows.Forms.BindingSource>z. <xref:System.Windows.Forms.BindingSource> Jest powiązany<xref:System.ComponentModel.BindingList%601> z, który zawiera listę czcionek.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingSource" />
    <altmember cref="T:System.Windows.Forms.BindingNavigator" />
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.CurrencyManager" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.ComponentModel.IBindingList" />
    <altmember cref="T:System.ComponentModel.IEditableObject" />
    <related type="Article" href="~/docs/framework/winforms/controls/bindingsource-component.md">BindingSource — Składnik</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.BindingSource" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.BindingSource" /> klasy do domyślnych wartości właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono domyślne <xref:System.Windows.Forms.BindingSource> wartości właściwości inicjowane przez tego konstruktora.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::ComponentModel::IContainer ^ container);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : System.ComponentModel.IContainer -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource container" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">Aby dodać bieżącą <see cref="T:System.Windows.Forms.BindingSource" />do. <see cref="T:System.ComponentModel.IContainer" /></param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.BindingSource" /> klasy i <see cref="T:System.Windows.Forms.BindingSource" /> dodaje do określonego kontenera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor wywołuje konstruktora bez parametrów, a następnie dodaje bieżącą <xref:System.Windows.Forms.BindingSource> do określonego kontenera. Nie jest zazwyczaj używany przez programistę rozwiązań, ale zamiast tego przez autorów środowiska czasu projektowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.BindingSource : obj * string -&gt; System.Windows.Forms.BindingSource" Usage="new System.Windows.Forms.BindingSource (dataSource, dataMember)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Źródło danych dla <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">Określona nazwa kolumny lub listy w źródle danych, z którą ma zostać utworzone powiązanie.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Windows.Forms.BindingSource" /> klasy z określonym źródłem danych i składową danych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Add : obj -&gt; int&#xA;override this.Add : obj -&gt; int" Usage="bindingSource.Add value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Element <see cref="T:System.Object" /> do dodania do listy wewnętrznej.</param>
        <summary>Dodaje istniejący element do listy wewnętrznej.</summary>
        <returns>Indeks (liczony od zera), <paramref name="value" /> który został dodany do podstawowej listy reprezentowanej <see cref="P:System.Windows.Forms.BindingSource.List" /> przez właściwość.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odwołuje się do wywołania `Add` metody podstawowej listy. <xref:System.Windows.Forms.BindingSource.Add%2A>  
  
 Wewnętrzna lista musi zawierać jednorodne typy. <xref:System.Windows.Forms.BindingSource.DataSource%2A> Jeśli właściwość nie została jeszcze ustawiona, pierwszy obiekt dodany do listy definiuje typ listy.  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.BindingSource.Add%2A> metody. Aby uruchomić ten przykład, wklej kod do formularza systemu Windows i Wywołaj `PopulateBindingSourceWithFonts` metodę z konstruktora formularza.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" />różni się w typie od istniejących elementów na liście podstawowej.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AddingNew As AddingNewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AddingNewEventHandler ^ AddingNew;" />
      <MemberSignature Language="F#" Value="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " Usage="member this.AddingNew : System.ComponentModel.AddingNewEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, zanim element zostanie dodany do listy podstawowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie występuje przed dodaniem nowego obiektu do podstawowej listy reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość. <xref:System.Windows.Forms.BindingSource.AddingNew> To zdarzenie jest wywoływane po <xref:System.Windows.Forms.BindingSource.AddNew%2A> wywołaniu metody, ale przed utworzeniem nowego elementu i dodaniem go do listy podstawowej. Dzięki obsłudze tego zdarzenia programista może zapewnić niestandardowe zachowanie tworzenia i wstawiania elementów bez wymuszania wykluczania <xref:System.Windows.Forms.BindingSource> z klasy. Jest to realizowane w programie obsługi zdarzeń przez ustawienie <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwości <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parametru na nowy element. Nowy obiekt utworzony w <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzeniu musi być tego samego typu co typ zawarty na liście lub wystąpił wyjątek. Nie można ustawić <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwości w przypadku powiązania <xref:System.Data.DataView> z lub <xref:System.Data.DataTable> , ponieważ nie można dodać nowego <xref:System.Data.DataRowView> elementu do listy.  
  
 Aby uzyskać więcej informacji na temat dostarczania funkcji niestandardowego nowego elementu, zobacz <xref:System.Windows.Forms.BindingSource.AddNew%2A> metodę. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.BindingSource> składnika, aby powiązać listę <xref:System.Windows.Forms.DataGridView> z kontrolką. Nowe elementy są dodawane do listy przez <xref:System.Windows.Forms.BindingSource.AddingNew> program obsługi zdarzeń. Ten przykład kodu jest częścią większego przykładu przedstawionego [w temacie How to: Dostosuj Dodawanie elementów za pomocą elementu BindingSource](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md)Windows Forms.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />nie jest tym samym typem, który znajduje się na liście.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNew () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ AddNew();" />
      <MemberSignature Language="F#" Value="abstract member AddNew : unit -&gt; obj&#xA;override this.AddNew : unit -&gt; obj" Usage="bindingSource.AddNew " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.AddNew</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nowy element do listy podstawowej.</summary>
        <returns>, <see cref="T:System.Object" /> Który został utworzony i dodany do listy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda dodaje nowy element do podstawowej listy reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość. <xref:System.Windows.Forms.BindingSource.AddNew%2A> Ta metoda konfiguruje następującą serię akcji:  
  
1.  <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Metoda jest wywoływana automatycznie, aby zatwierdzić wszystkie oczekujące operacje edycji.  
  
2.  <xref:System.Windows.Forms.BindingSource.AddingNew> Zdarzenie jest zgłaszane automatycznie. To zdarzenie może być obsługiwane programowo w celu skonstruowania nowego elementu. Jest to realizowane w programie obsługi zdarzeń przez ustawienie <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwości <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parametru na nowy element. Nowy obiekt utworzony w <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzeniu musi być tego samego typu co typ zawarty na liście lub wystąpił wyjątek.  
  
     Jeśli zdarzenie nie jest obsługiwane, a podstawową listą <xref:System.ComponentModel.IBindingList>jest a, żądanie jest <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> przesyłane do metody listy. <xref:System.Windows.Forms.BindingSource.AddingNew> Jeśli podstawowa lista nie <xref:System.ComponentModel.IBindingList>jest, element jest automatycznie tworzony za pomocą publicznego konstruktora bez parametrów. W obu przypadkach nowy element zostanie dodany na końcu listy.  
  
3.  Nowy element zostanie natychmiast dodany do listy wewnętrznej, chyba że źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejs. W takim przypadku nowy element nie jest zatwierdzany do momentu wywołania <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> jawnego lub do momentu zainicjowania nowej listy operacji. Przed zatwierdzeniem nowy element można wycofać, wywołując <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, w którym przypadku nowy element zostanie odrzucony.  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.BindingSource> składnika, aby powiązać listę <xref:System.Windows.Forms.DataGridView> z kontrolką. Nowe elementy są dodawane do listy przez <xref:System.Windows.Forms.BindingSource.AddingNew> program obsługi zdarzeń. Ten przykład kodu jest częścią większego przykładu przedstawionego [w temacie How to: Dostosuj Dodawanie elementów za pomocą elementu BindingSource](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md)Windows Forms.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Właściwość jest ustawiona na <see langword="false" />. <see cref="P:System.Windows.Forms.BindingSource.AllowNew" />  
  
—lub— 
Nie można odnaleźć publicznego konstruktora bez parametrów dla bieżącego typu elementu.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
        <altmember cref="T:System.ComponentModel.IBindingList" />
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowEdit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowEdit : bool" Usage="System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.AllowEdit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy elementy na liście bazowej mogą być edytowane.</summary>
        <value><see langword="true" />Aby wskazać, że można edytować elementy listy; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> Właściwość jest zwykle używana przez inne składniki, aby określić, czy edytowanie elementów na liście jest dozwolone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowNew As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowNew { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowNew : bool with get, set" Usage="System.Windows.Forms.BindingSource.AllowNew" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> Metoda może być używana do dodawania elementów do listy.</summary>
        <value><see langword="true" />Jeśli <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> można użyć, <see langword="false" />aby dodać elementy do listy; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość <xref:System.Windows.Forms.BindingSource.AllowNew%2A> domyślna właściwości zależy od bazowego typu źródła danych. Jeśli podstawowa lista implementuje <xref:System.ComponentModel.IBindingList> interfejs, ta właściwość zostanie delegowana do podstawowej listy. W przeciwnym razie ta właściwość zwróci `false` wartość, jeśli podstawowa lista ma jedną z następujących cech:  
  
-   Ma stały rozmiar, określony przez <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> właściwość.  
  
-   Jest on tylko do odczytu określony przez <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> właściwość.  
  
-   Typ elementu nie ma konstruktora bez parametrów.  
  
> [!NOTE]
>  Po ustawieniu wartości tej właściwości metoda pobierająca nie będzie już odwoływać wywołania do podstawowej listy. Zamiast tego po prostu zwraca wartość, która była poprzednio ustawiona do momentu <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> wywołania metody.  
  
 Ustawienie tej właściwości wywołuje <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną na <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>.  
  
 Jeśli ustawisz <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwość na `true` , a bazowy typ listy nie ma konstruktora bez parametrów <xref:System.Windows.Forms.BindingSource.AddingNew> , musisz obsłużyć zdarzenie i utworzyć odpowiedni typ.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości <xref:System.Windows.Forms.BindingSource> składnika, aby zezwolić użytkownikowi na <xref:System.Windows.Forms.BindingSource> Dodawanie nowych elementów do podstawowej listy składników. Ustawienie tej właściwości `true` powoduje, że formant <xref:System.Windows.Forms.DataGridView> powiązany będzie wyświetlał jego wiersz dla nowych rekordów.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest ustawiona na <see langword="true" /> , gdy podstawowa lista reprezentowana <see cref="P:System.Windows.Forms.BindingSource.List" /> przez właściwość ma ustalony rozmiar lub jest tylko do odczytu.</exception>
        <exception cref="T:System.MissingMethodException">Właściwość jest ustawiona na <see langword="true" /> <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> , a zdarzenie nie jest obsługiwane, jeśli typ listy podstawowej nie ma konstruktora bez parametrów.</exception>
        <altmember cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowEdit" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowRemove" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowRemove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowRemove { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowRemove : bool" Usage="System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.AllowRemove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy elementy można usunąć z listy podstawowej.</summary>
        <value><see langword="true" />Aby wskazać elementy listy, można je usunąć z listy. w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> Właściwość jest zwykle używana przez inne składniki, aby określić, czy edytowanie elementów na liście jest dozwolone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplySort">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje źródło danych z określonym opisem lub opisami sortowania.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (sorts As ListSortDescriptionCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::ListSortDescriptionCollection ^ sorts);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.ListSortDescriptionCollection -&gt; unit" Usage="bindingSource.ApplySort sorts" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingListView.ApplySort(System.ComponentModel.ListSortDescriptionCollection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">A <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> zawiera opisy sortowania, które mają zostać zastosowane do źródła danych.</param>
        <summary>Sortuje źródło danych z określonymi opisami sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView>implementuje sortowanie wielokolumnowe jako zbiór par kieruneku deskryptora właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Źródło danych nie <see cref="T:System.ComponentModel.IBindingListView" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (property As PropertyDescriptor, sort As ListSortDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::PropertyDescriptor ^ property, System::ComponentModel::ListSortDirection sort);" />
      <MemberSignature Language="F#" Value="abstract member ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit&#xA;override this.ApplySort : System.ComponentModel.PropertyDescriptor * System.ComponentModel.ListSortDirection -&gt; unit" Usage="bindingSource.ApplySort (property, sort)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> , który opisuje właściwość, według której ma zostać posortowane źródło danych.</param>
        <param name="sort"><see cref="T:System.ComponentModel.ListSortDirection" /> Wskazuje, jak powinna być posortowana lista.</param>
        <summary>Sortuje źródło danych przy użyciu określonego deskryptora właściwości i kierunku sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program implementuje sortowanie pojedynczej kolumny przy <xref:System.ComponentModel.PropertyDescriptor> użyciu elementu, aby wskazać właściwość, według której <xref:System.ComponentModel.ListSortDirection> ma zostać wykonane sortowanie, i wskazuje, czy zawartość właściwości ma być sortowana w kolejności rosnącej czy malejącej. <xref:System.ComponentModel.IBindingList>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Źródło danych nie <see cref="T:System.ComponentModel.IBindingList" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingComplete As BindingCompleteEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingCompleteEventHandler ^ BindingComplete;" />
      <MemberSignature Language="F#" Value="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " Usage="member this.BindingComplete : System.Windows.Forms.BindingCompleteEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wszystkie komputery klienckie zostały powiązane z tym <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie występuje, gdy wszyscy klienci, zazwyczaj kontrolki, zostały powiązana z bieżącym <xref:System.Windows.Forms.BindingSource>. <xref:System.Windows.Forms.BindingSource.BindingComplete> Procedura obsługi tego zdarzenia może wykonać odpowiednią akcję na podstawie sukcesu, błędu lub wyjątków w procesie powiązania, sprawdzając <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> Właściwość <xref:System.Windows.Forms.BindingCompleteEventArgs> parametru.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje obsługę <xref:System.Windows.Forms.BindingSource.BindingComplete> zdarzenia. Aby uruchomić ten kod, wklej go do pustego pliku kodu.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState" />
        <altmember cref="T:System.Windows.Forms.BindingCompleteEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberSignature Language="F#" Value="member this.CancelEdit : unit -&gt; unit" Usage="bindingSource.CancelEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Anuluje bieżącą operację edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odrzuca modyfikacje danych od momentu ostatniej operacji zapisywania lub ładowania w przypadku spełnienia obu następujących warunków:  
  
-   Źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejs.  
  
-   <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Metoda nie została jeszcze wywołana.  
  
 Ta metoda wywołuje <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> metodę źródłową <xref:System.Windows.Forms.CurrencyManager>i jest objęta zakresem zmian na poziomie wiersza.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="bindingSource.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda usuwa wszystkie elementy z podstawowej listy reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość i ustawia <xref:System.Windows.Forms.BindingSource.Count%2A> właściwość na zero. <xref:System.Windows.Forms.BindingSource.Clear%2A>  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : obj -&gt; bool&#xA;override this.Contains : obj -&gt; bool" Usage="bindingSource.Contains value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Aby znaleźć na liście podstawowej reprezentowanej <see cref="P:System.Windows.Forms.BindingSource.List" /> przez właściwość. <see cref="T:System.Object" /> Wartość może być <see langword="null" />równa.</param>
        <summary>Określa, czy obiekt jest elementem na liście.</summary>
        <returns><see langword="true" />Jeśli parametr zostanie znaleziony <see cref="P:System.Windows.Forms.BindingSource.List" />w; w przeciwnym razie, <see langword="false" />. <paramref name="value" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż implementacja jest zależna od `Contains` metody podstawowej listy, zazwyczaj stosuje się następujące cechy:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A>jest przeszukiwany Zaczynając od pierwszego elementu i kończąc na ostatnim elemencie.  
  
-   Metoda bazowa wykonuje wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny do wartości <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości.  
  
-   Metoda bazowa określa równość przez wywołanie <xref:System.Object.Equals%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (arr As Array, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ arr, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="bindingSource.CopyTo (arr, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Tablica docelowa.</param>
        <param name="index">Indeks w tablicy docelowej, w której ma zostać rozpoczęta operacja kopiowania.</param>
        <summary>Kopiuje zawartość <see cref="P:System.Windows.Forms.BindingSource.List" /> do określonej tablicy, rozpoczynając od określonej wartości indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tej metody można użyć do łączenia elementów z wielu źródeł w jedną tablicę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Windows.Forms.BindingSource.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera łączną liczbę elementów na podstawowej liście, pobierając bieżącą <see cref="P:System.Windows.Forms.BindingSource.Filter" /> wartość.</summary>
        <value>Całkowita liczba filtrowanych elementów na liście podstawowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość pobiera liczbę elementów na liście podstawowej reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość jako zmodyfikowaną <xref:System.Windows.Forms.BindingSource.Filter%2A> przez wartość właściwości. <xref:System.Windows.Forms.BindingSource.Count%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.BindingSource.List%2A>elementy, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>i <xref:System.Windows.Forms.BindingSource.Count%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> nazwane `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`i przycisk o nazwie `button1`. Skojarz metodę ze zdarzeniem `button1`. <xref:System.Windows.Forms.Control.Click> `button1_Click` Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrencyManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::CurrencyManager ^ CurrencyManager { System::Windows::Forms::CurrencyManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrencyManager : System.Windows.Forms.CurrencyManager" Usage="System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.ICurrencyManagerProvider.CurrencyManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera Menedżera waluty skojarzonego z tym <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <value>Skojarzone z tym <see cref="T:System.Windows.Forms.BindingSource" />elementem. <see cref="T:System.Windows.Forms.CurrencyManager" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz uzyskać dostęp do Menedżera waluty dla innego powiązania do tego samego elementu członkowskiego danych, <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> Użyj metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : obj" Usage="System.Windows.Forms.BindingSource.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element z listy.</summary>
        <value>Reprezentuje bieżący element na liście podstawowej reprezentowanej <see cref="P:System.Windows.Forms.BindingSource.List" /> przez właściwość lub <see langword="null" /> Jeśli lista nie zawiera żadnych elementów. <see cref="T:System.Object" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, aby uzyskać dostęp do bieżącego elementu, ale <xref:System.Windows.Forms.BindingSource.List%2A> Użyj właściwości, aby uzyskać całą listę. <xref:System.Windows.Forms.BindingSource.Current%2A> Aby określić typ bieżącego obiektu, użyj <xref:System.Object.GetType%2A>metody lub. <xref:System.Object.ToString%2A>  
  
 Aby zmienić bieżący element, należy ustawić <xref:System.Windows.Forms.BindingSource.Position%2A> właściwość na nową wartość całkowitą lub użyć jednej z metod nawigacji, takich jak. <xref:System.Windows.Forms.BindingSource.MoveNext%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.BindingSource.Current%2A> właściwość. Aby uruchomić ten przykład, wklej kod do formularza i Wywołaj `PopulateBindingSourceWithFonts` metodę z metody obsługi <xref:System.Windows.Forms.Form.Load> zdarzeń formularza.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentChanged : EventHandler " Usage="member this.CurrentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie aktualnie powiązanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest zgłaszane <xref:System.Windows.Forms.BindingSource.Current%2A> przy każdej zmianie właściwości z jednego z następujących powodów: <xref:System.Windows.Forms.BindingSource.CurrentChanged>  
  
-   Bieżąca pozycja <xref:System.Windows.Forms.BindingSource.List%2A> zmian.  
  
-   Zmiany właściwości <xref:System.Windows.Forms.BindingSource.DataMember%2A>lub. <xref:System.Windows.Forms.BindingSource.DataSource%2A>  
  
-   Członkostwo w podstawowych <xref:System.Windows.Forms.BindingSource.List%2A> zmianach, które powodują <xref:System.Windows.Forms.BindingSource.Position%2A> odwoływanie się do innego elementu. Przykłady obejmują dodawanie lub usuwanie elementu przed bieżącym elementem, usuwanie lub przeniesienie bieżącego elementu albo przeniesienie elementu do bieżącego położenia.  
  
-   Podstawowa lista jest odświeżana przez nową operację sortowania lub filtrowania.  
  
 Gdy to zdarzenie jest wyzwalane, <xref:System.Windows.Forms.BindingSource.Current%2A> właściwość będzie już zawierać nową wartość.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged>jest zdarzeniem domyślnym dla <xref:System.Windows.Forms.BindingSource> klasy.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentItemChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentItemChanged;" />
      <MemberSignature Language="F#" Value="member this.CurrentItemChanged : EventHandler " Usage="member this.CurrentItemChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość <see cref="P:System.Windows.Forms.BindingSource.Current" /> właściwości właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie jest zgłaszane w odpowiedzi na wszystkie okoliczności, które <xref:System.Windows.Forms.BindingSource.CurrentChanged> powodują wystąpienie zdarzenia. <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> Ponadto jest <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> również uruchamiany zawsze, gdy wartość jednej z <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości jest zmieniana.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataError As BindingManagerDataErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingManagerDataErrorEventHandler ^ DataError;" />
      <MemberSignature Language="F#" Value="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " Usage="member this.DataError : System.Windows.Forms.BindingManagerDataErrorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek związany z walutą jest dyskretnie obsługiwany przez <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie jest informacyjne i zgłasza tylko wyjątki zgodne ze specyfikacją CLS. Aby określić, jakiego typu wystąpił wyjątek, Obsłuż to zdarzenie i <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> Sprawdź właściwość. <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataMember : string with get, set" Usage="System.Windows.Forms.BindingSource.DataMember" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia określoną listę w źródle danych, do której jest aktualnie powiązany łącznik.</summary>
        <value>Nazwa listy (lub wiersza) w <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli zawiera wiele list (lub tabel) danych, należy <xref:System.Windows.Forms.BindingSource.DataMember%2A> ustawić właściwość na nazwę jednego ze źródeł. <xref:System.Windows.Forms.BindingSource.DataSource%2A>  
  
 Ustawienie tej właściwości wywołuje <xref:System.Windows.Forms.BindingSource.DataMemberChanged> zdarzenie  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataMemberChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataMemberChanged;" />
      <MemberSignature Language="F#" Value="member this.DataMemberChanged : EventHandler " Usage="member this.DataMemberChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.BindingSource.DataMember" /> gdy wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Zdarzenie występuje <xref:System.Windows.Forms.BindingSource.DataMember%2A> po zmianie właściwości.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DataSource : obj with get, set" Usage="System.Windows.Forms.BindingSource.DataSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia źródło danych, z którym jest powiązany łącznik.</summary>
        <value><see cref="T:System.Object" /> Działa jako źródło danych. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataSource%2A> Właściwość może być ustawiona na wiele źródeł danych, w tym typów, obiektów i list typów. Utworzone źródło danych zostanie uwidocznione jako lista. W poniższej tabeli przedstawiono niektóre typowe źródła danych i ocenę listy wyników.  
  
|DataSource — właściwość|Wyświetl wyniki|  
|-------------------------|------------------|  
|`null`|Puste <xref:System.ComponentModel.IBindingList> obiekty. Dodanie elementu ustawia listę na typ dodanego elementu.|  
|`null`z <xref:System.Windows.Forms.BindingSource.DataMember%2A> zestawem|Nieobsługiwane, podnosi <xref:System.ArgumentException>.|  
|Typ bez listy lub obiekt typu "T"|Puste <xref:System.ComponentModel.IBindingList> typu "T".|  
|Wystąpienie tablicy|<xref:System.ComponentModel.IBindingList>zawierający elementy tablicy.|  
|<xref:System.Collections.IEnumerable>np|<xref:System.ComponentModel.IBindingList> Zawierający<xref:System.Collections.IEnumerable> elementy.|  
|Wystąpienie listy zawierające typ "T"|<xref:System.ComponentModel.IBindingList>wystąpienie zawierające typ "T".|  
  
 Ponadto można ustawić <xref:System.Windows.Forms.BindingSource.DataSource%2A> inne typy list, takie jak <xref:System.ComponentModel.IListSource> i <xref:System.ComponentModel.ITypedList> , a <xref:System.Windows.Forms.BindingSource> następnie odpowiednio je obsłuży. W takim przypadku Typ zawarty na liście powinien mieć konstruktora bez parametrów.  
  
 Podczas ustawiania źródła danych, jeśli podane odwołanie zawiera więcej niż jedną listę lub tabelę, należy ustawić <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwość na ciąg określający listę, z którą ma zostać utworzone powiązanie. Ustawienie tej właściwości wywołuje <xref:System.Windows.Forms.BindingSource.DataSourceChanged> zdarzenie.  
  
> [!NOTE]
>  Jeśli wprowadzisz jakiekolwiek zmiany <xref:System.Windows.Forms.BindingSource.DataSource%2A> wartości właściwości, należy to zrobić w wątku interfejsu użytkownika, aby upewnić się, że ten interfejs użytkownika odzwierciedla zmiany.  
  
 Właściwość jest domyślną właściwością <xref:System.Windows.Forms.BindingSource> dla klasy. <xref:System.Windows.Forms.BindingSource.DataSource%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu przypisuje listę klientów do <xref:System.Windows.Forms.BindingSource.DataSource%2A> <xref:System.Windows.Forms.BindingSource> składnika. Ten przykład kodu jest częścią większego przykładu [: Zgłoś powiadomienia o zmianie za pomocą metody](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md)BindingSource ResetItem.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.ComponentModel.IListSource" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberSignature Language="F#" Value="member this.DataSourceChanged : EventHandler " Usage="member this.DataSourceChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, <see cref="P:System.Windows.Forms.BindingSource.DataSource" /> gdy wartość właściwości zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Zdarzenie występuje <xref:System.Windows.Forms.BindingSource.DataSource%2A> po zmianie właściwości.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="bindingSource.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Windows.Forms.BindingSource" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose` <xref:System.Object.Finalize%2A> i metodę. `Dispose`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość true, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Windows.Forms.BindingSource> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. W przypadku <see langword="Dispose(Boolean)" /> przesłaniania należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały <see langword="Dispose" />wcześniej usunięte w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose(Boolean)" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see cref="M:System.Object.Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndEdit();" />
      <MemberSignature Language="F#" Value="member this.EndEdit : unit -&gt; unit" Usage="bindingSource.EndEdit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stosuje oczekujące zmiany do bazowego źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wywołaniu <xref:System.Windows.Forms.BindingSource.EndEdit%2A> metody wszystkie oczekujące zmiany są stosowane do bazowego źródła danych.  
  
 Ta metoda nie działa, chyba że obiekty zawarte w źródle danych implementują <xref:System.ComponentModel.IEditableObject> interfejs. Jeśli obiekty nie implementują <xref:System.ComponentModel.IEditableObject> interfejsu, zmiany danych są kopiowane do bazowego źródła danych natychmiast po każdej zmianie.  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Filter : string with get, set" Usage="System.Windows.Forms.BindingSource.Filter" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.Filter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyrażenie używane do filtrowania wierszy, które są wyświetlane.</summary>
        <value>Ciąg określający sposób filtrowania wierszy. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle używane w scenariuszach <xref:System.Windows.Forms.BindingSource.Filter%2A> złożonych powiązań danych Właściwość pozwala na wyświetlanie podzestawu. <xref:System.Windows.Forms.BindingSource.DataSource%2A> Tylko podstawowe listy implementujące <xref:System.ComponentModel.IBindingListView> filtrowanie obsługi interfejsu.  
  
 Gdy <xref:System.Windows.Forms.BindingSource.Filter%2A> nie `null`jest ,<xref:System.Windows.Forms.BindingSource> przekazuje tę właściwość do listy podstawowej. Jeśli ustawisz tę właściwość podczas inicjowania obiektu, wywołanie zostanie odroczone do momentu ukończenia inicjalizacji.  
  
 Aby utworzyć wartość filtru, należy określić nazwę kolumny, po której następuje operator i wartość, według której ma zostać wykonane filtrowanie. Zaakceptowana składnia filtru zależy od bazowego źródła danych. Jeśli bazowe źródło danych <xref:System.Data.DataSet>to, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, można określić wyrażenia <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> logiczne przy użyciu składni udokumentowanej dla właściwości.  
  
 Wartość <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości ma wpływ na wartość <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości. Ponadto <xref:System.Windows.Forms.BindingSource.Filter%2A> wartość będzie trwała, gdy źródło danych zostanie zmienione. Aby zatrzymać filtrowanie <xref:System.Windows.Forms.BindingSource.DataSource%2A>, <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Wywołaj metodę.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Forms.BindingSource.Filter%2A> jak używać właściwości <xref:System.Data.DataView>z. Aby uruchomić ten przykład, wklej kod do formularza systemu Windows i Wywołaj `PopulateDataViewAndFilter` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń. Formularz powinien importować <xref:System.Xml> przestrzenie nazw <xref:System.IO> i.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveFilter" />
        <altmember cref="P:System.ComponentModel.IBindingList.IsSorted" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Znajdź określony element w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (prop As PropertyDescriptor, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Find(System::ComponentModel::PropertyDescriptor ^ prop, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="abstract member Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int&#xA;override this.Find : System.ComponentModel.PropertyDescriptor * obj -&gt; int" Usage="bindingSource.Find (prop, key)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop"><see cref="T:System.ComponentModel.PropertyDescriptor" /> Aby wyszukać.</param>
        <param name="key">Wartość <paramref name="prop" /> do dopasowania.</param>
        <summary>Wyszukuje indeks elementu, który ma dany deskryptor właściwości.</summary>
        <returns>Indeks (liczony od zera) elementu, który ma daną wartość dla <see cref="T:System.ComponentModel.PropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używana w złożonych przypadkach powiązań danych, aby zlokalizować pierwszy wiersz, w którym wartość pola określonego przez `prop` parametr jest równa wartości parametru `key`  
  
 Ta metoda po prostu przywołuje żądanie do <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> metody podstawowej listy. Na przykład, jeśli źródłowe źródło danych <xref:System.Data.DataSet>jest, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, metoda wywołuje <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> metodę. Zachowanie <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, takie jak wartość zwracana, jeśli nie znaleziono pasującego elementu, zależy od implementacji metody na liście podstawowej.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób używania <xref:System.Windows.Forms.BindingSource.Find%2A> metody. Aby zapoznać się z kompletnym przykładem, zobacz temat Omówienie klas.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie jest typu <see cref="T:System.ComponentModel.IBindingList" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (propertyName As String, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ propertyName, System::Object ^ key);" />
      <MemberSignature Language="F#" Value="member this.Find : string * obj -&gt; int" Usage="bindingSource.Find (propertyName, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa właściwości do wyszukania.</param>
        <param name="key">Wartość elementu z określonym <paramref name="propertyName" /> do znalezienia.</param>
        <summary>Zwraca indeks elementu na liście z określoną nazwą właściwości i wartością.</summary>
        <returns>Indeks (liczony od zera) elementu z określoną nazwą właściwości i wartością.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metody można używać tylko wtedy, gdy podstawową listą jest obiekt <xref:System.ComponentModel.IBindingList> z zaimplementowanym wyszukiwaniem. <xref:System.Windows.Forms.BindingSource.Find%2A> Ta metoda po prostu przywołuje żądanie do <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> metody podstawowej listy. Na przykład, <xref:System.Data.DataSet>Jeśli źródłowe źródło danych jest, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> ta metoda jest konwertowana `propertyName` na <xref:System.ComponentModel.PropertyDescriptor> a i wywołuje metodę. Zachowanie <xref:System.Windows.Forms.BindingSource.Find%2A>, takie jak wartość zwracana, jeśli nie znaleziono pasującego elementu, zależy od implementacji metody na liście podstawowej.  
  
 W porównaniu z nazwą właściwości nie jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, <xref:System.Windows.Forms.BindingSource.Find%2A> jak używać metody <xref:System.Data.DataView>z. Aby uruchomić ten przykład, wklej kod do formularza systemu Windows i Wywołaj `PopulateDataViewAndFind` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń. Formularz powinien importować <xref:System.Xml> przestrzenie nazw <xref:System.IO> i.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Podstawowa lista nie <see cref="T:System.ComponentModel.IBindingList" /> jest zaimplementowaną funkcją wyszukiwania.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="propertyName" />nie pasuje do właściwości na liście.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="bindingSource.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera moduł wyliczający dla <see cref="P:System.Windows.Forms.BindingSource.List" />.</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> Dla .<see cref="P:System.Windows.Forms.BindingSource.List" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection&#xA;override this.GetItemProperties : System.ComponentModel.PropertyDescriptor[] -&gt; System.ComponentModel.PropertyDescriptorCollection" Usage="bindingSource.GetItemProperties listAccessors" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ITypedList.GetItemProperties(System.ComponentModel.PropertyDescriptor[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów, które mają znajdować się na liście jako możliwe do powiązania.</param>
        <summary>Pobiera tablicę <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów reprezentujących właściwości powiązane z typem listy źródła danych.</summary>
        <returns>Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów, która reprezentuje właściwości tego typu listy używane do wiązania danych.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberSignature Language="F#" Value="abstract member GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string&#xA;override this.GetListName : System.ComponentModel.PropertyDescriptor[] -&gt; string" Usage="bindingSource.GetListName listAccessors" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ITypedList.GetListName(System.ComponentModel.PropertyDescriptor[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów, które mają znajdować się na liście jako możliwe do powiązania.</param>
        <summary>Pobiera nazwę listy dostarczającej dane dla powiązania.</summary>
        <returns>Nazwa listy dostarczającej dane do powiązania.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelatedCurrencyManager (dataMember As String) As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::CurrencyManager ^ GetRelatedCurrencyManager(System::String ^ dataMember);" />
      <MemberSignature Language="F#" Value="abstract member GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager&#xA;override this.GetRelatedCurrencyManager : string -&gt; System.Windows.Forms.CurrencyManager" Usage="bindingSource.GetRelatedCurrencyManager dataMember" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.ICurrencyManagerProvider.GetRelatedCurrencyManager(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Nazwa kolumny lub listy w źródle danych, dla której ma zostać pobrany Menedżer waluty.</param>
        <summary>Pobiera powiązanego Menedżera waluty dla określonego elementu członkowskiego danych.</summary>
        <returns>Powiązane <see cref="T:System.Windows.Forms.CurrencyManager" /> z określonym elementem członkowskim danych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `dataMember` jest `null` lub jest pustym ciągiem ("") <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> , zwraca Menedżera waluty głównej; w przeciwnym razie sprawdza inne <xref:System.Windows.Forms.BindingSource> powiązanie z określonym elementem członkowskim danych i zwraca jego Menedżera waluty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : obj -&gt; int&#xA;override this.IndexOf : obj -&gt; int" Usage="bindingSource.IndexOf value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Aby znaleźć na liście podstawowej reprezentowanej <see cref="P:System.Windows.Forms.BindingSource.List" /> przez właściwość. <see cref="T:System.Object" /> Wartość może być <see langword="null" />równa.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks pierwszego wystąpienia w całej liście.</summary>
        <returns>Indeks (liczony od zera) pierwszego wystąpienia <paramref name="value" /> parametru; w przeciwnym razie-1, jeśli <paramref name="value" /> nie znajduje się na liście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chociaż implementacja jest zależna od `IndexOf` metody podstawowej listy, zazwyczaj stosuje się następujące cechy:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> Jest przeszukiwany rozpoczynając od pierwszego elementu i kończąc na ostatnim elemencie.  
  
-   Metoda bazowa wykonuje wyszukiwanie liniowe; w związku z tym średni czas wykonywania jest proporcjonalny do wartości <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości.  
  
-   Metoda bazowa określa równość przez wywołanie <xref:System.Object.Equals%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Insert : int * obj -&gt; unit&#xA;override this.Insert : int * obj -&gt; unit" Usage="bindingSource.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera), <paramref name="value" /> który powinien zostać wstawiony.</param>
        <param name="value"><see cref="T:System.Object" /> Do wstawienia. Wartość może być <see langword="null" />równa.</param>
        <summary>Wstawia element do listy pod określonym indeksem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Lista jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBindingSuspended As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBindingSuspended { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBindingSuspended : bool" Usage="System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiązanie listy jest zawieszone.</summary>
        <value><see langword="true" />Aby wskazać, że powiązanie jest zawieszone; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lista podstawowa ma stały rozmiar.</summary>
        <value><see langword="true" />Jeśli lista podstawowa ma stały rozmiar; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista ma stały rozmiar, nie zezwala na dodawanie lub usuwanie elementów po utworzeniu listy, ale można modyfikować istniejące elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lista podstawowa jest tylko do odczytu.</summary>
        <value><see langword="true" />Jeśli lista jest tylko do odczytu; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lista, która jest tylko do odczytu, nie zezwala na dodawanie, usuwanie ani modyfikowanie elementów listy po utworzeniu listy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSorted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSorted : bool" Usage="System.Windows.Forms.BindingSource.IsSorted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.IsSorted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy elementy na liście podstawowej są sortowane.</summary>
        <value><see langword="true" />Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" /> i jest sortowana; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A>zawsze zwraca `false` , jeśli lista <xref:System.ComponentModel.IBindingList>nie jest.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do kolekcji jest synchronizowany (bezpieczny wątkowo).</summary>
        <value><see langword="true" />Aby wskazać, że lista jest zsynchronizowana; w przeciwnym razie. <see langword="false" /></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : obj with get, set" Usage="System.Windows.Forms.BindingSource.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Indeks (liczony od zera) elementu do pobrania.</param>
        <summary>Pobiera lub ustawia element listy pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Item%2A> Właściwość reprezentuje indeksator dla tej klasy. Akceptuje `null` jako prawidłową wartość i umożliwia duplikowanie elementów znajdujących się na liście.  
  
 Ustawienie wartości spowoduje <xref:System.Windows.Forms.BindingSource.ListChanged> wygenerowanie zdarzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub jest równa lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.List : System.Collections.IList" Usage="System.Windows.Forms.BindingSource.List" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę, z którą jest powiązany łącznik.</summary>
        <value>Reprezentuje listę lub <see langword="null" /> , jeśli nie istnieje skojarzona z nią lista <see cref="T:System.Windows.Forms.BindingSource" />podstawowa. <see cref="T:System.Collections.IList" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource> Klasa jednolicie obsługuje różne źródła danych. W <xref:System.Windows.Forms.BindingSource.List%2A> idealnym przypadku właściwość powinna być ustawiona na <xref:System.Collections.IList>ogólne. Czasami jednak może być konieczne rzutowanie tej właściwości na bardziej konkretny typ. W poniższej tabeli przedstawiono podstawowe typy list, które są zależne od typu lub wartości źródła danych.  
  
|Typ źródła danych|Opis listy podstawowej|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>i <xref:System.Windows.Forms.BindingSource.DataMember%2A> są`null`|Puste <xref:System.Collections.ArrayList>.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>jest `null`, ale <xref:System.Windows.Forms.BindingSource.DataMember%2A> nie jest`null`|Dawaj Próba pobrania <xref:System.Windows.Forms.BindingSource.List%2A> elementu <xref:System.ArgumentException>spowoduje zgłoszenie.|  
|<xref:System.Array> Wystąpienie|A <xref:System.Array>.|  
|<xref:System.ComponentModel.IListSource> Wystąpienie|Wartość zwracana z wywołania <xref:System.ComponentModel.IListSource.GetList%2A> metody tego <xref:System.ComponentModel.IListSource> wystąpienia.|  
|<xref:System.ComponentModel.IBindingList> Wystąpienie|A <xref:System.ComponentModel.IBindingList>.|  
|<xref:System.Collections.IList> Wystąpienie|A <xref:System.Collections.IList>.|  
|Nie<xref:System.Collections.IList> jest wystąpieniem typu "T"|<xref:System.ComponentModel.BindingList%601> Z jednym elementem.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor> Wystąpienie|<xref:System.Collections.ArrayList> Z jednym elementem.|  
|An <xref:System.Collections.IEnumerable>|<xref:System.Collections.ArrayList> Z skopiowanymi elementami.|  
|<xref:System.Array> Typ z<xref:System.Windows.Forms.BindingSource.DataMember%2A> typem elementu "T"|A <xref:System.ComponentModel.BindingList%601>.|  
|<xref:System.Type> Reprezentujący<xref:System.ComponentModel.IListSource> lub<xref:System.ComponentModel.ITypedList>|Wystąpienie utworzone przez wywołanie <xref:System.Activator.CreateInstance%28System.Type%29> metody <xref:System.Activator> klasy. <xref:System.NotSupportedException> Może zostać zgłoszony.|  
|<xref:System.Collections.IList> Typ z<xref:System.Windows.Forms.BindingSource.DataMember%2A> typem elementu "T"<br /><br /> —lub—<br /><br /> <xref:System.Collections.IList> Typ inny niż|A <xref:System.ComponentModel.BindingList%601>.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor> Typ|Dawaj Próba pobrania <xref:System.Windows.Forms.BindingSource.List%2A> elementu <xref:System.NotSupportedException>spowoduje zgłoszenie.|  
  
 Jeśli pobrany typ to <xref:System.Collections.IList> interfejs, źródłowa kolekcja może być bardziej złożona, <xref:System.Collections.ArrayList> na przykład klasy lub <xref:System.Data.DataView> .  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.BindingSource.List%2A>elementy, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>i <xref:System.Windows.Forms.BindingSource.Count%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> nazwane `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`i przycisk o nazwie `button1`. Skojarz metodę ze zdarzeniem `button1`. <xref:System.Windows.Forms.Control.Click> `button1_Click` Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberSignature Language="F#" Value="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " Usage="member this.ListChanged : System.ComponentModel.ListChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.IBindingList.ListChanged</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy zmienia się lista podstawowa lub element na liście ulegnie zmianie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zdarzenie występuje w przypadku zmiany członkostwa lub metadanych podstawowej listy reprezentowanej <xref:System.Windows.Forms.BindingSource.List%2A> przez właściwość. <xref:System.Windows.Forms.BindingSource.ListChanged> Na przykład to zdarzenie jest zgłaszane, gdy elementy są dodawane, usuwane lub przenoszone, lub <xref:System.Windows.Forms.BindingSource.DataSource%2A> <xref:System.Windows.Forms.BindingSource.DataMember%2A> zmiany właściwości. Wartości <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwości i <xref:System.Windows.Forms.BindingSource.Filter%2A> będą utrwalane w przypadku wystąpienia tego zdarzenia.  
  
 To zdarzenie można całkowicie pominąć, ustawiając <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwość na. `false` Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje obsługę <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia <xref:System.Windows.Forms.BindingSource> <xref:System.Windows.Forms.BindingSource> składnika do wykrycia, gdy zostanie zmieniona lista podstawowa składnika.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFirst();" />
      <MemberSignature Language="F#" Value="member this.MoveFirst : unit -&gt; unit" Usage="bindingSource.MoveFirst " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do pierwszego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia bieżącą wartość <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości na 0, pierwszy element w źródłowym źródle danych.  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.BindingSource.MoveNext%2A>przykład kodu demonstruje elementy, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>i <xref:System.Windows.Forms.BindingSource.Position%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeń nazw i <xref:System.Windows.Forms.BindingSource> zawiera nazwany `BindingSource1` i przycisk o nazwie `button1`. `Form1_Paint` <xref:System.Windows.Forms.Control.Paint> `button1` Skojarzmetody<xref:System.Windows.Forms.Control.Click> i ze `button1_click` zdarzeniami <xref:System.Windows.Forms.Form.Load> i dla formularza, a następnie skojarz metodę ze `Form1_Load` zdarzeniem. Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveLast();" />
      <MemberSignature Language="F#" Value="member this.MoveLast : unit -&gt; unit" Usage="bindingSource.MoveLast " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do ostatniego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia bieżącą wartość <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości na indeks ostatniego elementu w źródłowym źródle danych, która jest równa wartości <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości pomniejszonej o 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveNext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveNext();" />
      <MemberSignature Language="F#" Value="member this.MoveNext : unit -&gt; unit" Usage="bindingSource.MoveNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia bieżącą wartość <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości na następny element w źródłowym źródle danych.  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.BindingSource.MoveNext%2A>przykład kodu demonstruje elementy, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>i <xref:System.Windows.Forms.BindingSource.Position%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeń nazw i <xref:System.Windows.Forms.BindingSource> zawiera nazwany `BindingSource1` i przycisk o nazwie `button1`. `Form1_Paint` <xref:System.Windows.Forms.Control.Paint> `button1` Skojarzmetody<xref:System.Windows.Forms.Control.Click> i ze `button1_click` zdarzeniami <xref:System.Windows.Forms.Form.Load> i dla formularza, a następnie skojarz metodę ze `Form1_Load` zdarzeniem. Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Sub MovePrevious ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MovePrevious();" />
      <MemberSignature Language="F#" Value="member this.MovePrevious : unit -&gt; unit" Usage="bindingSource.MovePrevious " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do poprzedniego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zmienia bieżącą wartość <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości na poprzedni element w źródłowym źródle danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAddingNew (e As AddingNewEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAddingNew(System::ComponentModel::AddingNewEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit&#xA;override this.OnAddingNew : System.ComponentModel.AddingNewEventArgs -&gt; unit" Usage="bindingSource.OnAddingNew e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingComplete (e As BindingCompleteEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingComplete(System::Windows::Forms::BindingCompleteEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit&#xA;override this.OnBindingComplete : System.Windows.Forms.BindingCompleteEventArgs -&gt; unit" Usage="bindingSource.OnBindingComplete e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.BindingCompleteEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.BindingComplete" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCurrentItemChanged : EventArgs -&gt; unit&#xA;override this.OnCurrentItemChanged : EventArgs -&gt; unit" Usage="bindingSource.OnCurrentItemChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataError (e As BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataError(System::Windows::Forms::BindingManagerDataErrorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit&#xA;override this.OnDataError : System.Windows.Forms.BindingManagerDataErrorEventArgs -&gt; unit" Usage="bindingSource.OnDataError e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.DataError" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnDataError%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataMemberChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataMemberChanged : EventArgs -&gt; unit&#xA;override this.OnDataMemberChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataMemberChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.  
  
<see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDataSourceChanged : EventArgs -&gt; unit&#xA;override this.OnDataSourceChanged : EventArgs -&gt; unit" Usage="bindingSource.OnDataSourceChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnListChanged (e As ListChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnListChanged(System::ComponentModel::ListChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit&#xA;override this.OnListChanged : System.ComponentModel.ListChangedEventArgs -&gt; unit" Usage="bindingSource.OnListChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnListChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPositionChanged : EventArgs -&gt; unit&#xA;override this.OnPositionChanged : EventArgs -&gt; unit" Usage="bindingSource.OnPositionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.ListChangedEventArgs" /> , który zawiera dane zdarzenia.</param>
        <summary><see cref="E:System.Windows.Forms.BindingSource.PositionChanged" /> Podnosi zdarzenie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A> Metoda umożliwia również klasom pochodnym obsłużenia zdarzenia bez dołączania delegata. Jest to preferowana technika obsługi zdarzenia w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Podczas zastępowania <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> klasy pochodnej należy wywołać <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> metodę klasy bazowej, aby zarejestrowani delegowani odbierał zdarzenie.</para></block>
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberSignature Language="VB.NET" Value="Public Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Position { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Position : int with get, set" Usage="System.Windows.Forms.BindingSource.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks bieżącego elementu na liście podstawowej.</summary>
        <value>Indeks (liczony od zera) określający położenie bieżącego elementu na liście podstawowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości wartości spoza zakresu są traktowane w następujący sposób:  
  
-   Wartości ujemne są traktowane jak 0.  
  
-   Wartości większe niż lub równe <xref:System.Windows.Forms.BindingSource.Count%2A> są traktowane jak <xref:System.Windows.Forms.BindingSource.Count%2A> minus 1.  
  
 Zmiana właściwości spowoduje dostosowanie właściwości w <xref:System.Windows.Forms.BindingSource.Current%2A> analogiczny sposób. <xref:System.Windows.Forms.BindingSource.Position%2A>  
  
   
  
## Examples  
 Poniższy <xref:System.Windows.Forms.BindingSource.MoveNext%2A>przykład kodu demonstruje elementy, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>i <xref:System.Windows.Forms.BindingSource.Position%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeń nazw i <xref:System.Windows.Forms.BindingSource> zawiera nazwany `BindingSource1` i przycisk o nazwie `button1`. `Form1_Paint` <xref:System.Windows.Forms.Control.Paint> `button1` Skojarzmetody<xref:System.Windows.Forms.Control.Click> i ze `button1_click` zdarzeniami <xref:System.Windows.Forms.Form.Load> i dla formularza, a następnie skojarz metodę ze `Form1_Load` zdarzeniem. Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PositionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PositionChanged;" />
      <MemberSignature Language="F#" Value="member this.PositionChanged : EventHandler " Usage="member this.PositionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po zmianie wartości <see cref="P:System.Windows.Forms.BindingSource.Position" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.PositionChanged> Zdarzenie występuje <xref:System.Windows.Forms.BindingSource.Position%2A> po zmianie właściwości.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i](~/docs/standard/events/index.md)wywoływanie zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property RaiseListChangedEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RaiseListChangedEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RaiseListChangedEvents : bool with get, set" Usage="System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> zdarzenia mają być zgłaszane.</summary>
        <value><see langword="true" />Jeśli <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> zdarzenia powinny być zgłaszane; <see langword="false" />w przeciwnym razie. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy właściwość jest `false` ,<xref:System.Windows.Forms.BindingSource.ListChanged> wstrzymuje wywoływanie zdarzeń. <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> To zdarzenie wskazuje, że lista związana została zmodyfikowana w jakiś sposób, w tym dodawanie, usuwanie, wstawianie lub modyfikowanie elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : obj -&gt; unit&#xA;override this.Remove : obj -&gt; unit" Usage="bindingSource.Remove value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Element do usunięcia z podstawowej listy reprezentowanej przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość.</param>
        <summary>Usuwa określony element z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda powoduje przeszukiwanie listy `value` dla parametru. <xref:System.Windows.Forms.BindingSource.Remove%2A> Jeśli zostanie znaleziona, ta metoda podejmie próbę usunięcia elementu z <xref:System.Windows.Forms.BindingSource.List%2A>. Ta próba zakończy się niepowodzeniem, jeśli lista ma ustalony rozmiar lub jest tylko do odczytu. Te dwa warunki można testować odpowiednio przy <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> użyciu <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> i właściwości.  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa ma stały rozmiar lub jest tylko do odczytu.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberSignature Language="F#" Value="abstract member RemoveAt : int -&gt; unit&#xA;override this.RemoveAt : int -&gt; unit" Usage="bindingSource.RemoveAt index" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa element o określonym indeksie z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te dwa warunki można testować odpowiednio przy <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> użyciu <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> i właściwości.  
  
 Ta metoda podnosi <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje <xref:System.Windows.Forms.BindingSource.List%2A>elementy, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>i <xref:System.Windows.Forms.BindingSource.Count%2A> . Aby uruchomić ten przykład, wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> nazwane `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`i przycisk o nazwie `button1`. Skojarz metodę ze zdarzeniem `button1`. <xref:System.Windows.Forms.Control.Click> `button1_Click` Visual Basic użytkownicy będą musieli dodać odwołanie do System. Data. dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />jest mniejsza od zera lub większa niż wartość <see cref="P:System.Windows.Forms.BindingSource.Count" /> właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowa lista reprezentowana przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCurrent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; unit" Usage="bindingSource.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bieżący element z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda jest równoważna <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> z metodą. <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Windows.Forms.BindingSource.AllowRemove" /> Właściwość jest<see langword="false" />.  
  
—lub— 
 <see cref="P:System.Windows.Forms.BindingSource.Position" />jest mniejsza od zera lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Podstawowa lista reprezentowana przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveFilter ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveFilter();" />
      <MemberSignature Language="F#" Value="abstract member RemoveFilter : unit -&gt; unit&#xA;override this.RemoveFilter : unit -&gt; unit" Usage="bindingSource.RemoveFilter " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingListView.RemoveFilter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa filtr skojarzony z <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odwołuje żądanie do <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> metody podstawowej listy. <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Tylko listy, które <xref:System.ComponentModel.IBindingListView> implementują filtrowanie.  
  
 Domyślnie wywołanie tej metody jest równoznaczne z ustawieniem <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości na. `null`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie obsługuje filtrowania.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveSort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveSort();" />
      <MemberSignature Language="F#" Value="abstract member RemoveSort : unit -&gt; unit&#xA;override this.RemoveSort : unit -&gt; unit" Usage="bindingSource.RemoveSort " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.RemoveSort</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa sortowanie skojarzone z <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda odwołuje żądanie do <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> metody podstawowej listy. <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> Tylko listy implementujące <xref:System.ComponentModel.IBindingList> sortowanie.  
  
 Domyślnie wywołanie tej metody jest równoznaczne z ustawieniem <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwości na. `null`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie obsługuje sortowania.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetAllowNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetAllowNew();" />
      <MemberSignature Language="F#" Value="abstract member ResetAllowNew : unit -&gt; unit&#xA;override this.ResetAllowNew : unit -&gt; unit" Usage="bindingSource.ResetAllowNew " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie inicjuje <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> właściwość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda ponownie inicjuje <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwość w celu odzwierciedlenia wartości odpowiedniej <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości na liście podstawowej. <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings (metadataChanged As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings(bool metadataChanged);" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : bool -&gt; unit" Usage="bindingSource.ResetBindings metadataChanged" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged"><see langword="true" />Jeśli schemat danych został zmieniony; <see langword="false" /> w przypadku zmiany tylko wartości.</param>
        <summary>Powoduje, że formant powiązany z <see cref="T:System.Windows.Forms.BindingSource" /> , aby ponownie wczytał wszystkie elementy na liście i odświeżyć wyświetlane wartości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda informuje wszystkie formanty powiązane z, <xref:System.Windows.Forms.BindingSource> aby odświeżyć ich wartości. <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Metoda wykonuje to przez zwiększenie <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia co najmniej raz `metaDataChanged` ; parametr wskazuje charakter źródłowej zmiany.  
  
-   Wartość wskazuje, że schemat danych zostałzmieniony.<xref:System.Windows.Forms.BindingSource> `true` `metaDataChanged` Zdarzenie jest wywoływane z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawionym na <xref:System.ComponentModel.ListChangedType.PropertyDescriptorChanged?displayProperty=nameWithType>. <xref:System.Windows.Forms.BindingSource.ListChanged>  
  
-   `metaDataChanged` Wartośćwskazuje,żezmienionotylkowartości`false` co najmniej jednego elementu.  
  
 Niezależnie `metaDataChanged`od wartości <xref:System.Windows.Forms.BindingSource.ListChanged> , zdarzenie jest wywoływane z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną na <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>. W związku z tym wywołanie <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> z `true` parametrem spowoduje wystąpienie dwóch <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A>jest automatycznie wywoływana za każdym razem, gdy inny członek wprowadza istotne zmiany w powiązaniu danych, takie <xref:System.Windows.Forms.BindingSource.DataSource%2A> jak <xref:System.Windows.Forms.BindingSource.DataMember%2A> ustawienie właściwości lub. Jednak programista może również wywołać tę metodę jawnie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.BindingSource> składnika, aby powiązać listę tablicową, która nie zapewnia powiadomienia o zmianie. Element zostanie usunięty z listy, a kontrolki powiązane są powiadamiane o zmianie przez wywołanie <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> metody. Ten przykład kodu jest częścią większego przykładu przedstawionego [w temacie How to: Odzwierciedlanie aktualizacji źródła danych w kontrolce Windows Forms z elementem](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md)BindingSource.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCurrentItem ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCurrentItem();" />
      <MemberSignature Language="F#" Value="member this.ResetCurrentItem : unit -&gt; unit" Usage="bindingSource.ResetCurrentItem " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że formant powiązany z <see cref="T:System.Windows.Forms.BindingSource" /> , aby odczytywać aktualnie wybrany element i odświeżał wyświetlaną wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody spowoduje <xref:System.Windows.Forms.BindingSource.ListChanged> wystąpienie zdarzenia, określając element zmieniony w bieżącym położeniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetItem (itemIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetItem(int itemIndex);" />
      <MemberSignature Language="F#" Value="member this.ResetItem : int -&gt; unit" Usage="bindingSource.ResetItem itemIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Indeks (liczony od zera) elementu, który został zmieniony.</param>
        <summary>Powoduje, że formant powiązany z <see cref="T:System.Windows.Forms.BindingSource" /> , aby ponownie odczytać element pod określonym indeksem, i Odśwież jego wartość wyświetlaną.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda powiadamia wszystkie kontrolki powiązane z elementem w określonym <xref:System.Windows.Forms.BindingSource.Position%2A> celu odświeżania ich wartości. <xref:System.Windows.Forms.BindingSource.ResetItem%2A> Metoda wykonuje to przez wywołanie <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną na <xref:System.ComponentModel.ListChangedType.ItemChanged?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A>jest wywoływana automatycznie zawsze, gdy wprowadzane są zmiany wartości poszczególnych elementów. Jednak programista może również wywołać tę metodę jawnie.  
  
   
  
## Examples  
 Poniższy przykład kodu używa <xref:System.Windows.Forms.BindingSource> składnika, aby powiązać listę <xref:System.Windows.Forms.DataGridView> z kontrolką. Lista nie wywołuje powiadomień o zmianach, więc <xref:System.Windows.Forms.BindingSource.ResetItem%2A> Metoda <xref:System.Windows.Forms.BindingSource> na <xref:System.Windows.Forms.BindingSource.ListChanged> służy do podniesienia poziomu zdarzenia. Ten przykład kodu jest częścią większego przykładu przedstawionego [w temacie How to: Zgłoś powiadomienia o zmianie za pomocą metody](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md)BindingSource ResetItem.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeBinding();" />
      <MemberSignature Language="F#" Value="member this.ResumeBinding : unit -&gt; unit" Usage="bindingSource.ResumeBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia powiązanie danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A>i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są dwie metody, które pozwalają na tymczasowe zawieszenie i wznowienie wiązania danych w scenariuszu prostego powiązania. Zazwyczaj można wstrzymać powiązanie danych, jeśli użytkownik musi być uprawniony do wprowadzania kilku zmian w polach danych przed rozpoczęciem walidacji. Na przykład, jeśli jedno pole musi zostać zmienione zgodnie z drugim, ale gdzie sprawdzanie poprawności pierwszego pola spowodowałoby wystąpienie błędu drugiego pola.  
  
> [!NOTE]
>  Użycie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> zapobiega wypchnięciu zmian do źródła danych do momentu <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> wywołania, ale w rzeczywistości nie uniemożliwia wystąpienia jakichkolwiek zdarzeń. Kontrolki korzystające ze złożonego powiązania danych, <xref:System.Windows.Forms.DataGridView> takie jak kontrolka, aktualizują wartości na podstawie zdarzeń zmiany <xref:System.Windows.Forms.CurrencyManager.ListChanged> , takich jak zdarzenie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> , dlatego wywołanie nie uniemożliwi otrzymywania zmian w źródle danych. Z tego powodu te <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użytku z prostymi <xref:System.Windows.Forms.TextBox> kontrolkami, takimi jak formant. Alternatywnie można użyć tych metod w złożonym scenariuszu powiązania w przypadku pomijania <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń przez <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> ustawienie właściwości na `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Property Sort As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Sort { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Sort : string with get, set" Usage="System.Windows.Forms.BindingSource.Sort" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwy kolumn używane do sortowania, a także porządek sortowania służący do wyświetlania wierszy w źródle danych.</summary>
        <value>Ciąg z uwzględnieniem wielkości liter zawierający nazwę kolumny, a po niej wartość "ASC" (w przypadku rosnącego) lub "DESC" (dla malejąco). Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Sort%2A> Właściwość jest ciągiem z rozróżnianiem wielkości liter, który określa nazwy kolumn używane do sortowania wierszy oraz kierunek sortowania. Kolumny są domyślnie sortowane rosnąco. Wiele kolumn może być oddzielonych przecinkami, takimi `"State, ZipCode DESC"`jak.  
  
 Aby można było obsłużyć sortowanie, źródłowa <xref:System.ComponentModel.IBindingList> lista <xref:System.ComponentModel.IBindingListView> musi implementować interfejsy lub. Tę możliwość można wykonać za pomocą <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> właściwości. Sortowanie wielokolumnowe jest dostępne, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> gdy właściwość `true`jest.  
  
 <xref:System.Windows.Forms.BindingSource.Sort%2A> Ustawienie właściwości spowoduje zmianę listy wewnętrznej w zależności od jej typu:  
  
-   Jeśli lista jest typu <xref:System.ComponentModel.IBindingList> <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> , właściwości i <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> są ustawiane na liście wewnętrznej.  
  
-   Jeśli lista jest typu <xref:System.ComponentModel.IBindingListView> <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> , właściwość jest ustawiona.  
  
 Właściwości sortowania listy wewnętrznej są zmieniane tylko wtedy, gdy ciąg sortowania nie `null`jest. Metoda dostępu dla tej właściwości nie spowoduje pobrania wartości sortowania wewnętrznej listy. zamiast tego zostanie `set` zwrócona wartość metody dostępu. `get` Wartość <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwości będzie trwała, gdy źródło danych zostanie zmienione.  
  
   
  
## Examples  
 Poniższy przykład pokazuje, jak używać właściwości, <xref:System.Windows.Forms.BindingSource.Sort%2A> aby wykonać sortowanie podstawowe <xref:System.Data.DataView>przy użyciu. Aby uruchomić ten przykład, wklej kod do formularza systemu Windows i Wywołaj `PopulateDataViewAndSort` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń. Formularz powinien importować <xref:System.Xml> przestrzenie nazw <xref:System.IO> i.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 Poniższy przykład pokazuje, jak użyć właściwości, <xref:System.Windows.Forms.BindingSource.Sort%2A> aby przeprowadzić zaawansowane sortowanie <xref:System.Data.DataView>za pomocą. Aby uruchomić ten przykład, wklej kod do formularza systemu Windows i Wywołaj `PopulateDataViewAndAdvancedSort` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metody obsługi zdarzeń. Formularz powinien importować <xref:System.Xml> przestrzenie nazw <xref:System.IO> i.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveSort" />
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As ListSortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDescriptionCollection ^ SortDescriptions { System::ComponentModel::ListSortDescriptionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDescriptions : System.ComponentModel.ListSortDescriptionCollection" Usage="System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SortDescriptions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję opisów sortowania zastosowanych do źródła danych.</summary>
        <value>Jeśli źródło danych to element <see cref="T:System.ComponentModel.IBindingListView" /> <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> , który zawiera opisy sortowania zastosowane do listy; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista nie <xref:System.ComponentModel.IBindingListView>jest <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> , zawsze zwraca wartość `null`.  
  
 <xref:System.ComponentModel.ListSortDescriptionCollection> Jest kolekcją tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDirection As ListSortDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDirection SortDirection { System::ComponentModel::ListSortDirection get(); };" />
      <MemberSignature Language="F#" Value="member this.SortDirection : System.ComponentModel.ListSortDirection" Usage="System.Windows.Forms.BindingSource.SortDirection" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SortDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kierunek sortowania elementów na liście.</summary>
        <value>Jedna z <see cref="T:System.ComponentModel.ListSortDirection" /> wartości wskazująca kierunek sortowania listy.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podstawowa lista nie <xref:System.ComponentModel.IBindingList>jest, właściwość zawsze zwróci <xref:System.Windows.Forms.BindingSource.SortDirection%2A> <xref:System.ComponentModel.ListSortDirection.Ascending>wartość.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortProperty As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ SortProperty { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SortProperty : System.ComponentModel.PropertyDescriptor" Usage="System.Windows.Forms.BindingSource.SortProperty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SortProperty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptor" /> Pobiera, który jest używany do sortowania listy.</summary>
        <value>Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" /> <see cref="T:System.ComponentModel.PropertyDescriptor" /> , jest używana <see langword="null" />do sortowania; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista nie <xref:System.ComponentModel.IBindingList>jest, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> zawsze zwraca wartość `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAdvancedSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAdvancedSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsAdvancedSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SupportsAdvancedSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje sortowanie wielokolumnowe.</summary>
        <value><see langword="true" />Jeśli lista jest <see cref="T:System.ComponentModel.IBindingListView" /> i obsługuje sortowanie wiele kolumn; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista nie <xref:System.ComponentModel.IBindingListView>jest, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotification { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsChangeNotification : bool" Usage="System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsChangeNotification</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje powiadomienie o zmianie.</summary>
        <value><see langword="true" />we wszystkich przypadkach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsFiltering { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsFiltering : bool" Usage="System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingListView.SupportsFiltering</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje filtrowanie.</summary>
        <value><see langword="true" />Jeśli lista jest <see cref="T:System.ComponentModel.IBindingListView" /> i obsługuje filtrowanie; <see langword="false" />w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista nie <xref:System.ComponentModel.IBindingListView>jest, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSearching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSearching { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSearching : bool" Usage="System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsSearching</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje wyszukiwanie przy użyciu <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" /> metody.</summary>
        <value><see langword="true" />Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" /> i obsługuje wyszukiwanie <see cref="Overload:System.Windows.Forms.BindingSource.Find" /> przy użyciu metody; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło danych nie <xref:System.ComponentModel.IBindingList>jest, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> zawsze zwraca wartość `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje sposób korzystania z <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> elementu członkowskiego. Aby zapoznać się z kompletnym przykładem, zobacz temat Omówienie klas.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSorting { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsSorting : bool" Usage="System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IBindingList.SupportsSorting</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje sortowanie.</summary>
        <value><see langword="true" />Jeśli źródło danych jest <see cref="T:System.ComponentModel.IBindingList" /> i obsługuje sortowanie; w przeciwnym razie,. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło danych nie <xref:System.ComponentModel.IBindingList>jest <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> , właściwość zawsze zwraca wartość `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendBinding();" />
      <MemberSignature Language="F#" Value="member this.SuspendBinding : unit -&gt; unit" Usage="bindingSource.SuspendBinding " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje powiązanie danych, aby zapobiec zmianom aktualizacji powiązanego źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A>i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są dwie metody, które pozwalają na tymczasowe zawieszenie i wznowienie wiązania danych w scenariuszu prostego powiązania. Zazwyczaj można wstrzymać powiązanie danych, jeśli użytkownik musi być uprawniony do wprowadzania kilku zmian w polach danych przed rozpoczęciem walidacji. Na przykład, jeśli jedno pole musi zostać zmienione zgodnie z drugim, ale gdzie sprawdzanie poprawności pierwszego pola spowodowałoby wystąpienie błędu drugiego pola.  
  
> [!NOTE]
>  Korzystanie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> z i uniemożliwia wypychanie zmian do źródła danych do momentu <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> wywołania, ale nie zapobiega występowaniu jakichkolwiek zdarzeń. Kontrolki korzystające ze złożonego powiązania danych, <xref:System.Windows.Forms.DataGridView> takie jak kontrolka, aktualizują wartości na podstawie zdarzeń zmiany <xref:System.Windows.Forms.CurrencyManager.ListChanged> , takich jak zdarzenie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> , dlatego wywołanie nie uniemożliwi otrzymywania zmian w źródle danych. Z tego powodu te <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użytku z prostymi <xref:System.Windows.Forms.TextBox> kontrolkami, takimi jak formant. Alternatywnie można użyć tych metod w złożonym scenariuszu powiązania w przypadku pomijania <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń przez <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> ustawienie właściwości na `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizowania dostępu z listą podstawową.</summary>
        <value>Obiekt, który może służyć do synchronizowania dostępu z listą podstawową.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIndex (property As PropertyDescriptor) Implements IBindingList.AddIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.AddIndex(System::ComponentModel::PropertyDescriptor ^ property) = System::ComponentModel::IBindingList::AddIndex;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.AddIndex(System.ComponentModel.PropertyDescriptor)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">, <see cref="T:System.ComponentModel.PropertyDescriptor" /> Aby dodać do indeksów używanych do wyszukiwania.</param>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptor" /> Dodaje do indeksów używanych do wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista podstawowa jest <xref:System.ComponentModel.IBindingList> typem, ta metoda <xref:System.ComponentModel.PropertyDescriptor> doda do indeksów; w przeciwnym razie wywołanie <xref:System.NotSupportedException>tej metody spowoduje zgłoszenie.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Podstawowa lista nie <see cref="T:System.ComponentModel.IBindingList" />jest.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (prop As PropertyDescriptor) Implements IBindingList.RemoveIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.RemoveIndex(System::ComponentModel::PropertyDescriptor ^ prop) = System::ComponentModel::IBindingList::RemoveIndex;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.IBindingList.RemoveIndex(System.ComponentModel.PropertyDescriptor)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop"><see cref="T:System.ComponentModel.PropertyDescriptor" /> Do usunięcia z indeksów używanych do wyszukiwania.</param>
        <summary><see cref="T:System.ComponentModel.PropertyDescriptor" /> Usuwa z indeksów używanych do wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli podstawowa lista nie <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>jest, Metoda ta zawsze <xref:System.NotSupportedException>generuje.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew (position As Integer) Implements ICancelAddNew.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.CancelNew(int position) = System::ComponentModel::ICancelAddNew::CancelNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Indeks elementu, który został dodany do kolekcji.</param>
        <summary>Odrzuca oczekujące nowe elementy z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda wycofuje oczekujące dodanie elementu wcześniej dodanego do kolekcji w indeksie określonym przez `position`. <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> Parametr `position` jest niezbędny, ponieważ kilka nowych elementów może być jednocześnie oczekujących.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub EndNew (position As Integer) Implements ICancelAddNew.EndNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.EndNew(int position) = System::ComponentModel::ICancelAddNew::EndNew;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Indeks elementu, który został dodany do kolekcji.</param>
        <summary>Zatwierdza oczekujące nowe elementy do kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Metoda zatwierdza oczekujące dodanie elementu wcześniej dodanego do kolekcji w indeksie określonym przez `position`. <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> Parametr `position` jest niezbędny, ponieważ kilka nowych elementów może być jednocześnie oczekujących.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sygnalizuje <see cref="T:System.Windows.Forms.BindingSource" /> , że inicjalizacja jest uruchamiana.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sygnalizuje <see cref="T:System.Windows.Forms.BindingSource" /> , że Inicjowanie zostało zakończone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.Initialized">
      <MemberSignature Language="C#" Value="event EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler System.ComponentModel.ISupportInitializeNotification.Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#Initialized" />
      <MemberSignature Language="VB.NET" Value="Custom Event Initialized As EventHandler Implements System.ComponentModel.ISupportInitializeNotification" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.ComponentModel.ISupportInitializeNotification.Initialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po <see cref="T:System.Windows.Forms.BindingSource" /> zainicjowaniu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.Forms.BindingSource> gdy wystąpienie jest rzutowane <xref:System.ComponentModel.ISupportInitializeNotification> do interfejsu.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsInitialized As Boolean Implements ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::ComponentModel::ISupportInitializeNotification::IsInitialized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISupportInitializeNotification.IsInitialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, <see cref="T:System.Windows.Forms.BindingSource" /> czy jest zainicjowany.</summary>
        <value><see langword="true" />Aby wskazać, <see cref="T:System.Windows.Forms.BindingSource" /> <see langword="false" />że jest zainicjowany; w przeciwnym razie.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Może być używana tylko wtedy, <xref:System.Windows.Forms.BindingSource> gdy wystąpienie jest rzutowane <xref:System.ComponentModel.ISupportInitializeNotification> do interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="BindingSource" FullName="System.Windows.Forms.BindingSource">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37807cf706cb60b2fcaf0a83cdb1e84a812e7777" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30703850" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class BindingSource : System.ComponentModel.Component, System.Collections.IList, System.ComponentModel.IBindingList, System.ComponentModel.IBindingListView, System.ComponentModel.ICancelAddNew, System.ComponentModel.ISupportInitialize, System.ComponentModel.ISupportInitializeNotification, System.ComponentModel.ITypedList, System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit BindingSource extends System.ComponentModel.Component implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.ComponentModel.IBindingList, class System.ComponentModel.IBindingListView, class System.ComponentModel.ICancelAddNew, class System.ComponentModel.ISupportInitialize, class System.ComponentModel.ISupportInitializeNotification, class System.ComponentModel.ITypedList, class System.Windows.Forms.ICurrencyManagerProvider" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.BindingSource" />
  <TypeSignature Language="VB.NET" Value="Public Class BindingSource&#xA;Inherits Component&#xA;Implements IBindingList, IBindingListView, ICancelAddNew, ICurrencyManagerProvider, IList, ISupportInitialize, ISupportInitializeNotification, ITypedList" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingSource : System::ComponentModel::Component, System::Collections::IList, System::ComponentModel::IBindingList, System::ComponentModel::IBindingListView, System::ComponentModel::ICancelAddNew, System::ComponentModel::ISupportInitialize, System::ComponentModel::ISupportInitializeNotification, System::ComponentModel::ITypedList, System::Windows::Forms::ICurrencyManagerProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.IBindingListView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICancelAddNew</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitializeNotification</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ITypedList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.ICurrencyManagerProvider</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.ComplexBindingProperties("DataSource", "DataMember")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("CurrentChanged")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("DataSource")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.BindingSourceDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Hermetyzuje źródło danych dla formularza.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource> Składnika służy wiele celów. Najpierw upraszcza powiązanie formantów w formularzu danych przez podanie zarządzania waluty, powiadomienia o zmianie i innych usług między formanty formularzy systemu Windows i źródła danych. Jest to osiągane przez dołączenie <xref:System.Windows.Forms.BindingSource> składnika do Twojego źródła danych przy użyciu <xref:System.Windows.Forms.BindingSource.DataSource%2A> właściwości. Złożone powiązanie scenariusze można opcjonalnie ustawić <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwości do określonej kolumny lub listy w źródle danych. Następnie powiązać formantów <xref:System.Windows.Forms.BindingSource>. Wszystkie dodatkowe interakcji z danymi jest realizowane za pomocą wywołania <xref:System.Windows.Forms.BindingSource> składnika. Przykłady w sposób <xref:System.Windows.Forms.BindingSource> może uprościć proces wiązania, zobacz [porady: powiązanie formantów formularzy systemu Windows z wartościami bazy danych DBNull](~/docs/framework/winforms/controls/how-to-bind-windows-forms-controls-to-dbnull-database-values.md) i [porady: obsługi błędów i wyjątków tego Occur DataBinding](~/docs/framework/winforms/controls/how-to-handle-errors-and-exceptions-that-occur-with-databinding.md). Nawigacji i aktualizowanie źródła danych odbywa się za pośrednictwem metody takie jak <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveLast%2A>, i <xref:System.Windows.Forms.BindingSource.Remove%2A>. Operacje takie jak sortowania i filtrowania są obsługiwane za pośrednictwem <xref:System.Windows.Forms.BindingSource.Sort%2A> i <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości. Aby uzyskać więcej informacji na temat używania sortowania i filtrowania z <xref:System.Windows.Forms.BindingSource>, zobacz [porady: sortowanie i filtrowanie danych ADO.NET za pomocą składnika BindingSource formularzy systemu Windows](~/docs/framework/winforms/controls/sort-and-filter-ado-net-data-with-wf-bindingsource-component.md).  
  
 Ponadto <xref:System.Windows.Forms.BindingSource> składnika może działać jako źródło danych jednoznacznie. Zwykle typ źródła danych jest rozwiązany za pomocą jednego z następujących mechanizmów:  
  
-   Użyj <xref:System.Windows.Forms.BindingSource.Add%2A> metodę, aby dodać element do <xref:System.Windows.Forms.BindingSource> składnika.  
  
-   Ustaw <xref:System.Windows.Forms.BindingSource.DataSource%2A> właściwość do listy, pojedynczego obiektu lub typu.  
  
 Utwórz obu tych mechanizmów silnie typizowanej listy. Aby uzyskać więcej informacji na temat korzystania <xref:System.Windows.Forms.BindingSource> do powiązania z typem, zobacz [porady: powiązanie formantu formularzy systemu Windows z typem](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-type.md). Można również użyć <xref:System.Windows.Forms.BindingSource> o powiązanie formantów z obiektem fabryki. Aby uzyskać więcej informacji, jak to zrobić, zobacz [porady: powiązanie formantu formularzy systemu Windows z obiektem fabryki](~/docs/framework/winforms/controls/how-to-bind-a-windows-forms-control-to-a-factory-object.md).  
  
> [!NOTE]
>  Ponieważ <xref:System.Windows.Forms.BindingSource> dojść zarówno proste i złożone źródła danych, terminologii stanowi problem. W tej dokumentacji klasy termin *listy* odwołuje się do kolekcji danych w źródle danych hostowanej i *elementu* oznacza pojedynczy element. Gdy dyskutować funkcji skojarzone z złożonych źródłami danych, równoważne określenia *tabeli* i *wiersza* są używane.  
  
 <xref:System.Windows.Forms.BindingSource> zapewnia to członkom do uzyskiwania dostępu do danych. Bieżący element może zostać pobrane za pośrednictwem <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości i całą listę mogą zostać pobrane za pośrednictwem <xref:System.Windows.Forms.BindingSource.List%2A> właściwości. Operacje edycji są obsługiwane w bieżącym elemencie za pośrednictwem <xref:System.Windows.Forms.BindingSource.Current%2A> i <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A>, <xref:System.Windows.Forms.BindingSource.EndEdit%2A>, <xref:System.Windows.Forms.BindingSource.CancelEdit%2A> i <xref:System.Windows.Forms.BindingSource.Add%2A> i <xref:System.Windows.Forms.BindingSource.AddNew%2A> metody. Mimo że waluty zarządzania odbywa się automatycznie dla wszystkich typów podstawowych źródła danych, ta klasa przedstawia liczbę zdarzeń, takich jak <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> i <xref:System.Windows.Forms.BindingSource.DataSourceChanged>, który umożliwia dostosowywania.  
  
 Źródła danych, które są powiązane z <xref:System.Windows.Forms.BindingSource> składnika można również przejście i zarządzanych za pomocą <xref:System.Windows.Forms.BindingNavigator> klasy, która dostarcza interfejs Magnetowidu przypominającej użytkownika (UI) do nawigowania elementów na liście. Mimo że <xref:System.Windows.Forms.BindingNavigator> może być powiązana do dowolnego źródła danych został zaprojektowany do integracji z <xref:System.Windows.Forms.BindingSource> składnika za pomocą jego <xref:System.Windows.Forms.BindingNavigator.BindingSource%2A?displayProperty=nameWithType> właściwości.  
  
 Właściwość domyślna <xref:System.Windows.Forms.BindingSource> jest klasa <xref:System.Windows.Forms.BindingSource.DataSource%2A>. To zdarzenie domyślne <xref:System.Windows.Forms.BindingSource.CurrentChanged>.  
  
> [!CAUTION]
>  Duża liczba członków <xref:System.Windows.Forms.BindingSource> klasy działać na liście podstawowej reprezentowany przez <xref:System.Windows.Forms.BindingSource.List%2A> właściwości i po prostu można znaleźć na liście podstawowej ich operacji. W związku z tym, kiedy <xref:System.Windows.Forms.BindingSource> jest powiązany z niestandardowej implementacji <xref:System.Collections.IList>, dokładne zachowanie tych elementów członkowskich mogą się różnić od zachowania opisanej w dokumentacji klasy. Na przykład <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> wywołania metody <xref:System.Collections.IList.RemoveAt%2A?displayProperty=nameWithType>. <xref:System.Windows.Forms.BindingSource> Dokumentacji opisano <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> metody, pamiętając, że <xref:System.Collections.IList.RemoveAt%2A> metodę podstawową <xref:System.Collections.IList> jest poprawnie zaimplementowana.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.ListBox> powiązany <xref:System.Windows.Forms.BindingSource>. <xref:System.Windows.Forms.BindingSource> Jest powiązany z <xref:System.ComponentModel.BindingList%601> zawierający listę czcionek.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#0)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#0)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.BindingSource" />
    <altmember cref="T:System.Windows.Forms.BindingNavigator" />
    <altmember cref="T:System.Windows.Forms.DataGridView" />
    <altmember cref="T:System.Windows.Forms.CurrencyManager" />
    <altmember cref="T:System.Collections.IList" />
    <altmember cref="T:System.ComponentModel.IBindingList" />
    <altmember cref="T:System.ComponentModel.IEditableObject" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.BindingSource" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.BindingSource" /> klasy wartości domyślnej właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono domyślne <xref:System.Windows.Forms.BindingSource> wartości właściwości zainicjowane przez tego konstruktora.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.DataMember%2A>|<xref:System.String.Empty>|  
|<xref:System.Windows.Forms.BindingSource.Sort%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.Filter%2A>|`null`|  
|<xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A>|`true`|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Windows.Forms.CurrencyManager" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (System.ComponentModel.IContainer container);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ComponentModel.IContainer container) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.ComponentModel.IContainer)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (container As IContainer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::ComponentModel::IContainer ^ container);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
      </Parameters>
      <Docs>
        <param name="container">
          <see cref="T:System.ComponentModel.IContainer" /> Można dodać bieżącego <see cref="T:System.Windows.Forms.BindingSource" /> do.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.BindingSource" /> i dodaje <see cref="T:System.Windows.Forms.BindingSource" /> do określonego kontenera.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten konstruktor wywołuje konstruktor domyślny, a następnie dodanie bieżącego <xref:System.Windows.Forms.BindingSource> do określonego kontenera. Jest nie on zwykle używany przez programistę rozwiązań tylko przez autorów środowiska czasu projektowania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BindingSource (object dataSource, string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object dataSource, string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (dataSource As Object, dataMember As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BindingSource(System::Object ^ dataSource, System::String ^ dataMember);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dataSource" Type="System.Object" />
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataSource">Źródła danych dla <see cref="T:System.Windows.Forms.BindingSource" />.</param>
        <param name="dataMember">Określone kolumny listy nazwę lub w źródle danych, aby powiązać.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Windows.Forms.BindingSource" /> z określonego źródła danych i element członkowski danych.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual int Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Add(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Mają zostać dodane do listy wewnętrznej.</param>
        <summary>Dodaje istniejący element do listy wewnętrznej.</summary>
        <returns>Liczony od zera indeks, w którym <paramref name="value" /> został dodany do listy źródłowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Add%2A> Metody odwołuje się wywołanie Lista podstawowa `Add` metody.  
  
 Wewnętrzny lista musi zawierać jednorodnego typów. Jeśli <xref:System.Windows.Forms.BindingSource.DataSource%2A> właściwość nie została już ustawiona, a następnie pierwszy obiekt dodany do listy definiuje typ listy.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
   
  
## Examples  
 Poniższy kod przykładowy sposób użycia <xref:System.Windows.Forms.BindingSource.Add%2A> metody. Aby uruchomić ten przykład, Wklej kod w formularzu systemu Windows, a wywołania `PopulateBindingSourceWithFonts` metody z Konstruktor elementu form.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> różni się w typie z istniejących elementów na liście podstawowej.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AddingNew">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.AddingNewEventHandler AddingNew;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.AddingNewEventHandler AddingNew" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.AddingNew" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AddingNew As AddingNewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::AddingNewEventHandler ^ AddingNew;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.AddingNewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje przed element został dodany do listy źródłowej.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AddingNew> Zdarzenie przed dodaniem do listy źródłowej reprezentowany przez nowy obiekt <xref:System.Windows.Forms.BindingSource.List%2A> właściwości. To zdarzenie jest wywoływane po <xref:System.Windows.Forms.BindingSource.AddNew%2A> metoda jest wywoływana, ale zanim nowy element jest tworzony i dodawany do listy źródłowej. Obsługa tego zdarzenia, programistę zapewnia tworzenia niestandardowego elementu i zachowanie wstawiania bez wymuszone pochodzi od <xref:System.Windows.Forms.BindingSource> klasy. Odbywa się w obsłudze zdarzeń przez ustawienie <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwość <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parametr do nowego elementu. Nowy obiekt utworzony w <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzeń muszą być tego samego typu jako typu zawarte na liście lub wystąpi wyjątek. Nie można ustawić <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwości podczas wiązania z <xref:System.Data.DataView> lub <xref:System.Data.DataTable> , ponieważ nie można dodać nowego <xref:System.Data.DataRowView> do listy.  
  
 Aby uzyskać więcej informacji na temat podawania niestandardowych nowych funkcji elementu zobacz <xref:System.Windows.Forms.BindingSource.AddNew%2A> metody. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.BindingSource> składnika powiązać listy <xref:System.Windows.Forms.DataGridView> formantu. Nowe elementy są dodawane do listy przez <xref:System.Windows.Forms.BindingSource.AddingNew> obsługi zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego w [porady: dostosowywanie dodawania elementu przy formantu BindingSource formularzy systemu Windows](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" /> nie jest taki sam typ co typ zawarte na liście.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="AddNew">
      <MemberSignature Language="C#" Value="public virtual object AddNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.AddNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function AddNew () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ AddNew();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dodaje nowy element do listy źródłowej.</summary>
        <returns>
          <see cref="T:System.Object" /> Który został utworzony i dodany do listy.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AddNew%2A> Metody dodaje nowy element do listy źródłowej reprezentowany przez <xref:System.Windows.Forms.BindingSource.List%2A> właściwości. Ta metoda powoduje ustawienie serii następujące akcje:  
  
1.  <xref:System.Windows.Forms.BindingSource.EndEdit%2A> Wywoływana jest metoda automatycznie Zatwierdź wszystkie operacje oczekująca Edycja.  
  
2.  <xref:System.Windows.Forms.BindingSource.AddingNew> Automatycznie zdarzenia. To zdarzenie można programowo obsługiwać do utworzenia nowego elementu. Odbywa się w obsłudze zdarzeń przez ustawienie <xref:System.ComponentModel.AddingNewEventArgs.NewObject%2A> właściwość <xref:System.ComponentModel.AddingNewEventArgs?displayProperty=nameWithType> parametr do nowego elementu. Nowy obiekt utworzony w <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzeń muszą być tego samego typu jako typu zawarte na liście lub wystąpi wyjątek.  
  
     Jeśli <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzenie nie jest obsługiwane, a lista podstawowa jest <xref:System.ComponentModel.IBindingList>, żądania są przekazywane do listy, a następnie <xref:System.ComponentModel.IBindingList.AddNew%2A?displayProperty=nameWithType> metody. Jeżeli lista podstawowa nie jest <xref:System.ComponentModel.IBindingList>, element został automatycznie utworzony przez jego publicznego konstruktora domyślnego. W każdym przypadku nowy element zostanie dodany na końcu listy.  
  
3.  Nowy element jest natychmiast dodawane do listy wewnętrznej chyba, że źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejsu. W takim przypadku nowy element nie jest zatwierdzona do jawnym wywołaniem <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> staje się lub do nowej operacji listy jest inicjowana. Przed zatwierdzeniem, nowy element można wycofać przez wywołanie metody <xref:System.Windows.Forms.BindingSource.CancelEdit%2A>, w którym to przypadku nowy element zostaną odrzucone.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.BindingSource> składnika powiązać listy <xref:System.Windows.Forms.DataGridView> formantu. Nowe elementy są dodawane do listy przez <xref:System.Windows.Forms.BindingSource.AddingNew> obsługi zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego w [porady: dostosowywanie dodawania elementu przy formantu BindingSource formularzy systemu Windows](~/docs/framework/winforms/controls/how-to-customize-item-addition-with-the-windows-forms-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.AddingNew#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.AddingNew/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> Właściwość jest ustawiona na <see langword="false" />.  
  
 —lub—  
  
 Nie można odnaleźć domyślnego konstruktora publicznego dla bieżącego typu elementu.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="T:System.ComponentModel.AddingNewEventArgs" />
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
        <altmember cref="T:System.ComponentModel.IBindingList" />
      </Docs>
    </Member>
    <Member MemberName="AllowEdit">
      <MemberSignature Language="C#" Value="public virtual bool AllowEdit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowEdit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowEdit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowEdit { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy elementy na liście podstawowej można edytowane.</summary>
        <value>
          <see langword="true" /> Aby wskazać elementy listy może być edytowany; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AllowEdit%2A> Właściwość jest zwykle używana przez inne składniki do określenia, czy edytowanie elementów na liście jest dozwolone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowNew">
      <MemberSignature Language="C#" Value="public virtual bool AllowNew { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowNew" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowNew As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowNew { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> metody można użyć do dodawania elementów do listy.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="M:System.Windows.Forms.BindingSource.AddNew" /> mogą być używane do dodawania elementów do listy, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wartość domyślna dla <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości zależy od typu podstawowego źródła danych. Jeśli podstawowa lista implementuje <xref:System.ComponentModel.IBindingList> interfejsu, ta właściwość będzie delegowane do listy źródłowej. W przeciwnym razie wartość tej właściwości, którą będzie zwracać `false` Jeżeli lista podstawowa ma jakiekolwiek z następujących właściwości:  
  
-   Ma ona o stałym rozmiarze, na podstawie <xref:System.Collections.IList.IsFixedSize%2A?displayProperty=nameWithType> właściwości.  
  
-   Jest tylko do odczytu, zgodnie z ustaleniami <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> właściwości.  
  
-   Typ elementu nie ma domyślnego konstruktora.  
  
> [!NOTE]
>  Po ustawieniu wartości tej właściwości, metoda pobierająca odwołuje się już wywołanie Lista podstawowa. Zamiast tego po prostu zwraca wartość, która wcześniej została ustawiona do <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> metoda jest wywoływana.  
  
 Ustawienie tej właściwości zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>.  
  
 Jeśli ustawisz <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości `true` i podstawowy typ listy nie ma domyślnego konstruktora, musi obsługiwać <xref:System.Windows.Forms.BindingSource.AddingNew> zdarzeń i utworzenie odpowiedniego typu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, za pomocą <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwość <xref:System.Windows.Forms.BindingSource> składnik, aby zezwolić użytkownikowi na dodawanie nowych elementów do <xref:System.Windows.Forms.BindingSource> składnika podstawowej listy. Ustawienie tej właściwości na `true` powoduje, że to granica <xref:System.Windows.Forms.DataGridView> formantu, aby wyświetlić jego wiersz dla nowych rekordów.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ta właściwość jest ustawiona na <see langword="true" /> po liście podstawowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość ma stały rozmiar lub jest tylko do odczytu.</exception>
        <exception cref="T:System.MissingMethodException">Właściwość jest ustawiona na <see langword="true" /> i <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> zdarzenie nie jest obsługiwane, gdy podstawowy typ listy nie ma domyślnego konstruktora.</exception>
        <altmember cref="P:System.ComponentModel.AddingNewEventArgs.NewObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowEdit" />
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowRemove" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="AllowRemove">
      <MemberSignature Language="C#" Value="public virtual bool AllowRemove { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowRemove" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.AllowRemove" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AllowRemove As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowRemove { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy można usunąć elementy z listy źródłowej.</summary>
        <value>
          <see langword="true" /> Aby wskazać listy elementów można usunąć z listy; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.AllowRemove%2A> Właściwość jest zwykle używana przez inne składniki do określenia, czy edytowanie elementów na liście jest dozwolone.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplySort">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sortuje źródła danych z określonego sortowania opis lub opisy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.ListSortDescriptionCollection sorts);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.ListSortDescriptionCollection sorts) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.ListSortDescriptionCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (sorts As ListSortDescriptionCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::ListSortDescriptionCollection ^ sorts);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sorts" Type="System.ComponentModel.ListSortDescriptionCollection" />
      </Parameters>
      <Docs>
        <param name="sorts">A <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> zawierające opisy sortowania do zastosowania do źródła danych.</param>
        <summary>Sortuje źródła danych z opisami określonego sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingListView> implementuje wielokolumnowego sortowanie jako zestaw par kierunek deskryptora właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Źródło danych nie jest <see cref="T:System.ComponentModel.IBindingListView" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplySort">
      <MemberSignature Language="C#" Value="public virtual void ApplySort (System.ComponentModel.PropertyDescriptor property, System.ComponentModel.ListSortDirection sort);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplySort(class System.ComponentModel.PropertyDescriptor property, valuetype System.ComponentModel.ListSortDirection sort) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ApplySort (property As PropertyDescriptor, sort As ListSortDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplySort(System::ComponentModel::PropertyDescriptor ^ property, System::ComponentModel::ListSortDirection sort);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="sort" Type="System.ComponentModel.ListSortDirection" />
      </Parameters>
      <Docs>
        <param name="property">A <see cref="T:System.ComponentModel.PropertyDescriptor" /> , który opisuje właściwość, według której do sortowania źródła danych.</param>
        <param name="sort">A <see cref="T:System.ComponentModel.ListSortDirection" /> wskazującą sposób sortowania listy.</param>
        <summary>Sortuje źródła danych, używając określonej właściwości kierunku deskryptora i sortowania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.IBindingList> Implementuje jednej kolumny sortowania, przy użyciu <xref:System.ComponentModel.PropertyDescriptor> można wskazać właściwości, aby posortować według i <xref:System.ComponentModel.ListSortDirection> wskazującą, czy zawartość właściwości mają być sortowane w kolejności rosnącej lub malejącej.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Źródło danych nie jest <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BindingComplete">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingCompleteEventHandler BindingComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingCompleteEventHandler BindingComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.BindingComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingComplete As BindingCompleteEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingCompleteEventHandler ^ BindingComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingCompleteEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wszyscy klienci mają została powiązana z tym <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.BindingComplete> Zdarzenie po wszystkich klientów, zwykle formantów, mają została powiązana z bieżącą <xref:System.Windows.Forms.BindingSource>. Program obsługi tego zdarzenia można podjąć odpowiednie działania oparte na sukces, błędu lub wyjątki w procesie powiązanie, sprawdzając <xref:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState%2A> właściwość <xref:System.Windows.Forms.BindingCompleteEventArgs> parametru.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje Obsługa <xref:System.Windows.Forms.BindingSource.BindingComplete> zdarzeń. Aby uruchomić ten kod, wklej go do pliku kodu puste.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnectorBindingComplete#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorBindingComplete/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingCompleteEventArgs.BindingCompleteState" />
        <altmember cref="T:System.Windows.Forms.BindingCompleteEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="CancelEdit">
      <MemberSignature Language="C#" Value="public void CancelEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CancelEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umożliwia anulowanie bieżącej operacji edycji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda odrzuca wszystkie zmiany w danych od czasu ostatniego Zapisz lub operacja ładowania, jeśli są spełnione oba poniższe warunki:  
  
-   Źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejsu.  
  
-   <xref:System.Windows.Forms.BindingSource.EndEdit%2A> — Metoda nie została jeszcze wywołana.  
  
 Ta metoda wywołuje <xref:System.Windows.Forms.CurrencyManager.CancelCurrentEdit%2A> metody podstawowych <xref:System.Windows.Forms.CurrencyManager>i obejmuje zmiany na poziomie wiersza.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.EndEdit" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie elementy z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Clear%2A> Metoda usuwa wszystkie elementy na liście podstawowej reprezentowany przez <xref:System.Windows.Forms.BindingSource.List%2A> właściwości i zestawy <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości wartość zero.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można znaleźć na liście podstawowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwości. Wartość może być <see langword="null" />.</param>
        <summary>Określa, czy obiekt jest element na liście.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="value" /> zostanie znaleziony w <see cref="P:System.Windows.Forms.BindingSource.List" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że wdrożenia jest zależny od Lista podstawowa `Contains` metody, zwykle obowiązują następujące zasady:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> będzie przeszukiwana, rozpoczynając od pierwszego elementu i końcowy z ostatniego elementu.  
  
-   Metoda podstawowej przeprowadza wyszukiwanie liniowe; w związku z tym Średni czas wykonania jest proporcjonalny do wartości <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości.  
  
-   Metody podstawowej określa równości przez wywołanie metody <xref:System.Object.Equals%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array arr, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array arr, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub CopyTo (arr As Array, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ arr, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arr" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="arr">Tablica docelowa.</param>
        <param name="index">Indeks w tablicy docelowej, w którym można uruchomić operacji kopiowania.</param>
        <summary>Kopiuje zawartość <see cref="P:System.Windows.Forms.BindingSource.List" /> do określonej tablicy, zaczynając od wartości określonego indeksu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia łączenie elementów z wielu źródeł w pojedynczą tablicę.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera całkowitą liczbę elementów na liście podstawowej, biorąc bieżącego <see cref="P:System.Windows.Forms.BindingSource.Filter" /> wartość pod uwagę.</summary>
        <value>Całkowita liczba filtrowane elementy na liście podstawowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Count%2A> Właściwości pobiera liczbę elementów na liście podstawowej reprezentowany przez <xref:System.Windows.Forms.BindingSource.List%2A> właściwości zmodyfikowana przez wartość <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, i <xref:System.Windows.Forms.BindingSource.Count%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`, a przycisk o nazwie `button1`. Skojarz `button1_Click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
      </Docs>
    </Member>
    <Member MemberName="CurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager CurrencyManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CurrencyManager CurrencyManager" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.CurrencyManager" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrencyManager As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::CurrencyManager ^ CurrencyManager { System::Windows::Forms::CurrencyManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.ICurrencyManagerProvider.CurrencyManager</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera menedżera waluty skojarzony z tym <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <value>
          <see cref="T:System.Windows.Forms.CurrencyManager" /> Skojarzony z tym <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz otworzyć Menedżera waluty dla innego powiązania do używania tego samego elementu członkowskiego danych <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public object Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Current" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący element na liście.</summary>
        <value>
          <see cref="T:System.Object" /> Reprezentujący bieżący element na liście podstawowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwości, lub <see langword="null" /> Jeśli lista nie zawiera żadnych elementów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości dostępu do bieżącego elementu, ale <xref:System.Windows.Forms.BindingSource.List%2A> właściwości do pobrania całą listę. Aby określić typ bieżący obiekt, należy użyć <xref:System.Object.GetType%2A>, lub <xref:System.Object.ToString%2A> metody.  
  
 Aby zmienić bieżącego elementu, ustaw <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości do nowej wartości całkowitych lub użyj jednej z metod nawigacji takich jak <xref:System.Windows.Forms.BindingSource.MoveNext%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości. Aby uruchomić ten przykład, Wklej kod do formularza i wywołanie `PopulateBindingSourceWithFonts` metody z formularza <xref:System.Windows.Forms.Form.Load> metoda obsługi zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element obecnie powiązany.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged> Zdarzenie jest wywoływane zawsze, gdy <xref:System.Windows.Forms.BindingSource.Current%2A> zmiany właściwości dla każdego z następujących powodów:  
  
-   Bieżąca pozycja <xref:System.Windows.Forms.BindingSource.List%2A> zmiany.  
  
-   <xref:System.Windows.Forms.BindingSource.DataSource%2A> Lub <xref:System.Windows.Forms.BindingSource.DataMember%2A> zmiany właściwości.  
  
-   Członkostwo podstawowych <xref:System.Windows.Forms.BindingSource.List%2A> ulegnie zmianie, co powoduje, że <xref:System.Windows.Forms.BindingSource.Position%2A> do odwoływania się do innego elementu. Przykłady obejmują dodawanie lub usuwanie elementu przed bieżącego elementu, usuwanie, przenoszenie bieżącego elementu lub przenieść element do bieżącego położenia.  
  
-   Lista podstawowa jest odświeżany przez nowe sortowanie lub filtrowanie operacji.  
  
 Gdy to zdarzenie jest wyzwalane, <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości będzie już zawierać jego nowej wartości.  
  
 <xref:System.Windows.Forms.BindingSource.CurrentChanged> to domyślne zdarzenie dla <xref:System.Windows.Forms.BindingSource> klasy.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.BindingManagerBase.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItemChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CurrentItemChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentItemChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CurrentItemChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CurrentItemChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wartość właściwości <see cref="P:System.Windows.Forms.BindingSource.Current" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> Zdarzenie jest zgłaszane w odpowiedzi na wszystkie okoliczności, które uruchamiają <xref:System.Windows.Forms.BindingSource.CurrentChanged> zdarzeń. Ponadto <xref:System.Windows.Forms.BindingSource.CurrentItemChanged> również jest wywoływane zawsze, gdy wartość właściwości <xref:System.Windows.Forms.BindingSource.Current%2A> zostanie zmieniona.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataError">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.BindingManagerDataErrorEventHandler DataError;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.BindingManagerDataErrorEventHandler DataError" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataError" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataError As BindingManagerDataErrorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::BindingManagerDataErrorEventHandler ^ DataError;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingManagerDataErrorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wyjątek dotyczących dyskretnie jest obsługiwany przez <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie ma charakter informacyjny i raporty tylko wyjątki zgodne ze specyfikacją CLS. Aby ustalić, jakiego rodzaju wyjątek wystąpił, obsługa tego zdarzenia i sprawdź <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs.Exception%2A> właściwość <xref:System.Windows.Forms.BindingManagerDataErrorEventArgs>.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataMember">
      <MemberSignature Language="C#" Value="public string DataMember { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DataMember" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataMember" />
      <MemberSignature Language="VB.NET" Value="Public Property DataMember As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DataMember { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.DataMemberListEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia w źródle danych, do którego łącznik obecnie jest powiązany z określonej listy.</summary>
        <value>Nazwa listy (lub wiersza) w <see cref="P:System.Windows.Forms.BindingSource.DataSource" />. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Windows.Forms.BindingSource.DataSource%2A> zawiera wiele list (lub tabele) danych, należy ustawić <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwość na nazwę jednego ze źródeł.  
  
 Ustawienie tej właściwości zgłasza <xref:System.Windows.Forms.BindingSource.DataMemberChanged> zdarzeń  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataMemberChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataMemberChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataMemberChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataMemberChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataMemberChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.BindingSource.DataMember" /> zmieniono wartość właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataMemberChanged> Po wystąpieniu zdarzenia <xref:System.Windows.Forms.BindingSource.DataMember%2A> zmiany właściwości.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      </Docs>
    </Member>
    <Member MemberName="DataSource">
      <MemberSignature Language="C#" Value="public object DataSource { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.DataSource" />
      <MemberSignature Language="VB.NET" Value="Public Property DataSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataSource { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AttributeProvider(typeof(System.ComponentModel.IListSource))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia źródło danych, która wiąże łącznika.</summary>
        <value>
          <see cref="T:System.Object" /> , Który pełni rolę źródła danych. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataSource%2A> Właściwość można ustawić na liczbę źródeł danych, w tym typy obiektów i listy typów. Wynikowa źródła danych mają być widoczne w postaci listy. W poniższej tabeli przedstawiono niektóre wspólnych źródeł danych i wynikowy oceny listy.  
  
|Właściwości DataSource|Lista wyników|  
|-------------------------|------------------|  
|`null`|Pusta <xref:System.ComponentModel.IBindingList> obiektów. Dodawanie elementu ustawia listę typowi dodanego elementu.|  
|`null` z <xref:System.Windows.Forms.BindingSource.DataMember%2A> ustawić|Nieobsługiwane, generuje <xref:System.ArgumentException>.|  
|Typ spoza listy lub obiektu typu "T"|Pusty <xref:System.ComponentModel.IBindingList> typu "T".|  
|Wystąpienia tablicy|<xref:System.ComponentModel.IBindingList> zawierających elementy tablicy.|  
|<xref:System.Collections.IEnumerable> Wystąpienie|<xref:System.ComponentModel.IBindingList> Zawierający <xref:System.Collections.IEnumerable> elementów.|  
|Lista wystąpienia typu "T"|<xref:System.ComponentModel.IBindingList> wystąpienie typu "T".|  
  
 Ponadto <xref:System.Windows.Forms.BindingSource.DataSource%2A> można ustawić na inne typy listę takich jak <xref:System.ComponentModel.IListSource> i <xref:System.ComponentModel.ITypedList> i <xref:System.Windows.Forms.BindingSource> odpowiednio je będzie obsługiwać. W takim przypadku zawarte na liście Typ ma konstruktora domyślnego.  
  
 Podczas ustawiania źródła danych, jeśli dostarczone odwołanie zawiera więcej niż jedną lub tabeli, należy ustawić <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwości na ciąg, który określa listę, aby powiązać. Ustawienie tej właściwości zgłasza <xref:System.Windows.Forms.BindingSource.DataSourceChanged> zdarzeń.  
  
> [!NOTE]
>  Jeśli wprowadzisz zmiany w <xref:System.Windows.Forms.BindingSource.DataSource%2A> wartość właściwości, należy zrobić to w wątku interfejsu użytkownika do zapewnienia, że zmiany interfejsu użytkownika.  
  
 <xref:System.Windows.Forms.BindingSource.DataSource%2A> Właściwość jest właściwością domyślną dla <xref:System.Windows.Forms.BindingSource> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu przypisuje listę klientom <xref:System.Windows.Forms.BindingSource.DataSource%2A> z <xref:System.Windows.Forms.BindingSource> składnika. Ten przykładowy kod jest częścią większego przykładu udostępnionego w [porady: wywoływanie powiadomień o zmianie za pomocą metody BindingSource Resetitem](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.ComponentModel.IListSource" />
      </Docs>
    </Member>
    <Member MemberName="DataSourceChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DataSourceChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataSourceChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataSourceChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DataSourceChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy <see cref="P:System.Windows.Forms.BindingSource.DataSource" /> zmieniono wartość właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.DataSourceChanged> Po wystąpieniu zdarzenia <xref:System.Windows.Forms.BindingSource.DataSource%2A> zmiany właściwości.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Windows.Forms.BindingSource" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną `Dispose` — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr ma wartość true, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Windows.Forms.BindingSource> odwołania. Ta metoda wywołuje `Dispose` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" /> należy uważać, aby nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose(Boolean)" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see cref="M:System.Object.Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndEdit">
      <MemberSignature Language="C#" Value="public void EndEdit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndEdit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.EndEdit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndEdit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndEdit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zastosowanie oczekujących zmian źródła danych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Forms.BindingSource.EndEdit%2A> metoda jest wywoływana, wszystkie oczekujące zmiany są stosowane do źródła danych.  
  
 Ta metoda nie obowiązuje, chyba że obiekty zawarte źródło danych implementuje <xref:System.ComponentModel.IEditableObject> interfejsu. Jeśli obiekt nie implementuje <xref:System.ComponentModel.IEditableObject> interfejsu, zmiany danych są kopiowane do źródła danych od razu po każdej zmianie.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="T:System.ComponentModel.IEditableObject" />
        <altmember cref="M:System.Windows.Forms.BindingSource.CancelEdit" />
        <altmember cref="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual string Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Filter { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wyrażenie używane do filtrowania wierszy, które są wyświetlane.</summary>
        <value>Ciąg, który określa, jak wierszy są filtrowane. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używane w scenariuszach złożone powiązanie danych <xref:System.Windows.Forms.BindingSource.Filter%2A> Właściwość pozwala wyświetlić podzbiór <xref:System.Windows.Forms.BindingSource.DataSource%2A>. Tylko podstawowy listy, które implementują <xref:System.ComponentModel.IBindingListView> interfejsu filtrowania pomocy technicznej.  
  
 Gdy <xref:System.Windows.Forms.BindingSource.Filter%2A> nie jest `null`, <xref:System.Windows.Forms.BindingSource> przekazuje tę właściwość do listy źródłowej. Jeśli ta właściwość jest ustawiona podczas inicjowania obiektu, wywołanie zostanie odroczona do po zakończeniu inicjowania.  
  
 Do tworzenia wartości filtru, określ nazwę kolumny, a następnie operator i wartość do filtrowania. Składnia filtru zaakceptowane zależy od źródła danych. Jeśli źródła danych jest <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, można określić przy użyciu składni udokumentowane dla wyrażeń logicznych <xref:System.Data.DataColumn.Expression%2A?displayProperty=nameWithType> właściwości.  
  
 Wartość <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwość ma wpływ na wartość <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości. Ponadto <xref:System.Windows.Forms.BindingSource.Filter%2A> zostanie utrzymana podczas zmiany źródła danych. Aby zatrzymać filtrowanie <xref:System.Windows.Forms.BindingSource.DataSource%2A>, wywołaj <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> metody.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości o <xref:System.Data.DataView>. Aby uruchomić ten przykład, Wklej kod do formularza systemu Windows i wywołanie `PopulateDataViewAndFilter` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metoda obsługi zdarzeń. Formularza należy importować <xref:System.Xml> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveFilter" />
        <altmember cref="P:System.ComponentModel.IBindingList.IsSorted" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Znajdź element określonego w źródle danych.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public virtual int Find (System.ComponentModel.PropertyDescriptor prop, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Find(class System.ComponentModel.PropertyDescriptor prop, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Find (prop As PropertyDescriptor, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Find(System::ComponentModel::PropertyDescriptor ^ prop, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="prop">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> Do wyszukania.</param>
        <param name="key">Wartość <c>prop</c> do dopasowania.</param>
        <summary>Wyszukuje indeks elementu, który ma deskryptor właściwości.</summary>
        <returns>Liczony od zera indeks elementu, który ma podanej wartości dla <see cref="T:System.ComponentModel.PropertyDescriptor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest zwykle używanych w złożonych przypadkach wiązania danych do zlokalizuj pierwszy wiersz, w którym wartość pola określone przez `prop` parametru jest równa wartości `key` parametru  
  
 Ta metoda po prostu dotyczy żądanie Lista podstawowa <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> metody. Na przykład, jeśli jego źródło danych jest <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, ta metoda wywołuje <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A?displayProperty=nameWithType> metody. Zachowanie <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType>, takie jak wartość zwracana, jeśli żadnego pasującego elementu zostanie znaleziony, zależy od implementacji metody, na liście podstawowej.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Windows.Forms.BindingSource.Find%2A> metody. Na przykład Pełna zobacz temat Omówienie klasy.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie jest typu <see cref="T:System.ComponentModel.IBindingList" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string propertyName, object key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string propertyName, object key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Find(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (propertyName As String, key As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ propertyName, System::Object ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
        <Parameter Name="key" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="propertyName">Nazwa właściwości do wyszukania.</param>
        <param name="key">Wartość elementu z określonym <c>propertyName</c> można znaleźć.</param>
        <summary>Zwraca indeks elementu na liście o nazwie określonej właściwości i wartości.</summary>
        <returns>Liczony od zera indeks elementu o nazwie określonej właściwości i wartości.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Find%2A> Metody można użyć tylko, gdy jest lista podstawowa <xref:System.ComponentModel.IBindingList> z wyszukiwaniem zaimplementowana. Ta metoda po prostu dotyczy żądanie Lista podstawowa <xref:System.ComponentModel.IBindingList.Find%2A?displayProperty=nameWithType> metody. Na przykład, jeśli jego źródło danych jest <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, lub <xref:System.Data.DataView>, ta metoda konwertuje `propertyName` do <xref:System.ComponentModel.PropertyDescriptor> i wywołuje <xref:System.Data.DataView.System%23ComponentModel%23IBindingList%23Find%2A> metody. Zachowanie <xref:System.Windows.Forms.BindingSource.Find%2A>, takie jak wartość zwracana, jeśli żadnego pasującego elementu zostanie znaleziony, zależy od implementacji metody, na liście podstawowej.  
  
 Porównanie nazwa właściwości jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Forms.BindingSource.Find%2A> metody z <xref:System.Data.DataView>. Aby uruchomić ten przykład, Wklej kod do formularza systemu Windows i wywołanie `PopulateDataViewAndFind` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metoda obsługi zdarzeń. Formularza należy importować <xref:System.Xml> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Lista podstawowa nie jest <see cref="T:System.ComponentModel.IBindingList" /> z przypisanych funkcji wyszukiwania.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="propertyName" /> niezgodna z właściwością na liście.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera moduł wyliczający dla <see cref="P:System.Windows.Forms.BindingSource.List" />.</summary>
        <returns>
          <see cref="T:System.Collections.IEnumerator" /> Dla <see cref="P:System.Windows.Forms.BindingSource.List" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProperties">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptorCollection GetItemProperties (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.PropertyDescriptorCollection GetItemProperties(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetItemProperties(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemProperties (listAccessors As PropertyDescriptor()) As PropertyDescriptorCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::PropertyDescriptorCollection ^ GetItemProperties(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów można znaleźć na liście jako możliwej do wiązania.</param>
        <summary>Pobiera tablicę <see cref="T:System.ComponentModel.PropertyDescriptor" /> typ listy źródła obiekty reprezentujące właściwości powiązania danych.</summary>
        <returns>Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów, które reprezentuje właściwości dla tego typu listy używanych do wiązania danych.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetListName">
      <MemberSignature Language="C#" Value="public virtual string GetListName (System.ComponentModel.PropertyDescriptor[] listAccessors);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetListName(class System.ComponentModel.PropertyDescriptor[] listAccessors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetListName(System.ComponentModel.PropertyDescriptor[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetListName (listAccessors As PropertyDescriptor()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetListName(cli::array &lt;System::ComponentModel::PropertyDescriptor ^&gt; ^ listAccessors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="listAccessors" Type="System.ComponentModel.PropertyDescriptor[]" />
      </Parameters>
      <Docs>
        <param name="listAccessors">Tablica <see cref="T:System.ComponentModel.PropertyDescriptor" /> obiektów można znaleźć na liście jako możliwej do wiązania.</param>
        <summary>Pobiera nazwę listy dostarczająca dane dla tego powiązania.</summary>
        <returns>Nazwa listy dostarczająca dane dla powiązania.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.ListBindingHelper" />
      </Docs>
    </Member>
    <Member MemberName="GetRelatedCurrencyManager">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager (string dataMember);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.CurrencyManager GetRelatedCurrencyManager(string dataMember) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRelatedCurrencyManager (dataMember As String) As CurrencyManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::CurrencyManager ^ GetRelatedCurrencyManager(System::String ^ dataMember);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.ICurrencyManagerProvider.GetRelatedCurrencyManager(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CurrencyManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dataMember" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dataMember">Nazwa kolumny lub listy w źródle danych do menedżera waluty w celu pobrania.</param>
        <summary>Pobiera menedżera waluty powiązanych danych określonego elementu członkowskiego.</summary>
        <returns>Pokrewny <see cref="T:System.Windows.Forms.CurrencyManager" /> dla elementu członkowskiego określone dane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli `dataMember` jest `null` lub ciąg pusty (""), <xref:System.Windows.Forms.BindingSource.GetRelatedCurrencyManager%2A> zwraca Menedżera główną walutę; w przeciwnym razie sprawdza dla innej <xref:System.Windows.Forms.BindingSource> powiązany z elementem członkowskim określone dane i zwraca jego menedżera waluty.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <see cref="T:System.Object" /> Można znaleźć na liście podstawowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwości. Wartość może być <see langword="null" />.</param>
        <summary>Wyszukuje określony obiekt i zwraca indeks pierwszego wystąpienia w obrębie całej listy.</summary>
        <returns>Liczony od zera indeks pierwszego wystąpienia <paramref name="value" /> parametru; w przeciwnym razie wartość -1 Jeśli <paramref name="value" /> nie jest na liście.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mimo że wdrożenia jest zależny od Lista podstawowa `IndexOf` metody, zwykle obowiązują następujące zasady:  
  
-   <xref:System.Windows.Forms.BindingSource.List%2A> Jest przeszukiwany, rozpoczynając od pierwszego elementu i końcowy z ostatniego elementu.  
  
-   Metoda podstawowej przeprowadza wyszukiwanie liniowe; w związku z tym Średni czas wykonania jest proporcjonalny do wartości <xref:System.Windows.Forms.BindingSource.Count%2A> właściwości.  
  
-   Metody podstawowej określa równości przez wywołanie metody <xref:System.Object.Equals%2A> metody.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Contains(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public virtual void Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Insert (index As Integer, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Insert(int index, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks, w którym <c>wartość</c> powinien zostać wstawiony.</param>
        <param name="value">
          <see cref="T:System.Object" /> Do wstawienia. Wartość może być <see langword="null" />.</param>
        <summary>Wstawia element do listy w określonym indeksie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Lista jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      </Docs>
    </Member>
    <Member MemberName="IsBindingSuspended">
      <MemberSignature Language="C#" Value="public bool IsBindingSuspended { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBindingSuspended" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsBindingSuspended" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBindingSuspended As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBindingSuspended { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy powiązanie listy jest wstrzymana.</summary>
        <value>
          <see langword="true" /> Aby wskazać, że powiązanie jest zawieszony; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public virtual bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lista podstawowa o stałym rozmiarze.</summary>
        <value>
          <see langword="true" /> Jeżeli lista podstawowa ma stały rozmiar; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista zawiera o stałym rozmiarze, nie umożliwia dodawania lub usuwania elementów po utworzeniu listy, ale możesz zmodyfikować istniejące elementy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public virtual bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy lista podstawowa jest tylko do odczytu.</summary>
        <value>
          <see langword="true" /> Jeśli lista jest tylko do odczytu. w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Listę, która jest tylko do odczytu nie zezwala na dodanie, usunięcie lub zmiany żadnych elementów listy po utworzeniu listy.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSorted">
      <MemberSignature Language="C#" Value="public virtual bool IsSorted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSorted" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSorted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSorted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy elementy na liście podstawowej są sortowane.</summary>
        <value>
          <see langword="true" /> Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" /> i jest sortowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.IsSorted%2A> zawsze zwraca `false` Jeśli lista jest <xref:System.ComponentModel.IBindingList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy dostęp do kolekcji jest zsynchronizowany (wielowątkowość).</summary>
        <value>
          <see langword="true" /> Wskazuje, że lista jest synchronizowana; w przeciwnym razie <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual object this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable Property Item(index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu do pobrania.</param>
        <summary>Pobiera lub ustawia element listy pod określonym indeksem.</summary>
        <value>Element pod określonym indeksem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Item%2A> Właściwość reprezentuje indeksatora dla tej klasy. Akceptuje `null` jako prawidłowa wartość i umożliwia zduplikowane elementy na liście.  
  
 Ustawienie wartości zostanie podniesiony <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza od zera lub jest równa lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
      </Docs>
    </Member>
    <Member MemberName="List">
      <MemberSignature Language="C#" Value="public System.Collections.IList List { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IList List" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.List" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property List As IList" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::IList ^ List { System::Collections::IList ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera listę powiązaną łącznika.</summary>
        <value>
          <see cref="T:System.Collections.IList" /> Reprezentujący listy lub <see langword="null" /> Jeśli nie są znane źródłowy skojarzony z tym <see cref="T:System.Windows.Forms.BindingSource" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource> Klasa obsługuje jednolicie różnych źródeł danych. W idealnym przypadku <xref:System.Windows.Forms.BindingSource.List%2A> właściwość powinna być równa ogólny <xref:System.Collections.IList>. Jednak czasami może być konieczne tę właściwość, aby dokładniej typu rzutowania. W poniższej tabeli przedstawiono odpowiedni typ listy, która zależy od typu lub wartości źródła danych.  
  
|Typ źródła danych|Opis listy źródłowej|  
|----------------------|---------------------------------|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> i <xref:System.Windows.Forms.BindingSource.DataMember%2A> są `null`|Pusta <xref:System.Collections.ArrayList>.|  
|<xref:System.Windows.Forms.BindingSource.DataSource%2A> jest `null`, ale <xref:System.Windows.Forms.BindingSource.DataMember%2A> nie jest `null`|Brak; Próba pobrania <xref:System.Windows.Forms.BindingSource.List%2A> zgłosi <xref:System.ArgumentException>.|  
|<xref:System.Array> Wystąpienia|<xref:System.Array>.|  
|<xref:System.ComponentModel.IListSource> Wystąpienia|Wartość zwracana z wywołania <xref:System.ComponentModel.IListSource.GetList%2A> to metoda <xref:System.ComponentModel.IListSource> wystąpienia.|  
|<xref:System.ComponentModel.IBindingList> Wystąpienia|<xref:System.ComponentModel.IBindingList>.|  
|<xref:System.Collections.IList> Wystąpienia|<xref:System.Collections.IList>.|  
|Niż<xref:System.Collections.IList> wystąpienia typu "T"|A <xref:System.ComponentModel.BindingList%601> o jeden element.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor> Wystąpienia|<xref:System.Collections.ArrayList> o jeden element.|  
|An <xref:System.Collections.IEnumerable>|<xref:System.Collections.ArrayList> z elementami kopiowane.|  
|<xref:System.Array> To typ <xref:System.Windows.Forms.BindingSource.DataMember%2A> elementu typu "T"|A <xref:System.ComponentModel.BindingList%601>.|  
|A <xref:System.Type> reprezentujący <xref:System.ComponentModel.IListSource> lub <xref:System.ComponentModel.ITypedList>|Utworzona przez wywołanie do wystąpienia <xref:System.Activator.CreateInstance%28System.Type%29> metody <xref:System.Activator> klasy. A <xref:System.NotSupportedException> może zostać zgłoszony.|  
|<xref:System.Collections.IList> To typ <xref:System.Windows.Forms.BindingSource.DataMember%2A> elementu typu "T"<br /><br /> —lub—<br /><br /> Niż<xref:System.Collections.IList> typu|A <xref:System.ComponentModel.BindingList%601>.|  
|<xref:System.ComponentModel.ICustomTypeDescriptor> Typu|Brak; Próba pobrania <xref:System.Windows.Forms.BindingSource.List%2A> zgłosi <xref:System.NotSupportedException>.|  
  
 Jeśli typ pobrać jest <xref:System.Collections.IList> interfejsu, odpowiednia Kolekcja może być bardziej złożonych, takie jak <xref:System.Collections.ArrayList> lub <xref:System.Data.DataView> klasy.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, i <xref:System.Windows.Forms.BindingSource.Count%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`, a przycisk o nazwie `button1`. Skojarz `button1_Click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Item(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ListChanged">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.ListChangedEventHandler ListChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.ListChangedEventHandler ListChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.ListChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ListChanged As ListChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::ListChangedEventHandler ^ ListChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy podstawowy zmiany listy lub element listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.ListChanged> Zdarzeń występuje w przypadku zmiany członkostwa lub metadane Lista podstawowa reprezentowany przez <xref:System.Windows.Forms.BindingSource.List%2A> właściwości. Na przykład, to zdarzenie jest wywoływane, gdy elementy są dodane, usunięte lub przeniesione, lub <xref:System.Windows.Forms.BindingSource.DataSource%2A> lub <xref:System.Windows.Forms.BindingSource.DataMember%2A> zmiany właściwości. Wartości <xref:System.Windows.Forms.BindingSource.Sort%2A> i <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości będzie zachowywane po wystąpieniu tego zdarzenia.  
  
 To zdarzenie można całkowicie pominąć przez ustawienie <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwości `false`. Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje Obsługa <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie <xref:System.Windows.Forms.BindingSource> składnik do wykrycia, gdy <xref:System.Windows.Forms.BindingSource> Lista podstawowa elementu zostanie zmieniona.  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CPP/form1.cpp#9)]
 [!code-csharp[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/CS/form1.cs#9)]
 [!code-vb[System.Windows.Forms.DataConnector.ItemChangedEventMode#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ItemChangedEventMode/VB/form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="MoveFirst">
      <MemberSignature Language="C#" Value="public void MoveFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveFirst" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveFirst ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do pierwszego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia wartość bieżącego <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości na wartość 0, pierwszego elementu w źródle danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, i <xref:System.Windows.Forms.BindingSource.Position%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeni nazw i zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1` i przycisk o nazwie `button1`. Skojarz `Form1_Load` i `Form1_Paint` metod z <xref:System.Windows.Forms.Form.Load> i <xref:System.Windows.Forms.Control.Paint> zdarzenia formularza i powiąż `button1_click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveLast">
      <MemberSignature Language="C#" Value="public void MoveLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveLast" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveLast ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do ostatniego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia wartość bieżącego <xref:System.Windows.Forms.BindingSource.Position%2A> indeks ostatniego elementu w źródle danych, która jest równa wartości dla właściwości <xref:System.Windows.Forms.BindingSource.Count%2A> pomniejszonej o 1.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public void MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveNext ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zmienia wartość bieżącego <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości do następnego elementu w źródle danych.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, i <xref:System.Windows.Forms.BindingSource.Position%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeni nazw i zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1` i przycisk o nazwie `button1`. Skojarz `Form1_Load` i `Form1_Paint` metod z <xref:System.Windows.Forms.Form.Load> i <xref:System.Windows.Forms.Control.Paint> zdarzenia formularza i powiąż `button1_click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MovePrevious" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public void MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.MovePrevious" />
      <MemberSignature Language="VB.NET" Value="Public Sub MovePrevious ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MovePrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przenosi do poprzedniego elementu na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda zmiany bieżącej wartości <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości do poprzedniego elementu w źródle danych.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveLast" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveNext" />
        <altmember cref="M:System.Windows.Forms.BindingSource.MoveFirst" />
      </Docs>
    </Member>
    <Member MemberName="OnAddingNew">
      <MemberSignature Language="C#" Value="protected virtual void OnAddingNew (System.ComponentModel.AddingNewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAddingNew(class System.ComponentModel.AddingNewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAddingNew (e As AddingNewEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAddingNew(System::ComponentModel::AddingNewEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.AddingNewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.AddingNew" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnAddingNew%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnAddingNew(System.ComponentModel.AddingNewEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.AddingNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingComplete (System.Windows.Forms.BindingCompleteEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingComplete(class System.Windows.Forms.BindingCompleteEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingComplete (e As BindingCompleteEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingComplete(System::Windows::Forms::BindingCompleteEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingCompleteEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.BindingCompleteEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.BindingComplete" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnBindingComplete%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnBindingComplete(System.Windows.Forms.BindingCompleteEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.CurrentChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnCurrentChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnCurrentItemChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentItemChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentItemChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentItemChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentItemChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnCurrentItemChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnCurrentItemChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataError">
      <MemberSignature Language="C#" Value="protected virtual void OnDataError (System.Windows.Forms.BindingManagerDataErrorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataError(class System.Windows.Forms.BindingManagerDataErrorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataError (e As BindingManagerDataErrorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataError(System::Windows::Forms::BindingManagerDataErrorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.BindingManagerDataErrorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.Windows.Forms.BindingManagerDataErrorEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.DataError" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnDataError%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnDataError(System.Windows.Forms.BindingManagerDataErrorEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDataMemberChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataMemberChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataMemberChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataMemberChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataMemberChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnDataMemberChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.  
  
 <see cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" /> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataMemberChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataMember" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDataSourceChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDataSourceChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataSourceChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDataSourceChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDataSourceChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnDataSourceChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnDataSourceChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.DataSource" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnDataMemberChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnListChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnListChanged (System.ComponentModel.ListChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnListChanged(class System.ComponentModel.ListChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnListChanged (e As ListChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnListChanged(System::ComponentModel::ListChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.ListChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="T:System.EventArgs" /> Zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnListChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnListChanged(System.ComponentModel.ListChangedEventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.DataSourceChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
      </Docs>
    </Member>
    <Member MemberName="OnPositionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPositionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPositionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPositionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPositionChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">A <see cref="T:System.ComponentModel.ListChangedEventArgs" /> zawierający dane zdarzenia.</param>
        <summary>Zgłasza <see cref="E:System.Windows.Forms.BindingSource.PositionChanged" /> zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podnoszenie zdarzenia wywołuje program obsługi zdarzeń przez delegata. Aby uzyskać więcej informacji, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 <xref:System.Windows.Forms.BindingSource.OnPositionChanged%2A> Metoda umożliwia również klas pochodnych do obsługi zdarzenia bez dołączanie delegata. Jest to preferowana metoda obsługi zdarzeń w klasie pochodnej.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>W przypadku przesłaniania <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> w klasie pochodnej, należy wywołać klasy podstawowej <see cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" /> metody, które zarejestrowane delegatów odbierać zdarzenia.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.BindingSource.PositionChanged" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnCurrentChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public int Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Position" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Position" />
      <MemberSignature Language="VB.NET" Value="Public Property Position As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Position { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia indeks bieżącego elementu na liście podstawowej.</summary>
        <value>Liczony od zera indeks, który określa położenie bieżący element na liście podstawowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas ustawiania <xref:System.Windows.Forms.BindingSource.Position%2A> właściwości, wartości spoza zakresu, są traktowane w następujący sposób:  
  
-   Wartości ujemne są traktowane jako 0.  
  
-   Wartości większe niż lub równe <xref:System.Windows.Forms.BindingSource.Count%2A> są traktowane jako <xref:System.Windows.Forms.BindingSource.Count%2A> pomniejszonej o 1.  
  
 Zmiana <xref:System.Windows.Forms.BindingSource.Position%2A> dostosuje właściwości <xref:System.Windows.Forms.BindingSource.Current%2A> właściwości podobnie.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.MoveNext%2A>, <xref:System.Windows.Forms.BindingSource.MoveFirst%2A>, <xref:System.Windows.Forms.BindingSource.Current%2A>, i <xref:System.Windows.Forms.BindingSource.Position%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który importuje <xref:System.Drawing.Drawing2D> przestrzeni nazw i zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1` i przycisk o nazwie `button1`. Skojarz `Form1_Load` i `Form1_Paint` metod z <xref:System.Windows.Forms.Form.Load> i <xref:System.Windows.Forms.Control.Paint> zdarzenia formularza i powiąż `button1_click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-cpp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/cpp/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.DataConnectorCurrent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorCurrent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Current" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Count" />
      </Docs>
    </Member>
    <Member MemberName="PositionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PositionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PositionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.BindingSource.PositionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PositionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PositionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po wartości <see cref="P:System.Windows.Forms.BindingSource.Position" /> właściwość zostanie zmieniona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.PositionChanged> Po wystąpieniu zdarzenia <xref:System.Windows.Forms.BindingSource.Position%2A> właściwość zostanie zmieniona.  
  
 Aby uzyskać więcej informacji na temat obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.OnPositionChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseListChangedEvents">
      <MemberSignature Language="C#" Value="public bool RaiseListChangedEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RaiseListChangedEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.RaiseListChangedEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property RaiseListChangedEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RaiseListChangedEvents { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą czy <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> powinien być wywoływany zdarzenia.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="E:System.Windows.Forms.BindingSource.ListChanged" /> zdarzenia powinny być zgłoszono; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwość jest `false`, wstrzymuje, gromadzenia <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia. To zdarzenie oznacza, że listy powiązanej został zmodyfikowany w sposób, w tym dodawanie, usuwanie, wstawiania lub modyfikowanie elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="E:System.Windows.Forms.BindingSource.CurrentItemChanged" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public virtual void Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Remove (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Remove(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Element do usunięcia z listy źródłowej reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwości.</param>
        <summary>Usuwa określony element z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Remove%2A> Metoda powoduje listy mają być wyszukiwane `value` parametru. Jeśli znaleziono, ta metoda będzie podejmować próby usunięcia elementu z <xref:System.Windows.Forms.BindingSource.List%2A>. Ta próba zakończy się niepowodzeniem, jeśli lista ma stały rozmiar lub jest tylko do odczytu. Te dwa warunki można przetestować z <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> i <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> właściwości, odpowiednio.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa ma stały rozmiar lub jest tylko do odczytu.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public virtual void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveAt (index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveAt(int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Liczony od zera indeks elementu, który ma zostać usunięty.</param>
        <summary>Usuwa element o określonym indeksie na liście.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Te dwa warunki można przetestować z <xref:System.Windows.Forms.BindingSource.IsFixedSize%2A> i <xref:System.Windows.Forms.BindingSource.IsReadOnly%2A> właściwości, odpowiednio.  
  
 Ta metoda zgłasza <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje <xref:System.Windows.Forms.BindingSource.List%2A>, <xref:System.Windows.Forms.BindingSource.RemoveAt%2A>, i <xref:System.Windows.Forms.BindingSource.Count%2A> elementów członkowskich. Aby uruchomić ten przykład, Wklej kod do formularza, który zawiera <xref:System.Windows.Forms.BindingSource> o nazwie `BindingSource1`, dwie etykiety o nazwie `label1` i `label2`, a przycisk o nazwie `button1`. Skojarz `button1_Click` metody z <xref:System.Windows.Forms.Control.Click> zdarzenia dla `button1`. Visual Basic użytkowników należy dodać odwołanie do System.Data.dll.  
  
 [!code-csharp[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.DataConnectorFilterAndSort#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnectorFilterAndSort/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> jest mniejsza niż zero lub większa niż wartość <see cref="P:System.Windows.Forms.BindingSource.Count" /> właściwości.</exception>
        <exception cref="T:System.NotSupportedException">Lista podstawowa reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Remove(System.Object)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsFixedSize" />
        <altmember cref="P:System.Windows.Forms.BindingSource.IsReadOnly" />
        <altmember cref="M:System.Windows.Forms.BindingSource.IndexOf(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.AddNew" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public void RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveCurrent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bieżący element z listy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.RemoveCurrent%2A> Metoda jest odpowiednikiem <xref:System.Windows.Forms.BindingSource.RemoveAt%2A> metody.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Forms.BindingSource.AllowRemove" /> Jest właściwość <see langword="false" />.  
  
 —lub—  
  
 <see cref="P:System.Windows.Forms.BindingSource.Position" /> jest mniejsza niż zero lub większa niż <see cref="P:System.Windows.Forms.BindingSource.Count" />.</exception>
        <exception cref="T:System.NotSupportedException">Lista podstawowa reprezentowany przez <see cref="P:System.Windows.Forms.BindingSource.List" /> właściwość jest tylko do odczytu lub ma stały rozmiar.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveAt(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Add(System.Object)" />
        <altmember cref="M:System.Windows.Forms.BindingSource.Insert(System.Int32,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveFilter">
      <MemberSignature Language="C#" Value="public virtual void RemoveFilter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveFilter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveFilter ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveFilter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa filtr skojarzony z <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.RemoveFilter%2A> Metoda dotyczy Lista podstawowa żądania <xref:System.ComponentModel.IBindingListView.RemoveFilter%2A?displayProperty=nameWithType> metody. Przedstawia tylko które implementują <xref:System.ComponentModel.IBindingListView> obsługuje filtrowania.  
  
 Domyślnie wywołanie tej metody jest odpowiednikiem ustawienia <xref:System.Windows.Forms.BindingSource.Filter%2A> właściwości `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie obsługuje filtrowania.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="RemoveSort">
      <MemberSignature Language="C#" Value="public virtual void RemoveSort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveSort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.RemoveSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveSort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveSort();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa sortowania skojarzone z <see cref="T:System.Windows.Forms.BindingSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.RemoveSort%2A> Metoda dotyczy Lista podstawowa żądania <xref:System.ComponentModel.IBindingList.RemoveSort%2A?displayProperty=nameWithType> metody. Przedstawia tylko które implementują <xref:System.ComponentModel.IBindingList> obsługuje sortowania.  
  
 Domyślnie wywołanie tej metody jest odpowiednikiem ustawienia <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwości `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie obsługuje sortowania.</exception>
        <altmember cref="P:System.Windows.Forms.BindingSource.Sort" />
      </Docs>
    </Member>
    <Member MemberName="ResetAllowNew">
      <MemberSignature Language="C#" Value="public virtual void ResetAllowNew ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetAllowNew() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetAllowNew" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetAllowNew ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetAllowNew();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ponownie inicjuje <see cref="P:System.Windows.Forms.BindingSource.AllowNew" /> właściwości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.ResetAllowNew%2A> Ponowne metody <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości w celu odzwierciedlenia wartości odpowiadającego <xref:System.Windows.Forms.BindingSource.AllowNew%2A> właściwości na liście podstawowej.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.AllowNew" />
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings (bool metadataChanged);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings(bool metadataChanged) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings (metadataChanged As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings(bool metadataChanged);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataChanged" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="metadataChanged">
          <see langword="true" /> Jeśli schemat danych został zmieniony; <see langword="false" /> jeśli tylko wartości zostały zmienione.</param>
        <summary>Powoduje, że formant związany <see cref="T:System.Windows.Forms.BindingSource" /> odczytać wszystkie elementy na liście i odświeżanie ich wartości wyświetlane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> Metody informuje wszystkie formanty powiązane z <xref:System.Windows.Forms.BindingSource> odświeżyć ich wartości. Robi to przez wywołanie metody <xref:System.Windows.Forms.BindingSource.ListChanged> co najmniej raz zdarzeń; `metaDataChanged` parametr wskazuje rodzaj podstawowej zmiany.  
  
-   A `metaDataChanged` wartość `true` wskazuje, że schemat danych <xref:System.Windows.Forms.BindingSource> została zmieniona. A <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie jest wywoływane z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną <xref:System.ComponentModel.ListChangedType.PropertyDescriptorChanged?displayProperty=nameWithType>.  
  
-   A `metaDataChanged` wartość `false` wskazuje, że tylko wartości co najmniej jednego elementu zostały zmienione.  
  
 Niezależnie od wartości `metaDataChanged`, <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie jest wywoływane z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną <xref:System.ComponentModel.ListChangedType.Reset?displayProperty=nameWithType>. W konsekwencji wywoływania <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> z parametrem `true` zgłosi dwa <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia.  
  
 <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> automatycznie jest wywoływana, gdy innego członka zmienia głównych wiązania danych, takie jak ustawienie <xref:System.Windows.Forms.BindingSource.DataSource%2A> lub <xref:System.Windows.Forms.BindingSource.DataMember%2A> właściwości. Jednak programistę również tę metodę można wywołać bezpośrednio.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.BindingSource> składnika powiązać listy tablicy, która nie zapewnia powiadomienie o zmianie. Element został usunięty z listy i formanty powiązane są powiadamiani o zmiany wywołując <xref:System.Windows.Forms.BindingSource.ResetBindings%2A> metody. Ten przykładowy kod jest częścią większego przykładu udostępnionego w [porady: odzwierciedlają aktualizacji źródła danych w formancie formularzy systemu Windows za pomocą elementu BindingSource](~/docs/framework/winforms/controls/reflect-data-source-updates-in-a-wf-control-with-the-bindingsource.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetBindings#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetBindings/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.List" />
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResetCurrentItem">
      <MemberSignature Language="C#" Value="public void ResetCurrentItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetCurrentItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetCurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetCurrentItem ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetCurrentItem();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje, że formant związany <see cref="T:System.Windows.Forms.BindingSource" /> odczytać aktualnie zaznaczonego elementu i odświeżyć jego wyświetlana wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody spowoduje, że <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia, określenie elementu zmienić w bieżącym położeniu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetItem">
      <MemberSignature Language="C#" Value="public void ResetItem (int itemIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetItem(int32 itemIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResetItem(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetItem (itemIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetItem(int itemIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="itemIndex">Liczony od zera indeks elementu, który został zmieniony.</param>
        <summary>Powoduje, że formant związany <see cref="T:System.Windows.Forms.BindingSource" /> odczytać element pod określonym indeksem i Odśwież jego wyświetlana wartość.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A> Metody powiadamia wszystkie formanty powiązane z elementem w określonym <xref:System.Windows.Forms.BindingSource.Position%2A> odświeżyć ich wartości. Robi to przez wywołanie metody <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenie z <xref:System.ComponentModel.ListChangedEventArgs.ListChangedType?displayProperty=nameWithType> ustawioną <xref:System.ComponentModel.ListChangedType.ItemChanged?displayProperty=nameWithType>.  
  
 <xref:System.Windows.Forms.BindingSource.ResetItem%2A> automatycznie jest wywoływana ze zmianami do wartości pojedynczy element. Jednak programistę również tę metodę można wywołać bezpośrednio.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Windows.Forms.BindingSource> składnika powiązać listy <xref:System.Windows.Forms.DataGridView> formantu. Listy nie wywoływanie powiadomień o zmianie, więc <xref:System.Windows.Forms.BindingSource.ResetItem%2A> metoda <xref:System.Windows.Forms.BindingSource> służy do podniesienia <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzeń. Ten przykładowy kod jest częścią większego przykładu udostępnionego w [porady: wywoływanie powiadomień o zmianie za pomocą metody BindingSource Resetitem](~/docs/framework/winforms/controls/how-to-raise-change-notifications-using-the-bindingsource-resetitem-method.md).  
  
 [!code-cpp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.DataConnector.ResetItem#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.DataConnector.ResetItem/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.BindingSource.ResetBindings(System.Boolean)" />
        <altmember cref="P:System.Windows.Forms.BindingSource.Position" />
        <altmember cref="E:System.Windows.Forms.BindingSource.ListChanged" />
        <altmember cref="T:System.ComponentModel.ListChangedType" />
      </Docs>
    </Member>
    <Member MemberName="ResumeBinding">
      <MemberSignature Language="C#" Value="public void ResumeBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.ResumeBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wznawia wiązania z danymi.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> przy użyciu dwóch metod umożliwiających tymczasowe zawieszenia i wznowienia powiązanie danych w scenariuszu prosty — wiązanie. Powiązanie danych będzie zazwyczaj zawiesić, jeśli użytkownik musi mieć możliwość dokonaj edycji kilka do pola danych, zanim nastąpi jego poprawności. Na przykład jeśli jedno pole musi zostać zmieniona zgodnie z drugiej, ale sprawdzanie poprawności pierwsze pole spowodowałoby drugie pole jest błędny.  
  
> [!NOTE]
>  Przy użyciu <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> uniemożliwia przekazywanej do źródła danych do czasu zmiany <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> jest wywoływana, ale nie faktycznie zapobiega zdarzeń występujących. Formanty używające złożone powiązanie danych, takich jak <xref:System.Windows.Forms.DataGridView> kontrolować, zaktualizuj swoje wartości oparte na zdarzenia zmiany, takie jak <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń, dlatego wywołanie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> nie uniemożliwi ich odebranie zmian w źródle danych. Z tego powodu to <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użytku z formantów powiązanych z prostego, takich jak <xref:System.Windows.Forms.TextBox> formantu. Możesz też użyć tych metod w scenariuszu złożone powiązanie Jeśli można pominąć <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia przez ustawienie <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwości `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.ResumeBinding" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public string Sort { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Sort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.Sort" />
      <MemberSignature Language="VB.NET" Value="Public Property Sort As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Sort { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwy kolumn używana do sortowania i kolejność sortowania do wyświetlania wierszy w źródle danych.</summary>
        <value>Uwzględniana wielkość liter ciąg zawierający nazwę kolumny oraz "ASC" (dla rosnąco) lub "Opis" (dla malejąco). Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.Sort%2A> Właściwości jest uwzględniana wielkość liter ciąg, który określa nazwy kolumn sortowanie wierszy, oraz kierunek sortowania. Kolumny są sortowane w kolejności rosnącej domyślnie. Wiele kolumn mogą być oddzielone przecinkami, takich jak `"State, ZipCode DESC"`.  
  
 Aby obsługiwać, sortowanie, lista podstawowa musi implementować <xref:System.ComponentModel.IBindingList> lub <xref:System.ComponentModel.IBindingListView> interfejsów. Ta funkcja może być badana za pośrednictwem <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> właściwości. Sortowanie wielokolumnowego jest dostępne, gdy <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> jest właściwość `true`.  
  
 Ustawienie <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwość ulegnie zmianie listy wewnętrznej, w zależności od jego typu:  
  
-   Jeśli lista jest typu <xref:System.ComponentModel.IBindingList>, <xref:System.ComponentModel.IBindingList.SortProperty%2A?displayProperty=nameWithType> i <xref:System.ComponentModel.IBindingList.SortDirection%2A?displayProperty=nameWithType> właściwości są ustawione na wewnętrznej liście.  
  
-   Jeśli lista jest typu <xref:System.ComponentModel.IBindingListView>, <xref:System.ComponentModel.IBindingListView.SortDescriptions%2A?displayProperty=nameWithType> właściwość jest ustawiona.  
  
 Właściwości sortowania wewnętrznej liście tylko są zmieniane po ciąg sortowania nie jest `null`. `get` Metody dostępu dla tej właściwości nie pobiera wartość sortowania wewnętrznej listy; zamiast tego będzie zwracać `set` wartość metody dostępu. Wartość <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwość zostanie uwzględniona po zmiany źródła danych.  
  
   
  
## Examples  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwości do wykonywania podstawowych sortowania z <xref:System.Data.DataView>. Aby uruchomić ten przykład, Wklej kod do formularza systemu Windows i wywołanie `PopulateDataViewAndSort` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metoda obsługi zdarzeń. Formularza należy importować <xref:System.Xml> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#2)]  
  
 Poniższy przykład przedstawia użycie <xref:System.Windows.Forms.BindingSource.Sort%2A> właściwość, aby wykonywać zaawansowane sortowania z <xref:System.Data.DataView>. Aby uruchomić ten przykład, Wklej kod do formularza systemu Windows i wywołanie `PopulateDataViewAndAdvancedSort` z konstruktora formularza lub <xref:System.Windows.Forms.Form.Load> metoda obsługi zdarzeń. Formularza należy importować <xref:System.Xml> i <xref:System.IO> przestrzeni nazw.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceMethods#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceMethods/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.BindingSource.Filter" />
        <altmember cref="M:System.Windows.Forms.BindingSource.RemoveSort" />
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ListSortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As ListSortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDescriptionCollection ^ SortDescriptions { System::ComponentModel::ListSortDescriptionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolekcję sortowania opisy stosowane do źródła danych.</summary>
        <value>Jeśli źródło danych jest <see cref="T:System.ComponentModel.IBindingListView" />, <see cref="T:System.ComponentModel.ListSortDescriptionCollection" /> zawiera opisy sortowanie zastosowane do listy; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista jest <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SortDescriptions%2A> zawsze zwraca `null`.  
  
 <xref:System.ComponentModel.ListSortDescriptionCollection> Jest kolekcji tylko do odczytu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDirection">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.ListSortDirection SortDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ComponentModel.ListSortDirection SortDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortDirection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDirection As ListSortDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ListSortDirection SortDirection { System::ComponentModel::ListSortDirection get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ListSortDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kierunku, w którym sortowane są elementy na liście.</summary>
        <value>Jeden z <see cref="T:System.ComponentModel.ListSortDirection" /> wartości, wskazując kierunek lista jest sortowana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli lista podstawowa nie jest <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortDirection%2A> właściwość zawsze zwraca <xref:System.ComponentModel.ListSortDirection.Ascending>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortProperty">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.PropertyDescriptor SortProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.PropertyDescriptor SortProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SortProperty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortProperty As PropertyDescriptor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::PropertyDescriptor ^ SortProperty { System::ComponentModel::PropertyDescriptor ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyDescriptor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.ComponentModel.PropertyDescriptor" /> który jest używany do sortowania listy.</summary>
        <value>Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" />, <see cref="T:System.ComponentModel.PropertyDescriptor" /> są używane do sortowania; w przeciwnym razie <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista jest <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SortProperty%2A> zawsze zwraca `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsAdvancedSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsAdvancedSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAdvancedSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsAdvancedSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsAdvancedSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsAdvancedSorting { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje sortowanie wielokolumnowych.</summary>
        <value>
          <see langword="true" /> Jeśli lista jest <see cref="T:System.ComponentModel.IBindingListView" /> i obsługuje sortowanie wielokolumnowego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista jest <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsAdvancedSorting%2A> zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsChangeNotification">
      <MemberSignature Language="C#" Value="public virtual bool SupportsChangeNotification { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsChangeNotification" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsChangeNotification" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsChangeNotification As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsChangeNotification { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje powiadomienie o zmianie.</summary>
        <value>
          <see langword="true" /> we wszystkich przypadkach.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsFiltering">
      <MemberSignature Language="C#" Value="public virtual bool SupportsFiltering { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsFiltering" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsFiltering" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsFiltering As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsFiltering { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje filtrowania.</summary>
        <value>
          <see langword="true" /> Jeśli lista jest <see cref="T:System.ComponentModel.IBindingListView" /> i obsługuje filtrowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli lista jest <xref:System.ComponentModel.IBindingListView>, <xref:System.Windows.Forms.BindingSource.SupportsFiltering%2A> zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSearching">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSearching { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSearching" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSearching" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSearching As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSearching { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje wyszukiwanie za pomocą <see cref="M:System.Windows.Forms.BindingSource.Find(System.ComponentModel.PropertyDescriptor,System.Object)" /> metody.</summary>
        <value>
          <see langword="true" /> Jeśli lista jest <see cref="T:System.ComponentModel.IBindingList" /> i obsługuje wyszukiwanie za pomocą <see cref="Overload:System.Windows.Forms.BindingSource.Find" /> metody; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło danych nie jest <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> zawsze zwraca `false`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje sposób użycia <xref:System.Windows.Forms.BindingSource.SupportsSearching%2A> elementu członkowskiego. Na przykład Pełna zobacz temat Omówienie klasy.  
  
 [!code-csharp[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.BindingSourceAndBindingListOfT#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.BindingSourceAndBindingListOfT/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsSorting">
      <MemberSignature Language="C#" Value="public virtual bool SupportsSorting { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsSorting" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SupportsSorting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SupportsSorting As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool SupportsSorting { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy źródło danych obsługuje sortowanie.</summary>
        <value>
          <see langword="true" /> Jeśli źródło danych jest <see cref="T:System.ComponentModel.IBindingList" /> i obsługuje sortowanie; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli źródło danych nie jest <xref:System.ComponentModel.IBindingList>, <xref:System.Windows.Forms.BindingSource.SupportsSorting%2A> właściwość zawsze zwraca `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuspendBinding">
      <MemberSignature Language="C#" Value="public void SuspendBinding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendBinding() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.SuspendBinding" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendBinding ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendBinding();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wstrzymuje powiązania danych, aby uniemożliwić zmiany aktualizowanie źródła danych powiązania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> przy użyciu dwóch metod umożliwiających tymczasowe zawieszenia i wznowienia powiązanie danych w scenariuszu prosty — wiązanie. Powiązanie danych będzie zazwyczaj zawiesić, jeśli użytkownik musi mieć możliwość dokonaj edycji kilka do pola danych, zanim nastąpi jego poprawności. Na przykład jeśli jedno pole musi zostać zmieniona zgodnie z drugiej, ale sprawdzanie poprawności pierwsze pole spowodowałoby drugie pole jest błędny.  
  
> [!NOTE]
>  Przy użyciu <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i uniemożliwia przekazywanej do źródła danych do czasu zmiany <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> jest wywoływana, ale nie faktycznie zapobiega zdarzeń występujących. Formanty używające złożone powiązanie danych, takich jak <xref:System.Windows.Forms.DataGridView> kontrolować, zaktualizuj swoje wartości oparte na zdarzenia zmiany, takie jak <xref:System.Windows.Forms.CurrencyManager.ListChanged> zdarzeń, dlatego wywołanie <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> nie uniemożliwi ich odebranie zmian w źródle danych. Z tego powodu to <xref:System.Windows.Forms.BindingSource.SuspendBinding%2A> i <xref:System.Windows.Forms.BindingSource.ResumeBinding%2A> są przeznaczone do użytku z formantów powiązanych z prostego, takich jak <xref:System.Windows.Forms.TextBox> formantu. Możesz też użyć tych metod w scenariuszu złożone powiązanie Jeśli można pominąć <xref:System.Windows.Forms.BindingSource.ListChanged> zdarzenia przez ustawienie <xref:System.Windows.Forms.BindingSource.RaiseListChangedEvents%2A> właściwości `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.CurrencyManager.SuspendBinding" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera obiekt, który może służyć do synchronizujący dostęp do listy źródłowej.</summary>
        <value>Obiekt, który może służyć do synchronizujący dostęp do listy źródłowej.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.AddIndex">
      <MemberSignature Language="C#" Value="void IBindingList.AddIndex (System.ComponentModel.PropertyDescriptor property);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.AddIndex(class System.ComponentModel.PropertyDescriptor property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#AddIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub AddIndex (property As PropertyDescriptor) Implements IBindingList.AddIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.AddIndex(System::ComponentModel::PropertyDescriptor ^ property) = System::ComponentModel::IBindingList::AddIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="property">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> Do dodania do indeksów używane do wyszukiwania.</param>
        <summary>Dodaje <see cref="T:System.ComponentModel.PropertyDescriptor" /> indeksów używane do wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli lista podstawowa jest <xref:System.ComponentModel.IBindingList> typu tej metody spowoduje dodanie <xref:System.ComponentModel.PropertyDescriptor> indeksów; w przeciwnym razie wywołanie tej metody spowoduje zgłoszenie <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Lista podstawowa nie jest <see cref="T:System.ComponentModel.IBindingList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.IBindingList.RemoveIndex">
      <MemberSignature Language="C#" Value="void IBindingList.RemoveIndex (System.ComponentModel.PropertyDescriptor prop);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.IBindingList.RemoveIndex(class System.ComponentModel.PropertyDescriptor prop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#IBindingList#RemoveIndex(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveIndex (prop As PropertyDescriptor) Implements IBindingList.RemoveIndex" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.IBindingList.RemoveIndex(System::ComponentModel::PropertyDescriptor ^ prop) = System::ComponentModel::IBindingList::RemoveIndex;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prop" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="prop">
          <see cref="T:System.ComponentModel.PropertyDescriptor" /> Do usunięcia z indeksy używane do wyszukiwania.</param>
        <summary>Usuwa <see cref="T:System.ComponentModel.PropertyDescriptor" /> z indeksy używane do wyszukiwania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeżeli lista podstawowa nie jest <xref:System.ComponentModel.IBindingList?displayProperty=nameWithType>, ta metoda będzie zawsze zgłaszał <xref:System.NotSupportedException>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.CancelNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.CancelNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.CancelNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#CancelNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub CancelNew (position As Integer) Implements ICancelAddNew.CancelNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.CancelNew(int position) = System::ComponentModel::ICancelAddNew::CancelNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Indeks elementu, który został dodany do kolekcji.</param>
        <summary>Odrzuca oczekujące nowego elementu z kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23CancelNew%2A> Metody wycofuje Trwa oczekiwanie na dodanie wcześniej dodane do kolekcji w indeksie, określony przez element `position`. `position` Parametr jest konieczne, ponieważ kilka nowych elementów może być jednocześnie oczekujące.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.CancelNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ICancelAddNew.EndNew">
      <MemberSignature Language="C#" Value="void ICancelAddNew.EndNew (int position);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ICancelAddNew.EndNew(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ICancelAddNew#EndNew(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub EndNew (position As Integer) Implements ICancelAddNew.EndNew" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ICancelAddNew.EndNew(int position) = System::ComponentModel::ICancelAddNew::EndNew;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Indeks elementu, który został dodany do kolekcji.</param>
        <summary>Zatwierdza oczekujące nowy element do kolekcji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingSource.System%23ComponentModel%23ICancelAddNew%23EndNew%2A> Metody zatwierdza Trwa oczekiwanie na dodanie wcześniej dodane do kolekcji w indeksie, określony przez element `position`. `position` Parametr jest konieczne, ponieważ kilka nowych elementów może być jednocześnie oczekujące.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ComponentModel.ICancelAddNew.EndNew(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.BeginInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#BeginInit" />
      <MemberSignature Language="VB.NET" Value="Sub BeginInit () Implements ISupportInitialize.BeginInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.BeginInit() = System::ComponentModel::ISupportInitialize::BeginInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sygnały <see cref="T:System.Windows.Forms.BindingSource" /> tego inicjowania jest uruchamiana.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitialize.EndInit">
      <MemberSignature Language="C#" Value="void ISupportInitialize.EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.ISupportInitialize.EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitialize#EndInit" />
      <MemberSignature Language="VB.NET" Value="Sub EndInit () Implements ISupportInitialize.EndInit" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.ISupportInitialize.EndInit() = System::ComponentModel::ISupportInitialize::EndInit;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sygnały <see cref="T:System.Windows.Forms.BindingSource" /> tego Inicjowanie zostało zakończone.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.ISupportInitializeNotification.IsInitialized">
      <MemberSignature Language="C#" Value="bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.ComponentModel.ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.BindingSource.System#ComponentModel#ISupportInitializeNotification#IsInitialized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsInitialized As Boolean Implements ISupportInitializeNotification.IsInitialized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.ComponentModel.ISupportInitializeNotification.IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą czy <see cref="T:System.Windows.Forms.BindingSource" /> został zainicjowany.</summary>
        <value>
          <see langword="true" /> Aby wskazać <see cref="T:System.Windows.Forms.BindingSource" /> zainicjowane, a w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element jest jawną implementacją członków. Można go używać tylko wtedy, gdy <xref:System.Windows.Forms.BindingSource> wystąpienia jest rzutowane na <xref:System.ComponentModel.ISupportInitializeNotification> interfejsu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
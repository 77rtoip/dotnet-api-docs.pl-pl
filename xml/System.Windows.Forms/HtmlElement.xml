<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="87902a8466b3330ae39cf52a81c1f24b67dd60ed" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39941089" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje element HTML wewnątrz strony sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> reprezentuje dowolny możliwe typ elementu w dokumencie HTML, takich jak `BODY`, `TABLE`, i `FORM`, między innymi. Klasa przedstawia najbardziej typowe właściwości, których można oczekiwać, że można znaleźć w przypadku wszystkich elementów.  
  
 Większość elementów może mieć *elementy podrzędne*: inne elementy HTML, które są umieszczane ofert. Użyj <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> właściwości, aby sprawdzić, czy dany element ma elementy podrzędne, a <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji do iterowania po nich. <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość zwraca <xref:System.Windows.Forms.HtmlElement> w jest zagnieżdżona bieżącego elementu.  
  
 Często muszą mieć dostęp do atrybutów, właściwości i metody na element podstawowy, które nie są bezpośrednio widoczne przez <xref:System.Windows.Forms.HtmlElement>, takich jak `SRC` atrybutu na `IMG` element lub `Submit` metody `FORM`. <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> metody pozwalają na pobieranie i zmiany dowolnego atrybutu lub właściwość określonego elementu, gdy <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> zapewnia dostęp do dowolnej metody nie widoczne w zarządzanych Document Object Model (DOM). Jeśli aplikacja ma niezarządzane uprawnień kodu, można także przejść nieujawnionych właściwości i metody o <xref:System.Windows.Forms.HtmlElement.DomElement%2A> atrybutu.  
  
 Użyj <xref:System.Windows.Forms.HtmlElement.TagName%2A> właściwości, aby sprawdzić, czy element jest określonego typu.  
  
 Każdy dokument HTML można modyfikować w czasie wykonywania. Można tworzyć nowe <xref:System.Windows.Forms.HtmlElement> obiekty z <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody <xref:System.Windows.Forms.HtmlDocument>i dodaj je do innego elementu za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> metody. Możesz również tworzyć elementy jako tagi HTML i przypisać je do istniejącego elementu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak sprawdzić dowolnego dokumentu HTML i pobieraj ciąg opisujący elementów HTML, z wcięciem i numery poziomów używany do określania, jak głęboko zagnieżdżone elementy znajdują się w dokumencie. Ten przykład kodu wymaga, aby hosty aplikacji <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElementCollection" /> wszystkie elementy poniżej bieżącego elementu.</summary>
        <value>Kolekcja wszystkich elementów, które są bezpośrednie lub pośrednie elementy podrzędne bieżącego elementu. Jeśli bieżący element jest <c>tabeli</c>, na przykład <see cref="P:System.Windows.Forms.HtmlElement.All" /> zwróci co <c>TH</c>, <c>TR</c>, i <c>TD</c> elemencie tabeli jak jak wszystkie inne elementy, takie jak <c>DIV</c> i <c>zakres</c> zawartym w elemencie komórki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dostęp do tych elementów, które mają bieżącego elementu jako ich bezpośrednią lokacją nadrzędną, należy użyć <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji zamiast tego.  
  
 Elementów w tej kolekcji nie będzie zawsze być zwracane w porządku źródła.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">
          <see cref="T:System.Windows.Forms.HtmlElement" /> Do dołączenia do tej lokalizacji w drzewie.</param>
        <summary>Dodaje element do innego elementu poddrzewa.</summary>
        <returns>Element, po dodaniu do drzewa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML Document Object Model (DOM), można zmienić zawartość środowiska wykonawczego w pliku HTML na wiele sposobów. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Dodawanie nowych elementów do istniejącego dokumentu lub Przenieś element na stronie.  
  
 Jeśli element już został elementem nadrzędnym, dodanie elementu do innego elementu spowoduje automatyczne usunięcie tego elementu z nadrzędnego poprzedniego.  
  
 Wszystkie dodatki do dokumentu w czasie wykonywania za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> nie zostaną utrwalone po wywołaniu <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> metody <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową hiperłącza, używając <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody i dodaje go do końca strony przy użyciu `AppendChild` na `BODY` elementu. Przykład wymaga, że aplikacja zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Kodu zarządzanego, który obsługuje zdarzenie.</param>
        <summary>Dodaje program obsługi zdarzeń dla zdarzenia nazwanego na HTML Document Object Model (DOM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzane modelu DOM (Document Object) udostępnia wybierz liczbę zdarzeń. Większość zdarzeń nieujawnionych tylko są zdefiniowane dla określonych typów elementów; takie jak `submit` zdarzenie, które jest prawidłowy tylko w `FORM` elementów. Użyj <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> dodać program obsługi zdarzeń do nieujawnionych zdarzenia.  
  
 Nie należy dołączać zdarzenie w dokumencie lub jednego ze swoich obiektów, dopóki nie zakończy się dokument ładowania. Jest najwcześniejsza powinna wywołać tę metodę w <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenia <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
 Aby uzyskać więcej informacji na temat dostępnych zdarzenia niezarządzane zobacz [uzyskiwania dostępu do nieujawnionych elementów w zarządzanych HTML Document Object Model](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) i interfejsy IHTMLElement: [IHTMLElement](http://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](http://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](http://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](http://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element może mieć elementów podrzędnych.</summary>
        <value>
          <see langword="true" /> Jeśli element może mieć elementów podrzędnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre elementy, takie jak `IMG` i `SCRIPT`, nie może mieć żadnych elementów podrzędnych. Ta właściwość jest używana przed wywołaniem <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> dowolnego elementu.  
  
   
  
## Examples  
 Poniższy kod obsługuje przykład <xref:System.Windows.Forms.HtmlElement.Click> zdarzenie na <xref:System.Windows.Forms.HtmlDocument>. Jeśli element nie poprzedniej zaznaczone, kliknięcie myszą, kod przypisuje element do prywatnej klasy zmiennej o nazwie `MoveElement`. Jeśli element został wybrany, kod próbuje dołączyć do elementu, który właśnie został kliknięty. Ten przykład kodu wymaga, aby hosty aplikacji <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`, i czy masz już dodany do planowych zdarzeń <xref:System.Windows.Forms.HtmlElement.Click> zdarzenie na <xref:System.Windows.Forms.HtmlDocument>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElementCollection" /> wszystkie elementy podrzędne bieżącego elementu.</summary>
        <value>Kolekcja wszystkich <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów, które mają bieżący element jako element nadrzędny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów wewnątrz pliku HTML może mieć inne elementy HTML ofert. <xref:System.Windows.Forms.HtmlElement.Children%2A> Kolekcji udostępnia prosty mechanizm do eksplorowania strukturę drzewa dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> przedstawia tylko elementy, których bezpośrednią lokacją nadrzędną jest bieżącego elementu. Jeśli masz <xref:System.Windows.Forms.HtmlElement> dla `TABLE` elementu <xref:System.Windows.Forms.HtmlElement.Children%2A> spowoduje wyświetlenie wszystkich `TR` elementów (wiersz) wewnątrz `TABLE`. Można pobrać `TD` elementów (komórka) znajdujących się wewnątrz `TR` elementów, należy użyć <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji na poszczególnych osób `TR` elementu lub użyj <xref:System.Windows.Forms.HtmlElement.All%2A> kolekcji na <xref:System.Windows.Forms.HtmlElement>.  
  
 Elementy w tej kolekcji nie musi znajdować się w kolejności źródła.  
  
 Jeśli <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> jest `false`, `Children` zawsze będzie pusta.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy dowolnego dokumentu HTML i pobieraj ciąg opisujący elementów, z wcięciem i numery poziomów używany do określania, jak głęboko zagnieżdżonych elementów w dokumencie. Dzieje się tak, wyszukując `Children` zbiór wszystkich rekursywnie elementów, poczynając od elementu HTML, w górnej części dokumentu. Poniższy przykład kodu wymaga, że Twoja aplikacja ma <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie element z lewego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 Jeśli użytkownik kliknie element, który nie aktualnie ma fokus wejścia, <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń nastąpi po <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń, lecz przed <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzenia dla tego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zakresem obszaru klienckiego elementu w dokumencie HTML.</summary>
        <value>Obszar klienta zajmowany przez element minus dowolny obszar analizowaniem obramowanie i paski przewijania. Aby uzyskać położenie i wymiarów elementu z uwzględnieniem jego zakończeń, użyj <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zamiast tego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> zwróci umieszczanie danych tylko w przypadku elementów, które zostały przypisane jawne wysokość i szerokość lub elementy, które używają pozycjonowanie absolutne. Dokument jest pozycjonowane absolutnie, jeśli jest równa jego styl pozycji `absolute`, po którym go można umieścić w dowolnym współrzędną na stronie HTML.  
  
   
  
## Examples  
 Załóżmy następujące strony HTML zostały załadowane do hostowanego wystąpienia programu <xref:System.Windows.Forms.WebBrowser> kontroli.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 Poniższy przykład kodu demonstruje pobieranie tego elementu i rozszerzania jej wymiarów, jeśli obszaru klienta jest mniejszy niż 400 pikseli szerokości i wysokości 50 pikseli, a także ustawia `DIV` do `contentEditable` stanu, dzięki czemu użytkownik może wprowadzić tekst.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Kodu zarządzanego, który obsługuje zdarzenie.</param>
        <summary>Usuwa procedurę obsługi zdarzeń z zdarzenia nazwanego na HTML Document Object Model (DOM).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlDocument" /> do którego należy ten element.</summary>
        <value>Dokument nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre strony HTML można hostować przy użyciu klatek `FRAMESET` tagów. W tym przypadku poszczególnym `FRAME` element będzie zawierać własne wystąpienie <xref:System.Windows.Forms.HtmlDocument>. Ta właściwość jest najbardziej użyteczna w przypadku, gdy otrzymane odwołanie do elementu w obsłudze zdarzeń z <xref:System.Windows.Forms.HtmlElementEventArgs>i trzeba będzie wykonać inną akcję w dokumencie, w której znajduje się element.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskaźnik niezarządzanego interfejsu dla tego elementu.</summary>
        <value>COM <c>IUnknown</c> interfejsy wskaźnik do elementu, który może być rzutowany na jeden HTML element, takich jak <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> jest otoką dla Internet Explorer modelu DOM (Document Object), które są zapisywane przy użyciu Component Object Model (COM). Jeśli potrzebujesz dostępu do nieujawnionych właściwości lub metody na podstawowych interfejsów COM, takich jak `IHTMLElement`, można użyć tego obiektu, aby wykonać zapytanie dla nich.  
  
 Aby można było używać niezarządzane interfejsy, należy zaimportować biblioteki MSHTML (mshtml.dll) do aplikacji. Jednak można również wykonać nieujawnionych właściwości i metod za pomocą `Invoke` metody.  
  
   
  
## Examples  
 Poniższy przykład kodu używa niezarządzane interfejsy, aby przejąć kontrolę aktualnie zaznaczonego tekstu i przekonwertować go w hiperlink, za pomocą adresu URL wybranego przez użytkownika. Ten kod został zapisany przy założeniu, że formularz ma <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`, i że biblioteki niezarządzanej MSHTML zostały dodane jako odwołanie do projektu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie lewego przycisku myszy nad elementem dwa razy, w krótkim odstępie czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwukrotnie kliknięcie konfiguruje się w ustawieniach myszy w systemie operacyjnym użytkownika. Użytkownik może ustawić czas między kliknięciami myszy, które należy uwzględnić, kliknij dwukrotnie plik, a nie dwóch kliknięć.  
  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciągnie tekstu do różnych lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje, gdy tekst jest przeciągany w następujących lokalizacjach:  
  
-   W ramach lub między strony HTML, hostowana w <xref:System.Windows.Forms.WebBrowser> formantu lub Internet Explorer  
  
-   Do innej aplikacji  
  
-   Na pulpicie Windows  
  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.Drag> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zakończy operację przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik nie jest już przeciąga element nad tym elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.DragLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciągnie tekstu nad elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informację, czy użytkownik może wprowadzić dane do tego elementu.</summary>
        <value>
          <see langword="true" /> Jeśli element zezwala na dane wejściowe użytkownika w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać `FORM` elementy, takie jak pola tekstowe i przyciski radiowe, ustawienie <xref:System.Windows.Forms.HtmlElement.Enabled%2A> do `false` uniemożliwi korzystanie z tych pól formularza użytkownika. Dla innych elementów takich jak `DIV` lub `SPAN`, ustawiając <xref:System.Windows.Forms.HtmlElement.Enabled%2A> do `false` spowoduje, że cały tekst w elemencie do są zacieniowane; jednak tekst nadal będzie możliwe. Aby anulować zaznaczenie, Dodaj program obsługi zdarzeń dla nieujawnionych `onselectstart` zdarzeń za pomocą <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do testowania pod kątem równości.</param>
        <summary>Sprawdza, czy podany obiekt jest taki sam, do bieżącego elementu.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest <see cref="T:System.Windows.Forms.HtmlElement" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera następny element poniżej tego elementu w drzewie dokumentu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentujący pierwszy element spodem bieżącego elementu, w kolejności źródła.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> w połączeniu z <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> do wykonywania drzewie dokumentu do dokumentu HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przełącza fokus wprowadzania użytkownika dla bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawianie fokusu w elemencie zapewnia skupiające elementu i sprawia, że aktywnego elementu; na przykład element, który ma fokus zostaną zwrócone przez <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> właściwość <xref:System.Windows.Forms.HtmlDocument>.  
  
 Wszelkie naciśniętych klawiszy wprowadzonej przez użytkownika po <xref:System.Windows.Forms.HtmlElement.Focus%2A> została wywołana zostanie wysłane do tego elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element najpierw uzyskuje fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element, który był aktywny, zanim użytkownik przełączone do innej aplikacji przy użyciu paska zadań lub klawiszy ALT + TAB otrzyma <xref:System.Windows.Forms.HtmlElement.Focusing> i <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzenia ponownie po użytkownik przejdzie do aplikacji.  
  
 Nie można anulować domyślne zachowanie to zdarzenie. Aby usunąć fokus z elementu, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> na inny element z poziomu <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzeń.  
  
 A <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń w elemencie wystąpi również na nadrzędnych tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu. Ten argument jest rozróżniana wielkość liter.</param>
        <summary>Pobiera wartość atrybutu nazwanego elementu.</summary>
        <returns>Wartość tego atrybutu w elemencie jako <see cref="T:System.String" /> wartość. Jeśli nie ma określonego atrybutu na ten element, zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut w formacie HTML jest jakiejkolwiek parze Nieprawidłowa nazwa/wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement> udostępnia tylko te atrybuty, które są wspólne dla wszystkich elementów, pomijając te, które mają zastosowanie tylko do niektórych rodzajów elementów; `SRC` jest wstępnie zdefiniowany atrybut `IMG` tagu, na przykład, ale nie dla `DIV` tagu. Użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutów nie narażone na zarządzanych modelu DOM (Document Object).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera wszystkie `META` tagów w obrębie kodu HTML dokumentu, przy użyciu <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> można znaleźć `META` tag o nazwie `Description`. Przykład wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nazwa tagu którego <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty chcesz pobrać.</param>
        <summary>Pobiera kolekcję elementów reprezentowane w formacie HTML przez określony <c>HTML</c> tagu.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> Zawierający wszystkie elementy którego <c>HTML</c> nazwa tagu jest równa <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Służy jako funkcji wyznaczania wartości skrótu dla określonego typu.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element otrzymał fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować to zdarzenie domyślne zachowanie, ani uniemożliwić Propagacja. Aby usunąć fokus z elementu, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> na inny element z poziomu <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzeń.  
  
   
  
## Examples  
 Zapisz poniższy kod HTML w pliku, a następnie załadować plik do <xref:System.Windows.Forms.WebBrowser> formantu w projekcie programu Windows Forms.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 Poniższy przykład kodu uniemożliwia następnego `INPUT` elementu w kolejności tabulacji odbieranie fokus wprowadzania użytkownika, jeśli poprzedni element zawiera mniej niż pięć znaków. Przykład wymaga wymienionych wcześniej plik HTML jest ładowany wystąpienie <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia etykietę, za pomocą którego można zidentyfikować element.</summary>
        <value>Unikatowy identyfikator dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> musi być unikatowa. nie może mieć dwa elementy o takiej samej <xref:System.Windows.Forms.HtmlElement.Id%2A> wewnątrz tego samego dokumentu. Użyj <xref:System.Windows.Forms.HtmlElement.Name%2A> właściwość oferowanie tego samego identyfikatora grupy logicznie powiązanych elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod znaczników HTML, poniżej tego elementu.</summary>
        <value>Kod znaczników HTML, który definiuje elementy podrzędne bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje kilka sposobów, aby dodać nowe elementy do istniejącej strony HTML, takich jak <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> i <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> metody. Za pomocą <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> często jest to najszybszy sposób, aby dodać nową zawartość, gdy trzeba ustawić wiele atrybutów lub style w nowych elementów.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> różni się od <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> , <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> nie będzie zawierać kod HTML, który reprezentuje obiekt wywoływany. Zobacz <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> Aby uzyskać więcej informacji na temat różnic między te dwie właściwości.  
  
 Ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> niszczy żadnych elementów podrzędnych, które wcześniej dołączany do elementu. Jeśli odzyskujesz element z modelu DOM, a następnie Przypisz nowy HTML do jego elementów nadrzędnych <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość, której można się odwołać do tego elementu stanie się bezużyteczny i jego zachowanie, gdy wywołuje jej właściwości i metod jest niezdefiniowane.  
  
 Niektórym elementom ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> nie jest prawidłową operacją. Niektóre tagi HTML nie mają takich jak brak taga zamykającego `IMG` oznaczać i dlatego nie może zawierać elementów zagnieżdżonych. Niektóre tagi, takie jak `SCRIPT` tag, może zawierać tylko tekst zawartości; Ustawianie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> spowoduje wystąpienie błędu. Dla obu typów tagów <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> zwróci właściwość `false`. Jednak również nie można ustawić <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> na `TABLE` i `TR` elementów jako przypisywanie źle sformułowane HTML do tych elementów może spowodować uszkodzenie renderowania dokumentu. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub `insertRow` i `insertCell` metod niezarządzaną `IHTMLTable` interfejsu, aby dodać wiersze i komórki do `TABLE`.  
  
 Jeśli należy tylko przypisać tekstu do elementu, a nie kod znaczników HTML, użyj <xref:System.Windows.Forms.HtmlElement.InnerText%2A> właściwości zamiast tego.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zniszcz wszelkie wartości tekstowych zostali już wcześniej przypisani za pomocą <xref:System.Windows.Forms.HtmlElement.InnerText%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tworzenie elementów podrzędnych na ten element nie jest dozwolone.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst przypisany do elementu.</summary>
        <value>Tekst elementu go nie ma żadnych znaczników HTML. Jeśli element zawiera elementy podrzędne, tylko tekst przez te elementy podrzędne zostaną zachowane.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać do elementu za pomocą kodu HTML <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, kod HTML będą wyświetlane jako literały w dokumencie, tak, jakby był wyświetlany HTML w pliku tekstowym. Jeśli przypiszesz HTML do elementu za pomocą <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości <xref:System.Windows.Forms.HtmlElement.InnerText%2A> zwróci cały tekst, HTML, z kodu znaczników usunięte.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.InnerText%2A> zniszcz wszelkie elementy podrzędne, które należą do elementu.  
  
   
  
## Examples  
 Poniższy kod tworzy nową hiperłącza, używając <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>i przypisuje tekstu za pomocą łącza <xref:System.Windows.Forms.HtmlElement.InnerText%2A> właściwości.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Określony element nie może zawierać tekstu (na przykład <c>IMG</c> elementu).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Miejsca do wstawienia tego elementu w odniesieniu do bieżącego elementu.</param>
        <param name="newElement">Nowy element do wstawienia.</param>
        <summary>Wstawianie nowego elementu w modelu DOM (Document Object).</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Który właśnie został wstawiony. Jeśli wstawiania nie powiodła się, spowoduje to zwrócenie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody do momentu <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenie na <xref:System.Windows.Forms.WebBrowser> wystąpił kontroli. Wywołanie tej metody przed tym dniem może spowodować wyjątek, ponieważ dokument nie będzie mieć jeszcze załadowany.  
  
 Czy wartość <xref:System.Windows.Forms.HtmlElementInsertionOrientation> jest prawidłowa będzie zależeć od typu elementu. Na przykład <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> jest prawidłowa, jeśli element jest `DIV`, operacja jest niedostępna, jeśli jest `SCRIPT` lub `IMG` elementu, z których żadna nie może zawierać elementów podrzędnych.  
  
   
  
## Examples  
 Poniższy kod przykładowy wstawia `DIV` element do góry każdej strony, który użytkownicy wyświetlać poza serwerem ADatum.com. Przykład wymaga, że formularz zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`. Przykładu należy również zaimportować obszar nazw <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje metodę unikatowe dla bieżącego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <summary>Wykonuje metodę nieujawnionych bazowego elementu DOM tego elementu.</summary>
        <returns>Element zwracanego przez tę metodę w postaci <see cref="T:System.Object" />. Jeśli ten <see cref="T:System.Object" /> inny element HTML i utworzeniu odwołania do biblioteki niezarządzanej MSHTML dodane do projektu, można go rzutować do jego odpowiedniego interfejsu niezarządzanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wywołania metody z Model obiektu dokumentu (DOM), które nie mają odpowiedniki w kodzie zarządzanym. Użyj tej wersji <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> do wykonania nieujawnionych metody, które nie przyjmują argumentów. Aby uzyskać przykład, zobacz <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <param name="parameter">Lista parametry do przekazania.</param>
        <summary>Wykonuje funkcję zdefiniowaną w bieżącej stronie HTML za pomocą skryptów języka.</summary>
        <returns>Element, który został zwrócony przez funkcję, reprezentowane jako <see cref="T:System.Object" />. Jeśli ten <see cref="T:System.Object" /> inny element HTML i utworzeniu odwołania do biblioteki niezarządzanej MSHTML dodane do projektu, można go rzutować do jego odpowiedniego interfejsu niezarządzanych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wywołania metody z Model obiektu dokumentu (DOM), które nie mają odpowiedniki w kodzie zarządzanym. Wszystkie argumenty dostarczane do <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> zostaną przekonwertowane na Win32 `VARIANT` typów danych przed przekazaniem ich do nazwanych funkcji obsługi skryptów.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład `TABLE` o nazwie `dataTable` i używa nieujawnionych `moveRow` metodę, aby przejść na początek wiersza od końca tabeli.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> występuje przed <xref:System.Windows.Forms.HtmlElement.KeyPress>, które w chwili występuje przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie i zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> występuje po <xref:System.Windows.Forms.HtmlElement.KeyDown> i przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> występuje po <xref:System.Windows.Forms.HtmlElement.KeyPress>, która pojawia się po <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Nie można anulować to zdarzenie.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje po utracie fokusu wprowadzania użytkownika elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.LosingFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.LosingFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element utraciła fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element nie będzie już otrzymywać naciśnięcie klawisza zdarzenia po <xref:System.Windows.Forms.HtmlElement.LostFocus> występuje, dopóki nie otrzymuje fokus ponownie przez użytkownika, wybierając ją na stronie lub za pośrednictwem wywołania aplikacji <xref:System.Windows.Forms.HtmlElement.Focus%2A> metody dla tego elementu.  
  
 Nie można anulować to zdarzenie.  
  
 <xref:System.Windows.Forms.HtmlElement.LostFocus> Zdarzeń w elemencie wystąpi również na nadrzędnych tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik najpierw przesuwa wskaźnik myszy nad bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseEnter> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseEnter> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy zniżki w stosunku do bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy przez element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować to zdarzenie.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kursor myszy przekroczeniu granic elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślnym działaniem <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzenia na element, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń w elemencie wystąpi również na elementy nadrzędne tego elementu, a na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raporty w momencie wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby zgłosić na wiele zdarzeń lub zdarzeń, które często występują, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączane wiadomość w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wkleić go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę elementu.</summary>
        <value>A <see cref="T:System.String" /> reprezentujący nazwę elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.Name%2A> właściwość służąca do pobierania elementów z dokumentu za pomocą <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> metody <xref:System.Windows.Forms.HtmlElement.All%2A> właściwość <xref:System.Windows.Forms.HtmlDocument>.  
  
 Po zastosowaniu do `INPUT` elementów <xref:System.Windows.Forms.HtmlElement.Name%2A> definiuje nazwę zmiennej dla danych tego elementu po przesłaniu jej formularza do serwera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera następny element o tym samym poziomie co tego elementu w drzewie dokumentu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentujący element w prawo bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> w połączeniu z <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> do wykonywania drzewie dokumentu elementu HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element z którego <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> jest obliczana.</summary>
        <value>Element, z którego są obliczane przesunięcie.  
  
Jeśli element nadrzędny lub innego elementu w hierarchii elementu używa pozycjonowanie względna lub bezwzględna <see langword="OffsetParent" /> będzie pierwszego elementu pozycjonowanego względnie lub całkowicie, w którym jest zagnieżdżona bieżącego elementu. Jeśli żaden z elementów powyżej bieżącego elementu są całkowicie lub stosunkowo umieszczone, <see langword="OffsetParent" /> będzie <c>treści</c> tag dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy mogą być umieszczone na stronę HTML w jeden z trzech sposobów: domyślny przepływ pozycjonowanie; położenie względne, w której element jest przesuwane względem jego elementu nadrzędnego; ustaloną wartość i pozycjonowanie absolutne, w którym element otrzymuje stały Współrzędna względem lewego górnego rogu dokumencie.  
  
 Korzystając z elementów dokumentu pozycjonowanie względną lub bezwzględną, możesz użyć `OffsetParent` do obliczania współrzędnych pozycji elementu w obszarze klienta.  
  
 Aby uzyskać więcej informacji na temat elementu strony HTML, zobacz [o pozycjonowanie elementu](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> i <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> różnią się dla `span1`, `span2` i `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizację elementu względem jego elementu nadrzędnego.</summary>
        <value>Współrzędna x i y pozycji elementu, a jego szerokość i wysokość, względem jego elementu nadrzędnego.  
  
Jeśli element nadrzędny jest stosunkowo lub całkowicie umieszczony, <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zwróci przesunięcie elementu nadrzędnego. Jeśli sam element jest pozycjonowane względnie względem jego elementu nadrzędnego <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zostaną zwrócone przesunięcie od jego elementu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy mogą być umieszczone na stronę HTML w jeden z trzech sposobów:  
  
-   Domyślnie, pozycjonowanie przepływu.  
  
-   Położenie względne, w którym element zostanie przesunięty o stałą względem jego elementu nadrzędnego.  
  
-   Pozycjonowanie absolutne, w którym element otrzymuje stały Współrzędna względem lewego górnego rogu dokumencie.  
  
 Aby uzyskać więcej informacji na temat elementu strony HTML, zobacz [o pozycjonowanie elementu](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> i <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> różnią się dla `span1`, `span2` i `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Drugi <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje dwa elementy pod kątem równości.</summary>
        <returns>
          <see langword="true" /> Jeśli oba parametry <see langword="null" />, lub jeśli oba te elementy mają tego samego powiązanego interfejsu COM; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Testy operatora równości `IUnknown` wskaźniki obiektów COM opakowane przez podane <xref:System.Windows.Forms.HtmlElement> klasy.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Drugi <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje dwa <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty pod kątem nierówności.</summary>
        <returns>
          <see langword="true" /> jest to tylko jeden element <see langword="null" />, lub dwa obiekty nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Równoważne metodę dla tego operatora jest negację <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący element kodu HTML.</summary>
        <value>Kod HTML dla bieżącego elementu i jego elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Natomiast <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> będzie zwracać wszystkie HTML zawarte w bieżącego elementu, bieżącego elementu otaczającego tagów, z wyjątkiem <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> zawiera tag bieżącego elementu, a także kodu HTML zawierający tag, na przykład:  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 W tym przykładzie wywołanie <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> na `div2` zwróci:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Wywoływanie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zwróci:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Jeśli przypiszesz nowe wartości do <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>bieżącego odwołanie do elementu staną się nieprawidłowe; nie będzie odzwierciedlał nazwę, właściwości i podrzędny zawartość HTML po prostu przypisano.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst bieżącego elementu.</summary>
        <value>Tekst wewnątrz bieżącego elementu i jego elementy podrzędne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać do elementu za pomocą kodu HTML <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, kod HTML będą wyświetlane jako literały w dokumencie, tak, jakby był wyświetlany HTML w pliku tekstowym. Jeśli przypiszesz HTML do elementu za pomocą <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości <xref:System.Windows.Forms.HtmlElement.OuterText%2A> zwróci cały tekst, HTML, z kodu znaczników usunięte.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.OuterText%2A> zniszcz wszelkie elementy podrzędne, które należą do elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można ustawić tekst poza ten element.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny bieżącego elementu.</summary>
        <value>Element powyżej bieżącego elementu w hierarchii dokumentu HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość umożliwia odnajdowanie kontekst elementu. Jest najbardziej użyteczna wewnątrz procedury obsługi zdarzeń takich jak <xref:System.Windows.Forms.HtmlElement.Click>, które mogą wyzwalać dla każdego elementu w dowolnym miejscu hierarchii obiektów dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość elementu HTML (u góry dokumentu HTML) odwołuje się do samego. Jeśli wywołasz <xref:System.Windows.Forms.HtmlElement.Parent%2A> wewnątrz pętli, sprawdź, czy zapętlenie podziału porównuje typ bieżącego elementu i typ `Parent` właściwości; w przeciwnym razie kod może zostać wykonany wejścia w nieskończoną pętlę.  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia znalezienie wszystkich `IMG` tagów w dokumencie i używa <xref:System.Windows.Forms.HtmlElement.Parent%2A> właściwość do badania czy `IMG` jest hiperłącza do innej strony; Jeśli tak jest, kod przypisuje adres URL `ALT` atrybut `IMG`tag, dzięki czemu użytkownicy mogą myszą obraz, aby zobaczyć, gdzie potrwa je.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, aby wywołać.</param>
        <summary>Powoduje, że zdarzenia nazwanego do wywołania wszystkich procedur obsługi zdarzeń zarejestrowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana, aby uzyskać dostęp do zdarzeń HTML Document Object Model (DOM). Bezpośrednio wywołuje [IHTMLElement3::fireEvent](http://go.microsoft.com/fwlink/?LinkId=103189) metody. Aby uzyskać więcej informacji o sposobie używania modelu DOM przy użyciu <xref:System.Windows.Forms.HtmlElement> klasy, zobacz [uzyskiwania dostępu do nieujawnionych elementów w zarządzanych HTML Document Object Model](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa skoncentrować się od bieżącego elementu, jeśli ten element jest ustawiony fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zgłasza <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń dla elementu.  
  
 Gdy fokus jest wyczyszczone z elementu przy użyciu tej metody, biorąc pod uwagę do dokumentu zawierającego element, a nie do następnego elementu w kolejności tabulacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Jeśli <see langword="true" />, górnej krawędzi obiektu będą wyświetlane w górnej części okna. Jeśli <see langword="false" />, dół obiektu będą wyświetlane w dolnej części okna.</param>
        <summary>Przewija dokumentu zawierającego ten element, do momentu górną lub dolną krawędź ten element jest powiązana z okna dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod wyszukuje element według nazwy i przewija strony, czemu początku elementu jest powiązana z górnej części strony widoczny.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między lewą krawędzią jej zawartość krawędzi elementu.</summary>
        <value>Odległość w pikselach, między lewą krawędzią elementu i lewą krawędzią jej zawartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełne wymiary obszar przewijania są dostępne za pośrednictwem <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` i <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> niezależnie są widoczne, ponieważ są one tylko dwie właściwości obszar przewijania, które deweloperzy mogą ustawić.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymiary elementu przewijany regionu.</summary>
        <value>Rozmiar i współrzędnych lokalizacji przewijanym obszarze elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element będzie mieć przewijany region jeśli jego zawartość jest większy niż jej wymiarów, chyba że styl przepełnienie w elemencie zabrania renderowania paski przewijania.  
  
 Nie można zmodyfikować rozmiaru obszaru przewijania bezpośrednio, ale można zmodyfikować odległość między krawędziami obszar przewijania krawędzi elementu. Użyj <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> i <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> właściwości, aby to osiągnąć.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między górną krawędzią jej zawartość krawędzi elementu.</summary>
        <value>Odległość w pikselach, między górną krawędzią elementu a górną krawędzią jej zawartość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełne wymiary obszar przewijania są dostępne za pośrednictwem <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> i `ScrollTop` niezależnie są widoczne, ponieważ są one tylko dwie właściwości obszar przewijania, które deweloperzy mogą ustawić.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu, aby ustawić.</param>
        <param name="value">Nowa wartość tego atrybutu.</param>
        <summary>Ustawia wartość atrybutu nazwanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut w formacie HTML jest dowolnym prawidłowej pary nazwa wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement> udostępnia tylko te atrybuty, które są wspólne dla wszystkich elementów, pomijając te, które mają zastosowanie tylko do niektórych rodzajów elementów; `SRC` jest wstępnie zdefiniowany atrybut `IMG` tagu, na przykład, ale nie dla `DIV` tagu. Użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutów nie narażone na zarządzanych modelu DOM (Document Object).  
  
 Jeśli `attributeName` nie jest atrybutem zdefiniowanych w elemencie <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> określi ją na element jako nowy atrybut.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> jest rozróżniana wielkość liter.  
  
 Aby ustawić `class` atrybutu na <xref:System.Windows.Forms.HtmlElement> , musi odwoływać się do atrybutu jako `className` podczas określania pierwszy argument funkcji <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nowy `IMG` element do bieżącego dokumentu, za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> można ustawić `SRC` atrybutu dla obrazu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozdzieloną średnikami listę style dla bieżącego elementu.</summary>
        <value>Ciąg zawierający wszystkie style elementu</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML Document Object Model (DOM) używa style zgodnie z definicją w specyfikacji konsorcjum World Wide Web kaskadowe arkusze stylów do sterowania wyświetlaniem elementu. Style w <xref:System.Windows.Forms.HtmlElement.Style%2A> właściwość formę rozdzielonych średnikami z pary nazwa wartość z każdej pary, rozdzielając je średnikiem, w następujący sposób:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Aby ustawić czcionkę `DIV` elementu do 14 punktów podzbiory pogrubienia, na przykład, można przypisać następujące parametry:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Aby uzyskać pełną listę wszystkich dostępnych stylów w modelu DOM HTML, zobacz [atrybut stylu](http://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację tego elementu w kolejności tabulacji.</summary>
        <value>Indeksu liczbowego elementu w kolejności tabulacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> Określa, który element w dokumencie HTML następnie przenieść fokus, gdy użytkownik naciśnie klawisz TAB. Domyślnie są tylko elementy zawarte w kolejności tabulacji `INPUT` elementów `SELECT` kontroli i dowolnego elementu którego `contentEditable` właściwość jest ustawiona na `true`. Może zawierać dowolnego elementu HTML w kolejności tabulacji, takich jak `DIV`, przypisując go jawnie <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>.  
  
 Prawidłowe wartości dla <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> z zakresu od-32767 do 32767.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tagu HTML.</summary>
        <value>Nazwa używana do tworzenia tego elementu przy użyciu znaczników HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów w formacie HTML Document Object Model ma atrybuty, właściwości i metody, które są unikatowe dla tych elementów; takie jak `HREF` atrybutu na `A` elementu, lub `Submit` metody `FORM`. Użyj <xref:System.Windows.Forms.HtmlElement.TagName%2A> po użytkownik elementu potencjalnie dowolnego typu które potrzebują do wykonania operacji specyficznych dla typu.  
  
   
  
## Examples  
 Poniższy przykład kodu umożliwia znalezienie wszystkich `IMG` tagów w dokumencie i używa `TagName` właściwość do badania czy `IMG` jest hiperłącza do innej strony; Jeśli tak jest, kod przypisuje adres URL `ALT` atrybut `IMG`tag, dzięki czemu użytkownicy mogą myszą obraz, aby zobaczyć, gdzie potrwa je.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
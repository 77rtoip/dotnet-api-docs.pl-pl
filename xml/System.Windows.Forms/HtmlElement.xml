<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a86d3c0b0580ad13ab92f6f2399771049ddd054c" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452388" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje element HTML wewnątrz strony sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> reprezentuje dowolny możliwe typ elementu w dokumencie HTML, takie jak `BODY`, `TABLE`, i `FORM`, między innymi. Klasa przedstawia najbardziej typowe właściwości, których można oczekiwać, że można znaleźć na wszystkie elementy.  
  
 Większość elementów może mieć *elementy podrzędne*: innych elementów HTML, które znajdują się poniżej. Użyj <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> właściwości, aby sprawdzić, czy dany element ma elementów podrzędnych oraz <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji do iterowania po nich. <xref:System.Windows.Forms.HtmlElement.Parent%2A> Zwraca <xref:System.Windows.Forms.HtmlElement> w jest zagnieżdżony bieżącego elementu.  
  
 Często wymagają dostępu do atrybutów, właściwości i metody w elemencie podstawowych, które nie są bezpośrednio widoczne przez <xref:System.Windows.Forms.HtmlElement>, takich jak `SRC` atrybutu `IMG` element lub `Submit` metoda `FORM`. <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> metody umożliwiają pobieranie i zmiany dowolnego atrybutu lub właściwości w elemencie określonych podczas <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> zapewnia dostęp do dowolnej metody, nie ujawnione w zarządzanych modelu DOM (Document Object). Jeśli aplikacja ma niezarządzane uprawnień kodu, można także przejść nieujawnionych właściwości i metody o <xref:System.Windows.Forms.HtmlElement.DomElement%2A> atrybutu.  
  
 Użyj <xref:System.Windows.Forms.HtmlElement.TagName%2A> właściwości, aby sprawdzić, czy element jest określonego typu.  
  
 Każdy dokument HTML może być modyfikowany w czasie wykonywania. Można utworzyć nowego <xref:System.Windows.Forms.HtmlElement> obiekty z <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody <xref:System.Windows.Forms.HtmlDocument>i dodaj je do innego elementu przy użyciu <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> metody. Można również tworzyć elementy jako tagi HTML i przypisać je do istniejącego elementu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia sposób badania dowolnego dokumentu HTML i pochodzić ciąg opisujący elementy HTML, wcięcia i numery poziomów używany do określania, jak głęboko zagnieżdżone elementy w dokumencie. W tym przykładzie kodu wymaga, aby hosty aplikacji <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElementCollection" /> wszystkie elementy podrzędne bieżącego elementu.</summary>
        <value>Kolekcja wszystkich elementów, które są bezpośrednio lub pośrednio elementy podrzędne bieżącego elementu. Jeśli bieżący element jest <c>tabeli</c>, na przykład <see cref="P:System.Windows.Forms.HtmlElement.All" /> zwróci co <c>TH</c>, <c>TR</c>, i <c>TD</c> element w tabeli oraz jak wszystkie inne elementy, takie jak <c>DIV</c> i <c>zakres</c> zawartym w elemencie komórki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dostęp tylko tych elementów, które mają bieżącego elementu jako ich bezpośrednio nadrzędnej, należy użyć <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji zamiast tego.  
  
 Elementów w tej kolekcji nie będzie musi być zwracane w kolejności źródeł.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">
          <see cref="T:System.Windows.Forms.HtmlElement" /> Do dołączenia do tej lokalizacji w drzewie.</param>
        <summary>Dodaje element do innego elementu poddrzewa.</summary>
        <returns>Element po dodaniu do drzewa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML modelu DOM (Document Object) można zmienić zawartość czasu wykonywania pliku HTML na kilka sposobów. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Dodawanie nowych elementów do istniejącego dokumentu lub Przenieś element na stronie.  
  
 Jeśli element już został elementem nadrzędnym, dołączanie elementu do innego elementu spowoduje automatyczne usunięcie elementu z poprzednich nadrzędnej.  
  
 Wszystkie dodatki do dokumentu w czasie wykonywania za pomocą <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> nie zostaną utrwalone po wywołaniu <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> metoda <xref:System.Windows.Forms.WebBrowser> formantu.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy przy użyciu hyperlink <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> — metoda i dodaje go do końca, używając strony `AppendChild` na `BODY` elementu. Przykład wymaga aplikacja zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Zarządzany kod obsługujący zdarzenia.</param>
        <summary>Dodaje program obsługi zdarzeń dla zdarzenia o nazwie na HTML modelu DOM (Document Object).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzane modelu DOM (Document Object) udostępnia wybierz liczbę zdarzeń. Większość nieujawnionych zdarzeń jest zdefiniowana tylko dla określonych typów elementów; takie jak `submit` zdarzenie, które jest prawidłowa tylko dla `FORM` elementów. Użyj <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> można dodać obsługi zdarzeń do nieujawnionych dotyczących tych zdarzeń.  
  
 Nie należy dołączyć zdarzenia do dokumentu lub jednego ze swoich obiektów aż do zakończenia ładowania dokumentu. Najwcześniejsza powinny wywoływać tej metody jest <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenie <xref:System.Windows.Forms.WebBrowser> formantu.  
  
 Aby uzyskać więcej informacji o dostępnych zdarzeń niezarządzane, zobacz [podczas uzyskiwania dostępu do nieujawnionych elementów w modelu obiektów zarządzanych dokumentów HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) i interfejsy IHTMLElement: [IHTMLElement](http://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](http://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](http://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](http://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element może mieć elementów podrzędnych.</summary>
        <value>
          <see langword="true" /> Jeśli element może mieć elementów podrzędnych; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre elementy, takie jak `IMG` i `SCRIPT`, nie może mieć żadnych elementów podrzędnych. Przed wywołaniem tej właściwości należy użyć <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> dla dowolnego elementu.  
  
   
  
## Examples  
 Poniższy kod uchwytów przykład <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia <xref:System.Windows.Forms.HtmlDocument>. Jeśli element nie poprzedniej wybranych za pomocą kliknięcia myszą, kod przypisuje element do zmiennej prywatnej klasy o nazwie `MoveElement`. Jeśli wybrano element, kod próbuje dołączyć do elementu, który właśnie został kliknięty. W tym przykładzie kodu wymaga, aby hosty aplikacji <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`, oraz że masz już dodany program obsługi zdarzeń dla <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia <xref:System.Windows.Forms.HtmlDocument>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlElementCollection" /> z wszystkie elementy podrzędne bieżącego elementu.</summary>
        <value>Kolekcja wszystkich <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów, które mają bieżącego elementu jako elementu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów wewnątrz pliku HTML może mieć inne elementy HTML poniżej. <xref:System.Windows.Forms.HtmlElement.Children%2A> Kolekcji udostępnia prosty mechanizm do eksplorowania struktury drzewa dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> przedstawia tylko elementów, których bezpośrednią lokacją nadrzędną jest bieżącego elementu. Jeśli masz <xref:System.Windows.Forms.HtmlElement> dla `TABLE` elementu <xref:System.Windows.Forms.HtmlElement.Children%2A> spowoduje wyświetlenie wszystkich `TR` elementy (wiersz) wewnątrz `TABLE`. Można pobrać `TD` elementów (komórka) zawartych wewnątrz `TR` elementów, należy użyć <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji na poszczególnych `TR` elementu, lub użyj <xref:System.Windows.Forms.HtmlElement.All%2A> kolekcji na <xref:System.Windows.Forms.HtmlElement>.  
  
 Źródło kolejność elementów w tej kolekcji nie ma gwarancji.  
  
 Jeśli <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> jest `false`, `Children` zawsze będzie pusty.  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza dowolnego dokumentu HTML i pochodzić ciąg opisujący elementy, wcięcia i numery poziomów używany do określania, jak głęboko zagnieżdżone elementy w dokumencie. Robi to przez wyszukiwanie `Children` Kolekcja wszystkich elementów rekursywnie, począwszy od elementu HTML w górnej części dokumentu. W tym przykładzie kodu wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie element z lewego przycisku myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 Gdy użytkownik kliknie na element, który nie aktualnie ma wprowadzono fokus, <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń zostanie przeprowadzona po <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń, ale przed wysłaniem <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzenia dla tego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Click> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera granice obszaru klienckiego elementu w dokumencie HTML.</summary>
        <value>Obszaru klienckiego zajmowane przez element minus każdy obszar podjęte przez granice i paski przewijania. Aby uzyskać położenie i wymiarów elementu łącznie z jego skojarzenia, należy użyć <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zamiast tego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> zwróci pozycji danych tylko dla elementów, które zostały przypisane jawne wysokość i szerokość lub elementy korzystające z bezwzględny. Dokument jest bezwzględnego, jeśli ustawiono jego styl pozycji `absolute`, po którym on może być umieszczony żadnych współrzędną na stronie HTML.  
  
   
  
## Examples  
 Załóżmy następujące strony HTML zostały załadowane do hostowanej wystąpienia <xref:System.Windows.Forms.WebBrowser> formantu.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 Poniższy przykład kodu pokazuje podczas pobierania tego elementu i rozszerzanie jej wymiarów, jeśli obszaru klienta jest mniejszy niż szerokości 400 pikseli 50 pikseli, a także ustawia `DIV` do `contentEditable` stanu, dzięki czemu użytkownik może wprowadzić tekst.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które mają być obsługiwane.</param>
        <param name="eventHandler">Zarządzany kod obsługujący zdarzenia.</param>
        <summary>Usuwa program obsługi zdarzeń z nazwanego zdarzenia w formacie HTML modelu DOM (Document Object).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera <see cref="T:System.Windows.Forms.HtmlDocument" /> do której należy ten element.</summary>
        <value>Dokument nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre strony HTML może obsługiwać ramki za pomocą `FRAMESET` tagów. W tym przypadku poszczególnych `FRAME` element będzie zawierać własne wystąpienie <xref:System.Windows.Forms.HtmlDocument>. Ta właściwość jest najbardziej przydatna, gdy otrzymano w obsłudze zdarzeń z odwołaniem do elementu <xref:System.Windows.Forms.HtmlElementEventArgs>i konieczne jest wykonanie pewnych działań w dokumencie, w której znajduje się element.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wskaźnika interfejsu niezarządzane dla tego elementu.</summary>
        <value>COM <c>IUnknown</c> interfejsy wskaźnika do elementu, który można rzutować na jeden HTML element, takie jak <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> jest otokę dla Internet Explorer modelu DOM (Document Object), które zostały utworzone za pomocą modelu obiektów składników (COM). Jeśli potrzebujesz dostępu do nieujawnionych właściwości lub metody podstawowej interfejsy modelu COM, takich jak `IHTMLElement`, można użyć tego obiektu na zapytania dla nich.  
  
 Aby można było używać niezarządzane interfejsy, należy zaimportować biblioteki MSHTML (mshtml.dll) do aplikacji. Jednak możesz również wykonać nieujawnionych właściwości i metody, przy użyciu `Invoke` metody.  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje interfejsy niezarządzane wziąć aktualnie zaznaczonego tekstu i przekonwertować go jako hiperłącza, z adresem URL wybierany przez użytkownika. Ten kod został zapisany z założeniem formularz zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`, oraz że dodano niezarządzanej bibliotece MSHTML jako odwołanie do projektu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie lewego przycisku myszy nad elementem dwukrotnie w krótkim przedziale czasu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwukrotnie kliknięcie konfiguruje się w ustawieniach myszy w systemie operacyjnym użytkownika. Użytkownik może ustawić czas od kliknięcia przycisku myszy, który powinien być uznawany za dwukrotne zamiast dwóch kliknięć.  
  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciąga tekstu do różnych lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje, gdy tekst zostanie przeciągnięty w następujących lokalizacjach:  
  
-   W ramach lub między stron HTML znajdujących się w <xref:System.Windows.Forms.WebBrowser> kontroli lub program Internet Explorer  
  
-   Do innej aplikacji  
  
-   Na pulpicie systemu Windows  
  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.Drag> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Drag> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zakończy operację przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik nie jest już przeciąga element nad tym elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.DragLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciąga tekst nad elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia, czy użytkownik może wprowadzić dane do tego elementu.</summary>
        <value>
          <see langword="true" /> Jeśli element zezwala na dane wejściowe użytkownika; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać `FORM` elementów, takich jak pola tekstowe i przyciski radiowe, ustawienie <xref:System.Windows.Forms.HtmlElement.Enabled%2A> do `false` uniemożliwi użytkownika przy użyciu tych pól formularza. Dla innych elementów takich jak `DIV` lub `SPAN`, ustawienie <xref:System.Windows.Forms.HtmlElement.Enabled%2A> do `false` spowoduje, że cały tekst w elemencie się pojawiać przyciemnione; jednak tekst nadal będzie można wybrać. Aby anulować wybór, Dodaj program obsługi zdarzeń dla nieujawnionych `onselectstart` zdarzeń przy użyciu <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> metody.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do testowania pod kątem równości.</param>
        <summary>Testy, jeśli podany obiekt jest taki sam, jak bieżący element.</summary>
        <returns>
          <see langword="true" /> Jeśli <paramref name="obj" /> jest <see cref="T:System.Windows.Forms.HtmlElement" />; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element dalej poniżej tego elementu w drzewie dokumentu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentujący pierwszy element zawarte poniżej bieżącego elementu, w kolejności źródeł.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> w połączeniu z <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> przeprowadzenie drzewa dokumentu dla dokumentu HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umieszcza fokus wprowadzania użytkownika dla bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawianie fokusu na elemencie zarówno przenosi fokus tego elementu i ułatwia aktywnego elementu; na przykład element, który ma fokus zostaną zwrócone przez <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> właściwość <xref:System.Windows.Forms.HtmlDocument>.  
  
 Wszelkie naciśniętych klawiszy wprowadzonej przez użytkownika po <xref:System.Windows.Forms.HtmlElement.Focus%2A> została wywołana zostanie wysłane do tego elementu.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element najpierw zyska fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element, który był aktywny przed przełączona do innej aplikacji przy użyciu paska zadań lub klawiszy ALT + TAB, użytkownik otrzyma <xref:System.Windows.Forms.HtmlElement.Focusing> i <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzenia ponownie gdy użytkownik zmienia powrót do aplikacji.  
  
 Nie można anulować domyślne zachowanie to zdarzenie. Aby usunąć element fokus, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> na inny element z poziomu <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzeń.  
  
 A <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzenia na element występuje również w nadrzędnych tego elementu i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu. Ten argument jest rozróżniana wielkość liter.</param>
        <summary>Pobiera wartość atrybutu nazwanego elementu.</summary>
        <returns>Wartość tego atrybutu w elemencie jako <see cref="T:System.String" /> wartość. Jeśli określony atrybut nie istnieje w tym elemencie, zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut HTML jest jakiejkolwiek parze Nieprawidłowa nazwa/wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement> przedstawia tylko atrybuty, które są wspólne dla wszystkich elementów, pomijając te, które mają zastosowanie tylko do niektórych typów elementów; `SRC` jest wstępnie zdefiniowanych atrybutów dla `IMG` tagu, na przykład, ale nie dla `DIV` tagu. Użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutów nie widoczne na zarządzanych modelu DOM (Document Object).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> jest rozróżniana wielkość liter.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera wszystkie `META` tagów w pliku HTML dokumentu za pomocą <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> można znaleźć `META` tag o nazwie `Description`. Przykład wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nazwa tagu którego <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty chcesz pobrać.</param>
        <summary>Pobiera kolekcję elementów reprezentowane w formacie HTML w określonym <c>HTML</c> tagu.</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> Zawierający wszystkie elementy których <c>HTML</c> nazwa tagu jest równa <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pełni rolę funkcji skrótu dla określonego typu.</summary>
        <returns>Wartość skrótu dla bieżącego <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element otrzymał fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować to zdarzenie domyślne zachowanie, ani zapobiec wystąpieniu. Aby usunąć element fokus, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> na inny element z poziomu <xref:System.Windows.Forms.HtmlElement.GotFocus> zdarzeń.  
  
   
  
## Examples  
 Zapisz do pliku następujący kod HTML i załadować pliku <xref:System.Windows.Forms.WebBrowser> formantu w projekcie formularzy systemu Windows.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 Poniższy przykład kodu uniemożliwia następnej `INPUT` elementu w kolejności tabulacji odbieranie fokus wprowadzania użytkownika, jeśli poprzedni element zawiera mniej niż pięć znaków. Przykład wymaga, aby wymienione wcześniej plik HTML jest ładowany do wystąpienia <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia etykietę, o którą należy zidentyfikować elementu.</summary>
        <value>Unikatowy identyfikator dla elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> musi być unikatowa. nie może mieć dwóch elementów o takiej samej <xref:System.Windows.Forms.HtmlElement.Id%2A> wewnątrz tego samego dokumentu. Użyj <xref:System.Windows.Forms.HtmlElement.Name%2A> właściwości zapewnienie tego samego identyfikatora grupy logicznie powiązanych elementów.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod znaczników HTML pod tym elementem.</summary>
        <value>Kod znaczników HTML, który definiuje elementy podrzędne bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje kilka sposobów, takie jak dodawanie nowych elementów do istniejącej strony HTML, <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> i <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> metody. Przy użyciu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> często jest to najszybszy sposób, aby dodać nową zawartość, gdy trzeba ustawić wiele atrybutów lub style dla nowych elementów.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> różni się od <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> w tym <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> nie będzie zawierać kod HTML, który reprezentuje obiekt wywoływany. Zobacz <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> Aby uzyskać więcej informacji na temat różnic między te dwie właściwości.  
  
 Ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> niszczy podrzędnych wcześniej dołączone do elementu. Jeśli pobieranie elementu z modelu DOM, a następnie przypisz nowe HTML do jego elementów nadrzędnych <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość, odwołania do elementu stanie się bezużyteczny i jego zachowanie, gdy wywołuje jego właściwości i metody jest niezdefiniowana.  
  
 Niektórym elementom ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> nie jest prawidłową operacją. Niektóre tagi HTML ma tagu zamykającego, takich jak `IMG` tagu i dlatego nie może zawierać elementów zagnieżdżonych. Niektóre tagi, takie jak `SCRIPT` tagów, może zawierać tylko tekst zawartości; ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> spowoduje błąd. Dla obu typów znaczników <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> właściwość, którą będzie zwracać `false`. Jednak także nie można ustawić <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> na `TABLE` i `TR` elementów, jak przypisywanie źle sformułowane HTML do tych elementów może spowodować uszkodzenie renderowania dokumentu. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub `insertRow` i `insertCell` metody niezarządzanej `IHTMLTable` interfejsu, aby dodać wierszy i komórek do `TABLE`.  
  
 Jeśli tylko należy przypisać tekstu do elementu i nie kod znaczników HTML, użyj <xref:System.Windows.Forms.HtmlElement.InnerText%2A> właściwości zamiast tego.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zniszczy wszystkie wartości tekstowe uprzednio przypisane przy użyciu <xref:System.Windows.Forms.HtmlElement.InnerText%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tworzenie elementów podrzędnych w tym elemencie nie jest dozwolone.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst przypisany do elementu.</summary>
        <value>Tekst elementu go nie ma żadnych znaczników HTML. Jeśli element zawiera elementy podrzędne, zostanie zachowany tylko tekst w tych elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać HTML do elementu z <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, kod HTML będą wyświetlane jako literały w dokumencie, tak jak gdyby była wyświetlana HTML w pliku tekstowym. Po przypisaniu HTML przy użyciu elementu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość <xref:System.Windows.Forms.HtmlElement.InnerText%2A> zwróci cały tekst, w tym usunąć HTML przy użyciu znaczników.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.InnerText%2A> zniszczy wszystkie elementy podrzędne, które należą do elementu.  
  
   
  
## Examples  
 Poniższy kod tworzy nowy przy użyciu hyperlink <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>i przypisuje tekstu przy użyciu łącza <xref:System.Windows.Forms.HtmlElement.InnerText%2A> właściwości.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Określony element nie może zawierać tekstu (na przykład <c>IMG</c> elementu).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Miejsca do wstawienia tego elementu w stosunku do bieżącego elementu.</param>
        <param name="newElement">Nowy element do wstawienia.</param>
        <summary>Wstawianie nowego elementu do modelu DOM (Document Object).</summary>
        <returns>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Która właśnie została umieszczona. Jeśli wstawienie zakończyło się niepowodzeniem, spowoduje to zwrócenie <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody do momentu po <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> zdarzenia w <xref:System.Windows.Forms.WebBrowser> wystąpił formantu. Wywołanie tej metody przed upływem może spowodować wyjątek, jak dokument nie będzie mieć jeszcze załadowany.  
  
 Czy wartość <xref:System.Windows.Forms.HtmlElementInsertionOrientation> jest prawidłowa zależy od typu elementu. Na przykład <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> jest prawidłowa, jeśli element jest `DIV`, ale nie, jeśli jest `SCRIPT` lub `IMG` elementów, które mogą zawierać elementy podrzędne.  
  
   
  
## Examples  
 Poniższy kod przykładowy wstawia `DIV` element na początku każdej stronie, które użytkownicy będą wyświetlać poza serwerem ADatum.com. Przykład wymaga, aby formularz zawiera <xref:System.Windows.Forms.WebBrowser> formantu o nazwie `WebBrowser1`. Przykład należy również zaimportować przestrzeń nazw <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje metodę unikatowe dla bieżącego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <summary>Wykonuje metodę nieujawnionych na odpowiedniego elementu DOM tego elementu.</summary>
        <returns>Element zwracane przez tę metodę reprezentowane jako <see cref="T:System.Object" />. Jeśli ten <see cref="T:System.Object" /> inny element HTML i zawierają odwołanie do biblioteki MSHTML niezarządzane dodane do projektu, można rzutować go do odpowiedniego interfejsu niezarządzane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywoływać metod z modelu DOM (Document Object) bez ich odpowiedniki w kodzie zarządzanym. Użyj tej wersji <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> wykonać nieujawnionych metod, które nie przyjmują argumentów. Na przykład zobacz <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <param name="parameter">Lista parametry do przekazania.</param>
        <summary>Wykonuje funkcji zdefiniowanej w bieżącej strony HTML przez język skryptów.</summary>
        <returns>Element zwracane przez funkcję, reprezentowane jako <see cref="T:System.Object" />. Jeśli ten <see cref="T:System.Object" /> inny element HTML i zawierają odwołanie do biblioteki MSHTML niezarządzane dodane do projektu, można rzutować go do odpowiedniego interfejsu niezarządzane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tę metodę można wywoływać metod z modelu DOM (Document Object) bez ich odpowiedniki w kodzie zarządzanym. Wszystkie argumenty dostarczony do <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> zostanie przekonwertowany na Win32 `VARIANT` typy danych, zanim zostaną one przekazane do nazwanego funkcji obsługi skryptów.  
  
   
  
## Examples  
 Poniższy kod pobiera przykład `TABLE` o nazwie `dataTable` i używa nieujawnionych `moveRow` metodę, aby przejść na początek wiersza od końca tabeli.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> występuje przed <xref:System.Windows.Forms.HtmlElement.KeyPress>, który włącza występuje przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie i zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> występuje po <xref:System.Windows.Forms.HtmlElement.KeyDown> i przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> występuje po <xref:System.Windows.Forms.HtmlElement.KeyPress>, co ma miejsce po <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Nie można anulować to zdarzenie.  
  
 A <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element jest utraci fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.LosingFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.LosingFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element utraciła fokus wprowadzania użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element nie będziesz już otrzymywać zdarzeń naciśnięcie klawisza po <xref:System.Windows.Forms.HtmlElement.LostFocus> występuje do momentu jego otrzymuje fokus ponownie przez użytkownika, zaznaczając go na stronie lub wywołania aplikacji <xref:System.Windows.Forms.HtmlElement.Focus%2A> metody w tym elemencie.  
  
 Nie można anulować to zdarzenie.  
  
 <xref:System.Windows.Forms.HtmlElement.LostFocus> Zdarzenia na element występuje również w nadrzędnych tego elementu i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik najpierw przesuwa kursor myszy nad bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseEnter> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseEnter> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy wylogowuje bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseLeave> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseLeave> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy przez element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować to zdarzenie.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wskaźnik myszy przekroczeniu granic elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Domyślnym działaniem można anulować <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń dla elementu, ustawiając <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
 A <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzenia na element występuje również w przypadku tego elementu nadrzędnego elementów i na <xref:System.Windows.Forms.HtmlDocument> klasy, chyba że ustawisz <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy do `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportów w przypadku wystąpienia <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń. Ten raport pomaga, aby dowiedzieć się, gdy zdarzenie występuje i mogą pomóc w debugowaniu. Aby raport wiele zdarzeń lub zdarzeń, które występuje często, rozważ zastąpienie <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> z <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączanie wiadomości w wielowierszowym <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu, który zawiera wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie `HtmlElement1`. Następnie upewnij się, że program obsługi zdarzeń jest skojarzony z <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzeń.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę elementu.</summary>
        <value>A <see cref="T:System.String" /> reprezentujący nazwę elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.Name%2A> właściwości można pobrać elementów z dokumentu za pomocą <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> metoda <xref:System.Windows.Forms.HtmlElement.All%2A> właściwość <xref:System.Windows.Forms.HtmlDocument>.  
  
 Gdy jest stosowany do `INPUT` elementów <xref:System.Windows.Forms.HtmlElement.Name%2A> definiuje nazwę zmiennej dla tego elementu danych po przesłaniu jej formularza do serwera.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera następnego elementu na tym samym poziomie jako tego elementu w drzewie dokumentu.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentujący element w prawo bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> w połączeniu z <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> przeprowadzenie drzewo dokumentu dla elementu HTML.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, z którego <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> jest obliczana.</summary>
        <value>Element, z którego mają być obliczane przesunięcia.  Jeśli element nadrzędny lub innego elementu w hierarchii elementu używa pozycjonowanie względną lub bezwzględną, <see langword="OffsetParent" /> będzie pierwszy element względnie lub absolutnie pozycjonowane, w którym jest zagnieżdżony bieżącego elementu. Jeśli żaden z elementów powyżej bieżącego elementu są absolutnie lub stosunkowo, <see langword="OffsetParent" /> będzie <c>treści</c> tag dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy mogą znajdować się na stronie HTML w jeden z trzech sposobów: domyślny przepływ pozycjonowanie; względne położenie, w którym element zostanie przesunięty o stałą względem jego elementu nadrzędnego; i położenia bezwzględne, w którym element znajduje się określony Współrzędna względem lewego górnego rogu dokumentu.  
  
 Korzystając z elementów dokumentu pozycjonowanie względną lub bezwzględną, można użyć `OffsetParent` do obliczania pozycji współrzędnych elementu w obszarze klienckim.  
  
 Aby uzyskać więcej informacji o elemencie strony HTML, zobacz [o pozycjonowanie elementu](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> i <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> różnią się w przypadku `span1`, `span2` i `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizację elementu względem jego elementu nadrzędnego.</summary>
        <value>Współrzędna x i y położenia elementu i jego szerokość i wysokość, względem jego elementu nadrzędnego.  Jeśli element nadrzędny jest stosunkowo lub absolutnie, <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zwróci przesunięcie elementu nadrzędnego. Jeśli stosunkowo znajduje samego elementu względem jego elementu nadrzędnego <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zwróci przesunięcie od jego elementu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy mogą znajdować się na stronie HTML w jeden z trzech sposobów:  
  
-   Domyślny przepływ rozmieszczania.  
  
-   Względne położenie, w którym element zostanie przesunięty o stałą względem jego elementu nadrzędnego.  
  
-   Położenie bezwzględne, w którym element znajduje się określony Współrzędna względem lewego górnego rogu dokumentu.  
  
 Aby uzyskać więcej informacji o elemencie strony HTML, zobacz [o pozycjonowanie elementu](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy kod przedstawia przykład sposobu <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> i <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> różnią się w przypadku `span1`, `span2` i `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Drugi <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje dwa elementy pod kątem równości.</summary>
        <returns>
          <see langword="true" /> Jeśli oba parametry są <see langword="null" />, lub oba elementy mają tego samego powiązanego interfejsu COM; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Testy operator równości `IUnknown` wskaźniki obiektów COM opakowane przez podane <xref:System.Windows.Forms.HtmlElement> klasy.  
  
 Jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Drugi <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje dwa <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty pod kątem nierówności.</summary>
        <returns>
          <see langword="true" /> jest to tylko jeden element <see langword="null" />, lub dwa obiekty nie są równe; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Negacja jest równoważne metodę dla tego operatora <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia bieżący element kodu HTML.</summary>
        <value>Kod HTML dla bieżącego elementu i jego elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas gdy <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> HTML wszystkie zawarte w elemencie bieżący, z wyłączeniem bieżącego elementu otaczającego tagów, którą będzie zwracać <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> zawiera tag bieżącego elementu, a także kod HTML, który zawiera znacznik, na przykład:  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 W tym przykładzie wywołanie <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> na `div2` zwróci:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Wywoływanie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zwróci:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Po przypisaniu nową wartość do <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, odwołanie do bieżącego elementu staną się nieprawidłowe; Nazwa nie zostanie uwzględniona, właściwości i podrzędny zawartość HTML właśnie przypisano.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst bieżącego elementu.</summary>
        <value>Tekst wewnątrz bieżącego elementu i jego elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać HTML do elementu z <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, kod HTML będą wyświetlane jako literały w dokumencie, tak jak gdyby była wyświetlana HTML w pliku tekstowym. Po przypisaniu HTML przy użyciu elementu <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwość <xref:System.Windows.Forms.HtmlElement.OuterText%2A> zwróci cały tekst, w tym usunąć HTML przy użyciu znaczników.  
  
 Przypisywanie wartości do <xref:System.Windows.Forms.HtmlElement.OuterText%2A> zniszczy wszystkie elementy podrzędne, które należą do elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można ustawić tekst poza tego elementu.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny bieżącego elementu.</summary>
        <value>Element powyżej bieżącego elementu w hierarchii dokumentu HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość umożliwia odnajdywania elementu kontekstu. Najbardziej przydatny w ramach procedury obsługi zdarzeń jest takie jak <xref:System.Windows.Forms.HtmlElement.Click>, które mogą wyzwalać dla każdego elementu w dowolnym miejscu hierarchii obiektów dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Wskazuje właściwość elementu HTML (u góry dokumentu HTML) do samej siebie. Jeśli należy wywołać <xref:System.Windows.Forms.HtmlElement.Parent%2A> wewnątrz pętli, sprawdź, czy warunek podziału pętli porównuje typ bieżącego elementu i typ `Parent` właściwości, w przeciwnym razie kod może być wykonywane Pętla nieskończona.  
  
   
  
## Examples  
 Poniższy przykładowy kod znajduje wszystkie `IMG` tagów w dokumencie i używa <xref:System.Windows.Forms.HtmlElement.Parent%2A> właściwości, aby sprawdzić czy `IMG` jest Link do innej strony; Jeśli tak jest, kod przypisuje adres URL, który `ALT` atrybutu `IMG`tagów, dzięki czemu użytkownicy mogą wskaźnik myszy na obraz, aby zobaczyć, których potrwa je.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, aby wywołać.</param>
        <summary>Powoduje, że nazwanego zdarzenia w celu wywołania wszystkich procedur obsługi zdarzeń zarejestrowane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest używana do dostępu zdarzenia HTML modelu DOM (Document Object). Bezpośrednio wywołuje [IHTMLElement3::fireEvent](http://go.microsoft.com/fwlink/?LinkId=103189) metody. Aby uzyskać więcej informacji o sposobie używania modelu DOM za pośrednictwem <xref:System.Windows.Forms.HtmlElement> , zobacz [podczas uzyskiwania dostępu do nieujawnionych elementów w modelu obiektów zarządzanych dokumentów HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa skupić się od bieżącego elementu, jeśli ten element ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody zgłasza <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeń dla elementu.  
  
 Gdy fokus jest wyczyszczone z elementu za pomocą tej metody, znajduje się w dokumencie zawierający element, a nie do następnego elementu w kolejności tabulacji.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Jeśli <see langword="true" />, górnej krawędzi obiektu będą wyświetlane w górnej części okna. Jeśli <see langword="false" />, dół obiektu będą wyświetlane w dolnej części okna.</param>
        <summary>Przewija dokument zawierający ten element, do momentu top lub bottom edge tego elementu jest wyrównywana z okna dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod znajduje według nazwy elementu i do strony przewijania, dzięki czemu na początku elementu jest wyrównane do górnej części strony widoczny.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między krawędzią elementu i lewą krawędzią jego zawartości.</summary>
        <value>Odległość w pikselach między lewą krawędzią elementu i lewą krawędzią jego zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełna wymiary obszaru przewijania są dostępne przy użyciu <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` i <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> są widoczne niezależnie, ponieważ są one tylko dwie właściwości deweloperzy mogą ustawić obszaru przewijania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymiary elementu przewijanego regionu.</summary>
        <value>Rozmiar i współrzędnych lokalizacji przewijany obszar elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element ma przewijanego region jeśli jego zawartość jest większy niż jego wymiarów, chyba że styl przepełnienie w elemencie zabrania renderowania pasków przewijania.  
  
 Nie można zmodyfikować rozmiar obszaru przewijania bezpośrednio, ale można modyfikować odległość między krawędzi obszaru przewijania i krawędzi elementu. Użyj <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> i <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> właściwości można to osiągnąć.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia odległość między krawędzią elementu a górną krawędzią jego zawartości.</summary>
        <value>Odległość w pikselach między górną krawędzią elementu a górną krawędzią jego zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełna wymiary obszaru przewijania są dostępne przy użyciu <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> i `ScrollTop` są widoczne niezależnie, ponieważ są one tylko dwie właściwości deweloperzy mogą ustawić obszaru przewijania.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu, aby ustawić.</param>
        <param name="value">Nowa wartość tego atrybutu.</param>
        <summary>Ustawia wartość atrybutu nazwanego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut HTML jest wszystkie prawidłowe pary nazwa wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement> przedstawia tylko atrybuty, które są wspólne dla wszystkich elementów, pomijając te, które mają zastosowanie tylko do niektórych typów elementów; `SRC` jest wstępnie zdefiniowanych atrybutów dla `IMG` tagu, na przykład, ale nie dla `DIV` tagu. Użyj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutów nie widoczne na zarządzanych modelu DOM (Document Object).  
  
 Jeśli `attributeName` nie jest atrybutem zdefiniowanej w elemencie <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> zostaną zdefiniowane w elemencie jako nowy atrybut.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> jest rozróżniana wielkość liter.  
  
 Aby ustawić `class` atrybutu <xref:System.Windows.Forms.HtmlElement> , użytkownik musi odwoływać się do atrybutu jako `className` podczas określania pierwszy argument funkcji <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 Poniższy przykładowy kod dodaje nowy `IMG` element do bieżącego dokumentu za pomocą <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> można ustawić `SRC` atrybutu dla obrazu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia Rozdzielana średnikami lista style dla bieżącego elementu.</summary>
        <value>Ciąg zawierający wszystkie style elementu</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML modelu DOM (Document Object) używa style zgodnie z definicją w specyfikacji konsorcja sieci World Wide Web kaskadowych arkuszy stylów do wyświetlania elementu. Style w <xref:System.Windows.Forms.HtmlElement.Style%2A> właściwości formę średnikami lista par nazwa wartość, a każda para powinna oddzielone średnikami, w następujący sposób:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Aby ustawić czcionkę `DIV` elementu 14 punktów podzbiory bold, na przykład, jak w przypadku przypisywania następujący ciąg:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Aby uzyskać pełną listę wszystkich dostępnych stylów w modelu DOM kodu HTML, zobacz [atrybutu STYLE](http://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub Ustawia lokalizację tego elementu w kolejności tabulacji.</summary>
        <value>Liczbowa indeks elementu w kolejności tabulacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> Określa, który element w dokumencie HTML obok przenieść fokus, gdy użytkownik naciśnie klawisz TAB. Domyślnie są tylko elementy zawarte w kolejności tabulacji `INPUT` elementów `SELECT` kontroli, a każdy element których `contentEditable` właściwość jest ustawiona na `true`. Można uwzględnić dowolnego elementu HTML w kolejności tabulacji, takich jak `DIV`, przypisując jawnego <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>.  
  
 Prawidłowe wartości <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> z zakresu od-32767 do 32767.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tagu HTML.</summary>
        <value>Nazwa używana do utworzenia tego elementu za pomocą kodu znaczników HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów w modelu obiektu dokumentu HTML mają atrybuty, właściwości i metod, które są unikatowe dla tych elementów; takie jak `HREF` atrybutu `A` elementu, lub `Submit` metoda `FORM`. Użyj <xref:System.Windows.Forms.HtmlElement.TagName%2A> podczas wcześniej element potencjalnie dowolnego typu i konieczne jest wykonanie operacji określonego typu.  
  
   
  
## Examples  
 Poniższy przykładowy kod znajduje wszystkie `IMG` tagów w dokumencie i używa `TagName` właściwości, aby sprawdzić czy `IMG` jest Link do innej strony; Jeśli tak jest, kod przypisuje adres URL, który `ALT` atrybutu `IMG`tagów, dzięki czemu użytkownicy mogą wskaźnik myszy na obraz, aby zobaczyć, których potrwa je.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>
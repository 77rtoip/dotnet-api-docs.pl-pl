<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bce80241b72d7a09d5c7b0585a7cc810a5d7113d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69188197" /></Metadata><TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Reprezentuje element HTML wewnątrz strony sieci Web.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement>reprezentuje dowolny możliwy typ elementu w dokumencie HTML, taki jak `BODY`, `TABLE`, i `FORM`, między innymi. Klasa uwidacznia najbardziej typowe właściwości, które można oczekiwać na znalezienie wszystkich elementów.  
  
 Większość elementów może mieć *elementy podrzędne*: inne elementy HTML, które są umieszczone poniżej. Użyj właściwości <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> , aby sprawdzić, czy dany element ma elementy podrzędne, i <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcję, w której mają zostać przetestowane. Właściwość zwraca wartość, <xref:System.Windows.Forms.HtmlElement> w której bieżący element jest zagnieżdżony. <xref:System.Windows.Forms.HtmlElement.Parent%2A>  
  
 Często potrzebny jest dostęp do atrybutów, właściwości i metod w podstawowym elemencie, który nie jest bezpośrednio narażony przez <xref:System.Windows.Forms.HtmlElement>, takich `SRC` jak atrybut `Submit` w `IMG` elemencie lub metoda na `FORM`. Metody <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> umożliwiają pobieranie i modyfikowanie dowolnego atrybutu lub właściwości określonego elementu, a jednocześnie zapewnia dostęp do wszelkich metod niewidocznych w zarządzanym Document Object Model (dom). Jeśli aplikacja ma uprawnienia do kodu niezarządzanego, można także uzyskać dostęp do nieuwidocznionych właściwości <xref:System.Windows.Forms.HtmlElement.DomElement%2A> i metod przy użyciu atrybutu.  
  
 Użyj właściwości <xref:System.Windows.Forms.HtmlElement.TagName%2A> , aby sprawdzić, czy element jest określonego typu.  
  
 Dowolny dokument HTML można modyfikować w czasie wykonywania. Można <xref:System.Windows.Forms.HtmlElement> tworzyć nowe obiekty <xref:System.Windows.Forms.HtmlDocument> <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> za pomocą metody <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> i dodawać je do innego elementu przy użyciu metod lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> . Możesz również utworzyć elementy jako Tagi HTML i przypisać je do <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> właściwości istniejącego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, jak przeanalizować dowolny dokument HTML i utworzyć ciąg opisujący elementy HTML, z wcięciem i numerami poziomów używanymi do wskazania, jak głęboko zagnieżdżone elementy znajdują się w dokumencie. Ten przykład kodu wymaga, aby aplikacja hostuje <xref:System.Windows.Forms.WebBrowser> kontrolkę `WebBrowser1`o nazwie.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104876">IHTMLElement, interfejs</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">IHTMLElement2, interfejs</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104878">IHTMLElement3, interfejs</related>
    <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104879">IHTMLElement4, interfejs</related>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.HtmlElementCollection" /> Pobiera wszystkie elementy poniżej bieżącego elementu.</summary>
        <value>Kolekcja wszystkich elementów, które są bezpośrednimi lub pośrednimi elementami podrzędnymi bieżącego elementu. Jeśli bieżący element jest <c>tabelą</c>, <see cref="P:System.Windows.Forms.HtmlElement.All" /> na przykład zwróci każdy element, <c>TR</c>i <c>TD</c> w tabeli, a także inne elementy, takie jak elementy <c>DIV</c> i <c>span</c> , zawarte w <c></c> komórek.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aby uzyskać dostęp tylko do tych elementów, które mają bieżący element jako bezpośrednie elementy nadrzędne <xref:System.Windows.Forms.HtmlElement.Children%2A> , Użyj kolekcji zamiast niej.  
  
 Elementy w tej kolekcji nie muszą być zwracane w kolejności źródłowej.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement"><see cref="T:System.Windows.Forms.HtmlElement" /> Do dołączenia do tej lokalizacji w drzewie.</param>
        <summary>Dodaje element do poddrzewa innego elementu.</summary>
        <returns>Element po jego dodaniu do drzewa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Document Object Model HTML (DOM) pozwala na wiele sposobów zmienić zawartość pliku HTML w czasie wykonywania. Służy <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> do dodawania nowych elementów do istniejącego dokumentu lub do przenoszenia elementu na stronie.  
  
 Jeśli element został już nadrzędny, dołączenie elementu do innego elementu spowoduje automatyczne usunięcie tego elementu z jego poprzedniego elementu nadrzędnego.  
  
 Wszelkie dodatki wprowadzone do dokumentu w czasie <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> wykonywania nie będą utrwalane po <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> wywołaniu metody na <xref:System.Windows.Forms.WebBrowser> kontrolce.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowe hiperłącze przy użyciu <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> metody i dodaje ją do końca strony przy użyciu `AppendChild` `BODY` elementu. Przykład wymaga, aby aplikacja zawierała <xref:System.Windows.Forms.WebBrowser> kontrolkę o nazwie. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/Node/appendChild">appendChild, Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które ma zostać obsłużone.</param>
        <param name="eventHandler">Zarządzany kod, który obsługuje zdarzenie.</param>
        <summary>Dodaje procedurę obsługi zdarzeń dla nazwanego zdarzenia w Document Object Model HTML (DOM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarządzana Document Object Model (DOM) ujawnia tylko wybraną liczbę zdarzeń. Większość niewidocznych zdarzeń jest definiowana tylko dla określonych typów elementów; takie jak `submit` zdarzenie, które jest prawidłowe tylko dla `FORM` elementów. Służy <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> do dodawania obsługi zdarzeń do tych niewidocznych zdarzeń.  
  
 Nie należy dołączać zdarzenia do dokumentu lub jednego z jego obiektów do momentu zakończenia ładowania dokumentu. Najwcześniejsza Metoda powinna wywołać tę metodę w <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> przypadku <xref:System.Windows.Forms.WebBrowser> kontrolki.  
  
 Aby uzyskać więcej informacji na temat dostępnych zdarzeń niezarządzanych, zobacz [dostęp do niewidocznych członków w zarządzanym Document Object Model HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) i interfejsach IHTMLElement: [IHTMLElement](https://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](https://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](https://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](https://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</related>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy ten element może mieć elementy podrzędne.</summary>
        <value><see langword="true" />Jeśli element może mieć elementy podrzędne; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre elementy, takie jak `IMG` i `SCRIPT`, nie mogą mieć żadnych elementów podrzędnych. Użyj tej właściwości przed wywołaniem <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> lub <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> w dowolnym elemencie.  
  
   
  
## Examples  
 Poniższy przykład kodu obsługuje <xref:System.Windows.Forms.HtmlElement.Click> zdarzenie w. <xref:System.Windows.Forms.HtmlDocument> Jeśli element nie został wybrany wcześniej przy użyciu kliknięcia myszą, kod przypisze element do zmiennej klasy prywatnej o nazwie `MoveElement`. Jeśli element został wybrany, kod próbuje dołączyć go do elementu, który został właśnie kliknięty. Ten przykład kodu wymaga, aby aplikacja hostuje <xref:System.Windows.Forms.WebBrowser> kontrolkę `WebBrowser1`o nazwie i że została już dodana <xref:System.Windows.Forms.HtmlDocument>procedura obsługi zdarzeń dla <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.HtmlElementCollection" /> Pobiera wszystkie elementy podrzędne bieżącego elementu.</summary>
        <value>Kolekcja wszystkich <see cref="T:System.Windows.Forms.HtmlElement" /> obiektów, które mają bieżący element jako element nadrzędny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów wewnątrz pliku HTML może mieć inne elementy HTML poniżej. <xref:System.Windows.Forms.HtmlElement.Children%2A> Kolekcja zawiera prosty mechanizm eksplorowania struktury drzewa dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A>ujawnia tylko elementy, których bezpośredni element nadrzędny jest bieżącym elementem. <xref:System.Windows.Forms.HtmlElement> Jeśli masz <xref:System.Windows.Forms.HtmlElement.Children%2A> `TR` dla elementu element, zapewni wszystkie elementy (wiersz) wewnątrz `TABLE`. `TABLE` Aby pobrać `TD` elementy (komórki) zawarte wewnątrz `TR` elementów, musisz użyć <xref:System.Windows.Forms.HtmlElement.Children%2A> kolekcji <xref:System.Windows.Forms.HtmlElement.All%2A> dla każdego pojedynczego `TR` elementu lub użyć kolekcji w <xref:System.Windows.Forms.HtmlElement>.  
  
 Elementy w tej kolekcji nie są gwarantowane w kolejności źródłowej.  
  
 Jeśli <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> jest `false` ,`Children` będzie zawsze pusta.  
  
   
  
## Examples  
 Poniższy przykład kodu analizuje dowolny dokument HTML i tworzy ciąg opisujący elementy, z wcięciem i numerami poziomów używanymi do wskazania, jak głęboko zagnieżdżone elementy znajdują się w dokumencie. Robi to, przeszukując `Children` kolekcje wszystkich elementów cyklicznie, rozpoczynając od elementu HTML w górnej części dokumentu. Ten przykład kodu wymaga, aby aplikacja ma <xref:System.Windows.Forms.WebBrowser> kontrolkę o nazwie. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie element z lewym przyciskiem myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.Click> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.Click>  
  
 Jeśli użytkownik kliknie element, który aktualnie nie ma fokusu wprowadzania, <xref:System.Windows.Forms.HtmlElement.Click> zdarzenie zostanie wykonane <xref:System.Windows.Forms.HtmlElement.Focusing> po <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzeniu, ale przed zdarzeniem dla tego elementu.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.Click> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.Click> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536913.aspx">Zdarzenie onkliknięcia</related>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera granice obszaru klienckiego elementu w dokumencie HTML.</summary>
        <value>Obszar klienta zajmowany przez element, pomniejszony o wszystkie obszary wykonane przez obramowania i paski przewijania. Aby uzyskać położenie i wymiary elementu z uwzględnieniem jego elementów definiowania, użyj <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zamiast tego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A>zwraca dane położenia tylko dla elementów, do których przypisano jawną wysokość i szerokość, lub elementy, które używają pozycjonowania bezwzględnego. Dokument jest pozycjonowany absolutnie, jeśli jego styl położenia jest ustawiony `absolute`na, po którym może być umieszczony w dowolnej koordynacji na stronie HTML.  
  
   
  
## Examples  
 Załóżmy, że następująca strona HTML została załadowana do hostowanego wystąpienia <xref:System.Windows.Forms.WebBrowser> formantu.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 Poniższy przykład kodu pokazuje, jak pobrać ten element i zwiększyć jego wymiary, jeśli obszar klienta ma mniej niż 400 pikseli o szerokości `DIV` `contentEditable` do 50 pikseli, a także ustawia stan na tak, aby użytkownik mógł wprowadzić tekst.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533564.aspx">Właściwość clientLeft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533565.aspx">Właściwość clientTop</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533566.aspx">Właściwość clientWidth</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533563.aspx">Właściwość clientHeight</related>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia, które ma zostać obsłużone.</param>
        <param name="eventHandler">Zarządzany kod, który obsługuje zdarzenie.</param>
        <summary>Usuwa procedurę obsługi zdarzeń z nazwanego zdarzenia w Document Object Model HTML (DOM).</summary>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536411.aspx">detachEvent, Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera, <see cref="T:System.Windows.Forms.HtmlDocument" /> do którego należy ten element.</summary>
        <value>Dokument nadrzędny tego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Niektóre strony HTML mogą hostować ramki przy `FRAMESET` użyciu tagów. W takim przypadku każdy pojedynczy `FRAME` element będzie zawierać własne <xref:System.Windows.Forms.HtmlDocument>wystąpienie. Ta właściwość jest najbardziej przydatna w przypadku otrzymania odwołania do elementu w programie obsługi zdarzeń z <xref:System.Windows.Forms.HtmlElementEventArgs>i musi wykonać pewne czynności w dokumencie, w którym znajduje się element.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera niezarządzany wskaźnik interfejsu dla tego elementu.</summary>
        <value>Wskaźnik COM <c>IUnknown</c> elementu, który można rzutować na jeden z interfejsów elementu HTML, takich jak <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement>jest otoką dla programu Internet Explorer Document Object Model (DOM), która jest zapisywana przy użyciu Component Object Model (COM). Jeśli potrzebujesz dostępu do nieuwidocznionych właściwości lub metod w źródłowych interfejsach com, takich jak `IHTMLElement`, możesz użyć tego obiektu do wykonywania zapytań.  
  
 Aby można było używać interfejsów niezarządzanych, należy zaimportować bibliotekę MSHTML (Mshtml. dll) do aplikacji. Można jednak również wykonać nieuwidocznione właściwości i metody przy użyciu `Invoke` metody.  
  
   
  
## Examples  
 Poniższy przykład kodu używa niezarządzanych interfejsów do zastosowania aktualnie zaznaczonego tekstu i przekonwertowania go do hiperlinku przy użyciu adresu URL wybranego przez użytkownika. Ten kod został zapisany w założeniu, że formularz ma <xref:System.Windows.Forms.WebBrowser> kontrolkę o nazwie `WebBrowser1`i że dodaliśmy niezarządzaną bibliotekę MSHTML jako odwołanie do projektu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
        <related type="ExternalDocumentation" href="https://go.microsoft.com/fwlink/?LinkId=104877">IHTMLElement2, interfejs</related>
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik kliknie lewym przyciskiem myszy nad elementem dwa razy w krótkim czasie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwukrotnie kliknięcie konfiguruje się w ustawieniach myszy w systemie operacyjnym użytkownika. Użytkownik może ustawić czas między kliknięciami przycisku myszy, który powinien być uważany za dwukrotne kliknięcie, a nie dwoma kliknięciami.  
  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.DoubleClick> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.DoubleClick>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.DoubleClick> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.DoubleClick> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536921.aspx">Zdarzenie OnDblClick</related>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciągnie tekst do różnych lokalizacji.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To zdarzenie występuje, gdy tekst jest przeciągany do następujących lokalizacji:  
  
-   W obrębie lub między stronami HTML obsługiwanymi <xref:System.Windows.Forms.WebBrowser> w formancie lub Internet Explorer  
  
-   Do innej aplikacji  
  
-   Na pulpicie systemu Windows  
  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.Drag> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.Drag>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.Drag> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.Drag> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536923.aspx">Zdarzenie onprzeciągnij</related>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zakończy operację przeciągania.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.DragEnd> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.DragEnd>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.DragEnd> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.DragEnd> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536924.aspx">Zdarzenie ondragend</related>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik nie przeciągnie elementu nad tym elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.DragLeave> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.DragLeave> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przeciągnie tekst na element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.DragOver> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.DragOver>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.DragOver> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.DragOver> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536927.aspx">Zdarzenie OnDragOver</related>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość określającą, czy użytkownik może wprowadzać dane do tego elementu.</summary>
        <value><see langword="true" />Jeśli element zezwala na dane wejściowe użytkownika; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dla `FORM` elementów, takich jak pola tekstowe i przyciski radiowe <xref:System.Windows.Forms.HtmlElement.Enabled%2A> , `false` ustawienie uniemożliwi użytkownikowi korzystanie z tych pól formularza. W przypadku innych elementów, takich `DIV` jak `SPAN`lub, <xref:System.Windows.Forms.HtmlElement.Enabled%2A> ustawienie `false` powoduje, że cały tekst w elemencie zostanie zacieniowany, jednak tekst będzie nadal wybierany. Aby anulować zaznaczenie, Dodaj procedurę obsługi zdarzeń dla nieuwidocznionego `onselectstart` zdarzenia <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> przy użyciu metody.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533734.aspx">Właściwość disabled</related>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do przetestowania pod kątem równości.</param>
        <summary>Testuje, czy dostarczony obiekt jest równy bieżącemu elementowi.</summary>
        <returns><see langword="true" />Jeśli <paramref name="obj" /> <see langword="false" />jest ;wprzeciwnymrazie,.<see cref="T:System.Windows.Forms.HtmlElement" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera następny element poniżej tego elementu w drzewie dokumentu.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentujący pierwszy element zawarty poniżej bieżącego elementu w kolejności źródłowej.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> programu w połączeniu <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> z programem, aby przeszukać drzewo dokumentu dla dokumentu HTML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533755.aspx">Właściwość firstChild</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Umieszcza fokus danych wejściowych użytkownika na bieżącym elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawienie fokusu na elemencie powoduje, że fokus elementu i staje się elementem aktywnym; na przykład element, który ma fokus, będzie zwracany przez <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> <xref:System.Windows.Forms.HtmlDocument>właściwość.  
  
 Wszystkie pociągnięcia klawiszy wprowadzone przez użytkownika po <xref:System.Windows.Forms.HtmlElement.Focus%2A> wywołaniu zostaną wysłane do tego elementu.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536425.aspx">Metoda Focus</related>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element najpierw otrzymuje fokus wprowadzania danych przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element, który miał fokus przed przełączeniem użytkownika do innej aplikacji przy użyciu paska zadań lub klawiszy Alt + Tab, będzie otrzymywać <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzenia <xref:System.Windows.Forms.HtmlElement.GotFocus> i ponownie, gdy użytkownik przełączy się z powrotem do aplikacji.  
  
 Nie można anulować domyślnego zachowania tego zdarzenia. Aby usunąć fokus z elementu, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> inny element z <xref:System.Windows.Forms.HtmlElement.GotFocus> poziomu zdarzenia.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.Focusing>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.Focusing> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.Focusing> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536935.aspx">Zdarzenie onFocus</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu. W tym argumencie nie jest rozróżniana wielkość liter.</param>
        <summary>Pobiera wartość nazwanego atrybutu w elemencie.</summary>
        <returns>Wartość tego atrybutu dla elementu, jako <see cref="T:System.String" /> wartość. Jeśli określony atrybut nie istnieje w tym elemencie, zwraca pusty ciąg.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut w kodzie HTML jest dowolną poprawną parą nazwa/wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement>uwidacznia tylko te atrybuty, które są wspólne dla wszystkich elementów, pozostawiając te, które mają zastosowanie tylko do niektórych typów elementów; jest wstępnie zdefiniowanym atrybutem `IMG` dla tagu, na przykład `DIV` , ale nie dla tagu. `SRC` Używaj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i<xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutami nieujawnionymi w zarządzanym Document Object Model (dom).  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A>i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> nie uwzględnia wielkości liter.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera `META` wszystkie Tagi w dokumencie HTML przy użyciu polecenia <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> , aby znaleźć `META` tag o nazwie `Description`. Przykład wymaga, aby aplikacja miała <xref:System.Windows.Forms.WebBrowser> kontrolkę o nazwie. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536429.aspx">GetAttribute — Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Nazwa tagu, którego <see cref="T:System.Windows.Forms.HtmlElement" /> obiekty mają zostać pobrane.</param>
        <summary>Pobiera kolekcję elementów reprezentowanych w kodzie HTML przez określony tag <c>HTML</c> .</summary>
        <returns>Zawierający <see cref="T:System.Windows.Forms.HtmlElementCollection" /> wszystkie elementy, których <c></c> <paramref name="tagName" />nazwa tagu HTML jest równa.</returns>
        <remarks>To be added.</remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536439.aspx">getElementsByTagName, Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Służy jako funkcja skrótu dla określonego typu.</summary>
        <returns>Kod skrótu dla bieżącego <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element otrzymał fokus wprowadzania danych przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować domyślnego zachowania tego zdarzenia ani uniemożliwić jego propagacji. Aby usunąć fokus z elementu, należy wywołać <xref:System.Windows.Forms.HtmlElement.Focus%2A> inny element z <xref:System.Windows.Forms.HtmlElement.GotFocus> poziomu zdarzenia.  
  
   
  
## Examples  
 Zapisz następujący kod HTML w pliku i załaduj plik do <xref:System.Windows.Forms.WebBrowser> kontrolki w projekcie Windows Forms.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 Poniższy przykład kodu uniemożliwia następny `INPUT` element w kolejności tabulacji od momentu, gdy poprzedni element zawiera mniej niż pięć znaków. Przykład wymaga, aby poprzednio wymieniony plik HTML został załadowany do wystąpienia <xref:System.Windows.Forms.WebBrowser> kontrolki o nazwie. `WebBrowser1`  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536934.aspx">Zdarzenie onFocus</related>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia etykietę, według której ma być identyfikowany element.</summary>
        <value>Unikatowy identyfikator elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A>musi być unikatowa; w tym samym dokumencie nie mogą znajdować <xref:System.Windows.Forms.HtmlElement.Id%2A> się dwa elementy. <xref:System.Windows.Forms.HtmlElement.Name%2A> Użyj właściwości, aby nadać temu samemu identyfikatorowi grupę elementów powiązanych logicznie.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533880.aspx">ID — właściwość</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Właściwość name</related>
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia znacznik HTML poniżej tego elementu.</summary>
        <value>Znacznik HTML, który definiuje elementy podrzędne bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Istnieje kilka sposobów dodawania nowych elementów do istniejącej strony HTML, takiej jak <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metody i. <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> Używanie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> jest często najszybszym sposobem dodawania nowej zawartości, gdy trzeba ustawić wiele atrybutów lub stylów dla nowych elementów.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>różni się <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> od w <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> programie, który nie zawiera kodu HTML, który reprezentuje wywoływany obiekt. Zobacz <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> , aby uzyskać więcej informacji o różnicach między tymi dwiema właściwościami.  
  
 Ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> niszczy wszystkie elementy podrzędne poprzednio dołączone do elementu. Jeśli pobrano element z modelu dom, a następnie przypiszesz nowy kod HTML <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> do właściwości rodziców, odwołanie do tego elementu będzie bezużyteczny i jego zachowanie, gdy wywoła jego właściwości, a metody są niezdefiniowane.  
  
 Dla niektórych elementów ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> nie jest prawidłową operacją. Niektóre Tagi HTML nie mają taga zamykającego, takiego jak `IMG` tag, i w związku z tym nie mogą zawierać zagnieżdżonych elementów. Niektóre Tagi, takie jak `SCRIPT` tag, mogą zawierać tylko zawartość tekstową; ustawienie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> spowoduje wystąpienie błędu. Dla obu typów tagów właściwość zwróci <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> `false`wartość. Nie można jednak również ustawiać <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> elementów dla `TABLE` i `TR` , ponieważ przypisanie źle sformułowanego kodu HTML do tych elementów może spowodować uszkodzenie renderowania dokumentu. Użyj <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> metod `IHTMLTable` `TABLE`lub i w`insertCell` interfejsie niezarządzanym, aby dodać wiersze i komórki do. `insertRow`  
  
 Jeśli wystarczy przypisać tekst do elementu, a nie do znacznika HTML, użyj <xref:System.Windows.Forms.HtmlElement.InnerText%2A> właściwości.  
  
 Przypisanie wartości do spowoduje <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zniszczenie wszelkich wartości tekstowych, które zostały wcześniej <xref:System.Windows.Forms.HtmlElement.InnerText%2A>przypisane przy użyciu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Tworzenie elementów podrzędnych w tym elemencie jest niedozwolone.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533897.aspx">Właściwość innerHTML</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536452.aspx">insertAdjacentHTML, Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst przypisany do elementu.</summary>
        <value>Tekst elementu, nieobecny w kodzie HTML. Jeśli element zawiera elementy podrzędne, tylko tekst w tych elementach podrzędnych zostanie zachowany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać HTML do elementu z <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, kod HTML będzie wyświetlany jako literały w dokumencie, podobnie jak w przypadku wyświetlania kodu HTML w pliku tekstowym. Jeśli przypiszesz kod HTML do elementu przy <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> użyciu właściwości <xref:System.Windows.Forms.HtmlElement.InnerText%2A> , zwróci cały tekst w tym kodzie HTML z usuniętym znacznikiem.  
  
 Przypisanie wartości do <xref:System.Windows.Forms.HtmlElement.InnerText%2A> spowoduje zniszczenie wszelkich elementów podrzędnych należących do elementu.  
  
   
  
## Examples  
 Poniższy kod tworzy nowe hiperłącze przy użyciu <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>i przypisuje tekst do łącza <xref:System.Windows.Forms.HtmlElement.InnerText%2A> przy użyciu właściwości.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Określony element nie może zawierać tekstu (na przykład elementu <c>IMG</c> ).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms533899.aspx">Właściwość innerText</related>
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Gdzie wstawić ten element w odniesieniu do bieżącego elementu.</param>
        <param name="newElement">Nowy element do wstawienia.</param>
        <summary>Wstaw nowy element do Document Object Model (DOM).</summary>
        <returns><see cref="T:System.Windows.Forms.HtmlElement" /> , Który został właśnie wstawiony. Jeśli wstawianie nie powiodło się, <see langword="null" />spowoduje to zwrócenie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie wywołuj tej metody do momentu <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> wystąpienia zdarzenia <xref:System.Windows.Forms.WebBrowser> w kontrolce. Wywołanie tej metody przed następnie może spowodować wyjątek, ponieważ dokument nie zakończył ładowania.  
  
 Czy wartość <xref:System.Windows.Forms.HtmlElementInsertionOrientation> jest prawidłowa, zależy od typu elementu. Na przykład, <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> jest prawidłowy, jeśli element `DIV`jest, ale `SCRIPT` nie jeśli jest elementem lub `IMG` , żaden z nich nie może zawierać elementów podrzędnych.  
  
   
  
## Examples  
 Poniższy przykład kodu wstawia `DIV` element w górę każdej strony, którą użytkownicy widzą poza serwerem adatum.com. Przykład wymaga, aby formularz zawierał <xref:System.Windows.Forms.WebBrowser> kontrolkę o nazwie. `WebBrowser1` Przykład musi również zaimportować przestrzeń nazw <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536451.aspx">insertAdjacentElement, Metoda</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wykonuje metodę unikatową dla bieżącego elementu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <summary>Wykonuje nieuwidocznioną metodę dla bazowego elementu DOM tego elementu.</summary>
        <returns>Element zwracany przez tę metodę, reprezentowany jako <see cref="T:System.Object" />. Jeśli jest <see cref="T:System.Object" /> to inny element HTML i istnieje odwołanie do niezarządzanej biblioteki MSHTML dodanej do projektu, można rzutować go na odpowiedni niezarządzany interfejs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wywoływania metod z Document Object Model (DOM), które nie mają odpowiedników w kodzie zarządzanym. Ta wersja programu <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> umożliwia wykonywanie nieuwidocznionych metod, które nie przyjmują argumentów. Aby zapoznać się z przykładem, zobacz <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Nazwa właściwości lub metody do wywołania.</param>
        <param name="parameter">Lista parametrów do przekazania.</param>
        <summary>Wykonuje funkcję zdefiniowaną na bieżącej stronie HTML przez język skryptów.</summary>
        <returns>Element zwracany przez funkcję, reprezentowany jako <see cref="T:System.Object" />. Jeśli jest <see cref="T:System.Object" /> to inny element HTML i istnieje odwołanie do niezarządzanej biblioteki MSHTML dodanej do projektu, można rzutować go na odpowiedni niezarządzany interfejs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda może służyć do wywoływania metod z Document Object Model (DOM), które nie mają odpowiedników w kodzie zarządzanym. Wszystkie argumenty przekazane do <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> zostaną przekonwertowane na typy `VARIANT` danych Win32 przed przekazaniem ich do określonej funkcji skryptów.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera `TABLE` wywołane `dataTable` i używa nieuwidocznionej `moveRow` metody do przenoszenia wiersza od końca tabeli do początku.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown>występuje przed <xref:System.Windows.Forms.HtmlElement.KeyPress>, które w stanie się pojawiać przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.KeyDown> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.KeyDown>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.KeyDown> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.KeyDown> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536938.aspx">OnKeyDown — zdarzenie</related>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie i zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress>występuje po <xref:System.Windows.Forms.HtmlElement.KeyDown> i przed <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.KeyPress> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.KeyPress>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.KeyPress> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.KeyPress> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536939.aspx">Zdarzenie OnKeyPress</related>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni klawisz na klawiaturze.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp>występuje po <xref:System.Windows.Forms.HtmlElement.KeyPress>, który występuje po <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Nie można anulować tego zdarzenia.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.KeyUp>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.KeyUp> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.KeyUp> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536940.aspx">Zdarzenie OnKeyUp</related>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element utraci fokus wprowadzania danych przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.LosingFocus> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.LosingFocus> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy element utraci fokus wprowadzania danych przez użytkownika.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element nie będzie już otrzymywał zdarzeń naciśnięć klucza po <xref:System.Windows.Forms.HtmlElement.LostFocus> wystąpieniu, dopóki nie zostanie ponownie określony fokus, przez użytkownika, zaznaczając go na stronie lub przez aplikację <xref:System.Windows.Forms.HtmlElement.Focus%2A> wywołującą metodę dla tego elementu.  
  
 Nie można anulować tego zdarzenia.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.LostFocus>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.LostFocus> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536936.aspx">Zdarzenie onFocusOut</related>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik naciśnie przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.MouseDown> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.MouseDown>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseDown> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseDown> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536944.aspx">OnMouseDown — zdarzenie</related>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik po raz pierwszy przesunie wskaźnik myszy nad bieżący element.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseEnter> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseEnter> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy z bieżącego elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseLeave> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseLeave> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik przesuwa wskaźnik myszy nad elementem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie można anulować tego zdarzenia.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.MouseMove>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseMove> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseMove> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536947.aspx">Zdarzenie OnMouseMove</related>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy kursor myszy wprowadzi granice elementu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.MouseOver> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.MouseOver>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseOver> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseOver> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536949.aspx">Zdarzenie funkcja onMouseOver</related>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy użytkownik zwolni przycisk myszy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz anulować domyślną akcję <xref:System.Windows.Forms.HtmlElement.MouseUp> dla zdarzenia na elemencie, <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> ustawiając właściwość <xref:System.Windows.Forms.HtmlElementEventArgs> klasy na `true`.  
  
 <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> <xref:System.Windows.Forms.HtmlDocument> `true` <xref:System.Windows.Forms.HtmlElementEventArgs> Zdarzenie na elemencie zostanie również wykonane dla elementów nadrzędnych tego elementu i w samej klasie, chyba że ustawisz właściwość klasy na. <xref:System.Windows.Forms.HtmlElement.MouseUp>  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie tego elementu członkowskiego. W tym przykładzie program obsługi zdarzeń raportuje wystąpienie <xref:System.Windows.Forms.HtmlElement.MouseUp> zdarzenia. Ten raport pomaga dowiedzieć się, kiedy wystąpi zdarzenie i może pomóc w debugowaniu. Aby zgłosić wiele zdarzeń lub zdarzenia, które występują często, należy rozważyć <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> zamianę <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> lub dołączenie komunikatu do wielowierszowego <xref:System.Windows.Forms.TextBox>.  
  
 Aby uruchomić przykładowy kod, wklej go do projektu zawierającego wystąpienie typu <xref:System.Windows.Forms.HtmlElement> o nazwie. `HtmlElement1` Następnie upewnij się, że program obsługi zdarzeń jest skojarzony <xref:System.Windows.Forms.HtmlElement.MouseUp> ze zdarzeniem.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536950.aspx">Zdarzenie OnMouseUp</related>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę elementu.</summary>
        <value><see cref="T:System.String" /> Reprezentująca nazwę elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj właściwości, aby pobrać elementy z dokumentu <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> przy użyciu <xref:System.Windows.Forms.HtmlDocument>metody <xref:System.Windows.Forms.HtmlElement.All%2A> właściwości. <xref:System.Windows.Forms.HtmlElement.Name%2A>  
  
 Po zastosowaniu `INPUT` do <xref:System.Windows.Forms.HtmlElement.Name%2A> elementów definiuje nazwę zmiennej dla danych tego elementu, gdy formularz jest przesyłany do serwera.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534184.aspx">Właściwość name</related>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera następny element na tym samym poziomie co ten element w drzewie dokumentu.</summary>
        <value><see cref="T:System.Windows.Forms.HtmlElement" /> Reprezentująca element z prawej strony bieżącego elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> w połączeniu z <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> programem, aby przeszukać drzewo dokumentu dla elementu HTML.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534189.aspx">Właściwość nextSibling</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element, z którego <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> jest obliczany.</summary>
        <value>Element, z którego są obliczane przesunięcia.  
  
Jeśli element nadrzędny lub inny element w hierarchii elementu używa pozycjonowania względnego lub bezwzględnego, <see langword="OffsetParent" /> będzie to pierwszy względnie lub absolutnie pozycjonowane elementy, w których bieżący element jest zagnieżdżony. Jeśli żaden z elementów powyżej bieżącego elementu nie jest absolutnie lub relatywnie umiejscowiony <see langword="OffsetParent" /> , będzie tagiem <c>treści</c> dokumentu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy można umieścić na stronie HTML na jeden z trzech sposobów: Domyślne pozycjonowanie przepływu; Pozycjonowanie względne, w którym element jest przesunięty o stałą kwotę względem jego elementu nadrzędnego; i pozycjonowanie absolutne, w którym element otrzymuje stałą pozycję współrzędnej względem lewego górnego rogu dokumentu.  
  
 Gdy elementy dokumentu używają pozycjonowania względnego lub bezwzględnego, można `OffsetParent` użyć do obliczenia położenia współrzędne elementu w obszarze klienta.  
  
 Aby uzyskać więcej informacji na temat pozycjonowania elementów w języku HTML, zobacz [Informacje o pozycjonowaniu elementów](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> `span1` <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> jaki`span2` różne dla i: `span3`  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534302.aspx">Właściwość offsetParent</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Mierzenie wymiaru elementu i lokalizacji</related>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lokalizację elementu względem jego elementu nadrzędnego.</summary>
        <value>Współrzędne x i y elementu oraz jego szerokość i wysokość, w odniesieniu do jego elementu nadrzędnego.  
  
Jeśli element nadrzędny jest względny lub bezwzględny, <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> zwróci przesunięcie elementu nadrzędnego. Jeśli sam element jest względnie umiejscowiony w odniesieniu do <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> jego elementu nadrzędnego, zwróci przesunięcie od jego elementu nadrzędnego.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementy można umieścić na stronie HTML na jeden z trzech sposobów:  
  
-   Domyślne pozycjonowanie przepływu.  
  
-   Pozycjonowanie względne, w którym element jest przesunięty o stałą kwotę względem jego elementu nadrzędnego.  
  
-   Pozycjonowanie bezwzględne, w którym element otrzymuje stałą pozycję współrzędnej względem lewego górnego rogu dokumentu.  
  
 Aby uzyskać więcej informacji na temat pozycjonowania elementów w języku HTML, zobacz [Informacje o pozycjonowaniu elementów](https://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje, <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> `span1` <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> jaki`span2` różne dla i: `span3`  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534200.aspx">Właściwość offsetLeft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534303.aspx">Właściwość offsetTop</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534304.aspx">Właściwość offsetWidth</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534199.aspx">Właściwość offsetHeight</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms530302.aspx">Mierzenie wymiaru elementu i lokalizacji</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Sekunda <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje dwa elementy pod kątem równości.</summary>
        <returns><see langword="true" />Jeśli oba parametry są <see langword="null" />lub, jeśli oba elementy mają ten sam podstawowy interfejs com; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operator równości testuje `IUnknown` wskaźniki bazowych obiektów com opakowanych przez dostarczone <xref:System.Windows.Forms.HtmlElement> klasy.  
  
 Równoważna Metoda dla tego operatora to<xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Pierwszy <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Sekunda <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Porównuje <see cref="T:System.Windows.Forms.HtmlElement" /> dwa obiekty pod kątem nierówności.</summary>
        <returns><see langword="true" />jest tylko jeden element <see langword="null" />lub dwa obiekty nie są równe; <see langword="false" />w przeciwnym razie.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Równoważna Metoda dla tego operatora jest negacją<xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kod HTML bieżącego elementu.</summary>
        <value>Kod HTML bieżącego elementu i jego elementów podrzędnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Program zwróci cały kod HTML zawarty w bieżącym elemencie z wyjątkiem otaczających tagów bieżącego elementu, zawiera tag <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> bieżącego elementu, a także kod HTML, który zawiera tag, na przykład: <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A>  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 W tym przykładzie wywołanie metody <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> `div2` zwróci wynik:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Wywołanie <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> zwróci wynik:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Jeśli przypiszesz nową wartość do <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, odwołanie bieżącego elementu stanie się nieprawidłowe; nie będzie odzwierciedlać nazwy, właściwości i zawartości podrzędnej właśnie przypisanego kodu HTML.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534310.aspx">Właściwość outerHTML</related>
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia tekst bieżącego elementu.</summary>
        <value>Tekst wewnątrz bieżącego elementu i elementy podrzędne elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli spróbujesz przypisać HTML do elementu z <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, kod HTML będzie wyświetlany jako literały w dokumencie, podobnie jak w przypadku wyświetlania kodu HTML w pliku tekstowym. Jeśli przypiszesz kod HTML do elementu przy <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> użyciu właściwości <xref:System.Windows.Forms.HtmlElement.OuterText%2A> , zwróci cały tekst w tym kodzie HTML z usuniętym znacznikiem.  
  
 Przypisanie wartości do <xref:System.Windows.Forms.HtmlElement.OuterText%2A> spowoduje zniszczenie wszelkich elementów podrzędnych należących do elementu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Nie można ustawić tekstu spoza tego elementu.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534311.aspx">Właściwość outerText</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera element nadrzędny bieżącego elementu.</summary>
        <value>Element powyżej bieżącego elementu w hierarchii dokumentu HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość włącza odnajdywanie kontekstu elementu. Jest najbardziej przydatne w przypadku obsługi zdarzeń, takich jak <xref:System.Windows.Forms.HtmlElement.Click>, które mogą być uruchamiane dla każdego elementu w dowolnym miejscu w hierarchii obiektów dokumentu.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Właściwość elementu HTML (góra dokumentu HTML) wskazuje z powrotem do samego siebie. Jeśli wywołujesz <xref:System.Windows.Forms.HtmlElement.Parent%2A> wewnątrz pętli, sprawdź, czy warunek przerwania pętli porównuje typ bieżącego elementu i typ `Parent` właściwości, lub w przeciwnym razie kod może wykonać nieskończoną pętlę.  
  
   
  
## Examples  
 Poniższy przykład kodu znajduje `IMG` wszystkie Tagi w dokumencie i <xref:System.Windows.Forms.HtmlElement.Parent%2A> używa `IMG` właściwości, aby sprawdzić, czy jest to hiperłącze do innej strony. Jeśli tak `ALT` , kod przypisuje adres URL atrybutu `IMG`tag, dzięki czemu użytkownicy mogą przesuwać obraz, aby zobaczyć, gdzie przejdzie.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534327.aspx">Właściwość parentElement</related>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Nazwa zdarzenia do podniesienia.</param>
        <summary>Powoduje, że nazwane zdarzenie wywołuje wszystkie zarejestrowane procedury obsługi zdarzeń.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda służy do uzyskiwania dostępu do zdarzeń HTML Document Object Model (DOM). Bezpośrednio wywołuje metodę [IHTMLElement3:: FireEvent](https://go.microsoft.com/fwlink/?LinkId=103189) . Aby uzyskać więcej informacji o sposobach używania modelu Dom za <xref:System.Windows.Forms.HtmlElement> pomocą klasy, zobacz [dostęp do niewidocznych członków w zarządzanym Document Object Model HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa fokus z bieżącego elementu, jeśli ten element ma fokus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie tej metody wywołuje <xref:System.Windows.Forms.HtmlElement.LostFocus> zdarzenie dla elementu.  
  
 Gdy fokus jest wyczyszczony z elementu przy użyciu tej metody, jest on przyznany do dokumentu zawierającego element, a nie do następnego elementu w kolejności tabulacji.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536347.aspx">Blur — Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Jeśli <see langword="true" />Górna część obiektu będzie wyświetlana u góry okna. Jeśli <see langword="false" />Dolna część obiektu będzie wyświetlana u dołu okna.</param>
        <summary>Przewija dokument zawierający ten element, dopóki Górna lub dolna krawędź tego elementu jest wyrównana do okna dokumentu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykład kodu umożliwia znalezienie elementu według nazwy i przewinięcie strony w taki sposób, aby Górna część elementu była wyrównana do góry widocznej strony.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536730.aspx">scrollIntoView, Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odległość między krawędzią elementu a lewą krawędzią jego zawartości.</summary>
        <value>Odległość, w pikselach, między lewą krawędzią elementu a lewą krawędzią jego zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełne wymiary obszaru przewijania są dostępne przy użyciu polecenia <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` i<xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> są narażone niezależnie, ponieważ są to jedyne dwie właściwości obszaru przewijania, które deweloperzy mogą ustawić.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">Właściwość scrollLeft</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wymiary regionu przewijania elementu.</summary>
        <value>Rozmiar i położenie współrzędnych przewijanego obszaru elementu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Element będzie miał region przewijalny, jeśli jego zawartość przekracza rozmiar jego wymiarów, chyba że styl przepełnienia dla elementu nie Zabroń renderowania pasków przewijania.  
  
 Nie można modyfikować rozmiaru obszaru przewijania bezpośrednio, ale można modyfikować odległość między krawędziami obszaru przewijania i krawędziami elementu. Aby to osiągnąć <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> , użyj właściwości i.<xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A>  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534617.aspx">Właściwość scrollLeft</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">Właściwość scrollTop</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534615.aspx">Właściwość scrollHeight</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534619.aspx">Właściwość scrollWidth</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534312.aspx">Overflow — Właściwość</related>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia odległość między krawędzią elementu a górną krawędzią jego zawartości.</summary>
        <value>Odległość w pikselach między górną krawędzią elementu a górną krawędzią jego zawartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Pełne wymiary obszaru przewijania są dostępne przy użyciu polecenia <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> i`ScrollTop` są narażone niezależnie, ponieważ są to jedyne dwie właściwości obszaru przewijania, które deweloperzy mogą ustawić.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534618.aspx">Właściwość scrollTop</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Nazwa atrybutu do ustawienia.</param>
        <param name="value">Nowa wartość tego atrybutu.</param>
        <summary>Ustawia wartość nazwanego atrybutu w elemencie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atrybut w kodzie HTML jest dowolną poprawną parą nazwa-wartość dla tego elementu. <xref:System.Windows.Forms.HtmlElement>uwidacznia tylko te atrybuty, które są wspólne dla wszystkich elementów, pozostawiając te, które mają zastosowanie tylko do niektórych typów elementów; jest wstępnie zdefiniowanym atrybutem `IMG` dla tagu, na przykład `DIV` , ale nie dla tagu. `SRC` Używaj <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> i<xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do manipulowania atrybutami nieujawnionymi w zarządzanym Document Object Model (dom).  
  
 Jeśli `attributeName` nie jest zdefiniowanym atrybutem elementu, <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> program zdefiniuje go w elemencie jako nowy atrybut.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A>i <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> nie uwzględnia wielkości liter.  
  
 Aby ustawić `class` atrybut <xref:System.Windows.Forms.HtmlElement> na, należy odwołać się do atrybutu jako `className` podczas określania pierwszego argumentu<xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu dodaje nowy `IMG` element do bieżącego dokumentu, przy użyciu polecenia <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> do ustawiania `SRC` atrybutu dla obrazu.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms536739.aspx">SetAttribute — Metoda</related>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia rozdzielaną średnikami listę stylów dla bieżącego elementu.</summary>
        <value>Ciąg składający się ze wszystkich stylów elementu</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Document Object Model HTML (DOM) używa stylów zgodnie z definicją w specyfikacji kaskadowe arkusze stylów konsorcjum World Wide Web w celu kontrolowania wyświetlania elementu. Style we <xref:System.Windows.Forms.HtmlElement.Style%2A> właściwości przyjmuje postać par nazwa-wartość rozdzielana średnikami, a każda para oddzielona średnikami w następujący sposób:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Aby ustawić czcionkę `DIV` elementu na 14 punktów Times New Roman, na przykład, należy przypisać następujący ciąg:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Aby uzyskać pełną listę wszystkich dostępnych stylów w modelu HTML DOM, zobacz [atrybut style](https://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia lokalizację tego elementu w kolejności tabulacji.</summary>
        <value>Liczbowy indeks elementu w kolejności tabulacji.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>Określa, który element dokumentu HTML będzie dalej otrzymywać fokus, gdy użytkownik naciśnie klawisz TAB. Domyślnie jedynymi elementami zawartymi w kolejności tabulacji `INPUT` są elementy `SELECT` , kontrolka i każdy element, którego `contentEditable` właściwość jest ustawiona na `true`. Możesz dołączyć dowolny element HTML do kolejności tabulacji, na przykład `DIV`,, przypisując go jawnie. <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>  
  
 Prawidłowe wartości <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> z zakresu od-32767 do 32767.  
  
 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534654.aspx">tabIndex — Właściwość</related>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę tagu HTML.</summary>
        <value>Nazwa użyta do utworzenia tego elementu przy użyciu znacznika HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiele elementów w Document Object Model HTML ma atrybuty, właściwości i metody, które są unikatowe dla tych elementów; takie jak `HREF` atrybut `A` w elemencie lub `Submit` Metoda w `FORM`. Użyj <xref:System.Windows.Forms.HtmlElement.TagName%2A> , jeśli masz element potencjalnie dowolnego typu i musisz wykonać operację specyficzną dla typu.  
  
   
  
## Examples  
 Poniższy przykład kodu znajduje `IMG` wszystkie Tagi w dokumencie i `TagName` używa `IMG` właściwości, aby sprawdzić, czy jest to hiperłącze do innej strony. Jeśli tak `ALT` , kod przypisuje adres URL atrybutu `IMG`tag, dzięki czemu użytkownicy mogą przesuwać obraz, aby zobaczyć, gdzie przejdzie.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/ms534657.aspx">tagName — Właściwość</related>
      </Docs>
    </Member>
  </Members>
</Type>

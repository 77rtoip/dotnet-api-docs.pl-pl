<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee5a5741956a72eeb2506ea2845bf9ab2f1f66a0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36553204" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializuje i deserializuje obiekty do lub z treści wiadomości, w formacie XML na podstawie definicji schematu XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.XmlMessageFormatter> Jest domyślny element formatujący który wystąpienia <xref:System.Messaging.MessageQueue> używa do serializacji komunikatów zapisywanych w kolejce. Podczas tworzenia wystąpienia <xref:System.Messaging.MessageQueue>, wystąpienie <xref:System.Messaging.XmlMessageFormatter> jest tworzony i skojarzone z <xref:System.Messaging.MessageQueue>. Możesz określić inny element formatujący, tworząc go w kodzie i przypisywania go do <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości użytkownika <xref:System.Messaging.MessageQueue>.  
  
 Domyślne kolejki <xref:System.Messaging.XmlMessageFormatter> wystąpienie może być używane do zapisu w kolejce, ale nie można użyć do odczytu z kolejki, dopóki nie zostanie ustawiony <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwości elementu formatującego. Można ustawić jedną lub obie te wartości na domyślne wystąpienie elementu formatującego lub Utwórz nowe wystąpienie elementu formatującego i ustaw wartości automatycznie, przekazując je jako argumenty do odpowiedniej <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> konstruktora.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienia typu zaznaczono w czasie kompilacji, a nie czas odczytu, zmniejszając prawdopodobieństwo błędu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, określając jej nazwę zestawu. Co więcej podczas pracy z wieloma wersjami jednoczesnych, numer wersji musi również dołączony do również nazwę typu docelowego.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Dzięki temu program formatujący interpretować treść komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości musi być ustawiona podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwóch właściwości. Decyzja o którym właściwość do użycia jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla każdej właściwości, zostanie wygenerowany wyjątek podczas odczytywania wiadomości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest kluczowym składnikiem wiadomości luźno powiązanych opartych na języku XML. Używa narzędzia XSD.exe XML format jest używany do generowania schematu XML, na przykład przy użyciu narzędzia do serializacji klasą używaną przez aplikację. Klasa musi mieć konstruktora domyślnego.  
  
 Format jest używany ponownie w procesu narzędzie generuje klasę na podstawie schematu można dystrybuować do opisywania klasy danych. Korzystanie z narzędzia i schematu XML, który generuje pozwala uniknąć redistributing.dll pliki, zawsze skompiluj klasy po zmianie implementacji klasy. Tak długo, jak schemat nie zmienia się po stronie klienta lub serwerze, inne zmiany po obu stronach nie wpływają na drugi.  
  
   
  
## Examples  
 Poniższy przykładowy kod zawiera trzy fragmentów kodu: składnik serwera, klasa kolejności i kodu klienta. Klasa kolejności można za pomocą narzędzia XSD.exe do generowania schematu rozpoznawany przez serwer w komunikatach przychodzących. Schemat jest sformatowany plik XML, który opisuje "kształtu" klasy. Ten schemat mogą być następnie używane po stronie klienta do generowania klasy kolejności specyficzne dla klienta, które współużytkują ten sam schemat jako klasa serwera.  
  
 Poniższy przykładowy kod przedstawia składnika serwera służącą do odbierania zamówień za pośrednictwem kolejki komunikatów. Treść wiadomości powinna być obiekt kolejności którego schemat odpowiada klasie Order.cs poniżej. Proces serwera lub aplikacji deserializuje kolejności.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu reprezentuje klasę kolejność, która zapewnia schematu dla obiektów zlecenia, które otrzymuje i deserializuje aplikacji na serwerze.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Wszelkie aplikacji klienckiej, która współdziała z aplikacją na serwerze musi wysyłać wiadomości do serwera przez serializacji informacji w klasie lokalnie zdefiniowanej kolejności w treści wiadomości. Klasa lokalnie zdefiniowanej kolejności musi mieć ten sam schemat jako klasa kolejności zdefiniowanej na serwerze, do którego aplikacji na serwerze podejmie próbę deserializacji treści komunikatu. Narzędzie XSD.exe umożliwia Menedżera aplikacji na serwerze utworzyć i dystrybuować schematu, które klient musi używać do serializacji komunikatów do serwera.  
  
 Menedżer aplikacji klienckiej odbiera schemat dla klasy kolejności, narzędzie XSD.exe jest używane ponownie do generowania klasy specyficzne dla klienta kolejności ze schematu. Jest tej klasy, która jest używana w przykładzie kodu klient poniżej nie klasy kolejności serwera (narzędzie XSD.exe powoduje, że schemat wygenerowany klasy mają taką samą nazwę jak oryginalny klasy). Ta nowa klasa zlecenia służy do serializacji kolejności w treści wiadomości.  
  
 Poniższy przykładowy kod jest po stronie klienta przetwarzanie, używany do serializacji kolejności i wysyłania informacji skojarzonych z kolejnością do kolejki. Kod kojarzy elementu, ilość i adres informacje z elementy schematu, które zostały wygenerowane klasy Order.cs przez narzędzie XSD.exe. Kolejność jest wysyłany do kolejki zleceń na komputerze lokalnym.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Po schematu jest generowany na podstawie klasy kolejności na serwerze, można zmodyfikować tej klasy. Jeśli zmiany schematu, nie trzeba przeprowadzać ponownej dystrybucji schematu. Po rozproszonych schematu i wygenerowane klasy klienta kolejności tej klasy klienta można także modyfikować niezależnie od serwera kolejności klasy, tak długo, jak sam schematu nie jest modyfikowany. Dwie klasy stają się luźno powiązane.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy bez docelowego typy zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia konstruktora jest najczęściej używana podczas zapisywania w kolejce, jak typy elementów docelowych nie są wymagane podczas zapisywania.  
  
 Aby odczytać wiadomość z kolejki przy użyciu wystąpienia <xref:System.Messaging.XmlMessageFormatter> utworzony za pomocą tego konstruktora, należy ustawić <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości będzie wówczas traktował program formatujący, jakie typy aby podjąć próbę deserializacji.  
  
 Podczas tworzenia nowego <xref:System.Messaging.MessageQueue>, domyślny <xref:System.Messaging.XmlMessageFormatter> jest tworzone wystąpienie, bez zestaw typów obiektów docelowych. Podobnie jak w przypadku elementu formatującego utworzone za pomocą tego konstruktora musi ustawić typy elementów docelowych dla tego wystąpienia programu formatującego, jeśli czytania z kolejki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Tablica typu <see cref="T:System.String" /> , który określa zestaw możliwych typów, które będą deserializowane przez program formatujący z dostarczonej wiadomości. Te wartości muszą być w pełni kwalifikowana, na przykład "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy ustawienie typy elementów docelowych przekazany jako tablica wartości typu string (FQDN).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktorów z parametrami typu docelowego najczęściej używanych podczas czytania z kolejki. Podczas zapisywania, nie jest konieczne określić typy elementów docelowych.  
  
 To przeciążenie metody <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> ustawia konstruktora <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwości tablicy wartości przekazane za pośrednictwem `targetTypeNames` parametru. Ta właściwość umożliwia ustawienie <xref:System.Messaging.MessageQueue> za pomocą tej <xref:System.Messaging.XmlMessageFormatter> wystąpienie do czytania wiadomości zawiera obiekty z danego typu.  
  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Dzięki temu program formatujący interpretować treść komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości musi być ustawiona podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwóch właściwości. Wybór rodzaju, należy użyć jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla każdej właściwości, zostanie wygenerowany wyjątek w czasie odczytu.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetTypeNames" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Tablica typu <see cref="T:System.Type" /> , który określa zestaw możliwych typów, które będą deserializowane przez program formatujący z dostarczonej wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy ustawienie typy elementów docelowych przekazany jako tablicę typów obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktorów z parametrami typu docelowego najczęściej używanych podczas czytania z kolejki. Podczas zapisywania, nie jest konieczne określić typy elementów docelowych.  
  
 To przeciążenie metody <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> ustawia konstruktora <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości tablicy wartości przekazane za pośrednictwem `targetTypes` parametru. Ta właściwość umożliwia ustawienie <xref:System.Messaging.MessageQueue> za pomocą tej <xref:System.Messaging.XmlMessageFormatter> wystąpienie do czytania wiadomości zawierające obiekty danych typów.  
  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Dzięki temu program formatujący interpretować treść komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości musi być ustawiona podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwóch właściwości. Wybór rodzaju, należy użyć jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla każdej właściwości, zostanie wygenerowany wyjątek w czasie odczytu.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienia typu zaznaczono w czasie kompilacji, a nie czas odczytu, zmniejszając prawdopodobieństwo błędu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, określając jej nazwę zestawu. Co więcej podczas pracy z wieloma wersjami jednoczesnych, numer wersji musi również dołączony do również nazwę typu docelowego.  
  
 Korzystając z <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, można dodać każdego obiektu (na przykład `MyClass`) do listy w sposób dowodzą następujący kod C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetTypes" /> Parametr jest <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> Do zbadania.</param>
        <summary>Określa, czy element formatujący może wykonywać deserializację komunikatu.</summary>
        <returns>
          <see langword="true" /> Jeśli element formatujący XML może wykonywać deserializację komunikatu; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> po wywołaniu elementu formatującego próby ustalenia, czy zawartość wiadomości są coś może wykonywać deserializację. Program formatujący tylko może wykonywać deserializację komunikatu, jeśli typ w treści wiadomości ma ten sam schemat jako jeden z typów w tablicy reprezentowany przez <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Zwraca `false` w dwóch następujących okolicznościach:  
  
-   Komunikat nie został sformatowany przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Schemat treść komunikatu nie jest wymienionych w albo <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości program formatujący uzyskuje jakie typy obiektów musi być w stanie do deserializacji. Jeśli dowolny typ brakuje listy jeszcze znajduje się w komunikacie, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> zwraca `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwość została ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy odczytu/zapisu, którego właściwości (zestawy typy elementów docelowych) są takie same jak bieżące <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpienia.</summary>
        <returns>Obiekt, którego właściwości są identyczne z to <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpienia, ale których metadanych nie określa się do wystąpienia klasy elementu formatującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kopię elementu formatującego i inicjuje wszystkie właściwości z wartościami <xref:System.Messaging.XmlMessageFormatter> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" />, W formacie XML, do deserializacji.</param>
        <summary>Odczytuje zawartość z podanym komunikatem i tworzy obiekt, który zawiera komunikat zdeserializowany.</summary>
        <returns>Zdeserializowana komunikat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Jeden z tych właściwości musi być ustawiony przed można przeprowadzić deserializacji komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Aby można było zapisać do kolejki nie masz typy elementów docelowych.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwość została ustawiona.  - lub - wystąpienie serializacji w treści wiadomości nie jest zgodne ze wszystkimi schematów reprezentowany przez typy w <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> i <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwości.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które będą deserializowane przez program formatujący z dostarczonej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.String" /> , który określa typów obiektów do deserializacji z treści komunikatu podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Dzięki temu program formatujący interpretować treść komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości musi być ustawiona podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwóch właściwości. Decyzja o którym właściwość do użycia jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla każdej właściwości, zostanie wygenerowany wyjątek podczas odczytywania wiadomości.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, określając jej nazwę zestawu. Co więcej podczas pracy z wieloma wersjami jednoczesnych, numer wersji musi również dołączony do również nazwę typu docelowego.  
  
 Typy elementów docelowych to tylko wymagane podczas czytania z kolejki. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości nie muszą należeć do zapisu w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> Jest właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które będą deserializowane przez program formatujący z dostarczonej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.Type" /> , który określa typów obiektów do deserializacji z treści komunikatu podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> program formatujący uzyskuje właściwości, jakie schematów, aby podjąć próbę dopasowania, gdy podczas deserializacji komunikatu. Dzięki temu program formatujący interpretować treść komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości musi być zgodne z jednym ze schematów reprezentowane w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada schematu zidentyfikowane i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości musi być ustawiona podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwóch właściwości. Decyzja o którym właściwość do użycia jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla każdej właściwości, zostanie wygenerowany wyjątek podczas odczytywania wiadomości.  
  
 Typy elementów docelowych to tylko wymagane podczas czytania z kolejki. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości nie muszą należeć do zapisu w kolejce.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienia typu zaznaczono w czasie kompilacji, a nie czas odczytu, zmniejszając prawdopodobieństwo błędu.  
  
 Korzystając z <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, można dodać każdego obiektu (na przykład `MyClass`) do listy w sposób przedstawiona w kodzie C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> Jest właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Body" /> właściwości będzie zawierać Zserializowany obiekt.</param>
        <param name="obj">
          <see cref="T:System.Object" /> Do serializacji w treści wiadomości.</param>
        <summary>Serializuje obiektu na treść komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy elementów docelowych nie musi być określony do zapisu do kolejki, ponieważ muszą one być podczas odczytu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwość jest używana przez program formatujący tylko wtedy, gdy podczas deserializacji komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Sprawia, że użycie <xref:System.Xml.Serialization.XmlSerializer> klasy, która definiuje, jakie można serializować. Tylko publiczne pola i właściwości publiczne może być Zserializowany. Struktury, struktury z tablicami i tablice struktur są wszystkie serializacji, pod warunkiem, nie używaj styl zakodowany przy użyciu protokołu SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="message" /> Parametr jest <see langword="null" />.  - lub - <paramref name="obj" /> parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bcf03214bd0e54119fc99b044459a67f8df68556" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68396451" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializować i deserializacji obiektów do lub z treści wiadomości przy użyciu formatu XML na podstawie definicji schematu XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to domyślny program formatujący, którego <xref:System.Messaging.MessageQueue> wystąpienie używa do serializacji wiadomości zapisanych do kolejki. <xref:System.Messaging.XmlMessageFormatter> Po utworzeniu wystąpienia programu <xref:System.Messaging.MessageQueue> <xref:System.Messaging.XmlMessageFormatter> wystąpienie jest tworzone dla <xref:System.Messaging.MessageQueue>Ciebie i skojarzone z. Możesz określić inny program formatujący, tworząc go w kodzie i przypisując go do <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości. <xref:System.Messaging.MessageQueue>  
  
 Domyślnego <xref:System.Messaging.XmlMessageFormatter> wystąpienia kolejki można użyć do zapisu w kolejce, ale nie można go użyć do odczytu z kolejki do momentu ustawienia <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości lub <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> w programie formatującego. Można ustawić jedną lub obie te wartości w domyślnym wystąpieniu programu formatującego lub utworzyć nowe wystąpienie programu formatującego i ustawić wartości automatycznie przez przekazanie ich jako argumentów do odpowiedniego <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> konstruktora.  
  
 Kiedy określasz <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, zamiast, typ istnienia jest sprawdzany w czasie kompilacji zamiast czasu odczytu, zmniejszenie możliwości błędu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>wymaga, aby każdy wpis był w pełni kwalifikowany, określając jego nazwę zestawu. Ponadto w przypadku pracy z wieloma współbieżnymi wersjami numer wersji również musi być dołączony do nazwy typu docelowego.  
  
 Właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. Dzięki temu program formatujący interpretuje treść wiadomości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Podczas odczytywania z kolejki należy ustawić tylko jedną z tych właściwości, ale można ustawić oba typy. Zestaw typów jest zestawem połączonym z dwóch właściwości. Decyzja o tym, która właściwość powinna zostać użyta, jest specyficzna dla Twojej aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla jednej z tych właściwości, zostanie zgłoszony wyjątek podczas odczytywania komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest kluczowym składnikiem luźno sprzężonych komunikatów opartych na języku XML. Narzędzie XSD. exe używa formatu XML do generowania schematu XML, na przykład podczas korzystania z narzędzia do serializacji klasy używanej przez aplikację. Klasa musi mieć konstruktora bez parametrów.  
  
 Ten format jest używany ponownie w procesie wycofywania, gdy narzędzie generuje klasę na podstawie dystrybuowanego schematu, aby opisać dane klasy. Użycie narzędzia i schematu XML, który generuje, umożliwia uniknięcie redystrybucji plików DLL przy każdym ponownym skompilowaniu klasy po zmianie implementacji klasy. Dopóki schemat nie ulegnie zmianie na kliencie lub serwerze, inne zmiany po obu stronach nie wpływają na inne.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera trzy fragmenty kodu: składnik serwera, klasy zamówienia i kod klienta. Klasa Order może być używana przez narzędzie XSD. exe do generowania schematu rozpoznawanego przez serwer w wiadomościach przychodzących. Schemat jest plikiem w formacie XML, który opisuje "kształt" klasy. Tego schematu można następnie użyć po stronie klienta do wygenerowania klasy kolejności specyficznej dla klienta, która współużytkuje ten sam schemat, co Klasa serwera.  
  
 Poniższy przykład kodu reprezentuje składnik serwera, który odbiera zamówienia za pomocą kolejki komunikatów. Treść wiadomości powinna być obiektem Order, którego schemat pasuje do klasy Order.cs poniżej. Proces serwera lub aplikacja deserializacji zamówienie.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu reprezentuje klasę Order, która udostępnia schemat dla obiektów Order, które aplikacja na serwerze odbiera i deserializacji.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Wszystkie aplikacje klienckie, które współdziałają z aplikacją na serwerze programu, muszą wysyłać komunikaty do serwera przez Serializowanie informacji we zdefiniowanej lokalnie klasie Order w treści wiadomości. Klasa kolejności zdefiniowana lokalnie musi mieć ten sam schemat jak Klasa kolejności zdefiniowana przez serwer, w której aplikacja na serwerze podejmie próbę deserializacji treści komunikatu. Narzędzie XSD. exe umożliwia menedżerowi aplikacji na serwerze tworzenie i dystrybuowanie schematu, którego klient musi użyć do serializacji komunikatów wysyłanych do serwera.  
  
 Gdy Menedżer aplikacji klienckiej odbierze schemat klasy Order, narzędzie XSD. exe jest używane ponownie w celu wygenerowania klasy kolejności specyficznej dla klienta ze schematu. Jest to Klasa, która jest używana w poniższym przykładzie kodu klienta, a nie Klasa kolejności serwera (Narzędzie XSD. exe powoduje, że Klasa wygenerowana przez schemat ma taką samą nazwę jak oryginalna Klasa). Ta nowa klasa Order służy do serializacji kolejności w treści wiadomości.  
  
 Poniższy przykład kodu jest przetwarzaniem po stronie klienta używanym do serializacji zamówienia i wysyłania informacji skojarzonych z kolejnością do kolejki. Kod kojarzy element, ilość i informacje o adresie z elementami schematu, które zostały wygenerowane dla klasy Order.cs przez narzędzie XSD. exe. Zamówienie jest wysyłane do kolejki Orders na komputerze lokalnym.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Po wygenerowaniu schematu z klasy Order na serwerze można zmodyfikować klasę. Dopóki schemat nie ulegnie zmianie, nie trzeba ponownie rozpowszechniać schematu. Po przeprowadzeniu dystrybucji schematu i wygenerowaniu klasy kolejności po stronie klienta Ta klasa klienta może być również modyfikowana niezależnie od klasy kolejności serwera, o ile sam schemat nie jest modyfikowany. Dwie klasy stają się luźno sprzężone.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, bez ustawionego typu docelowego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie konstruktora jest najczęściej używane podczas zapisywania do kolejki, ponieważ typy docelowe nie są wymagane podczas pisania.  
  
 Aby odczytać komunikat z kolejki przy użyciu wystąpienia <xref:System.Messaging.XmlMessageFormatter> utworzonego za pomocą tego konstruktora, należy <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ustawić właściwości lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> , aby program formatujący wie, jakie typy próbują deserializować.  
  
 Podczas tworzenia nowego <xref:System.Messaging.MessageQueue>wystąpienia zostanie utworzone wystąpienie domyślne <xref:System.Messaging.XmlMessageFormatter> bez ustawionego typu docelowego. Podobnie jak w przypadku programu formatującego utworzonego za pomocą tego konstruktora, należy ustawić typy docelowe dla tego wystąpienia programu formatującego, jeśli chcesz odczytywać z kolejki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Tablica typu <see cref="T:System.String" /> , która określa zestaw możliwych typów, które zostaną rozszeregowane przez program formatujący z podanej wiadomości. Te wartości muszą być w pełni kwalifikowane, na przykład "Moja przestrzeń nazw. weborders, MyOrdersAssemblyName".</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, ustawiając typy docelowe przenoszone jako tablica wartości ciągu (w pełni kwalifikowanych).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktory z parametrami typu docelowego są najczęściej używane podczas odczytywania z kolejki. Podczas pisania nie trzeba określać typów docelowych.  
  
 To Przeciążenie <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> konstruktora <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ustawia właściwość na `targetTypeNames` wartości tablicy przekazaną za pomocą parametru. Ustawienie tej właściwości umożliwia <xref:System.Messaging.MessageQueue> używanie tego <xref:System.Messaging.XmlMessageFormatter> wystąpienia do odczytu komunikatów zawierających obiekty danego typu.  
  
 Obie właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> i informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Dzięki temu program formatujący interpretuje treść wiadomości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Podczas odczytywania z kolejki należy ustawić tylko jedną z tych właściwości, ale można ustawić oba typy. Zestaw typów jest zestawem połączonym z dwóch właściwości. Decyzja, która ma zostać użyta, jest specyficzna dla Twojej aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla jednej z tych właściwości, zostanie zgłoszony wyjątek w czasie odczytywania.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="targetTypeNames" /></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Tablica typu <see cref="T:System.Type" /> , która określa zestaw możliwych typów, które zostaną rozszeregowane przez program formatujący z podanej wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, ustawiając typy docelowe przenoszone jako tablica typów obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktory z parametrami typu docelowego są najczęściej używane podczas odczytywania z kolejki. Podczas pisania nie trzeba określać typów docelowych.  
  
 To Przeciążenie <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> konstruktora <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ustawia właściwość na `targetTypes` wartości tablicy przekazaną za pomocą parametru. Ustawienie tej właściwości umożliwia <xref:System.Messaging.MessageQueue> używanie tego <xref:System.Messaging.XmlMessageFormatter> wystąpienia do odczytu komunikatów zawierających obiekty danego typu.  
  
 Obie właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> i informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Dzięki temu program formatujący interpretuje treść wiadomości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Podczas odczytywania z kolejki należy ustawić tylko jedną z tych właściwości, ale można ustawić oba typy. Zestaw typów jest zestawem połączonym z dwóch właściwości. Decyzja, która ma zostać użyta, jest specyficzna dla Twojej aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla jednej z tych właściwości, zostanie zgłoszony wyjątek w czasie odczytywania.  
  
 Kiedy określasz <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, zamiast, typ istnienia jest sprawdzany w czasie kompilacji zamiast czasu odczytu, zmniejszenie możliwości błędu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>wymaga, aby każdy wpis był w pełni kwalifikowany, określając jego nazwę zestawu. Ponadto w przypadku pracy z wieloma współbieżnymi wersjami numer wersji również musi być dołączony do nazwy typu docelowego.  
  
 Korzystając <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>z programu, można dodać każdy obiekt (na `MyClass`przykład) do listy w sposób pokazany przez Poniższy C# kod.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="targetTypes" /></exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" /> Do inspekcji.</param>
        <summary>Określa, czy program formatujący może deserializować komunikat.</summary>
        <returns><see langword="true" />Jeśli program formatujący XML może deserializować komunikat; w przeciwnym razie. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> jest wywoływana, program formatujący próbuje określić, czy zawartość komunikatu jest coś, którego może deserializować. Program formatujący może deserializować komunikat tylko wtedy, gdy typ w treści komunikatu ma taki sam schemat jak jeden z typów w tablicy reprezentowane przez <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwości i. <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.CanRead%2A>zwraca `false` w następujących dwóch okolicznościach:  
  
-   Komunikat nie został sformatowany przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Schemat treści komunikatu nie należy do tych wymienionych w <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwości lub. <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>  
  
 Właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> informują program formatujący o typach obiektów, które muszą być w stanie deserializować. Jeśli na liście nie ma żadnego typu, jest on jeszcze znaleziony w komunikacie <xref:System.Messaging.XmlMessageFormatter.CanRead%2A>. `false`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ustawiono ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwości ani.<see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="message" /></exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, której właściwości odczytu/zapisu (zestawy typów docelowych) są takie same jak bieżące <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpienie.</summary>
        <returns>Obiekt, którego właściwości są identyczne z tymi <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpieniami, ale których metadane nie określają, jako wystąpienia klasy programu formatującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kopię programu formatującego i inicjuje wszystkie jej właściwości do wartości tego <xref:System.Messaging.XmlMessageFormatter> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" />, W formacie XML, do deserializacji.</param>
        <summary>Odczytuje zawartość z danego komunikatu i tworzy obiekt, który zawiera deserializowany komunikat.</summary>
        <returns>Komunikat z deserializowanym.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obie właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> i informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Aby można było deserializować komunikat, należy ustawić jedną z tych właściwości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Nie trzeba określać typów docelowych w celu zapisu do kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie ustawiono ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwości ani.<see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />  
  
—lub— 
Serializacja wystąpienia w treści komunikatu nie jest zgodna z żadnym schematem reprezentowanym przez typy we <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> właściwościach i. <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /></exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="message" /></exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które zostaną rozszeregowane przez program formatujący z podanej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.String" /> , która określa typy obiektów do deserializacji z treści wiadomości podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obie właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> i informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Dzięki temu program formatujący interpretuje treść wiadomości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Podczas odczytywania z kolejki należy ustawić tylko jedną z tych właściwości, ale można ustawić oba typy. Zestaw typów jest zestawem połączonym z dwóch właściwości. Decyzja o tym, która właściwość powinna zostać użyta, jest specyficzna dla Twojej aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla jednej z tych właściwości, zostanie zgłoszony wyjątek podczas odczytywania komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>wymaga, aby każdy wpis był w pełni kwalifikowany, określając jego nazwę zestawu. Ponadto w przypadku pracy z wieloma współbieżnymi wersjami numer wersji również musi być dołączony do nazwy typu docelowego.  
  
 Typy docelowe są wymagane tylko podczas odczytywania z kolejki. Właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> nie muszą być ustawione do zapisu w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> Właściwość jest<see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które zostaną rozszeregowane przez program formatujący z podanej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.Type" /> , która określa typy obiektów do deserializacji z treści wiadomości podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obie właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> i informują program formatujący, jakie schematy próbują dopasować podczas deserializacji komunikatu. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Dzięki temu program formatujący interpretuje treść wiadomości.  
  
 Serializacja wystąpienia w treści komunikatu musi być zgodna z jednym ze schematów przedstawionych w tablicy typów. Gdy odczytujesz komunikat przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odpowiada określonemu schematowi i odczytuje do niego treść komunikatu.  
  
 Podczas odczytywania z kolejki należy ustawić tylko jedną z tych właściwości, ale można ustawić oba typy. Zestaw typów jest zestawem połączonym z dwóch właściwości. Decyzja o tym, która właściwość powinna zostać użyta, jest specyficzna dla Twojej aplikacji. Jeśli treść wiadomości zawiera typ, którego schemat nie pasuje do żadnego z typów w tablicy dla jednej z tych właściwości, zostanie zgłoszony wyjątek podczas odczytywania komunikatu.  
  
 Typy docelowe są wymagane tylko podczas odczytywania z kolejki. Właściwości <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> nie muszą być ustawione do zapisu w kolejce.  
  
 Kiedy określasz <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, zamiast, typ istnienia jest sprawdzany w czasie kompilacji zamiast czasu odczytu, zmniejszenie możliwości błędu.  
  
 Korzystając <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>z programu, można dodać każdy obiekt (na `MyClass`przykład) do listy w sposób pokazany przez `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};` C# kod.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> Właściwość jest<see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">Właściwość, która <see cref="T:System.Messaging.Message" /> będzie zawierać serializowany obiekt. <see cref="P:System.Messaging.Message.Body" /></param>
        <param name="obj"><see cref="T:System.Object" /> Aby można było zserializować do treści komunikatu.</param>
        <summary>Serializacja obiektu w treści wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nie trzeba określać typów docelowych do zapisu w kolejce, ponieważ muszą one znajdować się podczas odczytu. Właściwość <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> or<xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> jest używana przez program formatujący tylko podczas deserializacji komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Używa<xref:System.Xml.Serialization.XmlSerializer> klasy, która definiuje, co może być serializowane. Tylko pola publiczne i właściwości publiczne mogą być serializowane. Struktury, struktury z tablicami i tablice struktur są możliwe do serializacji, o ile nie używają stylu zakodowanego w protokole SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="message" />  
  
—lub— 
Parametr ma wartość <see langword="null" />. <paramref name="obj" /></exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>
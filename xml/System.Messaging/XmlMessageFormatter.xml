<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f84dce420bbd218ac7a5239c45ed08057c395a0c" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53504444" /></Metadata><TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlMessageFormatter&#xA;Implements ICloneable, IMessageFormatter" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlMessageFormatter : ICloneable, System::Messaging::IMessageFormatter" />
  <TypeSignature Language="F#" Value="type XmlMessageFormatter = class&#xA;    interface IMessageFormatter&#xA;    interface ICloneable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializuje i deserializuje obiektów do i z treści wiadomości, w formacie XML na podstawie definicji schematu XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.XmlMessageFormatter> Jest domyślny element formatujący, wystąpienie <xref:System.Messaging.MessageQueue> używa do serializacji komunikatów zapisywanych w kolejce. Po utworzeniu wystąpienia <xref:System.Messaging.MessageQueue>, wystąpienie <xref:System.Messaging.XmlMessageFormatter> jest utworzony i skojarzony z <xref:System.Messaging.MessageQueue>. Możesz określić inny element formatujący, tworząc go w kodzie i przypisując go do <xref:System.Messaging.MessageQueue.Formatter%2A> właściwości usługi <xref:System.Messaging.MessageQueue>.  
  
 Domyślna kolejka <xref:System.Messaging.XmlMessageFormatter> wystąpienia może służyć do zapisu w kolejce, ale nie można użyć do odczytu z kolejki, dopóki nie zostanie ustawiony <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwość elementu formatującego. Można ustawić jedną lub obie te wartości w domyślnym wystąpieniu elementu formatującego lub Utwórz nowe wystąpienie elementu formatującego i ustaw wartości automatycznie, przekazując je jako argumenty do odpowiedniego <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> konstruktora.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienie typu jest sprawdzany w czasie kompilacji, a nie czasu odczytu, co zmniejsza prawdopodobieństwo błędów. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, podając jego nazwę zestawu. Co więcej podczas pracy z wieloma wersjami współbieżnych, numer wersji musi również dołączana do nazwy typu docelowego także.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Dzięki temu program formatujący interpretowanie treści komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości należy ustawić podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwie właściwości. Decyzja do użycia dla którym właściwość jest specyficzny dla aplikacji. Jeśli treść wiadomości zawiera typ nie pasuje do żadnego z typów w tablicy dla żadnej właściwości, którego schemat, zostanie zgłoszony wyjątek, gdy komunikat został odczytany.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest kluczowym składnikiem luźno powiązanych opartych na języku XML do obsługi komunikatów. Zastosowań narzędzia XSD.exe, na format XML jest używany do generowania schematu XML, takie jak podczas serializacji klasę, używanych przez aplikację za pomocą narzędzia. Klasa musi mieć domyślnego konstruktora.  
  
 Format jest używany ponownie w procesu narzędzie generuje klasę, na podstawie schematu można dystrybuować do opisują dane klasy. Korzystanie z narzędzia i schematu XML, który generuje pozwala uniknąć redistributing.dll plików, za każdym razem, gdy zostanie ponownie skompilowany klasy po zmianie implementacji klasy. Tak długo, jak schemat nie zmienia się po stronie klienta lub serwera, inne zmiany po obu stronach nie wpływają na drugi.  
  
   
  
## Examples  
 Poniższy przykład kodu zawiera trzy fragmentów kodu: składnik serwera, klasa kolejności i kod klienta. Klasa zamówienia może służyć za pomocą narzędzia XSD.exe do generowania schematu, który serwer rozpoznaje w przychodzących wiadomościach. Schemat jest sformatowany plik XML, który opisuje "kształt" klasy. Ten schemat mogą być następnie używane po stronie klienta do generowania klasy kolejności specyficzne dla klienta, która współużytkuje ten sam schemat, jak klasa serwera.  
  
 Poniższy przykład kodu przedstawia składnika serwera, który odbiera zamówień za pośrednictwem kolejki komunikatów. Treść komunikatu powinna być obiekt zamówienia, którego schemat jest zgodny klasy Order.cs poniżej. Proces serwera lub aplikacji deserializuje kolejności.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 Poniższy przykład kodu reprezentuje klasę kolejność, która zawiera schemat dla obiektów zamówienia, które aplikacji na serwerze odbiera i deserializuje.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Każda aplikacja kliencka, która wchodzi w interakcję z aplikacją na serwerze musi wysyłać wiadomości do serwera informacje o serializacji w klasie zdefiniowanej lokalnie zamówienia w treści wiadomości. Klasa lokalnie zdefiniowanej kolejności musi mieć ten sam schemat, jak klasa kolejności zdefiniowanej na serwerze, do którego aplikacji na serwerze będzie podejmować próby deserializacji treści komunikatu. Narzędzia XSD.exe służy Menedżer aplikacji na serwerze, tworzenie i rozpowszechnianie schematu, które klient musi używać do wykonywania serializacji komunikaty przesyłane na serwer.  
  
 Gdy Menedżer aplikacja kliencka odbiera schemat dla klasy kolejności, z narzędzia XSD.exe służy ponownie do generowania klasy specyficzne dla klienta kolejności ze schematu. Jest to klasy, która jest używana w przykładzie kodu klient poniżej nie klasy kolejności serwera (z narzędzia XSD.exe powoduje, że schemat wygenerowany klasy, która ma mieć taką samą nazwę jak oryginalny klasy). Ta nowa klasa zlecenia służy do wykonywania serializacji kolejności do treści wiadomości.  
  
 Poniższy przykład kodu jest klienta przetwarzania, służy do serializacji zamówienie i wysyłać je skojarzonego z zamówieniem do kolejki. Kod kojarzy elementu, ilości i adres informacje z elementy schematu, które zostały wygenerowane klasy Order.cs za pomocą narzędzia XSD.exe. Zamówienie jest wysyłany do kolejki zamówienia na komputerze lokalnym.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Po schematu jest generowany na podstawie klasy kolejności na serwerze, można zmodyfikować tej klasy. Chyba, że zmiany schematu, nie trzeba przeprowadzać ponownej dystrybucji schematu. Po rozproszonych schematu i wygenerowane klasy zamówienia klienta tej klasy klienta można także modyfikować niezależnie od serwera klasy zamówienia, tak długo, jak sam schemat nie został zmodyfikowany. Dwie klasy stają się luźno powiązane.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
    <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
    <altmember cref="T:System.Messaging.IMessageFormatter" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy bez docelowego typy zestawu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia konstruktora używana najczęściej podczas zapisywania do kolejki, ponieważ typy elementów docelowych nie są wymagane podczas pisania.  
  
 Aby odczytywać komunikaty z kolejki za pomocą wystąpienia <xref:System.Messaging.XmlMessageFormatter> utworzony za pomocą tego konstruktora, należy ustawić <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości, aby element formatujący wie, jakie typy próby deserializacji.  
  
 Podczas tworzenia nowego <xref:System.Messaging.MessageQueue>, domyślny <xref:System.Messaging.XmlMessageFormatter> tworzone jest wystąpienie bez docelowy zestaw typów. Podobnie jak w przypadku elementu formatującego utworzone za pomocą tego konstruktora, należy ustawić typy elementów docelowych dla tego wystąpienia programu formatującego, jeśli ma zostać odczytany z kolejki.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypeNames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;System::String ^&gt; ^ targetTypeNames);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : string[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypeNames" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Tablica typu <see cref="T:System.String" /> , który określa zestaw możliwych typów, które zostanie przeprowadzona przez program formatujący dostarczonej wiadomości. Te wartości muszą być w pełni kwalifikowana, na przykład "MyNamespace.MyOrders, MyOrdersAssemblyName".</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, ustawienie typy elementów docelowych przekazywane w postaci tablicy wartości typu ciąg (FQDN).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktorów z parametrami typu docelowego są najczęściej używane podczas czytania z kolejki. Podczas pisania, nie jest to konieczne określić typy elementów docelowych.  
  
 To przeciążenie <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> zestawy Konstruktor <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> właściwości tablicy wartości przekazane za pośrednictwem `targetTypeNames` parametru. Ta właściwość umożliwia ustawienie <xref:System.Messaging.MessageQueue> za pomocą tego <xref:System.Messaging.XmlMessageFormatter> wystąpienia do odczytywania komunikatów zawierających obiekty danego typu.  
  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Dzięki temu program formatujący interpretowanie treści komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości należy ustawić podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwie właściwości. Decyzja, należy użyć jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ nie pasuje do żadnego z typów w tablicy dla żadnej właściwości, którego schemat, zostanie zgłoszony wyjątek w czasie odczytu.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetTypeNames" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (targetTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlMessageFormatter(cli::array &lt;Type ^&gt; ^ targetTypes);" />
      <MemberSignature Language="F#" Value="new System.Messaging.XmlMessageFormatter : Type[] -&gt; System.Messaging.XmlMessageFormatter" Usage="new System.Messaging.XmlMessageFormatter targetTypes" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Tablica typu <see cref="T:System.Type" /> , który określa zestaw możliwych typów, które zostanie przeprowadzona przez program formatujący dostarczonej wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy, ustawienie typy elementów docelowych przekazywane w postaci tablicy typów obiektów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Konstruktorów z parametrami typu docelowego są najczęściej używane podczas czytania z kolejki. Podczas pisania, nie jest to konieczne określić typy elementów docelowych.  
  
 To przeciążenie <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> zestawy Konstruktor <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości tablicy wartości przekazane za pośrednictwem `targetTypes` parametru. Ta właściwość umożliwia ustawienie <xref:System.Messaging.MessageQueue> za pomocą tego <xref:System.Messaging.XmlMessageFormatter> wystąpienia do odczytywania komunikatów zawierających obiekty danego typu.  
  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Dzięki temu program formatujący interpretowanie treści komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości należy ustawić podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwie właściwości. Decyzja, należy użyć jest specyficzne dla aplikacji. Jeśli treść wiadomości zawiera typ nie pasuje do żadnego z typów w tablicy dla żadnej właściwości, którego schemat, zostanie zgłoszony wyjątek w czasie odczytu.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienie typu jest sprawdzany w czasie kompilacji, a nie czasu odczytu, co zmniejsza prawdopodobieństwo błędów. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, podając jego nazwę zestawu. Co więcej podczas pracy z wieloma wersjami współbieżnych, numer wersji musi również dołączana do nazwy typu docelowego także.  
  
 Korzystając z <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, można dodać każdy obiekt (na przykład `MyClass`) do listy w taki sposób, przedstawiona przez następujący kod C#.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="targetTypes" /> Parametr <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanRead(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member CanRead : System.Messaging.Message -&gt; bool&#xA;override this.CanRead : System.Messaging.Message -&gt; bool" Usage="xmlMessageFormatter.CanRead message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" /> Do wglądu.</param>
        <summary>Określa, czy element formatujący może wykonywać deserializację wiadomości.</summary>
        <returns><see langword="true" /> Jeśli element formatujący XML może wykonywać deserializację message; w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> jest wywoływana, element formatujący próbuje określić, czy zawartość wiadomości są coś, co może wykonywać deserializację. Element formatujący może deserializacji komunikatu tylko, jeśli typ w treści komunikatu ma ten sam schemat, jak jeden z typów w tablicy, reprezentowane przez <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> Zwraca `false` w następujących dwóch okolicznościach:  
  
-   Komunikat nie został sformatowany przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
-   Schemat treść komunikatu nie znajduje się wśród tych wymienionych w jednym <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie typy obiektów musi być w stanie wykonać deserializacji. Jeśli dowolny typ nie ma na liście, ale można znaleźć w komunikacie <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> zwraca `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwość została ustawiona.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="message" /> Parametr <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="xmlMessageFormatter.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy wystąpienie <see cref="T:System.Messaging.XmlMessageFormatter" /> klasy odczytu/zapisu, którego właściwości (zestawy typy elementów docelowych) są takie same jak bieżące <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpienia.</summary>
        <returns>Obiekt, którego właściwości są identyczne z tymi tego <see cref="T:System.Messaging.XmlMessageFormatter" /> wystąpienia, ale których metadanych nie określa się wystąpienia klasy elementu formatującego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda tworzy kopię elementu formatującego i inicjuje wszystkie właściwości do wartości tego <xref:System.Messaging.XmlMessageFormatter> obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.IMessageFormatter" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Read(System::Messaging::Message ^ message);" />
      <MemberSignature Language="F#" Value="abstract member Read : System.Messaging.Message -&gt; obj&#xA;override this.Read : System.Messaging.Message -&gt; obj" Usage="xmlMessageFormatter.Read message" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Read(System.Messaging.Message)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" />, W formacie XML do deserializacji.</param>
        <summary>Odczytuje zawartość z podanym komunikatem i tworzy obiekt, który zawiera komunikat po deserializacji.</summary>
        <returns>Komunikat po deserializacji.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Jedną z tych właściwości należy ustawić przed komunikat może być zdeserializowany.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Typy elementów docelowych jest konieczne można określić w celu zapisania w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> ani <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwość została ustawiona.  
  
—lub— 
Wystąpienie serializacji w treści komunikatu nie spełnia żadnego schematów, reprezentowane przez typy w <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> i <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> właściwości.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="message" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypeNames As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ TargetTypeNames { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypeNames : string[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które zostanie przeprowadzona przez program formatujący dostarczonej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.String" /> Określa typy obiektów do deserializacji z treści komunikatu podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Dzięki temu program formatujący interpretowanie treści komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości należy ustawić podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwie właściwości. Decyzja do użycia dla którym właściwość jest specyficzny dla aplikacji. Jeśli treść wiadomości zawiera typ nie pasuje do żadnego z typów w tablicy dla żadnej właściwości, którego schemat, zostanie zgłoszony wyjątek, gdy komunikat został odczytany.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> wymaga każdy wpis, aby być w pełni kwalifikowana, podając jego nazwę zestawu. Co więcej podczas pracy z wieloma wersjami współbieżnych, numer wersji musi również dołączana do nazwy typu docelowego także.  
  
 Typy elementów docelowych, to tylko wymagane podczas czytania z kolejki. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości nie muszą być ustawione na zapis do kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> Właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetTypes As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;Type ^&gt; ^ TargetTypes { cli::array &lt;Type ^&gt; ^ get(); void set(cli::array &lt;Type ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetTypes : Type[] with get, set" Usage="System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa zestaw możliwych typów, które zostanie przeprowadzona przez program formatujący dostarczonej wiadomości.</summary>
        <value>Tablica typu <see cref="T:System.Type" /> Określa typy obiektów do deserializacji z treści komunikatu podczas odczytywania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zarówno <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości Poinformuj elementu formatującego, jakie schematów w celu podjęcia próby dopasowania podczas deserializacji komunikatu. Dzięki temu program formatujący interpretowanie treści komunikatu.  
  
 Wystąpienie serializacji w treści wiadomości muszą być zgodne z jednym ze schematów, reprezentowany w tablicy typu. Podczas odczytu wiadomości przy użyciu <xref:System.Messaging.MessageQueue.Receive%2A> metody, metoda tworzy obiekt typu, który odnosi się do schematu, zidentyfikować i odczytuje treść komunikatu do niego.  
  
 Tylko jeden z dwóch właściwości należy ustawić podczas czytania z kolejki, ale można ustawić jednocześnie. Zestaw typów jest połączony zestaw z dwie właściwości. Decyzja do użycia dla którym właściwość jest specyficzny dla aplikacji. Jeśli treść wiadomości zawiera typ nie pasuje do żadnego z typów w tablicy dla żadnej właściwości, którego schemat, zostanie zgłoszony wyjątek, gdy komunikat został odczytany.  
  
 Typy elementów docelowych, to tylko wymagane podczas czytania z kolejki. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> i <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwości nie muszą być ustawione na zapis do kolejki.  
  
 Podczas określania <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> zamiast <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, istnienie typu jest sprawdzany w czasie kompilacji, a nie czasu odczytu, co zmniejsza prawdopodobieństwo błędów.  
  
 Korzystając z <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, można dodać każdy obiekt (na przykład `MyClass`) do listy w taki sposób, przedstawiona w kodzie C# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat, który zawiera zamówienia z kolejki.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> Właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="M:System.Messaging.XmlMessageFormatter.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Write(System::Messaging::Message ^ message, System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.Messaging.Message * obj -&gt; unit&#xA;override this.Write : System.Messaging.Message * obj -&gt; unit" Usage="xmlMessageFormatter.Write (message, obj)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Messaging.IMessageFormatter.Write(System.Messaging.Message,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message"><see cref="T:System.Messaging.Message" /> Którego <see cref="P:System.Messaging.Message.Body" /> właściwość będzie zawierać Zserializowany obiekt.</param>
        <param name="obj"><see cref="T:System.Object" /> Serializacji w treści wiadomości.</param>
        <summary>Serializuje obiekt w treści wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Typy elementów docelowych, nie musi być określony do zapisu w kolejce, ponieważ muszą być podczas odczytywania. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> Lub <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> właściwość jest używana przez program formatujący, tylko wtedy, gdy podczas deserializacji komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Sprawia, że użycie <xref:System.Xml.Serialization.XmlSerializer> klasy, która definiuje, co może być serializowany. Tylko pola publiczne i właściwości publiczne może być serializowany. Struktury, struktury z tablicami i tablic struktur są wszystkie możliwe do serializacji, tak długo, jak należy używać zakodowany stylu przy użyciu protokołu SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="message" /> Parametr <see langword="null" />.  
  
—lub— 
<paramref name="obj" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      </Docs>
    </Member>
  </Members>
</Type>
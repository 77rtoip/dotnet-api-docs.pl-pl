<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ad7acb0d32b9a05dce69496cdb0e4f4aada33827" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233409" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do właściwości niezbędnej do zdefiniowania komunikatów usługi kolejkowania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.Message> klasy wgląd ani odbierać wiadomości z kolejki, lub szczegółową kontrolę właściwości komunikatu podczas wysyłania komunikatu do kolejki.  
  
 <xref:System.Messaging.MessageQueue> używa <xref:System.Messaging.Message> klasy, gdy dokonuje lub odbiera komunikaty z kolejki, ponieważ zarówno <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> i <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> metody tworzą nowe wystąpienie klasy <xref:System.Messaging.Message> klasy, a następnie ustaw właściwości wystąpienia. <xref:System.Messaging.Message> Dotyczą pobieranie komunikatów z kolejki, natomiast właściwości odczytu/zapisu dotyczy przesyłanie i pobieranie wiadomości tylko do odczytu właściwości tej klasy. Gdy <xref:System.Messaging.MessageQueue> dokonuje lub otrzymuje komunikat z kolejki, jego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwość określa, które właściwości wiadomości są pobierane.  
  
 <xref:System.Messaging.MessageQueue> Klasy <xref:System.Messaging.MessageQueue.Send%2A> metody umożliwia określenie dowolnego typu obiektu dla wiadomości wysyłanych do tej kolejki. Możesz użyć <xref:System.Messaging.MessageQueue> wystąpienia <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwości w celu określenia ustawień ogólnych komunikatów wysłanych do kolejki. Rodzaje ustawień obejmują program formatujący, etykiety, szyfrowania i uwierzytelniania. Można również określić wartości dla odpowiednich <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementów członkowskich, gdy koordynować obsługi komunikatów aplikacji odpowiada na komunikaty po potwierdzeniu i raportów. Za pomocą <xref:System.Messaging.Message> wystąpienia, aby wysłać komunikat do kolejki zapewnia elastyczność wiele z tych właściwości - pojedynczej wiadomości lub na podstawie komunikatu, komunikat o modyfikacji i dostępu. <xref:System.Messaging.Message> właściwości mają pierwszeństwo względem <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Komunikat dane są przechowywane w <xref:System.Messaging.Message.Body%2A> właściwości i w mniejszym stopniu <xref:System.Messaging.Message.AppSpecific%2A> i <xref:System.Messaging.Message.Extension%2A> właściwości. Gdy dane wiadomości jest zaszyfrowany, serializowany lub deserializowany tylko zawartość <xref:System.Messaging.Message.Body%2A> właściwość ma wpływ.  
  
 Zawartość <xref:System.Messaging.Message.Body%2A> właściwości są serializowane, gdy komunikat jest wysyłany przy użyciu <xref:System.Messaging.Message.Formatter%2A> właściwości, które określisz. Zserializowany zawartości znajdują się w <xref:System.Messaging.Message.BodyStream%2A> właściwości. Można również ustawić <xref:System.Messaging.Message.BodyStream%2A> właściwości bezpośrednio, na przykład, aby wysłać plik jako zawartość danych wiadomości. Możesz zmienić <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwości w dowolnym momencie przed wysłaniem wiadomości i dane będą wykonywane szeregowo odpowiednio po wywołaniu <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Właściwości zdefiniowane przez <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> właściwości mają zastosowanie tylko do wiadomości, które nie mają wartości typu <xref:System.Messaging.Message>. Jeśli określisz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwość <xref:System.Messaging.MessageQueue>, identycznie nazwane właściwości w <xref:System.Messaging.Message> wystąpienia wysyłane do tej kolejki Przyczyna te domyślne właściwości mają być ignorowane.  
  
 Aby uzyskać listę początkowe wartości właściwości wystąpienia <xref:System.Messaging.Message>, zobacz <xref:System.Messaging.Message.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy o pustej treści.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasy, która ma pustą treść.  
  
 Wybierz opcję <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. <xref:System.Messaging.Message.Body%2A> Właściwość może być dowolny obiekt, który może być serializowany, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.  
  
 O ile nie bezpośrednio do pisania treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> , właściwością <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Treść jest serializowana, za pomocą <xref:System.Messaging.Message.Formatter%2A> wartości właściwości w czasie <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno powiązane, więc nie ma tego samego obiektu, wpisz na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializowania danych do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub odbierania składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt do zserializowania do treści wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy przy użyciu <see cref="T:System.Messaging.XmlMessageFormatter" /> do serializacji określonego obiektu na treść komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasę, która zawiera <xref:System.Messaging.Message.Body%2A> określony przez `body` parametru. `body` Parametr może być dowolnego obiektu, który może być serializowany, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Treść jest serializowana, za pomocą <xref:System.Messaging.XmlMessageFormatter> chyba że zmienił się <xref:System.Messaging.Message.Formatter%2A> właściwości przed <xref:System.Messaging.Message> są wysyłane. Jeśli zmienisz <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwość w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomość będzie serializowana zgodnie z nową wartość właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno powiązane, więc nie ma tego samego obiektu, wpisz na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializowania danych do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub odbierania składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametru.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową kolejkę, wysyła komunikat, który zawiera zamówienie do niego, a następnie pobiera go.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt do zserializowania do treści wiadomości.</param>
        <param name="formatter">A <see cref="T:System.Messaging.IMessageFormatter" /> , określa program formatujący, z którą ma zostać serializacji treści komunikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> przy użyciu określonego elementu formatującego do serializacji określonego obiektu na treść komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasę, która zawiera <xref:System.Messaging.Message.Body%2A> określony przez `body` parametr i korzysta z żadnych prawidłowy element formatujący do serializacji treści. `body` Parametr jest dowolny obiekt, który może być serializowany, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Jeśli zmienisz <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwość w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomość będzie serializowana zgodnie z nową wartość właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno powiązane, więc nie ma tego samego obiektu, wpisz na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializowania danych do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub odbierania składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametru.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` Parametru.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablicą o zerowej długości w bajtach|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ komunikatu potwierdzającego do zwrócenia do aplikacji wysyłającej.</summary>
        <value>Jedną z <see cref="T:System.Messaging.AcknowledgeTypes" /> wartości, które reprezentują typy komunikatów potwierdzenia, system zapisuje kolejkę administracyjną i warunki, w których są zwracane do aplikacji wysyłającej potwierdzenia. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość określa typ wiadomości potwierdzające żądane przez aplikację wysyłającą. Ustaw <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości przed wysłaniem wiadomość, aby powiadomienia o niektórych wystąpień — na przykład, komunikat docieranie do kolejki docelowej, trwa pobieranie wiadomości lub przekroczenia limitu czasu, wiadomość uniemożliwia osiągnięcie lub pobieraniu z kolejki docelowej.  
  
 Usługa kolejkowania komunikatów zwraca powiadomień, wysyłając komunikatów potwierdzenia <xref:System.Messaging.Message.AdministrationQueue%2A> właściwość określoną przez oryginalnej wiadomości. Wiadomości potwierdzającej <xref:System.Messaging.Message.Acknowledgment%2A> właściwość wskazuje typ potwierdzenia, który reprezentuje. Na przykład, jeśli wiadomości potwierdzającej została wysłana, ponieważ komunikat nie dotarła docelowym przed <xref:System.Messaging.Message.TimeToReachQueue%2A> minął, <xref:System.Messaging.Message.Acknowledgment%2A> właściwości komunikatu potwierdzającego będzie zawierał wartość `ReachQueueTimeout`.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat zawierający zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Komunikat jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AcknowledgeType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasyfikację potwierdzenia, który reprezentuje tę wiadomość.</summary>
        <value>Jedną z <see cref="T:System.Messaging.Acknowledgment" /> wartości wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy otrzymasz wiadomość z kolejki administracyjnej odczytywać <xref:System.Messaging.Message.Acknowledgment%2A> właściwości, aby sprawdzić stan oryginalnej wiadomości.  
  
 Po wysłaniu komunikatu do kolejki docelowej, usługi kolejkowania komunikatów może być wysłane do publikowania wiadomości potwierdzającej. Taki komunikat może wskazywać, na przykład wiadomość dotarła i czy został pobrany w ramach określonego limitu czasu, czy można wskazać, co poszło źle w przypadku niepowodzenia dostarczenia. Kolejka docelowa zwraca potwierdzenia komunikatów i zapisuje je do kolejki administracyjnej określonej w oryginalnej wiadomości <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości. <xref:System.Messaging.Message.Id%2A> Własności wiadomości potwierdzającej identyfikuje komunikatu potwierdzającego, a nie oryginalnego komunikatu. Identyfikator oryginalnego komunikatu można znaleźć w potwierdzenie <xref:System.Messaging.Message> wystąpienia <xref:System.Messaging.Message.CorrelationId%2A> właściwości.  
  
 Jeśli ten <xref:System.Messaging.Message> wystąpienie reprezentuje wiadomości potwierdzającej <xref:System.Messaging.Message.Acknowledgment%2A> właściwość określa typ potwierdzenia. W przeciwnym razie <xref:System.Messaging.Message.Acknowledgment%2A> właściwość zawiera wartość `Normal`.  
  
 Użyj <xref:System.Messaging.Message.AcknowledgeType%2A> właściwość oryginalnej wiadomości, aby określić okoliczności, w których zostanie zwrócony potwierdzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejki, która odbiera komunikaty potwierdzenia, które generuje usługi kolejkowania komunikatów.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> Określający kolejkę administracyjną wiadomości potwierdzenia generowanych przez system. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejkę określoną w <xref:System.Messaging.Message.AdministrationQueue%2A> właściwość może być dowolna kolejka nietransakcyjna. Potwierdzenia wiadomości do kolejki administracyjnej można wskazać, czy oryginalna wiadomość dotarła kolejki docelowej i czy została usunięta z kolejki.  
  
 Gdy <xref:System.Messaging.Message.AcknowledgeType%2A> właściwość ma żadnych wartości innych niż `None`, aplikacja wysyłająca musi określić kolejki do użycia jako kolejkę administracyjną.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat zawierający zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AdministrationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dodatkowe informacje specyficzne dla aplikacji.</summary>
        <value>Informacje dotyczące tej aplikacji. Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> Właściwość zawiera informacje specyficzne dla aplikacji, które służy do organizowania różnego rodzaju wiadomości. Na przykład można użyć indeksy specyficzne dla aplikacji. Jest odpowiedzialny za aplikację do interpretacji <xref:System.Messaging.Message.AppSpecific%2A> informacje o właściwościach.  
  
 Zawsze, gdy jest to możliwe, należy uwzględnić danych komunikatu w treści wiadomości, a nie od <xref:System.Messaging.Message.AppSpecific%2A> właściwości.  
  
 Podczas pracy z kolejkami obcego, użyj <xref:System.Messaging.Message.Extension%2A> właściwości w celu określenia właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów. Podobnie jak w przypadku <xref:System.Messaging.Message.AppSpecific%2A> właściwość, jest odpowiedzialny za aplikację, aby zrozumieć zawartość <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AppSpecific" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas odebrania wiadomości w kolejce docelowej.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentujący Godzina nadejścia wiadomości w kolejce docelowej. Czas jest uwzględniany w GMT czasu lokalnego komputera, na którym znajduje się kolejka docelowa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość wskazuje, jak szybko musi odebrać wiadomość z kolejki docelowej. <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość timer rozpoczyna się, gdy komunikat jest wysyłany nie nadejściu wiadomości w kolejce.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.ArrivedTime%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ArrivedTime" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy identyfikator nadawcy powinien być dołączony do wiadomości.</summary>
        <value><see langword="true" /> Jeśli <see cref="P:System.Messaging.Message.SenderId" /> powinien być dołączony do wiadomości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> Właściwość jest tablica bajtów, który reprezentuje identyfikator użytkownika wysyłającego. Identyfikator nadawcy jest ustawiony przez usługę kolejkowania komunikatów i jest używany na odbieranie Menedżer kolejki, aby sprawdzić, czy nadawca ma wystarczające uprawnienia dostępu do kolejki.  
  
 Brak nadawcy, których identyfikator jest wskazanie przez aplikację wysyłającą że kolejkowania powinna nie zweryfikować nadawcy wiadomości ani Sprawdź dostęp do nadawcy praw do odbierania kolejki. <xref:System.Messaging.Message.SenderId%2A> Jest zaufane, tylko wtedy, gdy wiadomość została uwierzytelniona, po jego osiągnięciu kolejki docelowej. Komunikat zostanie odrzucony, gdy osiągnie kolejki docelowej, jeśli kolejka akceptuje wyłącznie uwierzytelnione komunikaty, a następnie <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> lub <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> właściwość `false`.  
  
> [!CAUTION]
>  Jeśli komunikat zostanie odrzucony, jest albo wysłane do kolejki utraconych wiadomości (Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `true`), lub jest on ignorowany. Jeśli komunikat nie uda się połączyć kolejki, możesz poprosić potwierdzenia. W przeciwnym razie, gdy <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false` wiadomości mogą zostać utracone, bez ostrzeżenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.AttachSenderId%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AttachSenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość została uwierzytelniona.</summary>
        <value><see langword="true" /> Jeśli zażądano uwierzytelniania wiadomości po jej wprowadzeniu kolejki; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> Właściwość jest używana tylko przez aplikację podczas interakcji z komunikatem i próby określenia, czy żądano uwierzytelnienia. W przypadku wiadomości w kolejce, wiadomość została uwierzytelniona. Z drugiej strony Jeśli <xref:System.Messaging.Message.Authenticated%2A> właściwość `true`, Menedżera kolejki odbierającej uwierzytelniony wiadomości, kiedy otrzymuje tę wiadomość.  
  
 Nie można ustalić, czy komunikat niepowodzenie uwierzytelniania, analizując jego właściwości. Usługa kolejkowania komunikatów odrzuca wiadomości, które nie spełniają uwierzytelniania przed wysłaniem ich do kolejki. Jednakże możesz poprosić, wysyłane wiadomości potwierdzającej Jeśli błąd dostarczania uniemożliwia wiadomości przychodzące w kolejce.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.Authenticated%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Authenticated" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego komunikatu.</summary>
        <value>Nazwa dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego komunikatu. Wartość domyślna to Microsoft Base Cryptographic Provider w wersji 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używa się <xref:System.Messaging.Message.AuthenticationProviderName%2A> podczas pracy z kolejkami obcego. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i dostawcy usług kryptograficznych (dostawca uwierzytelnienia) sprawdzają poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i komunikaty przekazywane do wiadomości, typ dostawcy uwierzytelniania Usługi kolejkowania wiadomości z kolejki obcego.  
  
 Podczas wysyłania wiadomości, zawsze wartość <xref:System.Messaging.Message.AuthenticationProviderName%2A> i <xref:System.Messaging.Message.ConnectorType%2A> razem właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje Nazwa dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona.  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A> Właściwość nie może być `null`, ale może być pustym ciągiem ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> Nie można ustawić właściwości.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> Została ustawiona na <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego komunikatu.</summary>
        <value>Jedną z <see cref="T:System.Messaging.CryptographicProviderType" /> wartości. Wartość domyślna to <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używa się <xref:System.Messaging.Message.AuthenticationProviderType%2A> właściwości podczas pracy z kolejkami obcych do określenia, które usług kryptograficznych dostawcy jest skojarzony z komunikatem. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i dostawcy usług kryptograficznych (dostawca uwierzytelnienia) sprawdzają poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i komunikaty przekazywane do wiadomości, typ dostawcy uwierzytelniania Usługi kolejkowania wiadomości z kolejki obcego.  
  
 Tylko `RsaFull` jest przeznaczony do użycia z obsługą komunikatów.  
  
 Podczas wysyłania wiadomości, zawsze wartość <xref:System.Messaging.Message.AuthenticationProviderType%2A> i <xref:System.Messaging.Message.ConnectorType%2A> razem właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje typ dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.AuthenticationProviderType" /> Nie można ustawić właściwości.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość komunikatu.</summary>
        <value>Obiekt, który określa treść wiadomości. Obiekt może być ciąg, daty, waluty, liczbę, tablicę bajtów lub dowolnym obiektem zarządzanym.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat <xref:System.Messaging.Message.Body%2A> właściwość zazwyczaj zawiera dane skojarzone z wiadomością. Mimo że można również wysyłać dane specyficzne dla aplikacji <xref:System.Messaging.Message.AppSpecific%2A> i <xref:System.Messaging.Message.Extension%2A> właściwości powinien być dołączany do wiadomości dane w <xref:System.Messaging.Message.Body%2A> wiadomości, zawsze, gdy jest to możliwe. Tylko <xref:System.Messaging.Message.Body%2A> zawartość właściwość jest serializowana lub szyfrowane.  
  
 <xref:System.Messaging.Message.Body%2A> Właściwość może zawierać dowolny obiekt, którego rozmiar przekracza 4 MB. Jeśli używasz <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> wysyłać dowolnego obiektu, który nie jest typu <xref:System.Messaging.Message> do <xref:System.Messaging.MessageQueue>, ten obiekt będzie znajdować się w <xref:System.Messaging.Message.Body%2A> właściwość <xref:System.Messaging.Message> wystąpienie zwrócone przez <xref:System.Messaging.MessageQueue.Peek%2A> lub <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Argument ciągu w `MessageQueue.Send("hello.")` jest przykładem obiekt generyczny.  
  
 <xref:System.Messaging.Message.BodyType%2A> Właściwość wskazuje typ informacji przechowywanych w treści komunikatu. Usługa kolejkowania komunikatów używa tych informacji do identyfikowania typu <xref:System.Messaging.Message.Body%2A> zawartość właściwości.  
  
 Wybierz opcję <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. <xref:System.Messaging.Message.Body%2A> Właściwość może być możliwy do serializacji obiektu, takiego jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.  
  
 O ile nie bezpośrednio do pisania treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> , właściwością <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowana, przy użyciu elementu formatującego zawarte w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Trwa próba skonfigurowania treść komunikatu do <xref:System.Decimal.MaxValue> spowoduje, że <xref:System.OverflowException> podczas `Send` metody <xref:System.Messaging.MessageQueue> nosi nazwę klasy i <xref:System.Messaging.ActiveXMessageFormatter> jest używany.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.Formatter" /> Właściwość <see langword="null" />.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje w treści wiadomości.</summary>
        <value>A <see cref="T:System.IO.Stream" /> zawierającego zserializowane informacje zawarte w <see cref="P:System.Messaging.Message.Body" /> wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Treść komunikatu może składać się z dowolnego typu informacji — na przykład ciąg, daty, waluty, liczbę, tablicę bajtów lub dowolnym obiektem zarządzanym. Te informacje są szeregowane w <xref:System.IO.Stream> mają być przekazane do kolejki.  
  
 Wybierz opcję <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. Jeśli ustawisz <xref:System.Messaging.Message.Body%2A> właściwości zawartości są szeregowane w <xref:System.Messaging.Message.BodyStream%2A> właściwości. Jednak istnieje możliwość zapisu <xref:System.Messaging.Message.BodyStream%2A> właściwość bezpośrednio. Jest to przydatne, na przykład, jeśli chcesz nawiązać połączenie z plikiem i przesyłanie strumieniowe jego zawartość, jako treść komunikatu.  
  
 O ile nie bezpośrednio do pisania treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> , właściwością <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowana, przy użyciu elementu formatującego zawarte w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 Jeśli ustawisz <xref:System.Messaging.Message.UseEncryption%2A> właściwości `true` dla treści tej wiadomości zostaną zaszyfrowane wiadomości, po wysłaniu, nie wtedy, gdy ustawisz <xref:System.Messaging.Message.Body%2A> właściwości. W związku z tym <xref:System.Messaging.Message.BodyStream%2A> właściwość nigdy nie jest szyfrowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ danych, która zawiera treść komunikatu.</summary>
        <value>Treść komunikatu true typu, na przykład ciąg, daty, waluty lub liczbą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów rozpoznaje zawartość treści jako obiekt lub serializowanym strumieniu. <xref:System.Messaging.Message.BodyType%2A> Właściwość wskazuje typ obiektu, w ramach <xref:System.Messaging.Message.Body%2A> właściwość komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Wykonuje powiązanie między typami macierzystym i obiekt w treści komunikatu. Jeśli używasz <xref:System.Messaging.XmlMessageFormatter>, ustawia program formatujący <xref:System.Messaging.Message.BodyType%2A> właściwości dla Ciebie.  
  
 Inne elementy formatujące zapewniają również, jak pokazano w poniższym kodzie języka C# powiązania funkcji.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.BodyType%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że niektóre właściwości komunikatów zazwyczaj ustawiane przez usługę kolejkowania komunikatów były ustawione przez aplikację wysyłającą.</summary>
        <value>A <see cref="T:System.Guid" /> zdefiniowany przez aplikację i używane w połączeniu z łącznika aplikacji lub szyfrowania wiadomości. To <see cref="T:System.Guid" /> umożliwia aplikacji odbierającej interpretowanie właściwości wiadomości, które były ustawione przez aplikację wysyłającą, ale są zazwyczaj ustawiane przez usługę kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów wymaga <xref:System.Messaging.Message.ConnectorType%2A> można ustawić właściwości, gdy aplikacja ustawia właściwości wiadomości, który zazwyczaj jest ustawiony przez usługę kolejkowania komunikatów. Aplikacja zazwyczaj używa <xref:System.Messaging.Message.ConnectorType%2A> w dwóch przypadkach:  
  
-   Zawsze, gdy aplikacja łącznika przekazuje komunikat. <xref:System.Messaging.Message.ConnectorType%2A> Informuje aplikacji wysyłanie i odbieranie interpretowanie właściwości zabezpieczeń i potwierdzenia komunikatu.  
  
-   Zawsze, gdy aplikacji wysyłającej, a nie usługi kolejkowania komunikatów, szyfruje wiadomość. <xref:System.Messaging.Message.ConnectorType%2A> Informuje MSMQ do użycia <xref:System.Messaging.Message.DestinationSymmetricKey%2A> wartości właściwości do odszyfrowywania wiadomości.  
  
 Należy ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwość, jeśli dowolny z następujących właściwości ustawione (w przeciwnym razie kolejka ignoruje te właściwości po wysłaniu wiadomości):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ConnectorType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia identyfikator komunikatu, używane przez potwierdzenie, raport i komunikatów odpowiedzi można odwoływać się do oryginalnej wiadomości.</summary>
        <value>Identyfikator wiadomości określony przez <see cref="P:System.Messaging.Message.Id" /> właściwości oryginalnej wiadomości. Identyfikator korelacji jest używany przez usługę kolejkowania komunikatów, generując komunikat potwierdzenia lub raport i aplikacja, generując komunikat odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas kolejkowania generuje komunikat potwierdzenia lub raportu, używa właściwości identyfikator korelacji Aby określić identyfikator wiadomości w oryginalnej wiadomości. W ten sposób identyfikator korelacji więzi komunikat potwierdzenia lub raportu na pierwotny komunikat.  
  
 Aplikacji wysyłającej można następnie dopasować potwierdzenia lub raportu z oryginalnym komunikatem, za pomocą <xref:System.Messaging.Message.CorrelationId%2A> właściwość do identyfikacji oryginalnego komunikatu <xref:System.Messaging.Message.Id%2A> właściwości.  
  
 Łącznik aplikacji również ustawić <xref:System.Messaging.Message.CorrelationId%2A> własności wiadomości po potwierdzeniu i raportów do identyfikatora wiadomości oryginalnej wiadomości.  
  
 Gdy aplikacja wysyła komunikat odpowiedzi do aplikacji wysyłającej, można ustawić <xref:System.Messaging.Message.CorrelationId%2A> właściwości komunikatu odpowiedzi do identyfikatora wiadomości oryginalnej wiadomości. Następnie aplikacja wysyłająca może odnosić się wiadomości odpowiedzi na komunikat, który został wysłany.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat, który zawiera zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.CorrelationId" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> Jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolejki miejsca docelowego dla wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.MessageQueue" /> określający kolejki miejsca docelowego dla wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> Jest najczęściej używana do określenia początkowego miejsca docelowego o dostarczeniu w kolejce dziennika lub utraconych wiadomości. Zazwyczaj nie trzeba sprawdzić tę właściwość, ponieważ zwykle pobierają wiadomości z kolejki docelowej.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.DestinationQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DestinationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz symetryczny stosowany do szyfrowania wiadomości zaszyfrowane aplikacji lub komunikatów wysłanych do kolejki obcego.</summary>
        <value>Tablica wartości bajt określa miejsce docelowe klucz symetryczny używane do szyfrowania wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa scenariusze wymagają użycia <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwości. Pierwszy jest podczas twojej aplikacji, a nie usługi kolejkowania komunikatów, szyfruje wiadomość. Drugim jest podczas wysyłania zaszyfrowanego komunikatu do kolejkowania systemu innego niż usługi kolejkowania komunikatów.  
  
 Zanim ustawisz tę właściwość, należy zaszyfrować klucza symetrycznego za pomocą klucza publicznego odbieranie Menedżer kolejki. Podczas wysyłania wiadomości zaszyfrowane aplikacji Menedżera kolejki odbierającej używa klucza symetrycznego do odszyfrowywania wiadomości przed wysłaniem ich do kolejki docelowej.  
  
 Jeśli wyślesz wiadomość do kolejki obcej pierwszym odebraniu komunikatu przez aplikację odpowiedni łącznik, która przekazuje zaszyfrowanego komunikatu przy użyciu klucza symetrycznego dołączonych do aplikacji odbierającej. Jest ona odpowiedzialność za aplikację do odszyfrowywania wiadomości przy użyciu klucza symetrycznego.  
  
 Po ustawieniu <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwość, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwość Jeśli <xref:System.Messaging.Message.ConnectorType%2A> właściwość nie jest również ustawiona.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Właściwość ma maksymalny rozmiar tablicy 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> Jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podpis cyfrowy, który używa Usługa Kolejkowanie komunikatów do uwierzytelniania wiadomości.</summary>
        <value>Tablica wartości bajt Określa podpis cyfrowy 1.0 usługi kolejkowania komunikatów, używany do uwierzytelniania wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów używa podpis cyfrowy podczas uwierzytelniania wiadomości, które zostały wysłane przez usługę kolejkowania komunikatów w wersji 1.0. W większości przypadków usługa kolejkowania komunikatów generuje i ustawia <xref:System.Messaging.Message.DigitalSignature%2A> właściwość podczas wysyłania aplikacja żąda uwierzytelnienia. Aplikacja używa tej właściwości, aby pobrać podpisu cyfrowego dołączanego do wiadomości.  
  
 Można używać tylko <xref:System.Messaging.Message.DigitalSignature%2A> właściwości podczas uruchamiania usługi kolejkowania komunikatów w wersji 2.0. Aplikacji wysyłającej należy określić sygnatury usługi kolejkowania komunikatów w wersji 1.0, podczas żądania uwierzytelniania. Jeśli aplikacja wysyłająca wysyła sygnatury usługi kolejkowania komunikatów w wersji 2.0, ta właściwość zawiera bufor cztery bajty, każdy zawierający zero.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwości wraz z <xref:System.Messaging.Message.SenderCertificate%2A> , jest również używana przez aplikacje łącznika po wysłaniu wiadomości. W tym scenariuszu łącznika aplikacji — a nie usługi kolejkowania komunikatów - generuje podpisu cyfrowego, który ją określa na podstawie certyfikatu użytkownika, wysyłając wiadomość.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwość ma maksymalny rozmiar tablicy 256.  
  
 Po ustawieniu <xref:System.Messaging.Message.DigitalSignature%2A> właściwość, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje <xref:System.Messaging.Message.DigitalSignature%2A> właściwość Jeśli <xref:System.Messaging.Message.ConnectorType%2A> właściwość nie jest również ustawiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DigitalSignature" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DigitalSignature" /> Właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytm szyfrowania używany do szyfrowania treści wiadomości prywatnej.</summary>
        <value>Jedną z <see cref="T:System.Messaging.EncryptionAlgorithm" /> wartości wyliczenia. Wartość domyślna to <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny (zaszyfrowane), są szyfrowane, zanim wysyłanych i odszyfrowywane po otrzymaniu. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Właściwość określa algorytm używany do szyfrowania treści wiadomości prywatnej.  
  
 Kolejka może wymagać tego przychodzące wiadomości być szyfrowane. Jeśli aplikacja wysyła komunikat (nieprywatny) niezaszyfrowane do kolejki, która akceptuje tylko wiadomości prywatnej lub jeśli wysyła wiadomości prywatnej do kolejki, która akceptuje tylko wiadomości nieprywatny, kolejki odrzuca komunikat. Aplikacja wysyłająca mogą żądać, że w takim przypadku jest zwracany komunikat o negatywnego potwierdzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dodatkowe, zdefiniowanych przez aplikację informacje skojarzone z wiadomością.</summary>
        <value>Tablica wartości bajtów zawierający informacje zdefiniowane przez aplikację, skojarzonych z wiadomością. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> Dostarcza informacji zdefiniowanych przez aplikację, takich jak dużego obiektu binarnego, który jest skojarzony z komunikatem. Jest odpowiedzialny za aplikacji odbierającej i nterpretowanie zawartości <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 W przypadku, gdy jest to możliwe, należy dołączyć dane wiadomości w <xref:System.Messaging.Message.Body%2A> właściwości wiadomości, a nie od <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 Podczas pracy z kolejkami obcego, użyj <xref:System.Messaging.Message.Extension%2A> właściwości w celu określenia właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów.  
  
 Obcy kolejka istnieje w systemie kolejkowania innych niż firmy Microsoft usługi kolejkowania komunikatów. Usługa kolejkowania komunikatów komunikuje się z takiego kolejki za pomocą łącznika aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Extension" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Extension" /> Właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element formatujący używany do serializacji obiektu na lub deserializacji obiektu z treści wiadomości.</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" /> Która wytwarza strumień być zapisywane lub odczytać ich z treści wiadomości. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.Message.Formatter%2A> właściwości podczas odczytywania i zapisywania wiadomości. Po wysłaniu komunikatu do kolejki, element formatujący serializuje <xref:System.Messaging.Message.Body%2A> właściwości do strumienia, które mogą być wysyłane do kolejki komunikatów. Podczas czytania z kolejki, element formatujący deserializuje dane wiadomości do <xref:System.Messaging.Message.Body%2A> właściwości.  
  
 O ile nie bezpośrednio do pisania treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> , właściwością <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowana, przy użyciu elementu formatującego zawarte w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno powiązane, więc nie ma tego samego obiektu, wpisz na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializowania danych do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub odbierania składników COM.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje, formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Formatter" /> Właściwość <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia mieszania algorytmu, który używa Usługa Kolejkowanie komunikatów uwierzytelniania wiadomości lub tworzenia podpisu cyfrowego komunikatu.</summary>
        <value>Jedną z <see cref="T:System.Messaging.HashAlgorithm" /> wartości wyliczenia. Windows XP, wartość domyślna to <see langword="SHA" />. W przeciwnym razie wartość domyślna to <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na komputerze źródłowym usługi kolejkowania komunikatów używa algorytmu wyznaczania wartości skrótu używanym podczas tworzenia podpisu cyfrowego komunikatu. Menedżer kolejki docelowej następnie używa tego samego algorytmu wyznaczania wartości skrótu do uwierzytelniania wiadomości po odebraniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.HashAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator komunikatu.</summary>
        <value>Komunikat o Unikatowy identyfikator, który jest generowany przez usługę kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów generuje identyfikator komunikatu, gdy komunikat jest wysyłany. Identyfikator składa się z 20 bajtów i zawiera dwa elementy: maszynie <xref:System.Guid> wysyłający komputer i unikatowy identyfikator wiadomości na komputerze. Kombinacja dwóch elementów generuje identyfikator komunikatu, który jest unikatowy w sieci.  
  
 Usługa kolejkowania komunikatów generuje komunikat identyfikatory wszystkie komunikaty — w tym komunikaty o potwierdzenie i raportu. Wiadomości potwierdzającej zazwyczaj są wysyłane przez usługę kolejkowania komunikatów w reakcji na nadejście lub niepowodzenie oryginalny, wysyłany komunikat o. Możesz znaleźć <xref:System.Messaging.Message.Id%2A> wartości właściwości w oryginalnej wiadomości w <xref:System.Messaging.Message.CorrelationId%2A> właściwość komunikat potwierdzenia.  
  
 Można również użyć <xref:System.Messaging.Message.Id%2A> właściwości podczas wysyłania komunikatu odpowiedzi do kolejki odpowiedzi. Aby podać identyfikator oryginalnego komunikatu w komunikacie odpowiedzi, należy ustawić <xref:System.Messaging.Message.CorrelationId%2A> właściwości komunikatu odpowiedzi do <xref:System.Messaging.Message.Id%2A> właściwości oryginalnej wiadomości. Aplikacji do czytania wiadomości odpowiedzi służy następnie identyfikator korelacji z komunikatu odpowiedzi do identyfikowania oryginalnej wiadomości.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła i odbiera komunikat zawierający zamówienia z kolejki. Go zażąda potwierdzenia dodatnie, gdy oryginalna wiadomość osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Id" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy limit czasu nie istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> i <xref:System.Messaging.Message.TimeToReachQueue%2A> wymaga wartości, która określa limit czasu. Pierwsze, limit czasu jest maksymalny dozwolony czas realizacji komunikat do odebrania z kolejki. W przypadku drugiego nagłówka limit czasu jest czas przeznaczony na dostarczenie komunikatu do kolejki. W obu przypadkach można określić limit czasu jako liczbę sekund lub użyć <xref:System.Messaging.Message.InfiniteTimeout> do wskazania, że limit czasu nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.Message.InfiniteTimeout> pola.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była pierwszą wiadomością wysłaną w transakcji.</summary>
        <value><see langword="true" /> Jeśli wiadomość była pierwszą wiadomością wysłaną w transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie użycia aplikacji <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w ramach jednej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępne tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 i nowszych wersjach.  
  
 Aby sprawdzić, czy transakcja granic, można użyć <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości oraz dwa inne właściwości: <xref:System.Messaging.Message.IsLastInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Użyj pierwszych, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w transakcji, a następnie użyć drugiej opcji, aby pobrać identyfikator transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w ramach transakcji <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości są ustawione na `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była ostatnią wiadomością wysłaną w transakcji.</summary>
        <value><see langword="true" /> Jeśli wiadomość była ostatnią wiadomością wysłaną w ramach jednej transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie użycia aplikacji <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w ramach jednej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępne tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 i nowszych wersjach.  
  
 Aby sprawdzić, czy transakcja granic, można użyć <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości oraz dwa inne właściwości: <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Użyj pierwszych, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w transakcji, a następnie użyć drugiej opcji, aby pobrać identyfikator transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w ramach transakcji <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości są ustawione na `true`.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.IsLastInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg Unicode zdefiniowanych przez aplikację, który opisano komunikatów.</summary>
        <value>Etykieta wiadomości. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Etykieta wiadomości można użyć do kilku celów. Na przykład służy do wyświetlania lub selektywnie przetwarzanie komunikatów, na podstawie wartości etykiety. Etykieta nie musi być unikatowa wśród wiadomości.  
  
 Kolejki komunikatów i wiadomości dla etykiety reprezentują wartością zdefiniowanych przez aplikację, które mogą pomóc zidentyfikować kolejki lub wiadomości w warunkach czytelny dla człowieka. Jest odpowiedzialny za aplikację do interpretacji zawartości etykiet, które nie mają wewnętrzne znaczenia dla usługi kolejkowania komunikatów aplikacji.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.Label%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Label" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Pobiera identyfikator wyszukiwania wiadomości.</summary>
        <value>Identyfikator wyszukiwania wiadomości, jest generowany przez usługę kolejkowania komunikatów, która jest unikatowa w kolejce, gdzie znajduje się komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość zapewnia dostęp tylko do odczytu do identyfikator wyszukiwania wiadomości. Identyfikator wyszukiwania, wprowadzona w usłudze MSMQ 3.0 jest identyfikatorem 64-bitowym, który jest generowany przez usługę kolejkowania komunikatów i przypisane do każdego komunikatu, gdy komunikat jest umieszczany w kolejce. Identyfikator wyszukiwania nie jest taki sam jak identyfikator komunikatu, który jest generowany, gdy komunikat jest wysyłany.  
  
 Usługa kolejkowania komunikatów generuje identyfikator wyszukiwania dla wszystkich wiadomości, które są umieszczane w kolejkach, w tym wygenerowane w aplikacji docelowej, administracji, a kolejki raportu, a także generowanych przez system dziennika utraconych wiadomości, łącznik i kolejek. Innymi słowy w tym komunikaty wysyłane przez wysyłanie aplikacje i usługi kolejkowania komunikatów. Identyfikator wyszukiwania jest unikatowy w kolejce i nie ma znaczenia, poza kolejki.  
  
 Jeśli komunikat jest wysyłany do wielu kolejek docelowych lub kopia wiadomości są przechowywane w dzienniku komputera lub kolejki dziennika, każda kopia wiadomości ma swój własny identyfikator wyszukiwania, gdy jest on umieszczany w jej w odpowiedniej kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
 Identyfikator wyszukiwania jest używana do odczytu szczegółowy komunikat o błędzie w kolejce. Gdy identyfikator wyszukiwania wiadomości jest znany, aplikacja może wywołać <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> lub <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> funkcję, aby przejść bezpośrednio do tej wiadomości i wgląd lub Pobierz ją z kolejki, w odróżnieniu od kursorów, które muszą być uruchomione na wierzchu kolejki i Przejdź pod koniec kolejki  
  
 Uzyskiwanie identyfikatory wyszukiwania wiadomości w kolejce jest odpowiedzialny za aplikacji. Możliwy sposób uzyskania identyfikatory wyszukiwania jest utworzyć wyzwalacz dla kolejki docelowej, która wywołuje składnik, który buforuje identyfikatory każdego komunikatu, ponieważ są one umieszczane w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.LookupId" /> właściwości.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ komunikatu: <see langword="Normal" />, <see langword="Acknowledgment" />, lub <see langword="Report" />.</summary>
        <value>Jedną z <see cref="P:System.Messaging.Message.MessageType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów zwykle ustawia tę właściwość, gdy wysyła on wiadomość. Komunikatów usługi kolejkowania komunikatów może być jednym z następujących typów:  
  
-   `Normal`, który jest typowy wiadomość wysłana z aplikacji do kolejki lub komunikat odpowiedzi zwrócony do aplikacji wysyłającej.  
  
-   `Acknowledgement`, kolejkowania generująca zawsze wtedy, gdy jeden żądań aplikacji wysyłającej. Na przykład usługi kolejkowania komunikatów może wygenerować dodatnie lub ujemne wiadomości, aby wskazać, że oryginalna wiadomość dotarła lub została odczytana. Usługa kolejkowania komunikatów zwraca komunikatu potwierdzającego odpowiednie do kolejki administracyjnej określonej przez aplikację wysyłającą.  
  
-   `Report`, kolejkowania generująca zawsze wtedy, gdy kolejka raportów jest zdefiniowany w źródle, Menedżer kolejki. Po włączeniu funkcji śledzenia usługi kolejkowania komunikatów wysyła raport komunikat do kolejki usługi kolejkowania komunikatów raportu za każdym razem oryginalnego komunikatu wprowadza lub pozostawia serwer usługi kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.MessageType%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.MessageType" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia priorytet wiadomości, która określa, gdzie w kolejce wiadomości jest umieszczony.</summary>
        <value>Jedną z <see cref="T:System.Messaging.MessagePriority" /> wartości, które reprezentują poziomy priorytetów nietransakcyjnej komunikatów. Wartość domyślna to <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> Właściwość ma wpływ na sposób usługi kolejkowania komunikatów obsługi wiadomości obu, jest on trasy niepoufnej i gdy osiągnie ona miejsca docelowego. Komunikaty o wyższym priorytecie są pierwszeństwo podczas routingu i dodaje do przodu kolejki docelowej. Wiadomości o tym samym priorytecie są umieszczane w kolejce zgodnie z ich czas nadejścia.  
  
 Można ustawić priorytet istotne tylko dla wiadomości nietransakcyjnej. Usługa MSMQ automatycznie ustawia priorytet wiadomości transakcyjnych do `Lowest`, co powoduje, że priorytet wiadomości transakcyjne do zignorowania.  
  
   
  
## Examples  
 Poniższy przykładowy kod wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Priority" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomość musi być dostarczane w przypadku problemu awarii lub sieć komputera.</summary>
        <value><see langword="true" /> Jeśli dostarczania wiadomości jest gwarantowane (za pośrednictwem zapisywania komunikatu do dysku podczas dostarczania); <see langword="false" /> Jeśli dostarczanie nie jest zapewnione. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> Właściwość wskazuje, czy jest gwarantowane dostarczanie komunikatów — nawet jeśli komputer ulegnie awarii, gdy komunikat jest przenoszony do kolejki docelowej.  
  
 Jeśli jest gwarantowane dostarczanie komunikatów, wiadomości są przechowywane lokalnie na każdym etapie wzdłuż trasy, aż komunikat pomyślnie jest przekazywany do następnego komputera. Ustawienie <xref:System.Messaging.Message.Recoverable%2A> właściwości `true` mogą mieć wpływ na wydajność.  
  
 Jeśli komunikat jest transakcyjna, automatycznie kolejkowania wiadomości traktuje jako możliwe do odzyskania, bez względu na wartość <xref:System.Messaging.Message.Recoverable%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.Recoverable%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Recoverable" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejki, która odbiera komunikaty odpowiedzi generowane przez aplikację.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> Które odpowiedzi generowanych przez aplikację wiadomości są zwracane. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> Właściwość identyfikuje kolejkę, która odbiera wiadomości odpowiedzi generowane przez aplikacje, które aplikacja odbierająca zwraca do aplikacji wysyłającej. Aplikacja wysyłająca określa kolejki odpowiedzi, gdy aplikacja wysyła swoje wiadomości. Wszystkie dostępne kolejki można określić jako kolejki odpowiedzi.  
  
 Komunikaty zwracane do kolejki odpowiedzi są specyficzne dla aplikacji. Aplikacja musi definiować zawartość wiadomości, a także akcję do wykonania po otrzymaniu komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.ResponseQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ResponseQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst zabezpieczeń dla wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.SecurityContext" /> obiekt, który zawiera kontekst zabezpieczeń wiadomości, jeśli wcześniej została ustawiona właściwość; w przeciwnym razie wartość NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia certyfikat zabezpieczeń używany do uwierzytelniania komunikatów.</summary>
        <value>Tablica wartości bajtów reprezentuje certyfikatu zabezpieczeń, którego używa Usługa Kolejkowanie komunikatów, aby zweryfikować nadawcy wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Messaging.Message.SenderCertificate%2A> właściwości, gdy wiadomość zawiera certyfikat zabezpieczeń zewnętrznych.  
  
 Usługa kolejkowania komunikatów może uwierzytelniać wiadomości przy użyciu certyfikatu zabezpieczeń wewnętrznych lub zewnętrznych. Usługa kolejkowania komunikatów zapewnia wewnętrznego certyfikaty, które są używane w celu sprawdzenia integralności komunikatu. Urząd certyfikacji zawiera certyfikatu zewnętrznego, który jest dostępny za pośrednictwem <xref:System.Messaging.Message.SenderCertificate%2A> właściwość komunikatu. Oprócz umożliwienia usługi kolejkowania komunikatów do uwierzytelniania wiadomości, certyfikatu zewnętrznego umożliwia aplikacji odbierającej dodatkową weryfikację nadawcy. Wewnętrzny certyfikat nie ma można używać wartości do aplikacji odbierającej.  
  
 Certyfikatu zewnętrznego, musi być zarejestrowana w usłudze katalogowej systemu usługi kolejkowania komunikatów. Certyfikat zewnętrzny zawiera informacje o urzędzie certyfikacji, certyfikatu użytkownika, okres ważności certyfikatu, klucz publiczny certyfikatu użytkownika i podpisu urzędu certyfikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderCertificate" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator użytkownika wysyłającego.</summary>
        <value>Tablica wartości bajtów identyfikuje nadawcę. Odbieranie Menedżer kolejki używa identyfikatora, gdy uwierzytelnia się ono komunikat, aby zweryfikować nadawcy wiadomości i nadawcy prawa dostępu do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Messaging.Message.AttachSenderId%2A> właściwość `false`, identyfikator nadawcy, określony w <xref:System.Messaging.Message.SenderId%2A> właściwość nie jest dołączony do wiadomości, gdy są wysyłane. Oznacza to, aby usługi kolejkowania komunikatów, nadawca nie powinny być weryfikowane, podczas wysyłania komunikatu do kolejki docelowej. Jeśli <xref:System.Messaging.Message.AttachSenderId%2A> właściwość `true`, <xref:System.Messaging.Message.SenderId%2A> wartość właściwości jest godne zaufania tylko wtedy, gdy wiadomość została uwierzytelniona. Użyj <xref:System.Messaging.Message.Authenticated%2A> właściwość w połączeniu z <xref:System.Messaging.Message.SenderId%2A> właściwości, aby sprawdzić prawa dostępu nadawcy.  
  
 Łącznik aplikacji jest aplikacja, która korzysta z serwera łącznika, aby zapewnić komunikację między usługi kolejkowania komunikatów i innych systemów kolejkowania. Usługa kolejkowania komunikatów wymaga łącznika aplikacji w celu zapewnienia identyfikator nadawcy. Należy ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości podczas wysyłania komunikatów przy użyciu łącznika aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję używane do wysyłania wiadomości usługi MSMQ.</summary>
        <value>Wersja używana do wysyłania wiadomości usługi MSMQ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> Właściwość jest ważne w przypadku niektórych funkcji. Na przykład przetwarzanie transakcji jest obsługiwana tylko przez usługę kolejkowania komunikatów w wersji 2.0 lub nowszy i podpisy cyfrowe są używane do uwierzytelniania komunikatów wysłanych przez MSMQ 1.0.  
  
 Wysyłanie zestawów Menedżer kolejki <xref:System.Messaging.Message.SenderVersion%2A> właściwości po wysłaniu wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.SenderVersion%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderVersion" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę na komputerze z wysyłanie wiadomość została wysłana przez menedżera kolejki źródła.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentująca godzinę wysłania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A> Właściwość jest dostosowywana do czasu lokalnego komputera, na którym znajduje się ten wystąpienie <xref:System.Messaging.Message> klasy został utworzony. Tej strefy czasowej mogą być inne od tych kolejkach źródłowym i docelowym.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.SentTime%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SentTime" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komputera, z którego wiadomość pochodzi.</summary>
        <value>Nazwa komputera, z którego została wysłana wiadomość.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format <xref:System.Messaging.Message.SourceMachine%2A> właściwość nie ma poprzednich dwóch ukośników (\\\\). Na przykład `myServer` jest prawidłowym <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.SourceMachine%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SourceMachine" /> właściwości.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Nie można uzyskać dostępu do usługi informacji lub katalogu komputera.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną ilość czasu, aby uzyskać komunikat, który ma być pobrany z kolejki docelowej.</summary>
        <value>Całkowity czas wysłaną wiadomość z kolejki docelowej. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość określa całkowity czas wysłaną wiadomość z kolejki docelowej. Limit czasu obejmuje czas droga do kolejki docelowej, a czas oczekiwania w kolejce, zanim zostanie odebrana wiadomość.  
  
> [!CAUTION]
>  Korzystając z zależnych komputerów klienckich, upewnij się, że zegar na komputerze klienckim jest zsynchronizowany z zegara na serwerze, na którym działa usługa kolejkowania komunikatów. W przeciwnym razie może spowodować nieprzewidywalne zachowanie, podczas wysyłania komunikatu którego <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość nie jest <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość wygaśnie przed usunięciem wiadomości z kolejki, kolejkowania odrzuca wiadomości w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false`, komunikat zostanie zignorowany.  
  
 Możesz ustawić komunikatu <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości żądania, aby usługi kolejkowania komunikatów, Wyślij wiadomość negatywnego potwierdzenia z powrotem do aplikacji wysyłającej Jeśli wiadomość nie została pobrana przed wygaśnięciem czasomierza.  
  
 Jeśli wartość jest określona przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość jest mniejsza niż wartość określoną przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 Gdy kilka komunikatów są wysyłane w ramach jednej transakcji, używa Usługa Kolejkowanie <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości pierwszego komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TimeToBeReceived" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <see cref="P:System.Messaging.Message.TimeToBeReceived" /> jest nieprawidłowy.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną ilość czasu na dostarczenie komunikatu do kolejki.</summary>
        <value>Limit czasu na dostarczenie komunikatu do kolejki docelowej, rozpoczynające się od momentu wiadomość jest wysyłana. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwość wygaśnie przed komunikat dociera do miejsca docelowego, kolejkowania odrzuca wiadomości w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false`, komunikat jest ignorowana.  
  
 Można ustawić komunikat he <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości żądania, aby usługi kolejkowania komunikatów, Wyślij wiadomość negatywnego potwierdzenia z powrotem do aplikacji wysyłającej Jeśli komunikat nie pojawić się przed okresu działania czasomierza.  
  
 Jeśli <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwość jest ustawiona na 0 sekund, kolejkowania próbuje raz wysłać wiadomość do miejsca docelowego — jeśli kolejka oczekuje na komunikat. W przypadku lokalnego kolejki wiadomości zawsze osiągnie on.  
  
 Jeśli wartość jest określona przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości jest większa niż wartość określoną przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 Gdy kilka komunikatów są wysyłane w ramach jednej transakcji, używa Usługa Kolejkowanie <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości pierwszego komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TimeToReachQueue" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <see cref="P:System.Messaging.Message.TimeToReachQueue" /> jest nieprawidłowy. Może ona reprezentować liczbą ujemną.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator transakcji, w których wiadomość była częścią.</summary>
        <value>Identyfikator transakcji skojarzonych z wiadomością.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie użycia aplikacji <xref:System.Messaging.Message.TransactionId%2A> właściwości, aby sprawdzić, czy wiadomość została wysłana w ramach danej transakcji. Identyfikator transakcji zawiera identyfikator komputera wysyłającego (pierwsze 16 bitów), z numerem sekwencji 4-bajtowych transakcji.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszej.  
  
 Identyfikatory transakcji nie musi być unikatowa, ponieważ numerów sekwencji transakcji nie są trwałe i mogą zacząć za pośrednictwem ponownie 2 <sup>20</sup>. Usługa kolejkowania komunikatów gwarantuje tylko, że podczas kolejnych transakcji numerów sekwencyjnych innej transakcji.  
  
 Możesz użyć <xref:System.Messaging.Message.TransactionId%2A> właściwości wraz z <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości, aby sprawdzić granice transakcji.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.TransactionId%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TransactionId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolejkę stanu transakcji na komputerze źródłowym.</summary>
        <value>Kolejkę stanu transakcji na komputerze źródłowym, który jest używany do wysyłania wiadomości potwierdzenia do aplikacji wysyłającej. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> Właściwość identyfikuje transakcyjne kolejki na komputerze źródłowym, który odbiera potwierdzenie odczytu potwierdzenia z łącznika aplikacji. Usługa kolejkowania komunikatów ustawia właściwość, a aplikacje łącznika Użyj właściwości podczas pobierania wiadomości transakcyjnych wysłanych do kolejki obcego.  
  
 Obcy kolejka istnieje w systemie kolejkowania innych niż firmy Microsoft usługi kolejkowania komunikatów. Usługa kolejkowania komunikatów komunikuje się z takiego kolejki za pomocą łącznika aplikacji.  
  
 Aplikacja łącznika może wysyłać potwierdzenia do wysyłania aplikacji za pomocą kolejkę stanu transakcji. Te potwierdzenia powinien zostać wyświetlony kolejkę stanu transakcji, nawet wtedy, gdy aplikacja wysyłająca nie żąda innych potwierdzenia.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość komunikat <xref:System.Messaging.Message.TransactionStatusQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie została wysłana wiadomość. Tej właściwości mogą być odczytane tylko na wiadomości są pobierane z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomość została (lub musi być) uwierzytelnionego przed wysyłane.</summary>
        <value><see langword="true" /> aplikacji wysyłającej żądanie uwierzytelniania dla wiadomości; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> Właściwość określa, czy wiadomość musi zostać uwierzytelniony. Jeśli aplikacja wysyłająca żądań uwierzytelniania, usługi kolejkowania komunikatów tworzy podpis cyfrowy i używa ich do podpisywanie komunikatów, gdy są wysyłane i uwierzytelniania wiadomości po odebraniu.  
  
 Jeśli <xref:System.Messaging.Message.UseAuthentication%2A> jest `false` i komunikat jest wysyłany do kolejki, która akceptuje wyłącznie uwierzytelnione komunikaty, komunikat zostanie odrzucony, po osiągnięciu kolejki.  
  
 Nie można ustalić, czy komunikat niepowodzenie uwierzytelniania, analizując jego właściwości. Usługa kolejkowania komunikatów odrzuca takich wiadomości przed wysłaniem ich do kolejki. Jednak możesz zażądać wysyłane wiadomości potwierdzającej Jeśli błąd dostarczania uniemożliwia wiadomości przychodzące w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseAuthentication" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy do kolejki utraconych wiadomości powinna zostać wysłana kopia wiadomości, którego nie można dostarczyć.</summary>
        <value><see langword="true" /> Jeśli awaria dostarczanie komunikatów powinna być rozwiązywana WE kopię wiadomości wysyłanych do kolejki utraconych wiadomości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości określają, jak usługi kolejkowania komunikatów śledzi wiadomość. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `true`, dostarczania awarii (wiadomość nietransakcyjna), powoduje, że komunikat do wysłania do nietransakcyjnej kolejki utraconych wiadomości na komputerze, który nie może dostarczyć wiadomości. Może być spowodowane mogło zostać dostarczone przez czasomierz komunikat wygasa, na przykład.  
  
 W przypadku awarii dostarczania wiadomości transakcyjnych usługi kolejkowania komunikatów wysyła komunikat do kolejki utraconych wiadomości transakcyjnych na maszynie źródłowej we wszystkich przypadkach ujemne, jak i w razie wątpliwości.  
  
 Gdy zapisujesz wiadomości w kolejce wiadomości utraconych należy wyczyścić kolejki okresowo, aby usunąć wiadomości, które nie są już potrzebne. Przechowywane w liczbę limit przydziału rozmiaru dla komputera, na którym znajduje się kolejka kolejki utraconych wiadomości. Przydział komputera jest ustawiany przez administratora i odnosi się do rozmiaru przydzielonych do przechowywania wiadomości na całego komputera, nie tylko z pojedynczą kolejką.  
  
 Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomości prywatnej.</summary>
        <value><see langword="true" /> Aby wymagać usługi kolejkowania komunikatów do szyfrowania wiadomości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny, jego treść ma być zaszyfrowany przed wysyłanych i odszyfrowywane po ich odebraniu. Aby wysłać wiadomość prywatna, aplikacji wysyłającej należy określić, można użyć, aby funkcja szyfrowania i, opcjonalnie, algorytm szyfrowania.  
  
 Podczas wysyłania wiadomości, aplikacji nie trzeba wykonywać szyfrowania wiadomości. Usługa kolejkowania komunikatów może szyfrować treść komunikatu dla Ciebie, jeśli aplikacja wysyła wiadomości w obrębie przedsiębiorstwa systemu Microsoft Windows 2000, który ma dostęp do usługi katalogowej. Podczas odbierania wiadomości, Menedżera kolejki odbierającej zawsze Odszyfrowuje treść komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseEncryption%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseEncryption" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kopia komunikatu powinna być przechowywana w dzienniku maszyny na komputerze źródłowym.</summary>
        <value><see langword="true" /> będą musieli zachowane kopię komunikat w dzienniku maszyny komputera źródłowego po wiadomość została pomyślnie przesłana (z komputera źródłowego do następnego serwera); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości określają, jak usługi kolejkowania komunikatów śledzi wiadomość. Jeśli <xref:System.Messaging.Message.UseJournalQueue%2A> jest `true`, a następnie kopię są przechowywane w dzienniku komputera na maszynie źródłowej w każdym kroku wysłaniem wiadomości.  
  
 Wysłaną wiadomością tylko są kopiowane do kolejki dziennika, jeśli kolejka docelowa znajduje się na komputerze zdalnym. Jeśli miejsce docelowe znajduje się na komputerze lokalnym, komunikat jest wysyłany bezpośrednio do kolejki; Brak pośredniego instrukcje wymagają rejestrowania.  
  
 Gdy zapisujesz wiadomości w kolejce dziennika wyczyść kolejkę okresowo, aby usunąć wiadomości, które nie są już potrzebne. Wiadomości przechowywanych w liczbę kolejek dziennika limitu przydziału dla komputera, na którym znajduje się kolejka. (Przydział komputera jest ustawiany przez administratora).  
  
 Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseJournalQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseJournalQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy komunikat śledzenia, kiedy przesuwa się on do kolejki docelowej.</summary>
        <value><see langword="true" /> Jeśli każdy krok pośrednich polegającymi na trasie na pierwotny komunikat do kolejki docelowej generuje raport do wysłania do kolejki raportu systemu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> Właściwość określa, czy śledzenie trasy wiadomości, kiedy przesuwa się on do kolejki docelowej. Jeśli `true`, raport (generowany przez usługę kolejkowania komunikatów) wysłaniu komunikatu do kolejki raportu każdorazowo komunikat przechodzi przez serwer routingu usługi MSMQ. Kolejka raportów jest określona przez źródło menedżera kolejek. Kolejki raportu nie są ograniczone do raportu komunikaty generowane przez usługę kolejkowania komunikatów; wiadomości wygenerowane w aplikacji mogą być również wysyłane do kolejki raportu.  
  
 Za pomocą funkcji śledzenia polega na konfigurowaniu usługi Active Directory i określenie kolejki raportu dla przedsiębiorstw usługi kolejkowania komunikatów. Administrator konfiguruje te ustawienia.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseTracing%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseTracing" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>
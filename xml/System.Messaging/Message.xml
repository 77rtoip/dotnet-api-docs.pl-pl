<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata><Meta Name="ms.openlocfilehash" Value="daa0e77edf7b25392c1fdafe9ec2d03ec85cbf7c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69115952" /></Metadata><TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do właściwości wymaganych do zdefiniowania komunikatu usługi kolejkowania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message> Użyj klasy w celu wglądu lub odbierania komunikatów z kolejki lub w celu uzyskania dokładnej kontroli nad właściwościami komunikatów podczas wysyłania komunikatu do kolejki.  
  
 <xref:System.Messaging.MessageQueue>używa klasy podczas wglądu lub odbierania komunikatów z kolejek, ponieważ <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> obie metody i <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> tworzą nowe wystąpienie <xref:System.Messaging.Message> klasy i ustawiają właściwości wystąpienia. <xref:System.Messaging.Message> Właściwości tylko do odczytu klasydotycząpobieraniakomunikatówzkolejki,podczasgdywłaściwościdoodczytu/zapisudotycząwysyłaniaipobieraniakomunikatów.<xref:System.Messaging.Message> Gdy <xref:System.Messaging.MessageQueue> Pobiera lub odbiera komunikat z kolejki, jego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> Właściwość określa, które właściwości komunikatu są pobierane.  
  
 Metoda<xref:System.Messaging.MessageQueue.Send%2A>klasyumożliwia określenie dowolnego typu obiektu dla wiadomości wysyłanej do kolejki. <xref:System.Messaging.MessageQueue> Można użyć <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwości wystąpienia <xref:System.Messaging.MessageQueue> , aby określić ustawienia dla komunikatów ogólnych wysyłanych do kolejki. Typy ustawień to program formatujący, etykieta, szyfrowanie i uwierzytelnianie. Możesz również określić wartości dla odpowiednich <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członków, gdy koordynujesz aplikację do obsługi wiadomości, aby odpowiedzieć na potwierdzenie i komunikaty raportu. <xref:System.Messaging.Message> Użycie wystąpienia do wysłania wiadomości do kolejki zapewnia elastyczność dostępu i modyfikacji wielu z tych właściwości — zarówno w przypadku pojedynczego komunikatu, jak i komunikatów na podstawie komunikatów. <xref:System.Messaging.Message>właściwości mają pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>przed.  
  
 Dane komunikatu są przechowywane we <xref:System.Messaging.Message.Body%2A> właściwości i w mniejszym zakresie <xref:System.Messaging.Message.AppSpecific%2A> , właściwości i <xref:System.Messaging.Message.Extension%2A> . Gdy dane komunikatu są szyfrowane, serializowane lub deserializowane, wpływają tylko na zawartość <xref:System.Messaging.Message.Body%2A> właściwości.  
  
 Zawartość <xref:System.Messaging.Message.Body%2A> właściwości jest serializowana, gdy komunikat jest wysyłany <xref:System.Messaging.Message.Formatter%2A> przy użyciu określonej właściwości. Serializowana zawartość znajduje się we <xref:System.Messaging.Message.BodyStream%2A> właściwości. Możesz również ustawić <xref:System.Messaging.Message.BodyStream%2A> właściwość bezpośrednio, na przykład, aby wysłać plik jako zawartość danych wiadomości. Można zmienić <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.Formatter%2A> w dowolnym momencie przed wysłaniem komunikatu, a dane zostaną odpowiednio zserializowane po wywołaniu <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Właściwości zdefiniowane przez <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> Właściwość mają zastosowanie tylko do wiadomości, które nie są typu <xref:System.Messaging.Message>. Jeśli określisz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość <xref:System.Messaging.MessageQueue> <xref:System.Messaging.Message> obiektu, właściwości o identycznej nazwie w wystąpieniu wysłanym do tej kolejki powodują Ignorowanie tych domyślnych właściwości.  
  
 Aby uzyskać listę początkowych wartości właściwości dla wystąpienia <xref:System.Messaging.Message>, <xref:System.Messaging.Message.%23ctor%2A> Zobacz Konstruktor.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.Message" /> klasy z pustą treścią.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie <xref:System.Messaging.Message> klasy, która ma pustą treść.  
  
 Określ właściwość lub właściwość przed wysłaniem <xref:System.Messaging.Message>obiektu. <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A> Właściwość może być dowolnym obiektem, który może być serializowany, taki jak ciąg tekstowy, obiekt struktury, wystąpienie klasy lub osadzony obiekt.  
  
 Jeśli zawartość komunikatu nie zostanie zapisana bezpośrednio do <xref:System.Messaging.Message.BodyStream%2A> właściwości, należy <xref:System.Messaging.Message.Formatter%2A> ustawić właściwość przed wysłaniem wiadomości. Treść jest serializowana przy użyciu <xref:System.Messaging.Message.Formatter%2A> wartości właściwości w <xref:System.Messaging.MessageQueue.Send%2A> momencie wywołania <xref:System.Messaging.MessageQueue> metody w wystąpieniu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno sprzężony, więc nie trzeba mieć tego samego typu obiektu na nadawcy i odbiorniku podczas korzystania z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> I<xref:System.Messaging.BinaryMessageFormatter> serializować dane do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub otrzymywania składników com.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Podstawowa dostawca usług kryptograficznych firmy Microsoft w wersji 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je w późniejszym czasie.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt, który ma zostać Zserializowany w treści wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.Message" /> klasy, <see cref="T:System.Messaging.XmlMessageFormatter" /> używając do serializacji określonego obiektu w treści wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie <xref:System.Messaging.Message> klasy, która <xref:System.Messaging.Message.Body%2A> zawiera określony `body` parametr. `body` Parametr może być dowolnym obiektem, który może być serializowany, taki jak ciąg tekstowy, obiekt struktury, wystąpienie klasy lub osadzony obiekt. Treść jest serializowana przy użyciu <xref:System.Messaging.XmlMessageFormatter> , chyba że <xref:System.Messaging.Message.Formatter%2A> zmienisz właściwość przed <xref:System.Messaging.Message> wysłaniem. W przypadku zmiany <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.Formatter%2A> w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>komunikat zostanie Zserializowany zgodnie z nową wartością właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno sprzężony, więc nie trzeba mieć tego samego typu obiektu na nadawcy i odbiorniku podczas korzystania z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> I<xref:System.Messaging.BinaryMessageFormatter> serializować dane do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub otrzymywania składników com.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Podstawowa dostawca usług kryptograficznych firmy Microsoft w wersji 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametr.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nową kolejkę, wysyła do niej komunikat zawierający zamówienie, a następnie pobiera go.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt, który ma zostać Zserializowany w treści wiadomości.</param>
        <param name="formatter">A <see cref="T:System.Messaging.IMessageFormatter" /> , który określa program formatujący, za pomocą którego można serializować treść wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie <see cref="T:System.Messaging.Message" /> klasy przy użyciu określonego programu formatującego do serializacji określonego obiektu w treści wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie <xref:System.Messaging.Message> klasy, która <xref:System.Messaging.Message.Body%2A> zawiera określony `body` parametr i który używa dowolnego prawidłowego programu formatującego do serializacji treści. `body` Parametr jest dowolnym obiektem, który może być serializowany, taki jak ciąg tekstowy, obiekt struktury, wystąpienie klasy lub osadzony obiekt. W przypadku zmiany <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.Formatter%2A> w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>komunikat zostanie Zserializowany zgodnie z nową wartością właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno sprzężony, więc nie trzeba mieć tego samego typu obiektu na nadawcy i odbiorniku podczas korzystania z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> I<xref:System.Messaging.BinaryMessageFormatter> serializować dane do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub otrzymywania składników com.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Podstawowa dostawca usług kryptograficznych firmy Microsoft w wersji 1,0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametr.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` Parametr.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|Tablica bajtów o zerowej długości|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ komunikatu potwierdzającego do zwrócenia do aplikacji wysyłającej.</summary>
        <value>Jedna z <see cref="T:System.Messaging.AcknowledgeTypes" /> wartości, która reprezentuje typy komunikatów potwierdzających wpisów systemu w kolejce administracyjnej i warunki, w których potwierdzenia są zwracane do aplikacji wysyłającej. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość określa typ komunikatów potwierdzających żądany przez aplikację wysyłającą. <xref:System.Messaging.Message.AcknowledgeType%2A> Ustaw właściwość przed wysłaniem komunikatu, aby zażądać powiadomienia o określonych wystąpieniach — na przykład komunikat docierający do kolejki docelowej, pobierany komunikat lub limit czasu uniemożliwiający pobranie komunikatu z Kolejka docelowa.  
  
 Usługa kolejkowania komunikatów zwraca powiadomienie przez wysłanie komunikatów potwierdzenia do <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości określonej przez oryginalny komunikat. <xref:System.Messaging.Message.Acknowledgment%2A> Właściwość komunikatu potwierdzającego wskazuje typ potwierdzenia, który reprezentuje. Na przykład jeśli wiadomość potwierdzająca została wysłana, ponieważ wiadomość nie dotarła do miejsca docelowego przed <xref:System.Messaging.Message.TimeToReachQueue%2A> upływem interwału <xref:System.Messaging.Message.Acknowledgment%2A> , właściwość komunikatu potwierdzającego będzie zawierać wartość `ReachQueueTimeout`.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Komunikat jest filtrowany do ignorowania <see cref="P:System.Messaging.Message.AcknowledgeType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasyfikację potwierdzenia, że ta wiadomość reprezentuje.</summary>
        <value>Jedna z <see cref="T:System.Messaging.Acknowledgment" /> wartości wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po otrzymaniu komunikatu z kolejki administracyjnej Odczytaj <xref:System.Messaging.Message.Acknowledgment%2A> właściwość, aby zweryfikować stan oryginalnej wiadomości.  
  
 Po wysłaniu komunikatu do kolejki docelowej usługa kolejkowania komunikatów może zażądać wysłania wiadomości z potwierdzeniem. Taki komunikat może wskazywać na przykład, czy komunikat dotarł i został pobrany w określonych przedziałach czasowych, czy może wskazywać na to, co poszło źle, w przypadku niepowodzenia dostawy. Kolejka docelowa zwraca komunikaty potwierdzające i publikuje je w kolejce administracyjnej określonej we <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości oryginalnej wiadomości. <xref:System.Messaging.Message.Id%2A> Właściwość wiadomości potwierdzającej identyfikuje komunikat potwierdzający, a nie oryginalny komunikat. Identyfikator oryginalnej wiadomości można znaleźć we <xref:System.Messaging.Message> <xref:System.Messaging.Message.CorrelationId%2A> właściwości wystąpienia potwierdzenia.  
  
 Jeśli to <xref:System.Messaging.Message> wystąpienie reprezentuje komunikat z potwierdzeniem <xref:System.Messaging.Message.Acknowledgment%2A> , właściwość określa typ potwierdzenia. W przeciwnym `Normal`razie <xref:System.Messaging.Message.Acknowledgment%2A> Właściwość zawiera wartość.  
  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Użyj właściwości oryginalnej wiadomości, aby określić sytuacje, w których zostaną zwrócone potwierdzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejkę odbierającą komunikaty potwierdzające generowane przez usługę kolejkowania komunikatów.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> Określa kolejkę administracyjną służącą do wygenerowanych przez system komunikatów potwierdzających. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kolejka określona we <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości może być dowolną kolejką nietransakcyjną. Komunikaty potwierdzające wysyłane do kolejki administracyjnej mogą wskazywać, czy oryginalny komunikat osiągnął kolejkę docelową i czy został usunięty z kolejki.  
  
 Gdy właściwość ma dowolną wartość inną niż `None`, aplikacja wysyłająca musi określić kolejkę, która ma być używana jako kolejka administracyjna. <xref:System.Messaging.Message.AcknowledgeType%2A>  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AdministrationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dodatkowe informacje specyficzne dla aplikacji.</summary>
        <value>Informacje specyficzne dla aplikacji. Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> Właściwość zawiera informacje specyficzne dla aplikacji, za pomocą których można organizować różne typy komunikatów. Można na przykład użyć indeksów specyficznych dla aplikacji. Jest odpowiedzialna za aplikacje do interpretowania <xref:System.Messaging.Message.AppSpecific%2A> informacji o właściwościach.  
  
 Zawsze, gdy to możliwe, należy uwzględnić dane wiadomości w treści wiadomości, a nie na <xref:System.Messaging.Message.AppSpecific%2A> właściwości.  
  
 Podczas pracy z kolejkami obcymi Użyj <xref:System.Messaging.Message.Extension%2A> właściwości, aby określić właściwości komunikatu, które nie istnieją w usłudze kolejkowania komunikatów. Podobnie jak w <xref:System.Messaging.Message.AppSpecific%2A> przypadku właściwości, odpowiada aplikacji, aby zrozumieć zawartość <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AppSpecific" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę odebrania komunikatu w kolejce docelowej.</summary>
        <value><see cref="T:System.DateTime" /> Reprezentuje godzinę przybycia komunikatu w kolejce docelowej. Czas jest dostosowywany od GMT do czasu lokalnego na komputerze, na którym znajduje się kolejka docelowa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość komunikatu wskazuje, jak szybko należy odebrać komunikat z kolejki docelowej. Czasomierz <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości jest uruchamiany, gdy komunikat jest wysyłany, a nie po nadejściu wiadomości w kolejce.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.ArrivedTime%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ArrivedTime" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy identyfikator nadawcy powinien zostać dołączony do wiadomości.</summary>
        <value><see langword="true" />Jeśli powinna być dołączona do wiadomości; w przeciwnym razie <see langword="false" />,. <see cref="P:System.Messaging.Message.SenderId" /> Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> Właściwość jest tablicą bajtów reprezentującą identyfikator użytkownika wysyłającego. Identyfikator nadawcy jest ustawiany przez usługę kolejkowania komunikatów i jest używany przez Menedżera kolejki odbioru w celu sprawdzenia, czy nadawca ma prawa dostępu do kolejki.  
  
 Brak identyfikatora nadawcy to wskazanie przez aplikację wysyłającą, którą usługa kolejkowania komunikatów nie powinna zweryfikować nadawcy wiadomości ani zweryfikować praw dostępu nadawcy do kolejki odbiorczej. <xref:System.Messaging.Message.SenderId%2A> Jest godna zaufania tylko wtedy, gdy wiadomość została uwierzytelniona po osiągnięciu kolejki docelowej. Komunikat jest odrzucany po osiągnięciu kolejki docelowej, jeśli kolejka akceptuje tylko uwierzytelnione komunikaty i <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> albo właściwość jest `false`.  
  
> [!CAUTION]
>  Jeśli komunikat zostanie odrzucony, jest wysyłany do kolejki utraconych wiadomości (Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `true`) lub ignorowany. Można żądać potwierdzeń, gdy komunikat nie dociera do kolejki. W przeciwnym razie <xref:System.Messaging.Message.UseDeadLetterQueue%2A> , `false` gdy komunikat może zostać utracony bez ostrzeżenia.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.AttachSenderId%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AttachSenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość została uwierzytelniona.</summary>
        <value><see langword="true" />Jeśli zażądano uwierzytelnienia komunikatu po wprowadzeniu kolejki; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> Właściwość jest używana tylko przez aplikację w czasie, gdy współdziała z komunikatem i próbuje określić, czy zażądano uwierzytelniania. Jeśli komunikat znajduje się w kolejce, wiadomość została uwierzytelniona. Z drugiej strony <xref:System.Messaging.Message.Authenticated%2A> , jeśli właściwość `true`ma wartość, Menedżer kolejki odbierania uwierzytelnia komunikat po odebraniu tego komunikatu.  
  
 Nie można określić, czy nie można uwierzytelnić komunikatu, sprawdzając jego właściwości. Usługa kolejkowania komunikatów odrzuca komunikaty, które nie są uwierzytelniane, zanim zostaną dostarczone do kolejki. Można jednak zażądać wysłania komunikatu potwierdzającego, jeśli błąd dostarczania uniemożliwia odebranie komunikatu w kolejce.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.Authenticated%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Authenticated" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości.</summary>
        <value>Nazwa dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości. Wartość domyślna to dostawca usług kryptograficznych firmy Microsoft w wersji 1,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwykle używasz <xref:System.Messaging.Message.AuthenticationProviderName%2A> podczas pracy z kolejkami obcymi. Usługa kolejkowania komunikatów wymaga nazwy dostawcy uwierzytelniania i typu dostawcy uwierzytelniania dostawcy usług kryptograficznych (dostawcy uwierzytelniania) do weryfikowania podpisów cyfrowych obu komunikatów wysyłanych do kolejki obcej i komunikatów przekazywanych do wiadomości Kolejkowanie z kolejki obcej.  
  
 Podczas wysyłania komunikatu zawsze ustawiaj <xref:System.Messaging.Message.AuthenticationProviderName%2A> właściwości i. <xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości usługa kolejkowania komunikatów ignoruje nazwę dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiony.  
  
 Właściwość nie może być `null`, ale może być pustym ciągiem (""). <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości. <see cref="P:System.Messaging.Message.AuthenticationProviderName" />  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.AuthenticationProviderName" /> Ustawiono<see langword="null" />wartość.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości.</summary>
        <value>Jedna z <see cref="T:System.Messaging.CryptographicProviderType" /> wartości. Wartość domyślna to <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj <xref:System.Messaging.Message.AuthenticationProviderType%2A> właściwość jest używana podczas pracy z kolejkami obcymi, aby określić, który dostawca usług kryptograficznych jest skojarzony z komunikatem. Usługa kolejkowania komunikatów wymaga nazwy dostawcy uwierzytelniania i typu dostawcy uwierzytelniania dostawcy usług kryptograficznych (dostawcy uwierzytelniania) do weryfikowania podpisów cyfrowych obu komunikatów wysyłanych do kolejki obcej i komunikatów przekazywanych do wiadomości Kolejkowanie z kolejki obcej.  
  
 Tylko `RsaFull` jest przeznaczony do użycia z obsługą wiadomości.  
  
 Podczas wysyłania komunikatu zawsze ustawiaj <xref:System.Messaging.Message.AuthenticationProviderType%2A> właściwości i. <xref:System.Messaging.Message.ConnectorType%2A> Po wysłaniu wiadomości usługa kolejkowania komunikatów ignoruje typ dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiony.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nie można ustawić właściwości. <see cref="P:System.Messaging.Message.AuthenticationProviderType" />  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość wiadomości.</summary>
        <value>Obiekt, który określa zawartość komunikatu. Obiekt może być ciągiem, datą, walutą, liczbą, tablicą bajtów lub dowolnym zarządzanym obiektem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Body%2A> Właściwość komunikatu zwykle zawiera dane skojarzone z wiadomością. Chociaż można wysłać dane specyficzne dla <xref:System.Messaging.Message.AppSpecific%2A> aplikacji we właściwościach i <xref:System.Messaging.Message.Extension%2A> , w miarę możliwości należy <xref:System.Messaging.Message.Body%2A> uwzględnić w komunikacie dane dotyczące komunikatów. Tylko zawartość <xref:System.Messaging.Message.Body%2A> właściwości jest serializowana lub zaszyfrowana.  
  
 <xref:System.Messaging.Message.Body%2A> Właściwość może zawierać dowolny obiekt, którego rozmiar nie przekracza 4 MB. Jeśli używasz <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> do wysyłania dowolnego obiektu, który nie jest typu <xref:System.Messaging.Message> do <xref:System.Messaging.Message> <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.MessageQueue>, obiekt ten zostanie umieszczony we właściwości wystąpienia zwróconego przez <xref:System.Messaging.MessageQueue.Peek%2A> lub <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Argument String w `MessageQueue.Send("hello.")` jest przykładem takiego obiektu generycznego.  
  
 <xref:System.Messaging.Message.BodyType%2A> Właściwość wskazuje typ informacji przechowywanych w treści komunikatu. Usługa kolejkowania komunikatów używa tych informacji do identyfikowania typu <xref:System.Messaging.Message.Body%2A> zawartości właściwości.  
  
 Określ właściwość lub właściwość przed wysłaniem <xref:System.Messaging.Message>obiektu. <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message.Body%2A> <xref:System.Messaging.Message.Body%2A> Właściwość może być dowolnym obiektem możliwym do serializacji, takim jak ciąg tekstowy, obiekt struktury, wystąpienie klasy lub osadzony obiekt.  
  
 Jeśli zawartość komunikatu nie zostanie zapisana bezpośrednio do <xref:System.Messaging.Message.BodyStream%2A> właściwości, należy <xref:System.Messaging.Message.Formatter%2A> ustawić właściwość przed wysłaniem wiadomości. Gdy metoda jest wywoływana <xref:System.Messaging.MessageQueue> w wystąpieniu, treść jest serializowana przy użyciu <xref:System.Messaging.Message.Formatter%2A> programu formatującego zawartego we właściwości. <xref:System.Messaging.MessageQueue.Send%2A> W przypadku wysłania komunikatu bez określenia wartości <xref:System.Messaging.Message.Formatter%2A> właściwości program formatujący <xref:System.Messaging.XmlMessageFormatter>domyślnie przyjmuje wartość.  
  
> [!NOTE]
>  Próba ustawienia treści komunikatu do <xref:System.Decimal.MaxValue> spowoduje, że zostanie <xref:System.OverflowException> `Send` wywołana <xref:System.Messaging.ActiveXMessageFormatter> Metoda <xref:System.Messaging.MessageQueue> klasy i zostanie użyta.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je w późniejszym czasie.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Messaging.Message.Formatter" /> Właściwość jest<see langword="null" />.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje w treści wiadomości.</summary>
        <value>A <see cref="T:System.IO.Stream" /> , który zawiera zserializowane informacje zawarte <see cref="P:System.Messaging.Message.Body" /> w wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Treść komunikatu może zawierać dowolny typ informacji — na przykład ciąg, datę, walutę, liczbę, tablicę bajtów lub dowolny obiekt zarządzany. Te informacje są serializowane w <xref:System.IO.Stream> celu przekazywania do kolejki.  
  
 Określ właściwość lub właściwość przed wysłaniem <xref:System.Messaging.Message>obiektu. <xref:System.Messaging.Message.BodyStream%2A> <xref:System.Messaging.Message.Body%2A> Jeśli ustawisz <xref:System.Messaging.Message.Body%2A> właściwość, zawartość jest serializowana <xref:System.Messaging.Message.BodyStream%2A> do właściwości. Można jednak wybrać opcję bezpośredniego zapisu <xref:System.Messaging.Message.BodyStream%2A> właściwości. Jest to przydatne na przykład wtedy, gdy chcesz otworzyć połączenie z plikiem i przesłać strumieniowo jego zawartość jako treść wiadomości.  
  
 Jeśli zawartość komunikatu nie zostanie zapisana bezpośrednio do <xref:System.Messaging.Message.BodyStream%2A> właściwości, należy <xref:System.Messaging.Message.Formatter%2A> ustawić właściwość przed wysłaniem wiadomości. Gdy metoda jest wywoływana <xref:System.Messaging.MessageQueue> w wystąpieniu, treść jest serializowana przy użyciu <xref:System.Messaging.Message.Formatter%2A> programu formatującego zawartego we właściwości. <xref:System.Messaging.MessageQueue.Send%2A> W przypadku wysłania komunikatu bez określenia wartości <xref:System.Messaging.Message.Formatter%2A> właściwości program formatujący <xref:System.Messaging.XmlMessageFormatter>domyślnie przyjmuje wartość.  
  
 Jeśli ustawisz <xref:System.Messaging.Message.UseEncryption%2A> `true` właściwość na dla treści tego komunikatu, komunikat zostanie zaszyfrowany w momencie wysłania, a <xref:System.Messaging.Message.Body%2A> nie podczas ustawiania właściwości. W związku z <xref:System.Messaging.Message.BodyStream%2A> tym Właściwość nigdy nie jest zaszyfrowana.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ danych, które zawiera treść wiadomości.</summary>
        <value>Typ prawdziwej treści wiadomości, na przykład ciąg, datę, walutę lub liczbę.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów rozpoznaje zawartość treści jako obiekt lub jako strumień serializowany. Właściwość wskazuje typ obiektu <xref:System.Messaging.Message.Body%2A> we właściwości komunikatu. <xref:System.Messaging.Message.BodyType%2A>  
  
 <xref:System.Messaging.XmlMessageFormatter> Wykonuje powiązanie między typami natywnymi a obiektem w treści komunikatu. Jeśli używasz <xref:System.Messaging.XmlMessageFormatter>, program formatujący <xref:System.Messaging.Message.BodyType%2A> ustawia właściwość.  
  
 Inne elementy formatujące mogą również udostępniać funkcje wiążące, jak pokazano w C# poniższym kodzie.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.BodyType%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że niektóre właściwości komunikatów zwykle ustawiane przez usługę kolejkowania komunikatów były ustawiane przez aplikację wysyłającą.</summary>
        <value><see cref="T:System.Guid" /> Zdefiniowane przez aplikację i używane w połączeniu z aplikacjami łączników lub szyfrowaniem wiadomości. Umożliwia <see cref="T:System.Guid" /> to aplikacji odbiorczej interpretowanie właściwości wiadomości ustawionych przez aplikację wysyłającą, ale zazwyczaj ustawionych przez usługę kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów wymaga, <xref:System.Messaging.Message.ConnectorType%2A> aby właściwość była ustawiana za każdym razem, gdy aplikacja ustawia właściwość komunikatu, która jest zwykle ustawiana przez usługę kolejkowania komunikatów. Aplikacja zwykle używa <xref:System.Messaging.Message.ConnectorType%2A> w następujących dwóch przypadkach:  
  
-   Za każdym razem, gdy aplikacja łącznika przekazuje komunikat. <xref:System.Messaging.Message.ConnectorType%2A> Informuje o wysyłaniu i otrzymywaniu aplikacji, jak interpretować właściwości zabezpieczeń i potwierdzania wiadomości.  
  
-   Za każdym razem, gdy aplikacja wysyłająca, a nie usługa kolejkowania komunikatów, szyfruje komunikat. Informuje usługę kolejkowania komunikatów, aby <xref:System.Messaging.Message.DestinationSymmetricKey%2A> użyć wartości właściwości w celu odszyfrowania wiadomości. <xref:System.Messaging.Message.ConnectorType%2A>  
  
 Należy ustawić właściwość w <xref:System.Messaging.Message.ConnectorType%2A> przypadku ustawienia dowolnej z następujących właściwości (w przeciwnym razie Kolejka ignoruje te właściwości po wysłaniu wiadomości):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ConnectorType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia identyfikator komunikatu używany przez potwierdzenia, raport i komunikaty odpowiedzi, aby odwołać się do oryginalnej wiadomości.</summary>
        <value>Identyfikator komunikatu określony przez <see cref="P:System.Messaging.Message.Id" /> Właściwość oryginalnej wiadomości. Identyfikator korelacji jest używany przez usługę kolejkowania komunikatów podczas generowania potwierdzenia lub komunikatu raportu oraz przez aplikację, gdy generuje komunikat odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy usługa kolejkowania komunikatów generuje komunikat potwierdzenia lub raportu, używa właściwości identyfikator korelacji, aby określić identyfikator wiadomości oryginalnej wiadomości. W ten sposób identyfikator korelacji łączy raport lub komunikat potwierdzający z oryginalną wiadomością.  
  
 Aplikacja wysyłająca może następnie dopasować potwierdzenie lub raport z oryginalnym komunikatem przy użyciu <xref:System.Messaging.Message.CorrelationId%2A> właściwości, aby zidentyfikować <xref:System.Messaging.Message.Id%2A> Właściwość oryginalnego komunikatu.  
  
 Aplikacje łącznika muszą również ustawić <xref:System.Messaging.Message.CorrelationId%2A> Właściwość komunikatów potwierdzających i raportów na identyfikator wiadomości oryginalnej wiadomości.  
  
 Gdy aplikacja wysyła komunikat odpowiedzi do aplikacji wysyłającej, można ustawić <xref:System.Messaging.Message.CorrelationId%2A> Właściwość komunikatu odpowiedzi na identyfikator wiadomości oryginalnej wiadomości. Aplikacja wysyłająca może następnie dopasować komunikat odpowiedzi do wysłanego komunikatu.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.CorrelationId" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.CorrelationId" /> Ma<see langword="null" />wartość.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera zaplanowaną kolejkę docelową dla wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.MessageQueue" /> określa zaplanowaną kolejkę docelową wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> Właściwość jest najczęściej używana do określenia oryginalnego miejsca docelowego komunikatu, który dotarł do dziennika lub kolejki utraconych wiadomości. Zazwyczaj nie trzeba analizować tej właściwości, ponieważ zazwyczaj pobierany jest komunikat z kolejki docelowej.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.DestinationQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DestinationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz symetryczny używany do szyfrowania komunikatów szyfrowanych przez aplikacje lub komunikatów wysyłanych do kolejek obcych.</summary>
        <value>Tablica wartości bajtów, która określa docelowy klucz symetryczny używany do szyfrowania wiadomości. Wartość domyślna to tablica o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa scenariusze wymagają użycia <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwości. Pierwszy polega na tym, że aplikacja, a nie usługa kolejkowania komunikatów, szyfruje komunikat. Druga z nich polega na wysłaniu zaszyfrowanego komunikatu do systemu kolejkowania poza kolejką komunikatów.  
  
 Przed ustawieniem tej właściwości należy zaszyfrować klucz symetryczny przy użyciu klucza publicznego Menedżera kolejki odbiorczej. Po wysłaniu wiadomości zaszyfrowanej przez aplikację Menedżer kolejki otrzymującej używa klucza symetrycznego do odszyfrowania komunikatu przed wysłaniem go do kolejki docelowej.  
  
 Po wysłaniu komunikatu do kolejki obcej komunikat jest najpierw odbierany przez odpowiednią aplikację łącznika, która przekazuje zaszyfrowaną wiadomość z dołączonym kluczem symetrycznym do aplikacji odbiorczej. Następnie odpowiedzialność aplikacji odbiorczej o odszyfrowanie komunikatu przy użyciu klucza symetrycznego.  
  
 Po ustawieniu <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwości należy również <xref:System.Messaging.Message.ConnectorType%2A> ustawić właściwość. Po wysłaniu wiadomości usługa kolejkowania komunikatów ignoruje <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwość, <xref:System.Messaging.Message.ConnectorType%2A> Jeśli właściwość nie jest również ustawiona.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Właściwość ma maksymalny rozmiar tablicy wynoszący 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> Ma<see langword="null" />wartość.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podpis cyfrowy wykorzystywany przez usługę kolejkowania komunikatów do uwierzytelniania wiadomości.</summary>
        <value>Tablica wartości bajtów określająca podpis cyfrowy usługi kolejkowania komunikatów 1,0 używany do uwierzytelniania wiadomości. Wartość domyślna to tablica o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów używa podpisu cyfrowego podczas uwierzytelniania komunikatów, które zostały wysłane przez usługę kolejkowania komunikatów w wersji 1,0. W większości przypadków usługa kolejkowania komunikatów generuje i ustawia <xref:System.Messaging.Message.DigitalSignature%2A> właściwość, gdy aplikacja wysyłająca żąda uwierzytelnienia. Aplikacja do odbierania używa tej właściwości do pobrania podpisu cyfrowego dołączanego do wiadomości.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwości można używać tylko podczas uruchamiania usługi kolejkowania komunikatów w wersji 2,0. Aplikacja wysyłająca musi określać sygnatury usługi kolejkowania komunikatów w wersji 1,0 podczas żądania uwierzytelnienia. Jeśli aplikacja wysyłająca wysyła sygnaturę usługi kolejkowania komunikatów w wersji 2,0, ta właściwość zawiera bufor zawierający cztery bajty, z których każdy zawiera zero.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwość wraz <xref:System.Messaging.Message.SenderCertificate%2A> z właściwością jest również używana przez aplikacje łącznika podczas wysyłania komunikatu. W tym scenariuszu aplikacja łącznika — zamiast usługi kolejkowania komunikatów — generuje podpis cyfrowy, który opiera się na certyfikacie użytkownika wysyłającego wiadomość.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwość ma maksymalny rozmiar tablicy wynoszący 256.  
  
 Po ustawieniu <xref:System.Messaging.Message.DigitalSignature%2A> właściwości należy również <xref:System.Messaging.Message.ConnectorType%2A> ustawić właściwość. Po wysłaniu komunikatu usługa kolejkowania komunikatów ignoruje <xref:System.Messaging.Message.DigitalSignature%2A> właściwość, <xref:System.Messaging.Message.ConnectorType%2A> Jeśli właściwość nie jest również ustawiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.DigitalSignature" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.DigitalSignature" /> Właściwość jest<see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytm szyfrowania używany do szyfrowania treści wiadomości prywatnej.</summary>
        <value>Jedna z <see cref="T:System.Messaging.EncryptionAlgorithm" /> wartości wyliczenia. Wartość domyślna to <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny (zaszyfrowany), jest szyfrowany przed wysłaniem i odszyfrowany po odebraniu. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Właściwość określa algorytm używany do szyfrowania treści wiadomości prywatnej.  
  
 Kolejka może wymagać szyfrowania wiadomości przychodzących. Jeśli aplikacja wysyła niezaszyfrowany (nieprywatny) komunikat do kolejki, która akceptuje tylko wiadomości prywatne, lub jeśli wysyła wiadomość prywatną do kolejki, która akceptuje tylko komunikaty nieprywatne, kolejka odrzuca komunikat. Aplikacja wysyłająca może zażądać, aby w takim przypadku zwracał komunikat z potwierdzeniem negatywnym.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dodatkowe zdefiniowane przez aplikację informacje skojarzone z wiadomością.</summary>
        <value>Tablica wartości bajtów, która zawiera informacje zdefiniowane przez aplikację skojarzone z wiadomością. Wartość domyślna to tablica o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> Właściwość zapewnia informacje zdefiniowane przez aplikację, takie jak duży obiekt binarny, który jest skojarzony z komunikatem. Jest odpowiedzialna za aplikację otrzymującą do interpretowania zawartości <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 Tam, gdzie to możliwe, należy uwzględnić dane wiadomości <xref:System.Messaging.Message.Body%2A> we właściwości komunikatu, a nie na <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 Podczas pracy z kolejkami obcymi Użyj <xref:System.Messaging.Message.Extension%2A> właściwości, aby określić właściwości komunikatu, które nie istnieją w usłudze kolejkowania komunikatów.  
  
 Kolejka obca istnieje w systemie kolejkowania niż usługa kolejkowania komunikatów firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takimi kolejkami za pośrednictwem aplikacji łącznika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Extension" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Extension" /> Właściwość jest<see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia program formatujący służący do serializacji obiektu do lub deserializacji obiektu z treści komunikatu.</summary>
        <value><see cref="T:System.Messaging.IMessageFormatter" /> Tworzy strumień do zapisu lub odczytu z treści wiadomości. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Formatter%2A> Użyj właściwości podczas odczytywania i zapisywania komunikatu. Gdy wiadomość jest wysyłana do kolejki, program formatujący serializować <xref:System.Messaging.Message.Body%2A> właściwość do strumienia, który można wysłać do kolejki komunikatów. Podczas odczytywania z kolejki program formatujący deserializacjije dane komunikatu do <xref:System.Messaging.Message.Body%2A> właściwości.  
  
 Jeśli zawartość komunikatu nie zostanie zapisana bezpośrednio do <xref:System.Messaging.Message.BodyStream%2A> właściwości, należy <xref:System.Messaging.Message.Formatter%2A> ustawić właściwość przed wysłaniem wiadomości. Gdy metoda jest wywoływana <xref:System.Messaging.MessageQueue> w wystąpieniu, treść jest serializowana przy użyciu <xref:System.Messaging.Message.Formatter%2A> programu formatującego zawartego we właściwości. <xref:System.Messaging.MessageQueue.Send%2A> W przypadku wysłania komunikatu bez określenia wartości <xref:System.Messaging.Message.Formatter%2A> właściwości program formatujący <xref:System.Messaging.XmlMessageFormatter>domyślnie przyjmuje wartość.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno sprzężony, więc nie trzeba mieć tego samego typu obiektu na nadawcy i odbiorniku podczas korzystania z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> I<xref:System.Messaging.BinaryMessageFormatter> serializować dane do reprezentacji binarnej. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany podczas wysyłania lub otrzymywania składników com.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu demonstruje formatowanie treści komunikatu przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Messaging.Message.Formatter" /> Właściwość jest<see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytm wyznaczania wartości skrótu używany przez usługę kolejkowania komunikatów podczas uwierzytelniania wiadomości lub tworzenia podpisu cyfrowego wiadomości.</summary>
        <value>Jedna z <see cref="T:System.Messaging.HashAlgorithm" /> wartości wyliczenia. W przypadku systemu Windows XP wartość domyślna <see langword="SHA" />to. W przeciwnym razie wartość domyślna <see langword="MD5" />to.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na komputerze źródłowym Usługa kolejkowania komunikatów używa algorytmu wyznaczania wartości skrótu podczas tworzenia podpisu cyfrowego wiadomości. Program target QUEUE Manager używa tego samego algorytmu wyznaczania wartości skrótu do uwierzytelniania wiadomości po odebraniu.  

 Ze względu na kolizje problemów z algorytmem MD5 i algorytmem SHA1 firma Microsoft zaleca SHA256. 
 
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.HashAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator wiadomości.</summary>
        <value>Unikatowy identyfikator wiadomości, który jest generowany przez usługę kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów generuje identyfikator komunikatu podczas wysyłania wiadomości. Identyfikator składa się z 20 bajtów i zawiera dwa elementy: <xref:System.Guid> komputer komputera wysyłającego i unikatowy identyfikator wiadomości na komputerze. Kombinacja dwóch elementów generuje identyfikator wiadomości, który jest unikatowy w sieci.  
  
 Usługa kolejkowania komunikatów generuje identyfikatory komunikatów dla wszystkich komunikatów — w tym potwierdzenia i komunikatów raportów. Komunikat potwierdzający jest zazwyczaj wysyłany przez usługę kolejkowania komunikatów w odpowiedzi na nadejście lub niepowodzenie oryginalnej, wysłanej wiadomości. Wartość <xref:System.Messaging.Message.Id%2A> właściwości oryginalnego komunikatu można znaleźć <xref:System.Messaging.Message.CorrelationId%2A> we właściwości wiadomości potwierdzającej.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości można również użyć podczas wysyłania komunikatu odpowiedzi do kolejki odpowiedzi. Aby dołączyć identyfikator oryginalnej wiadomości w komunikacie odpowiedzi, ustaw <xref:System.Messaging.Message.CorrelationId%2A> Właściwość komunikatu odpowiedzi <xref:System.Messaging.Message.Id%2A> na Właściwość oryginalnej wiadomości. Aplikacja odczytująca komunikat odpowiedzi może następnie użyć identyfikatora korelacji komunikatu odpowiedzi, aby zidentyfikować oryginalny komunikat.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera komunikat zawierający zamówienie do i z kolejki. Zażąda pozytywnego potwierdzenia, gdy oryginalny komunikat osiągnie lub zostanie pobrany z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Id" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, że limit czasu nie istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A>i <xref:System.Messaging.Message.TimeToReachQueue%2A> Wymagaj wartości określającej limit czasu. W przypadku dawnego limitu czasu jest maksymalny dozwolony czas odbierania komunikatu z kolejki. W przypadku tej ostatniej przekroczenie limitu czasu zezwala na komunikat docierający do kolejki. W obu przypadkach można określić limit czasu jako liczbę sekund lub użyć <xref:System.Messaging.Message.InfiniteTimeout> , aby wskazać, że limit czasu nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu demonstruje użycie <xref:System.Messaging.Message.InfiniteTimeout> pola.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była pierwszą wiadomością wysłaną w transakcji.</summary>
        <value><see langword="true" />Jeśli wiadomość była pierwszą wiadomością wysłaną w transakcji; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje do odbioru używają <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2,0 lub nowszej.  
  
 Aby sprawdzić granice transakcji, można użyć <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości wraz z dwiema innymi właściwościami: <xref:System.Messaging.Message.IsLastInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Użyj tej opcji, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w transakcji, i Użyj tej ostatniej do pobrania identyfikatora transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w transakcji, <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości i <xref:System.Messaging.Message.IsLastInTransaction%2A> są ustawiane na. `true`  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była ostatnią wiadomością wysłaną w transakcji.</summary>
        <value><see langword="true" />Jeśli wiadomość była ostatnią wiadomością wysłaną w ramach pojedynczej transakcji; w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje do odbioru używają <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2,0 lub nowszej.  
  
 Aby sprawdzić granice transakcji, można użyć <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości wraz z dwiema innymi właściwościami: <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Użyj tej opcji, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w transakcji, i Użyj tej ostatniej do pobrania identyfikatora transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w transakcji, <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości i <xref:System.Messaging.Message.IsLastInTransaction%2A> są ustawiane na. `true`  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.IsLastInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ciąg Unicode zdefiniowany przez aplikację, który opisuje komunikat.</summary>
        <value>Etykieta komunikatu. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Etykiety wiadomości można użyć do kilku celów. Na przykład można użyć go do celów wyświetlania lub selektywnie przetwarzać komunikaty na podstawie wartości etykiety. Etykieta nie musi być unikatowa w obrębie komunikatów.  
  
 Etykiety kolejki komunikatów i komunikatów reprezentują wartość zdefiniowaną przez aplikację, która może pomóc identyfikować kolejkę lub komunikat w warunkach czytelnych dla człowieka. Jest odpowiedzialna aplikacja do interpretacji zawartości etykiety, która nie ma wewnętrznej znaczenia dla aplikacji usługi kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.Label%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Label" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzone w usłudze MSMQ 3,0. Pobiera identyfikator wyszukiwania wiadomości.</summary>
        <value>Identyfikator wyszukiwania wiadomości, który jest generowany przez usługę kolejkowania komunikatów i jest unikatowy dla kolejki, w której znajduje się komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość zapewnia dostęp tylko do odczytu do identyfikatora wyszukiwania wiadomości. Identyfikator wyszukiwania wprowadzony w usłudze MSMQ 3,0 jest identyfikatorem 64-bitowym, który jest generowany przez usługę kolejkowania komunikatów i przypisany do każdego komunikatu, gdy wiadomość zostanie umieszczona w kolejce. Identyfikator wyszukiwania nie jest taki sam jak Identyfikator komunikatu, który jest generowany podczas wysyłania wiadomości.  
  
 Usługa kolejkowania komunikatów generuje identyfikator wyszukiwania dla wszystkich komunikatów, które są umieszczane w dowolnej kolejce, w tym z wygenerowanymi przez aplikację kolejkami docelowymi, administracjami i raportami, a także z wygenerowanymi przez system dziennikami, komunikatami o utraconych, łącznikach i kolejkach wychodzących. Innymi słowy dotyczy to zarówno komunikatów wysyłanych przez wysyłanie aplikacji, jak i kolejkowanie komunikatów. Identyfikator wyszukiwania jest unikatowy dla kolejki i nie ma znaczenia poza kolejką.  
  
 Jeśli wiadomość jest wysyłana do kilku kolejek docelowych lub kopia wiadomości jest przechowywana w dzienniku komputera lub dzienniku kolejki, każda kopia wiadomości będzie miała własny identyfikator wyszukiwania, gdy zostanie umieszczony w odpowiedniej kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość można odczytać tylko na komunikatach pobranych z kolejki.  
  
 Identyfikator wyszukiwania jest używany do odczytywania określonej wiadomości w kolejce. Gdy identyfikator wyszukiwania komunikatu jest znany, aplikacja do odbierania może wywołać <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> funkcję lub <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> , aby przejść bezpośrednio do tej wiadomości i uzyskać wgląd lub pobrać ją z kolejki, w przeciwieństwie do kursorów, które muszą zostać uruchomione na początku kolejki i Przejdź do końca kolejki,  
  
 Uzyskanie identyfikatorów wyszukiwania komunikatów w kolejce jest odpowiedzialne za aplikację. Jednym z możliwych sposobów uzyskania identyfikatorów wyszukiwania jest utworzenie wyzwalacza dla kolejki docelowej, która wywołuje składnik, który buforuje identyfikatory poszczególnych komunikatów w miarę ich umieszczenia w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Nie zainstalowano usługi MSMQ 3,0.</exception>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.LookupId" /> właściwości.</exception>
        <altmember cref="Overload:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="Overload:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ komunikatu: <see langword="Normal" />, <see langword="Acknowledgment" />, lub <see langword="Report" />.</summary>
        <value>Jedna z <see cref="P:System.Messaging.Message.MessageType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów zwykle ustawia tę właściwość podczas wysyłania wiadomości. Komunikat usługi kolejkowania komunikatów może być jednym z następujących typów:  
  
-   `Normal`, który jest typowym komunikatem wysyłanym z aplikacji do kolejki lub komunikatem odpowiedzi zwróconym do aplikacji wysyłającej.  
  
-   `Acknowledgement`, która usługa kolejkowania komunikatów jest generowana za każdym razem, gdy aplikacja wysyłająca żądanie. Na przykład usługa kolejkowania komunikatów może generować komunikaty pozytywne lub ujemne, aby wskazać, że oryginalny komunikat dotarł lub został odczytany. Usługa kolejkowania komunikatów zwraca odpowiedni komunikat potwierdzający do kolejki administracyjnej określonej przez aplikację wysyłającą.  
  
-   `Report`, która usługa kolejkowania komunikatów jest generowana za każdym razem, gdy kolejka raportu jest zdefiniowana w Menedżerze kolejki źródłowej. Po włączeniu śledzenia usługa kolejkowania komunikatów wysyła komunikat raportu do kolejki raportu usługi kolejkowania komunikatów za każdym razem, gdy oryginalny komunikat przejdzie lub opuści serwer usługi kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.MessageType%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.MessageType" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia priorytet wiadomości, który określa, gdzie w kolejce zostanie umieszczony komunikat.</summary>
        <value>Jedna z <see cref="T:System.Messaging.MessagePriority" /> wartości, która reprezentuje poziomy priorytetów komunikatów nietransakcyjnych. Wartość domyślna to <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> Właściwość wpływa na to, w jaki sposób usługa kolejkowania komunikatów obsługuje komunikat zarówno w czasie, jak i po osiągnięciu jego miejsca docelowego. Komunikaty o wyższym priorytecie są przypisywane podczas routingu i wstawiane do przodu kolejki docelowej. Komunikaty o takim samym priorytecie są umieszczane w kolejce zgodnie z ich czasem przybycia.  
  
 Można ustawić zrozumiały priorytet tylko dla wiadomości nietransakcyjnych. Usługa kolejkowania komunikatów automatycznie ustawia priorytet komunikatów transakcyjnych na `Lowest`, co powoduje ignorowanie priorytetu wiadomości transakcyjnych.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła dwa komunikaty o różnych priorytetach do kolejki i pobiera je w późniejszym czasie.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Priority" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy komunikat ma być dostarczany w przypadku awarii komputera lub problemu z siecią.</summary>
        <value><see langword="true" />Jeśli dostarczenie komunikatu jest gwarantowane (przez zapisanie komunikatu na dysku w czasie wykonywania trasy); <see langword="false" /> Jeśli dostarczenie nie jest gwarantowane. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość <xref:System.Messaging.Message.Recoverable%2A> wskazuje, czy dostarczenie komunikatu jest gwarantowane — nawet w przypadku awarii komputera, gdy komunikat jest w trasie do kolejki docelowej.  
  
 Jeśli zostanie zagwarantowana dostarczenie komunikatu, komunikat jest przechowywany lokalnie na każdym etapie na trasie, dopóki komunikat nie zostanie pomyślnie przekazany do następnego komputera. Ustawienie właściwości, która `true` może mieć wpływ na przepływność. <xref:System.Messaging.Message.Recoverable%2A>  
  
 Jeśli komunikat jest transakcyjny, usługa kolejkowania komunikatów automatycznie traktuje komunikat jako możliwy do odzyskania, niezależnie od wartości <xref:System.Messaging.Message.Recoverable%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.Recoverable%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.Recoverable" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejkę odbierającą komunikaty odpowiedzi generowane przez aplikację.</summary>
        <value><see cref="T:System.Messaging.MessageQueue" /> Do którego są zwracane komunikaty odpowiedzi generowane przez aplikację. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> Właściwość identyfikuje kolejkę, która odbiera komunikaty odpowiedzi generowane przez aplikację, które aplikacja odbierająca zwraca do aplikacji wysyłającej. Aplikacja wysyłająca określa kolejki odpowiedzi, gdy aplikacja wysyła swoje wiadomości. Wszystkie dostępne kolejki można określić jako kolejkę odpowiedzi.  
  
 Komunikaty zwrócone do kolejki odpowiedzi są specyficzne dla aplikacji. Aplikacja musi definiować zawartość komunikatów oraz akcję, która ma zostać podjęta po odebraniu komunikatu.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.ResponseQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.ResponseQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst zabezpieczeń wiadomości.</summary>
        <value><see cref="T:System.Messaging.SecurityContext" /> Obiekt, który zawiera kontekst zabezpieczeń wiadomości, jeśli właściwość została wcześniej ustawiona; w przeciwnym razie wartość null.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia certyfikat zabezpieczeń używany do uwierzytelniania komunikatów.</summary>
        <value>Tablica wartości bajtowych reprezentujących certyfikat zabezpieczeń, którego usługa kolejkowania komunikatów używa do weryfikacji nadawcy wiadomości. Wartość domyślna to tablica o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja do odbioru używa właściwości <xref:System.Messaging.Message.SenderCertificate%2A> , gdy komunikat zawiera zewnętrzny certyfikat zabezpieczeń.  
  
 Usługa kolejkowania komunikatów może uwierzytelniać komunikat przy użyciu wewnętrznego lub zewnętrznego certyfikatu zabezpieczeń. Usługa kolejkowania komunikatów zapewnia certyfikaty wewnętrzne, które są używane do weryfikowania integralności komunikatów. Urząd certyfikacji udostępnia certyfikat zewnętrzny, do którego można uzyskać dostęp za pomocą <xref:System.Messaging.Message.SenderCertificate%2A> właściwości komunikatu. Oprócz zezwalania usłudze kolejkowania komunikatów na uwierzytelnianie wiadomości, certyfikat zewnętrzny umożliwia aplikacji odbiorczej dalsze sprawdzenie nadawcy. Certyfikat wewnętrzny nie ma użytecznych wartości do aplikacji odbiorczej.  
  
 Certyfikat zewnętrzny musi być zarejestrowany w usłudze katalogowej systemu kolejkowania komunikatów. Certyfikat zewnętrzny zawiera informacje o urzędzie certyfikacji, użytkowniku certyfikatu, okres ważności certyfikatu, klucz publiczny użytkownika certyfikatu i podpis urzędu certyfikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderCertificate" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator użytkownika wysyłającego.</summary>
        <value>Tablica wartości bajtowych, która identyfikuje nadawcę. Menedżer kolejki odbioru używa identyfikatora podczas uwierzytelniania wiadomości w celu zweryfikowania nadawcy wiadomości i prawa dostępu nadawcy do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli właściwość ma `false`wartość, identyfikator <xref:System.Messaging.Message.SenderId%2A> nadawcy określony we właściwości nie jest dołączany do wiadomości wysyłanej. <xref:System.Messaging.Message.AttachSenderId%2A> Oznacza to, że usługa kolejkowania komunikatów nie powinna zostać zweryfikowana, gdy wyśle komunikat do kolejki docelowej. Jeśli właściwość jest `true` ,<xref:System.Messaging.Message.SenderId%2A> wartość właściwości jest godna zaufania tylko wtedy, gdy wiadomość została uwierzytelniona. <xref:System.Messaging.Message.AttachSenderId%2A> Użyj właściwości w połączeniu z właściwością, aby zweryfikować prawa dostępu nadawcy. <xref:System.Messaging.Message.SenderId%2A> <xref:System.Messaging.Message.Authenticated%2A>  
  
 Aplikacja łącznika to aplikacja, która korzysta z serwera łącznika w celu zapewnienia komunikacji między usługą kolejkowania komunikatów i innymi systemami kolejkowania. Usługa kolejkowania komunikatów wymaga, aby aplikacje łączników zapewniały identyfikację nadawcy. <xref:System.Messaging.Message.ConnectorType%2A> Właściwość należy ustawić podczas wysyłania komunikatu przez aplikację łącznika.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję usługi kolejkowania komunikatów używaną do wysłania wiadomości.</summary>
        <value>Wersja usługi kolejkowania komunikatów użyta do wysłania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> Właściwość jest ważna dla niektórych funkcji. Na przykład przetwarzanie transakcji jest obsługiwane tylko przez usługę kolejkowania komunikatów 2,0 lub nowszą, a podpisy cyfrowe są używane do uwierzytelniania komunikatów wysyłanych przez usługę MSMQ 1,0.  
  
 Menedżer kolejki wysyłania ustawia <xref:System.Messaging.Message.SenderVersion%2A> właściwość podczas wysyłania wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.SenderVersion%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SenderVersion" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę komputera wysyłającego, który komunikat został wysłany przez Menedżera kolejki źródłowej.</summary>
        <value><see cref="T:System.DateTime" /> Reprezentuje godzinę wysłania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwość jest dostosowywana do czasu lokalnego komputera, na którym utworzono to wystąpienie <xref:System.Messaging.Message> klasy. <xref:System.Messaging.Message.SentTime%2A> Ta strefa czasowa może być inna niż w przypadku kolejek źródłowych i docelowych.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.SentTime%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SentTime" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komputer, z którego pochodzi wiadomość.</summary>
        <value>Nazwa komputera, z którego wiadomość została wysłana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format <xref:System.Messaging.Message.SourceMachine%2A> właściwości nie zawiera poprzednich dwóch ukośników (\\\\). Na przykład `myServer` jest prawidłowy <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.SourceMachine%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.SourceMachine" /> właściwości.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Nie można uzyskać dostępu do informacji o komputerze lub usługi katalogowej.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny czas odbierania wiadomości z kolejki docelowej.</summary>
        <value>Łączny czas odebrania wysyłanej wiadomości z kolejki docelowej. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość określa łączny czas odbierania wysyłanej wiadomości z kolejki docelowej. Limit czasu obejmuje czas spędzony na przystąpieniu do kolejki docelowej i czas oczekiwania w kolejce przed odebraniem wiadomości.  
  
> [!CAUTION]
>  W przypadku używania zależnych komputerów klienckich upewnij się, że zegar komputera klienckiego jest zsynchronizowany z zegarem na serwerze, na którym działa usługa kolejkowania komunikatów. W przeciwnym razie zachowanie nieprzewidywalne może wynikać z wysłaniem komunikatu <xref:System.Messaging.Message.TimeToBeReceived%2A> , którego właściwość <xref:System.Messaging.Message.InfiniteTimeout>nie jest.  
  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość wygasa przed usunięciem komunikatu z kolejki, usługa kolejkowania komunikatów odrzuca komunikat w jeden z dwóch sposobów. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Właściwość komunikatu to `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest`false`, komunikat jest ignorowany.  
  
 Możesz ustawić <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość komunikatu, aby zażądać, aby usługa kolejkowania komunikatów wysyłał negatywny komunikat potwierdzający z powrotem do aplikacji wysyłającej, jeśli wiadomość nie zostanie pobrana przed wygaśnięciem czasomierza.  
  
 Jeśli wartość określona przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość jest mniejsza niż wartość określona <xref:System.Messaging.Message.TimeToReachQueue%2A> przez właściwość, <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 Gdy kilka komunikatów jest wysyłanych w ramach pojedynczej transakcji, usługa kolejkowania komunikatów <xref:System.Messaging.Message.TimeToBeReceived%2A> używa właściwości pierwszej wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TimeToBeReceived" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Określona <see cref="P:System.Messaging.Message.TimeToBeReceived" /> wartość jest nieprawidłowa.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.TimeoutConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny czas, przez jaki komunikat dociera do kolejki.</summary>
        <value>Limit czasu wiadomości do dotarcia do kolejki docelowej, zaczynając od momentu wysłania komunikatu. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToReachQueue%2A> Właściwość wygasa zanim komunikat osiągnie miejsce docelowe, usługa kolejkowania komunikatów odrzuca komunikat w jeden z dwóch sposobów. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> Właściwość komunikatu to `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest`false`, komunikat jest ignorowany  
  
 Można ustawić <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość komunikatu, aby zażądać, aby usługa kolejkowania komunikatów wysyłał negatywny komunikat potwierdzający z powrotem do aplikacji wysyłającej, jeśli wiadomość nie zostanie odebrana przed wygaśnięciem czasomierza.  
  
 <xref:System.Messaging.Message.TimeToReachQueue%2A> Jeśli właściwość ma wartość 0 sekund, usługa kolejkowania komunikatów próbuje wysłać komunikat do lokalizacji docelowej — Jeśli kolejka oczekuje na komunikat. Jeśli kolejka jest lokalna, komunikat zawsze osiągnie ją.  
  
 Jeśli wartość określona przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwość jest większa niż wartość określona <xref:System.Messaging.Message.TimeToBeReceived%2A> przez właściwość, <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 Gdy kilka komunikatów jest wysyłanych w ramach pojedynczej transakcji, usługa kolejkowania komunikatów <xref:System.Messaging.Message.TimeToReachQueue%2A> używa właściwości pierwszej wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TimeToReachQueue" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Określona <see cref="P:System.Messaging.Message.TimeToReachQueue" /> wartość jest nieprawidłowa. Może reprezentować liczbę ujemną.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator transakcji będącej częścią wiadomości.</summary>
        <value>Identyfikator transakcji skojarzonej z wiadomością.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacje do odbioru używają <xref:System.Messaging.Message.TransactionId%2A> właściwości, aby sprawdzić, czy wiadomość została wysłana jako część określonej transakcji. Identyfikator transakcji zawiera identyfikator komputera wysyłającego (pierwszych 16 bitów), po którym następuje 4-bajtowy numer sekwencyjny transakcji.  
  
 Ta właściwość jest dostępna tylko dla usługi kolejkowania komunikatów w wersji 2,0 lub nowszej.  
  
 Identyfikatory transakcji nie mogą być unikatowe, ponieważ numery sekwencji transakcji nie są trwałe i zaczynają się ponownie przy 2 <sup>20</sup>. Usługa kolejkowania komunikatów gwarantuje tylko, że kolejne transakcje będą mieć różne numery sekwencji transakcji.  
  
 Możesz użyć <xref:System.Messaging.Message.TransactionId%2A> właściwości wraz <xref:System.Messaging.Message.IsFirstInTransaction%2A> z właściwościami i, <xref:System.Messaging.Message.IsLastInTransaction%2A> aby zweryfikować granice transakcji.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.TransactionId%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TransactionId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolejkę stanu transakcji na komputerze źródłowym.</summary>
        <value>Kolejka stanu transakcji na komputerze źródłowym, która jest używana do wysyłania komunikatów potwierdzania z powrotem do aplikacji wysyłającej. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> Właściwość identyfikuje kolejkę transakcyjną na komputerze źródłowym, który odbiera potwierdzenia odczytania z aplikacji łączników. Usługa kolejkowania komunikatów ustawia właściwość, a aplikacje łączników używają właściwości podczas pobierania komunikatów transakcyjnych wysyłanych do kolejek obcych.  
  
 Kolejka obca istnieje w systemie kolejkowania niż usługa kolejkowania komunikatów firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takimi kolejkami za pośrednictwem aplikacji łącznika.  
  
 Aplikacja łącznika może używać kolejki stanu transakcji do wysyłania komunikatów potwierdzających z powrotem do aplikacji wysyłającej. Kolejka stanu transakcji powinna otrzymywać te potwierdzenia nawet wtedy, gdy aplikacja wysyłająca nie zażąda innych potwierdzeń.  
  
   
  
## Examples  
 Poniższy przykład kodu wyświetla wartość <xref:System.Messaging.Message.TransactionStatusQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Ta właściwość może zostać odczytana tylko na komunikatach pobranych z kolejki.  
  
—lub— 
Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomość była (albo musi być) uwierzytelniona przed wysłaniem.</summary>
        <value><see langword="true" />Jeśli aplikacja nadawcza zażądała uwierzytelnienia wiadomości, w przeciwnym razie. <see langword="false" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> Właściwość określa, czy wiadomość musi zostać uwierzytelniona. Jeśli aplikacja wysyłająca żądanie uwierzytelnienia, usługa kolejkowania komunikatów tworzy podpis cyfrowy i używa go do podpisania wysyłanej wiadomości i uwierzytelniania komunikatu po odebraniu.  
  
 Jeśli <xref:System.Messaging.Message.UseAuthentication%2A> jest`false` i wysyłany jest komunikat do kolejki, która akceptuje tylko uwierzytelnione komunikaty, komunikat zostanie odrzucony po osiągnięciu kolejki.  
  
 Nie można określić, czy nie można uwierzytelnić komunikatu, sprawdzając jego właściwości. Usługa kolejkowania komunikatów odrzuca takie komunikaty przed ich dostarczeniem do kolejki. Można jednak zażądać wysłania komunikatu potwierdzającego, jeśli błąd dostarczania uniemożliwia nadejście komunikatu do kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseAuthentication" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kopia komunikatu, która nie mogła zostać dostarczona, powinna zostać wysłana do kolejki utraconych wiadomości.</summary>
        <value><see langword="true" />Jeśli błąd dostarczania komunikatów powinien skutkować wysłaniem komunikatu do kolejki utraconych wiadomości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> określają sposób, w jaki usługa kolejkowania komunikatów śledzi komunikat. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest`true`, błąd dostarczania (nietransakcyjny komunikat), powoduje, że komunikat jest wysyłany do kolejki utraconych wiadomości nietransakcyjnych na komputerze, który nie mógł dostarczyć wiadomości. Błąd dostarczania może być spowodowany przez czasomierz komunikatów, na przykład.  
  
 W przypadku niepowodzenia dostarczania wiadomości transakcyjnej usługa kolejkowania komunikatów wysyła komunikat do kolejki utraconych wiadomości transakcyjnych na maszynie źródłowej we wszystkich przypadkach negatywnych i wątpliwych.  
  
 W przypadku przechowywania komunikatów w kolejce utraconych wiadomości należy wyczyścić kolejkę okresowo, aby usunąć komunikaty, które nie są już potrzebne. Komunikaty przechowywane w kolejkach wiadomości utraconych są wliczane do limitu przydziału rozmiaru komputera, na którym znajduje się kolejka. Przydział komputera jest ustawiany przez administratora i odnosi się do rozmiaru przydzielonego do przechowywania komunikatów na całym komputerze, a nie tylko w jednej kolejce.  
  
 Nie tworzysz kolejki ani kolejek utraconych wiadomości. Są to kolejki systemowe generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy komunikat ma być prywatny.</summary>
        <value><see langword="true" />Aby wymagać usługi kolejkowania komunikatów do zaszyfrowania wiadomości; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny, jego treść jest zaszyfrowana przed wysłaniem i odszyfrowaniem po odebraniu. Aby wysłać wiadomość prywatną, aplikacja wysyłająca musi określić, że szyfrowanie ma być używane, i opcjonalnie algorytm szyfrowania.  
  
 Podczas wysyłania wiadomości prywatnych aplikacja nie musi wykonywać szyfrowania wiadomości. Usługa kolejkowania komunikatów może zaszyfrować treść wiadomości, jeśli aplikacja wysyła komunikaty w systemie Microsoft Windows 2000 Enterprise, który ma dostęp do usługi katalogowej. Podczas otrzymywania wiadomości prywatnych Menedżer kolejki otrzymującej zawsze odszyfrowuje treść wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.UseEncryption%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseEncryption" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kopia komunikatu powinna być przechowywana w dzienniku komputera na komputerze źródłowym.</summary>
        <value><see langword="true" />Aby wymagać, aby kopia komunikatu była przechowywana w dzienniku komputera źródłowego komputera po pomyślnym przesłaniu komunikatu (z komputera źródłowego do następnego serwera); w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Właściwości <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> określają sposób, w jaki usługa kolejkowania komunikatów śledzi komunikat. Jeśli <xref:System.Messaging.Message.UseJournalQueue%2A> tak`true`, kopia jest zachowywana w dzienniku komputera na maszynie źródłowej w każdym kroku, do którego zostanie wysłany komunikat.  
  
 Wysłany komunikat jest kopiowany tylko do kolejki dziennika, jeśli kolejka docelowa znajduje się na komputerze zdalnym. Jeśli miejsce docelowe znajduje się na komputerze lokalnym, komunikat jest wysyłany bezpośrednio do kolejki; nie ma żadnych kroków pośrednich, aby wymagać rejestrowania.  
  
 W przypadku przechowywania wiadomości w kolejce dziennika należy okresowo czyścić kolejki, aby usunąć komunikaty, które nie są już potrzebne. Komunikaty przechowywane w kolejkach dziennika są wliczane do przydziału dla komputera, na którym znajduje się kolejka. (Przydział komputera jest ustawiany przez administratora).  
  
 Nie tworzysz kolejki ani kolejek utraconych wiadomości. Są to kolejki systemowe generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.UseJournalQueue%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseJournalQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy komunikat ma być śledzony w kierunku jego kolejki docelowej.</summary>
        <value><see langword="true" />Jeśli każdy pośredni krok wykonany przez oryginalną wiadomość w trasie do kolejki docelowej generuje raport, który zostanie wysłany do kolejki raportu systemu; w przeciwnym razie. <see langword="false" /> Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> Właściwość określa, czy śledzenie trasy wiadomości jest przenoszone do kolejki docelowej. Jeśli `true`komunikat raportu (generowany przez usługę kolejkowania komunikatów) jest wysyłany do kolejki raportu za każdym razem, gdy komunikat przechodzi przez serwer routingu usługi kolejkowania komunikatów. Kolejka raportu jest określana przez Menedżera kolejki źródła. Kolejki raportów nie są ograniczone do komunikatów raportów generowanych przez usługę kolejkowania komunikatów; Komunikaty generowane przez aplikację można również wysyłać do kolejek raportów.  
  
 Śledzenie za pomocą funkcji śledzenia obejmuje konfigurowanie Active Directory i określanie kolejki raportu dla przedsiębiorstwa usługi kolejkowania komunikatów. Administrator konfiguruje te ustawienia.  
  
   
  
## Examples  
 Poniższy przykład kodu pobiera i ustawia wartość <xref:System.Messaging.Message.UseTracing%2A> właściwości komunikatu.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów jest filtrowana w celu ignorowania <see cref="P:System.Messaging.Message.UseTracing" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>

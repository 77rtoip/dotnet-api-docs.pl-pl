<Type Name="Message" FullName="System.Messaging.Message">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="aca17eb5c1214cd7837f89c181242c98095e8144" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36477557" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Message : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Message extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.Message" />
  <TypeSignature Language="VB.NET" Value="Public Class Message&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Message : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Message = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Messaging.Design.MessageDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do właściwości, należy zdefiniować kolejkowania wiadomości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.Message> klasy wgląd lub odbierać wiadomości z kolejki lub mieć szczegółową kontrolę właściwości wiadomości przy wysyłaniu wiadomości do kolejki.  
  
 <xref:System.Messaging.MessageQueue> używa <xref:System.Messaging.Message> klasy dokonuje lub odbiera komunikaty z kolejki, ponieważ zarówno <xref:System.Messaging.MessageQueue.Peek%2A?displayProperty=nameWithType> i <xref:System.Messaging.MessageQueue.Receive%2A?displayProperty=nameWithType> metody Utwórz nowe wystąpienie klasy <xref:System.Messaging.Message> klasy i ustaw właściwości wystąpienia. <xref:System.Messaging.Message> Właściwości tylko do odczytu klasy dotyczą pobieranie wiadomości z kolejki, podczas gdy właściwości odczytu/zapisu dotyczą wysyłanie i pobieranie wiadomości. Gdy <xref:System.Messaging.MessageQueue> dokonuje lub odbiera wiadomości z kolejki, jego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwość określa, które właściwości wiadomości są pobierane.  
  
 <xref:System.Messaging.MessageQueue> Klasy <xref:System.Messaging.MessageQueue.Send%2A> metody można określić typ obiektu dla wiadomości wysyłanych do tej kolejki. Można użyć <xref:System.Messaging.MessageQueue> wystąpienia <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwości w celu określenia ustawień ogólnych komunikatów wysłanych do kolejki. Typy ustawień obejmują program formatujący, etykiety, szyfrowania i uwierzytelniania. Można również określić wartości dla odpowiednich <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> elementów członkowskich, gdy koordynować komunikatów aplikacji odpowiada na komunikaty potwierdzenia i raportów. Przy użyciu <xref:System.Messaging.Message> wystąpienia, aby wysłać wiadomość do kolejki zapewnia elastyczność wiele z tych właściwości modyfikacji i dostępu — pojedynczej wiadomości lub na podstawie komunikatów przez komunikat. <xref:System.Messaging.Message> właściwości pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>.  
  
 Komunikat dane są przechowywane w <xref:System.Messaging.Message.Body%2A> właściwości i w mniejszym stopniu <xref:System.Messaging.Message.AppSpecific%2A> i <xref:System.Messaging.Message.Extension%2A> właściwości. Po dane wiadomości jest zaszyfrowany, serializacji lub deserializacji tylko zawartość <xref:System.Messaging.Message.Body%2A> dotyczy właściwości.  
  
 Zawartość <xref:System.Messaging.Message.Body%2A> właściwości są serializowane, gdy komunikat jest wysyłany przy użyciu <xref:System.Messaging.Message.Formatter%2A> możesz określić właściwości. Zserializowany zawartości znajdują się w <xref:System.Messaging.Message.BodyStream%2A> właściwości. Można również ustawić <xref:System.Messaging.Message.BodyStream%2A> właściwości bezpośrednio, na przykład można wysłać pliku jako zawartość danych komunikatu. Możesz zmienić <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwości w dowolnym momencie przed wysłaniem wiadomości i danych będzie wykonywana serializacja odpowiednio podczas wywoływania <xref:System.Messaging.MessageQueue.Send%2A>.  
  
 Właściwości zdefiniowane przez <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A?displayProperty=nameWithType> właściwość dotyczy tylko wiadomości, które nie są typu <xref:System.Messaging.Message>. Jeśli określisz <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwość <xref:System.Messaging.MessageQueue>, o identycznej nazwie właściwości w <xref:System.Messaging.Message> wystąpienia wysyłane do tej kolejki Przyczyna te właściwości domyślne mają być ignorowane.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>, zobacz <xref:System.Messaging.Message.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.MessageQueue" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> klasy o pustej treści.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasy, która ma pustej treści.  
  
 Określ <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. <xref:System.Messaging.Message.Body%2A> Właściwość może być dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.  
  
 O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Treść jest zserializowanym przy użyciu <xref:System.Messaging.Message.Formatter%2A> wartość właściwości w czasie <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializuje dane na reprezentacja binarna. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany przy wysyłaniu lub odbieraniu składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`null`|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła komunikaty dwóch różnych priorytetów do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj -&gt; System.Messaging.Message" Usage="new System.Messaging.Message body" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt do serializacji w treści wiadomości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> przy użyciu <see cref="T:System.Messaging.XmlMessageFormatter" /> do serializacji określonego obiektu na treść komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasę, która zawiera <xref:System.Messaging.Message.Body%2A> określonego przez `body` parametru. `body` Parametr może być dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Treść jest zserializowanym przy użyciu <xref:System.Messaging.XmlMessageFormatter> chyba że zostanie zmienione <xref:System.Messaging.Message.Formatter%2A> właściwości przed <xref:System.Messaging.Message> są wysyłane. Jeśli zmienisz <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwości w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomości będą wykonywane szeregowo w zależności od nowa wartość właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializuje dane na reprezentacja binarna. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany przy wysyłaniu lub odbieraniu składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametru.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.Formatter%2A>|`XmlMessageFormatter`|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową kolejkę, wysyła komunikat, który zawiera celu, a następnie pobiera go.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Message (object body, System.Messaging.IMessageFormatter formatter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object body, class System.Messaging.IMessageFormatter formatter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.Message.#ctor(System.Object,System.Messaging.IMessageFormatter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (body As Object, formatter As IMessageFormatter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Message(System::Object ^ body, System::Messaging::IMessageFormatter ^ formatter);" />
      <MemberSignature Language="F#" Value="new System.Messaging.Message : obj * System.Messaging.IMessageFormatter -&gt; System.Messaging.Message" Usage="new System.Messaging.Message (body, formatter)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="body" Type="System.Object" />
        <Parameter Name="formatter" Type="System.Messaging.IMessageFormatter" />
      </Parameters>
      <Docs>
        <param name="body">Obiekt do serializacji w treści wiadomości.</param>
        <param name="formatter">A <see cref="T:System.Messaging.IMessageFormatter" /> , który określa formatujący serializacji treści komunikatu.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.Message" /> przy użyciu określonego programu formatującego do serializacji określonego obiektu na treść komunikatu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.Message> klasę, która zawiera <xref:System.Messaging.Message.Body%2A> określonego przez `body` parametr i korzysta z żadnych prawidłowy element formatujący do serializacji treści. `body` Parametr jest dowolny obiekt, który można serializować, takie jak ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu. Jeśli zmienisz <xref:System.Messaging.Message.Body%2A> lub <xref:System.Messaging.Message.Formatter%2A> właściwości w dowolnym momencie przed wywołaniem <xref:System.Messaging.MessageQueue.Send%2A>, wiadomości będą wykonywane szeregowo w zależności od nowa wartość właściwości.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializuje dane na reprezentacja binarna. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany przy wysyłaniu lub odbieraniu składników COM.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.Message>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.Message.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.Message.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.Message.AppSpecific%2A>|0|  
|<xref:System.Messaging.Message.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.Message.AuthenticationProviderName%2A>|Microsoft Base Cryptographic Provider w wersji 1.0|  
|<xref:System.Messaging.Message.AuthenticationProviderType%2A>|`CryptoProviderType.RSA_FULL`|  
|<xref:System.Messaging.Message.Body%2A>|`body` Parametru.|  
|<xref:System.Messaging.Message.BodyStream%2A>|`Stream.null`|  
|<xref:System.Messaging.Message.BodyType%2A>|0|  
|<xref:System.Messaging.Message.ConnectorType%2A>|`Guid.Empty`|  
|<xref:System.Messaging.Message.CorrelationId%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.DestinationSymmetricKey%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.DigitalSignature%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.Message.Extension%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.Formatter%2A>|`formatter` Parametru.|  
|<xref:System.Messaging.Message.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.Message.Label%2A>|Ciąg pusty ("")|  
|<xref:System.Messaging.Message.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.Message.Recoverable%2A>|`false`|  
|<xref:System.Messaging.Message.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.Message.SenderCertificate%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.Message.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.Message.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.Message.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.Message.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.Message.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.Message.UseTracing%2A>|`false`|  
  
   
  
## Examples  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.MessageQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="AcknowledgeType">
      <MemberSignature Language="C#" Value="public System.Messaging.AcknowledgeTypes AcknowledgeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.AcknowledgeTypes AcknowledgeType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AcknowledgeType" />
      <MemberSignature Language="VB.NET" Value="Public Property AcknowledgeType As AcknowledgeTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::AcknowledgeTypes AcknowledgeType { System::Messaging::AcknowledgeTypes get(); void set(System::Messaging::AcknowledgeTypes value); };" />
      <MemberSignature Language="F#" Value="member this.AcknowledgeType : System.Messaging.AcknowledgeTypes with get, set" Usage="System.Messaging.Message.AcknowledgeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgeType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.AcknowledgeTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ komunikatu potwierdzenia do aplikację wysyłającą.</summary>
        <value>Jeden z <see cref="T:System.Messaging.AcknowledgeTypes" /> wartości, które reprezentują typy wiadomości potwierdzających system zapisuje na kolejkę administracyjną i warunków, w których są zwracane potwierdzenia wysyłania aplikacji. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AcknowledgeType%2A> Właściwość określa typ wiadomości potwierdzających żądany przez aplikację wysyłającą. Ustaw <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości przed wysłaniem wiadomość, aby powiadomienia o niektórych wystąpień — na przykład komunikat dotarciem do kolejki docelowej, trwa pobieranie wiadomości lub limit czasu wiadomości uniemożliwia osiągnięcie bądź właśnie pobierane z kolejki docelowej.  
  
 Usługa kolejkowania komunikatów zwraca powiadomień przez wysłanie wiadomości potwierdzających do <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości określone przez oryginalnej wiadomości. Wiadomości potwierdzającej <xref:System.Messaging.Message.Acknowledgment%2A> właściwość wskazuje typ potwierdzenia, który reprezentuje. Na przykład, jeśli wiadomości potwierdzającej została wysłana, ponieważ wiadomość nie dotarła docelowym przed <xref:System.Messaging.Message.TimeToReachQueue%2A> interwał uznawane za wygasłe, <xref:System.Messaging.Message.Acknowledgment%2A> zawiera wartość właściwości komunikatu potwierdzenia `ReachQueueTimeout`.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Komunikat jest filtrowana do ignorowania <see cref="P:System.Messaging.Message.AcknowledgeType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="Acknowledgment">
      <MemberSignature Language="C#" Value="public System.Messaging.Acknowledgment Acknowledgment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.Acknowledgment Acknowledgment" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Acknowledgment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Acknowledgment As Acknowledgment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Acknowledgment Acknowledgment { System::Messaging::Acknowledgment get(); };" />
      <MemberSignature Language="F#" Value="member this.Acknowledgment : System.Messaging.Acknowledgment" Usage="System.Messaging.Message.Acknowledgment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAcknowledgement")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.Acknowledgment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera klasyfikację potwierdzenia reprezentowanego przez tę wiadomość.</summary>
        <value>Jeden z <see cref="T:System.Messaging.Acknowledgment" /> wartości wyliczenia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy zostanie wyświetlony komunikat z kolejki administracyjnej, odczytać <xref:System.Messaging.Message.Acknowledgment%2A> właściwości, aby sprawdzić stan oryginalnej wiadomości.  
  
 Po wysłaniu wiadomości do kolejki docelowej usługi kolejkowania komunikatów może zażądać wiadomości potwierdzającej publikowania. Taki komunikat może wskazywać na przykład, czy wiadomość dotarła i czy został pobrany w ramach określonego limitu czasu lub może on wskazywać co poszło źle w przypadku niepowodzenia dostarczenia. Kolejka docelowa zwraca potwierdzeń wiadomości i przesyła je do kolejki administracyjnej określonej w oryginalnej wiadomości <xref:System.Messaging.Message.AdministrationQueue%2A> właściwości. <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości potwierdzającej identyfikuje komunikat potwierdzenia nie oryginalnej wiadomości. Identyfikator oryginalnej wiadomości można znaleźć w potwierdzenie <xref:System.Messaging.Message> wystąpienia <xref:System.Messaging.Message.CorrelationId%2A> właściwości.  
  
 Jeśli <xref:System.Messaging.Message> wystąpienie reprezentuje wiadomości potwierdzającej <xref:System.Messaging.Message.Acknowledgment%2A> właściwość określa typ potwierdzenia. W przeciwnym razie <xref:System.Messaging.Message.Acknowledgment%2A> właściwość zawiera wartość `Normal`.  
  
 Użyj <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości oryginalnej wiadomości, aby określić okoliczności, w których będą zwracane potwierdzenia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AdministrationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue AdministrationQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue AdministrationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AdministrationQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property AdministrationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ AdministrationQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AdministrationQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.AdministrationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAdministrationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejki, który odbiera komunikaty potwierdzenia, które generuje usługi kolejkowania komunikatów.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> , Który określa kolejkę administracyjną dla potwierdzeń generowanych przez system komunikatów. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Określonej w kolejce <xref:System.Messaging.Message.AdministrationQueue%2A> właściwość może być każdej kolejki nietransakcyjnej. Wiadomości potwierdzających wysłanych do kolejki administracyjnej można określić, czy oryginalnej wiadomości osiągnął kolejki docelowej i określa, czy została usunięta z kolejki.  
  
 Gdy <xref:System.Messaging.Message.AcknowledgeType%2A> właściwość ma żadnej wartości innych niż `None`, aplikacja wysyłająca musi określić kolejkę, która ma być używana jako kolejkę administracyjną.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.AdministrationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.Acknowledgment" />
      </Docs>
    </Member>
    <Member MemberName="AppSpecific">
      <MemberSignature Language="C#" Value="public int AppSpecific { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AppSpecific" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AppSpecific" />
      <MemberSignature Language="VB.NET" Value="Public Property AppSpecific As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int AppSpecific { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.AppSpecific : int with get, set" Usage="System.Messaging.Message.AppSpecific" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAppSpecific")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje dodatkowe, specyficzne dla aplikacji.</summary>
        <value>Informacje dotyczące tej aplikacji. Wartością domyślną jest zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.AppSpecific%2A> Właściwość zawiera informacje specyficzne dla aplikacji, które umożliwia organizowanie różnych typów wiadomości. Na przykład można użyć indeksów specyficzne dla aplikacji. Jest odpowiedzialny za aplikacji, aby zinterpretować <xref:System.Messaging.Message.AppSpecific%2A> informacje dotyczące właściwości.  
  
 Jeśli to możliwe, należy uwzględnić dane komunikatów w treści wiadomości, a nie <xref:System.Messaging.Message.AppSpecific%2A> właściwości.  
  
 Podczas pracy z kolejkami obcego, użyj <xref:System.Messaging.Message.Extension%2A> właściwości, aby określić właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów. Jak <xref:System.Messaging.Message.AppSpecific%2A> właściwości, jest odpowiedzialny za aplikacji, aby zrozumieć zawartość <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.AppSpecific" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="ArrivedTime">
      <MemberSignature Language="C#" Value="public DateTime ArrivedTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ArrivedTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ArrivedTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArrivedTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ArrivedTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ArrivedTime : DateTime" Usage="System.Messaging.Message.ArrivedTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgArrivedTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czas odebrania wiadomości w kolejce docelowej.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentujący Godzina nadejścia wiadomości w kolejce docelowej. Czas jest uwzględniany z GMT na czas lokalny komputera, na którym znajduje się kolejka docelowa.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość wskazuje, jak szybko można odebrać wiadomości z kolejki docelowej. <xref:System.Messaging.Message.TimeToBeReceived%2A> Czasomierza właściwości rozpoczyna się, gdy komunikat jest wysyłany nie nadejściu wiadomości w kolejce.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.ArrivedTime%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.ArrivedTime" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
      </Docs>
    </Member>
    <Member MemberName="AttachSenderId">
      <MemberSignature Language="C#" Value="public bool AttachSenderId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AttachSenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AttachSenderId" />
      <MemberSignature Language="VB.NET" Value="Public Property AttachSenderId As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AttachSenderId { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AttachSenderId : bool with get, set" Usage="System.Messaging.Message.AttachSenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAttachSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy identyfikator nadawcy powinien być dołączony do wiadomości.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="P:System.Messaging.Message.SenderId" /> powinien być dołączony do wiadomości, a w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderId%2A> Właściwość jest tablicą bajtów reprezentujący identyfikator użytkownika, wysyłania. Identyfikator nadawcy jest ustawiana przez usługę kolejkowania komunikatów i jest używany przez odbierającego menedżera kolejek, aby sprawdzić, czy nadawca ma prawa dostępu do kolejki.  
  
 Brak wskazanie przez aplikację wysyłającą, że usługi kolejkowania komunikatów należy zweryfikować nadawcy wiadomości nie Sprawdź dostęp do nadawcy to identyfikator nadawcy praw do odbierania kolejki. <xref:System.Messaging.Message.SenderId%2A> Jest zaufane, tylko wtedy, gdy wiadomość została uwierzytelniona, gdy jej dotarła do kolejki docelowej. Komunikat został odrzucony, gdy dotrze do kolejki docelowej, jeśli kolejka akceptuje tylko wiadomości uwierzytelnione, a następnie <xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A> lub <xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A> jest właściwość `false`.  
  
> [!CAUTION]
>  Jeśli komunikat zostanie odrzucony, jest albo wysłane do kolejki utraconych wiadomości (Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `true`), lub jest on ignorowany. Można zażądać potwierdzenia nieudanej wiadomości do kolejki. W przeciwnym razie po wybraniu <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false` wiadomości mogą zostać utracone bez ostrzeżenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.AttachSenderId%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.AttachSenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.SenderId" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="Authenticated">
      <MemberSignature Language="C#" Value="public bool Authenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticated" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Authenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authenticated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Authenticated : bool" Usage="System.Messaging.Message.Authenticated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość została uwierzytelniona.</summary>
        <value>
          <see langword="true" /> Jeśli żądano uwierzytelnienia wiadomości wprowadzenie kolejki; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Authenticated%2A> Właściwość jest używana tylko przez aplikację podczas próby określenia, czy żądano uwierzytelnienia i interakcji z komunikatem. W przypadku wiadomości w kolejce, wiadomość została uwierzytelniona. Z drugiej strony Jeśli <xref:System.Messaging.Message.Authenticated%2A> właściwość jest `true`, odbierającego menedżera kolejek uwierzytelniony wiadomości, gdy ten komunikat.  
  
 Nie można ustalić, czy wiadomość niepowodzenie uwierzytelniania analizując jego właściwości. Usługa kolejkowania komunikatów odrzuca wiadomości, które niepowodzenia uwierzytelniania przed wysłaniem ich do kolejki. Można jednak żądanie wysłane wiadomości potwierdzającej Jeśli awaria dostarczania uniemożliwia wiadomości w kolejce.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.Authenticated%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.Authenticated" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderName">
      <MemberSignature Language="C#" Value="public string AuthenticationProviderName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AuthenticationProviderName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderName" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AuthenticationProviderName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderName : string with get, set" Usage="System.Messaging.Message.AuthenticationProviderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości.</summary>
        <value>Nazwa dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości. Wartość domyślna to Microsoft Base Cryptographic Provider w wersji 1.0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używają <xref:System.Messaging.Message.AuthenticationProviderName%2A> podczas pracy z kolejkami obcego. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i typ dostawcy uwierzytelniania dostawcy usług kryptograficznych (dostawcy uwierzytelniania), aby sprawdzić poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i komunikatów przesyłanych do wiadomości Usługi kolejkowania wiadomości z kolejki obcego.  
  
 Podczas wysyłania wiadomości, zawsze wartość <xref:System.Messaging.Message.AuthenticationProviderName%2A> i <xref:System.Messaging.Message.ConnectorType%2A> razem właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje Nazwa dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona.  
  
 <xref:System.Messaging.Message.AuthenticationProviderName%2A> Właściwość nie może być `null`, ale może być pustym ciągiem ("").  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> Nie można ustawić właściwości.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderName" /> Ustawiono <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
      </Docs>
    </Member>
    <Member MemberName="AuthenticationProviderType">
      <MemberSignature Language="C#" Value="public System.Messaging.CryptographicProviderType AuthenticationProviderType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.CryptographicProviderType AuthenticationProviderType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.AuthenticationProviderType" />
      <MemberSignature Language="VB.NET" Value="Public Property AuthenticationProviderType As CryptographicProviderType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::CryptographicProviderType AuthenticationProviderType { System::Messaging::CryptographicProviderType get(); void set(System::Messaging::CryptographicProviderType value); };" />
      <MemberSignature Language="F#" Value="member this.AuthenticationProviderType : System.Messaging.CryptographicProviderType with get, set" Usage="System.Messaging.Message.AuthenticationProviderType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgAuthenticationProviderType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.CryptographicProviderType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ dostawcy usług kryptograficznych używanego do generowania podpisu cyfrowego wiadomości.</summary>
        <value>Jeden z <see cref="T:System.Messaging.CryptographicProviderType" /> wartości. Wartość domyślna to <see langword="RSA_FULL" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zazwyczaj używają <xref:System.Messaging.Message.AuthenticationProviderType%2A> właściwości podczas pracy z obcego kolejki, aby określić, które usług kryptograficznych dostawca jest skojarzony z komunikatem. Usługa kolejkowania komunikatów wymaga Nazwa dostawcy uwierzytelniania i typ dostawcy uwierzytelniania dostawcy usług kryptograficznych (dostawcy uwierzytelniania), aby sprawdzić poprawność podpisów cyfrowych wiadomości wysłanych do kolejki obcego i komunikatów przesyłanych do wiadomości Usługi kolejkowania wiadomości z kolejki obcego.  
  
 Tylko `RsaFull` jest przeznaczony do użycia z obsługą wiadomości.  
  
 Podczas wysyłania wiadomości, zawsze wartość <xref:System.Messaging.Message.AuthenticationProviderType%2A> i <xref:System.Messaging.Message.ConnectorType%2A> razem właściwości. Po wysłaniu wiadomości usługi kolejkowania komunikatów ignoruje typ dostawcy uwierzytelniania, jeśli typ łącznika nie jest również ustawiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> Nie można ustawić właściwości.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.AuthenticationProviderType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.CryptographicProviderType" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public object Body { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Body" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Body" />
      <MemberSignature Language="VB.NET" Value="Public Property Body As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Body { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Body : obj with get, set" Usage="System.Messaging.Message.Body" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zawartość komunikatu.</summary>
        <value>Obiekt, który określa treść komunikatu. Obiekt może być ciągiem, datę, waluty, liczbę, tablicę bajtów lub dowolny obiekt zarządzany.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Komunikat <xref:System.Messaging.Message.Body%2A> właściwość zwykle zawiera dane skojarzone z wiadomością. Mimo że można również wysyłać dane specyficzne dla aplikacji, <xref:System.Messaging.Message.AppSpecific%2A> i <xref:System.Messaging.Message.Extension%2A> właściwości, należy uwzględnić dane komunikatów w <xref:System.Messaging.Message.Body%2A> wiadomości, jeśli to możliwe. Tylko <xref:System.Messaging.Message.Body%2A> treści właściwości są serializowane lub szyfrowane.  
  
 <xref:System.Messaging.Message.Body%2A> Właściwość może zawierać dowolny obiekt, którego rozmiar nie przekracza 4 MB. Jeśli używasz <xref:System.Messaging.MessageQueue.Send%2A?displayProperty=nameWithType> wysłać dowolny obiekt, który nie jest typu <xref:System.Messaging.Message> do <xref:System.Messaging.MessageQueue>, obiektu będą znajdować się w <xref:System.Messaging.Message.Body%2A> właściwość <xref:System.Messaging.Message> zwrócone przez wystąpienie <xref:System.Messaging.MessageQueue.Peek%2A> lub <xref:System.Messaging.MessageQueue.Receive%2A>.  
  
 Argument ciągu w `MessageQueue.Send("hello.")` przykładem obiekt generyczny.  
  
 <xref:System.Messaging.Message.BodyType%2A> Właściwość wskazuje typ informacji przechowywanych w treści wiadomości. Usługa kolejkowania komunikatów użyje tych informacji do identyfikowania typu <xref:System.Messaging.Message.Body%2A> właściwości zawartości.  
  
 Określ <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. <xref:System.Messaging.Message.Body%2A> Właściwość może być możliwy do serializacji obiektu, na przykład ciąg tekstowy, obiekt struktury, wystąpienia klasy lub osadzonego obiektu.  
  
 O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowany przy użyciu elementu formatującego, zawartych w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
> [!NOTE]
>  Trwa próba skonfigurowania treści wiadomości <xref:System.Decimal.MaxValue> spowoduje, że <xref:System.OverflowException> podczas `Send` metody <xref:System.Messaging.MessageQueue> nosi nazwę klasy i <xref:System.Messaging.ActiveXMessageFormatter> jest używany.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła komunikaty dwóch różnych priorytetów do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Messaging.Message.Formatter" /> Jest właściwość <see langword="null" />.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream BodyStream { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BodyStream" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyStream" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ BodyStream { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BodyStream : System.IO.Stream with get, set" Usage="System.Messaging.Message.BodyStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.ComponentModel.Design.BinaryEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyStream")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia informacje w treści wiadomości.</summary>
        <value>A <see cref="T:System.IO.Stream" /> zawiera seryjnych informacje zawarte w <see cref="P:System.Messaging.Message.Body" /> wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Treść komunikatu może składać się z dowolnego typu informacji — na przykład ciąg, datę, waluty, liczbę, tablicę bajtów lub dowolny obiekt zarządzany. Te informacje jest serializowany w <xref:System.IO.Stream> do przekazania do kolejki.  
  
 Określ <xref:System.Messaging.Message.Body%2A> właściwości lub <xref:System.Messaging.Message.BodyStream%2A> właściwości przed wysłaniem <xref:System.Messaging.Message> obiektu. Jeśli ustawisz <xref:System.Messaging.Message.Body%2A> właściwości, zawartość są serializowane w <xref:System.Messaging.Message.BodyStream%2A> właściwości. Jednak użytkownik może zapisać <xref:System.Messaging.Message.BodyStream%2A> właściwości bezpośrednio. Jest to przydatne, na przykład, jeśli chcesz nawiązać połączenie z pliku i przesyłania strumieniowego jego zawartość jako treść komunikatu.  
  
 O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowany przy użyciu elementu formatującego, zawartych w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 Jeśli ustawisz <xref:System.Messaging.Message.UseEncryption%2A> właściwości `true` komunikat dla treści wiadomości, będą szyfrowane podczas wysyłania, nie po ustawieniu <xref:System.Messaging.Message.Body%2A> właściwości. W związku z tym <xref:System.Messaging.Message.BodyStream%2A> właściwości nigdy nie są szyfrowane.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyType" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Extension" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BodyType">
      <MemberSignature Language="C#" Value="public int BodyType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BodyType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.BodyType" />
      <MemberSignature Language="VB.NET" Value="Public Property BodyType As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BodyType { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BodyType : int with get, set" Usage="System.Messaging.Message.BodyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgBodyType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia typ danych, który zawiera treść komunikatu.</summary>
        <value>Treść komunikatu true typu, na przykład ciąg, datę, waluty lub liczbą.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów rozpoznaje zawartość treści jako obiekt lub strumieniu serializowanym. <xref:System.Messaging.Message.BodyType%2A> Właściwość wskazuje typ obiektu w <xref:System.Messaging.Message.Body%2A> właściwości komunikatu.  
  
 <xref:System.Messaging.XmlMessageFormatter> Wykonuje powiązanie między natywnych typów i obiektu w treści wiadomości. Jeśli używasz <xref:System.Messaging.XmlMessageFormatter>, ustawia program formatujący <xref:System.Messaging.Message.BodyType%2A> właściwości dla Ciebie.  
  
 Inne elementy formatujące udostępniają funkcje powiązanie również, jak pokazano w poniższym kodzie C#.  
  
```  
message.Formatter = new ActiveXMessageFormatter();  
object myObject message.Body;  
if (myObject is string) {  
}  
if (myObject is int) {  
}  
if (myObject is float) {  
}  
```  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.BodyType%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Body" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.Message.Body" />
        <altmember cref="P:System.Messaging.Message.BodyStream" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
        <altmember cref="M:System.Messaging.MessageQueue.Send(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ConnectorType">
      <MemberSignature Language="C#" Value="public Guid ConnectorType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ConnectorType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ConnectorType" />
      <MemberSignature Language="VB.NET" Value="Public Property ConnectorType As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid ConnectorType { Guid get(); void set(Guid value); };" />
      <MemberSignature Language="F#" Value="member this.ConnectorType : Guid with get, set" Usage="System.Messaging.Message.ConnectorType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgConnectorType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, że niektóre właściwości komunikatów, na ogół ustawiane przez usługę MSMQ zostały określone przez aplikację wysyłającą.</summary>
        <value>A <see cref="T:System.Guid" /> zdefiniowane przez aplikację i używane w połączeniu z aplikacjami łącznik lub szyfrowania wiadomości. To <see cref="T:System.Guid" /> umożliwia aplikacji odbierającej interpretować właściwości wiadomości, które zostały określone przez aplikację wysyłającą, ale zazwyczaj mają ustawiony przez usługę kolejkowania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów wymaga <xref:System.Messaging.Message.ConnectorType%2A> można ustawić właściwości, gdy aplikacja ustawia właściwości wiadomości, która zwykle jest ustawiana przez usługę kolejkowania komunikatów. Zazwyczaj używa aplikacja <xref:System.Messaging.Message.ConnectorType%2A> w dwóch następujących przypadków:  
  
-   Zawsze, gdy aplikacja łącznika przekazuje komunikat. <xref:System.Messaging.Message.ConnectorType%2A> Informuje aplikacje wysyłające i odbierające jak interpretować właściwości zabezpieczeń i potwierdzeń wiadomości.  
  
-   Zawsze, gdy aplikacja wysyłająca, a nie usługi kolejkowania komunikatów, szyfruje wiadomości. <xref:System.Messaging.Message.ConnectorType%2A> Nakazuje, aby użyć usługi kolejkowania komunikatów <xref:System.Messaging.Message.DestinationSymmetricKey%2A> wartości właściwości do odszyfrowywania wiadomości.  
  
 Należy ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości w przypadku ustawienia dowolnej z następujących właściwości (w przeciwnym razie kolejki ignoruje te właściwości, gdy komunikat jest wysyłany):  
  
-   <xref:System.Messaging.Message.AuthenticationProviderName%2A>  
  
-   <xref:System.Messaging.Message.AuthenticationProviderType%2A>  
  
-   <xref:System.Messaging.Message.DestinationSymmetricKey%2A>  
  
-   <xref:System.Messaging.Message.DigitalSignature%2A>  
  
-   <xref:System.Messaging.Message.MessageType%2A>  
  
-   <xref:System.Messaging.Message.SenderId%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.ConnectorType" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DestinationSymmetricKey" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.Message.SenderId" />
      </Docs>
    </Member>
    <Member MemberName="CorrelationId">
      <MemberSignature Language="C#" Value="public string CorrelationId { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CorrelationId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.CorrelationId" />
      <MemberSignature Language="VB.NET" Value="Public Property CorrelationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CorrelationId { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CorrelationId : string with get, set" Usage="System.Messaging.Message.CorrelationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgCorrelationId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia identyfikator komunikatu używany przez potwierdzenie, raportów i komunikatów odpowiedzi w celu oryginalnej wiadomości.</summary>
        <value>Określony przez identyfikator wiadomości <see cref="P:System.Messaging.Message.Id" /> właściwości oryginalnej wiadomości. Identyfikator korelacji jest używany przez MSMQ podczas generowania wiadomości potwierdzającej lub raportu i przez aplikację, generując komunikat odpowiedzi.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas kolejkowania generuje komunikat potwierdzenia lub raport, używa właściwości identyfikator korelacji Aby określić identyfikator wiadomości oryginalnej wiadomości. W ten sposób identyfikator korelacji wiąże raportu lub potwierdzeń wiadomości do oryginalnej wiadomości.  
  
 Aplikacja wysyłająca może następnie być zgodne z potwierdzeń lub raport z oryginalnej wiadomości przy użyciu <xref:System.Messaging.Message.CorrelationId%2A> właściwość do identyfikacji oryginalnej wiadomości <xref:System.Messaging.Message.Id%2A> właściwości.  
  
 Aplikacje łącznika również ustawić <xref:System.Messaging.Message.CorrelationId%2A> właściwości komunikatów potwierdzenia i raportu do identyfikatora wiadomości oryginalnej wiadomości.  
  
 Aplikacja wysyła komunikat odpowiedzi do wysyłania aplikacji, można ustawić <xref:System.Messaging.Message.CorrelationId%2A> właściwości komunikat odpowiedzi do identyfikatora wiadomości oryginalnej wiadomości. Aplikacja wysyłająca można następnie powiązać komunikatu odpowiedzi na komunikat, który został wysłany.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.CorrelationId" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DestinationQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue DestinationQueue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue DestinationQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationQueue" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DestinationQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ DestinationQueue { System::Messaging::MessageQueue ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DestinationQueue : System.Messaging.MessageQueue" Usage="System.Messaging.Message.DestinationQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera przeznaczenia kolejki wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.MessageQueue" /> , który określa przeznaczenia kolejki wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.DestinationQueue%2A> Właściwość najczęściej służy do określania początkowego miejsca docelowego wiadomości, które dotarły w kolejce dziennika lub utraconych. Zwykle nie trzeba sprawdzić tę właściwość, ponieważ zwykle pobierają wiadomości z kolejki docelowej.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.DestinationQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.DestinationQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="DestinationSymmetricKey">
      <MemberSignature Language="C#" Value="public byte[] DestinationSymmetricKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DestinationSymmetricKey" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DestinationSymmetricKey" />
      <MemberSignature Language="VB.NET" Value="Public Property DestinationSymmetricKey As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DestinationSymmetricKey { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DestinationSymmetricKey : byte[] with get, set" Usage="System.Messaging.Message.DestinationSymmetricKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDestinationSymmetricKey")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia klucz symetryczny stosowany do szyfrowania wiadomości zaszyfrowanych przez aplikację lub wiadomości wysyłanych do kolejki obcego.</summary>
        <value>Tablica wartości bajtów określający docelowy klucz symetryczny stosowany do szyfrowania wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dwa scenariusze wymagają użycia <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwości. Pierwsza to gdy z aplikacji, a nie usługi kolejkowania komunikatów, szyfruje wiadomości. Drugim jest podczas wysyłania wiadomości zaszyfrowanych do system kolejkowania wiadomości innego niż usługi kolejkowania komunikatów.  
  
 Przed skonfigurowaniem tej właściwości, należy zaszyfrować klucza symetrycznego z klucza publicznego odbierającego menedżera kolejek. Podczas wysyłania wiadomości zaszyfrowanych przez aplikację odbierającego menedżera kolejek używa klucza symetrycznego do odszyfrowywania wiadomości przed wysłaniem ich do swojej kolejki docelowej.  
  
 Po wysłaniu wiadomości do kolejki obcego komunikat jest najpierw odbierany przez aplikację odpowiedni łącznik, który przesyła dalej zaszyfrowanego komunikatu z klucza symetrycznego dołączona do aplikacji odbierającej. Następnie jest odpowiedzialny za aplikację do odszyfrowywania wiadomości za pomocą klucza symetrycznego.  
  
 Podczas ustawiania <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwość, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości. Po wysłaniu wiadomości MSMQ ignoruje <xref:System.Messaging.Message.DestinationSymmetricKey%2A> właściwości Jeśli <xref:System.Messaging.Message.ConnectorType%2A> właściwość nie jest również ustawiona.  
  
 <xref:System.Messaging.Message.DestinationSymmetricKey%2A> Właściwości ma rozmiar tablicy maksymalną 256.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DestinationSymmetricKey" /> Jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="DigitalSignature">
      <MemberSignature Language="C#" Value="public byte[] DigitalSignature { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] DigitalSignature" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.DigitalSignature" />
      <MemberSignature Language="VB.NET" Value="Public Property DigitalSignature As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ DigitalSignature { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DigitalSignature : byte[] with get, set" Usage="System.Messaging.Message.DigitalSignature" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgDigitalSignature")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podpis cyfrowy, którego używa Usługa Kolejkowanie komunikatów do uwierzytelniania wiadomości.</summary>
        <value>Tablica wartości bajtów określający 1.0 usługi kolejkowania komunikatów podpis cyfrowy używany do uwierzytelniania wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów używa podpis cyfrowy do uwierzytelniania komunikatów wysłanych przez usługę kolejkowania komunikatów w wersji 1.0. W większości przypadków kolejkowania generuje i ustawia <xref:System.Messaging.Message.DigitalSignature%2A> właściwości, gdy aplikacja wysyłająca żąda uwierzytelnienia. Aplikacja używa tej właściwości można pobrać podpisu cyfrowego dołączanego do wiadomości.  
  
 Można używać tylko <xref:System.Messaging.Message.DigitalSignature%2A> właściwości podczas uruchamiania usługi kolejkowania komunikatów w wersji 2.0. Aplikacja wysyłająca musi określić usługi kolejkowania komunikatów w wersji 1.0 podpisów podczas żądania uwierzytelniania. Jeśli aplikacja wysyłająca wysyła podpis MSMQ w wersji 2.0, ta właściwość zawiera buforu czterech bajtów, każdy zawierający zero.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwości wraz z <xref:System.Messaging.Message.SenderCertificate%2A> , jest również używana przez łącznik aplikacji podczas wysyłania wiadomości. W tym scenariuszu aplikacja łącznika — zamiast usługi kolejkowania komunikatów — generuje podpisu cyfrowego opiera się on na certyfikat użytkownika, wysyłając ten komunikat.  
  
 <xref:System.Messaging.Message.DigitalSignature%2A> Właściwości ma rozmiar tablicy maksymalną 256.  
  
 Podczas ustawiania <xref:System.Messaging.Message.DigitalSignature%2A> właściwość, należy także ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości. Po wysłaniu wiadomości MSMQ ignoruje <xref:System.Messaging.Message.DigitalSignature%2A> właściwości Jeśli <xref:System.Messaging.Message.ConnectorType%2A> właściwość nie jest również ustawiona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.DigitalSignature" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.DigitalSignature" /> Jest właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.SenderCertificate" />
        <altmember cref="P:System.Messaging.Message.HashAlgorithm" />
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionAlgorithm EncryptionAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionAlgorithm EncryptionAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.EncryptionAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionAlgorithm As EncryptionAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionAlgorithm EncryptionAlgorithm { System::Messaging::EncryptionAlgorithm get(); void set(System::Messaging::EncryptionAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.EncryptionAlgorithm : System.Messaging.EncryptionAlgorithm with get, set" Usage="System.Messaging.Message.EncryptionAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgEncryptionAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytm szyfrowania używany do szyfrowania treści wiadomości prywatnej.</summary>
        <value>Jeden z <see cref="T:System.Messaging.EncryptionAlgorithm" /> wartości wyliczenia. Wartość domyślna to <see langword="RC2" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny (zaszyfrowane), są szyfrowane przed wysyłanych i odszyfrować po otrzymaniu. <xref:System.Messaging.Message.EncryptionAlgorithm%2A> Właściwość określa algorytm używany do szyfrowania treści wiadomości prywatnej.  
  
 Kolejki mogą wymagać tego przychodzące można zaszyfrować wiadomości. Jeśli aplikacja wysyła wiadomość (z systemem innym niż prywatny) niezaszyfrowane do kolejki, która akceptuje tylko wiadomości prywatne lub jeśli wysyła wiadomości prywatne do kolejki, która akceptuje tylko wiadomości nieprywatne, kolejki odrzuca komunikat. Aplikacja wysyłająca mogą żądać, że w takim przypadku jest zwracany komunikat o potwierdzenie negatywne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.EncryptionAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="T:System.Messaging.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="Extension">
      <MemberSignature Language="C#" Value="public byte[] Extension { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Extension" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Extension" />
      <MemberSignature Language="VB.NET" Value="Public Property Extension As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Extension { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Extension : byte[] with get, set" Usage="System.Messaging.Message.Extension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgExtension")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia dodatkowe, zdefiniowane przez aplikację informacje skojarzone z wiadomością.</summary>
        <value>Tablica wartości bajtów zawiera zdefiniowane przez aplikację informacje skojarzone z wiadomością. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Extension%2A> Właściwość zawiera informacje zdefiniowane przez aplikację, takich jak dużego obiektu binarnego, który jest skojarzony z komunikatem. Jest odpowiedzialny za zinterpretować zawartości aplikacji odbierającej <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 Jeśli to możliwe, powinny obejmować dane komunikatów w <xref:System.Messaging.Message.Body%2A> właściwości wiadomości, a nie <xref:System.Messaging.Message.Extension%2A> właściwości.  
  
 Podczas pracy z kolejkami obcego, użyj <xref:System.Messaging.Message.Extension%2A> właściwości, aby określić właściwości wiadomości, które nie istnieją w usługi kolejkowania komunikatów.  
  
 Obcy kolejka istnieje w systemie kolejkowania innego niż usługi kolejkowania wiadomości firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takich kolejek za pomocą łącznika aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Extension" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Extension" /> Jest właściwość <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.Message.AppSpecific" />
        <altmember cref="P:System.Messaging.Message.Body" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Formatter : System.Messaging.IMessageFormatter with get, set" Usage="System.Messaging.Message.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element formatujący używany do serializacji obiektu do lub deserializacji obiektu z treści wiadomości.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> Daje strumienia zapisywane lub odczytywać treść komunikatu. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.Message.Formatter%2A> właściwości podczas odczytywania i zapisywania wiadomości. Po wysłaniu wiadomości do kolejki program formatujący serializuje <xref:System.Messaging.Message.Body%2A> właściwości do strumienia, który można wysłać do kolejki wiadomości. Podczas czytania z kolejki, element formatujący deserializuje dane wiadomości do <xref:System.Messaging.Message.Body%2A> właściwości.  
  
 O ile bezpośrednio do zapisu treści wiadomości <xref:System.Messaging.Message.BodyStream%2A> właściwość, ustaw <xref:System.Messaging.Message.Formatter%2A> właściwości przed wysłaniem wiadomości. Gdy <xref:System.Messaging.MessageQueue.Send%2A> wywoływana jest metoda <xref:System.Messaging.MessageQueue> wystąpienia, treść jest serializowany przy użyciu elementu formatującego, zawartych w <xref:System.Messaging.Message.Formatter%2A> właściwości. Możesz wysłać wiadomość bez określenia wartości dla <xref:System.Messaging.Message.Formatter%2A> właściwości, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializuje dane na reprezentacja binarna. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany przy wysyłaniu lub odbieraniu składników COM.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.Message.Formatter" /> Jest właściwość <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.IMessageFormatter.CanRead(System.Messaging.Message)" />
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.MessageQueue.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Messaging.HashAlgorithm HashAlgorithm { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.HashAlgorithm HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.HashAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Property HashAlgorithm As HashAlgorithm" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::HashAlgorithm HashAlgorithm { System::Messaging::HashAlgorithm get(); void set(System::Messaging::HashAlgorithm value); };" />
      <MemberSignature Language="F#" Value="member this.HashAlgorithm : System.Messaging.HashAlgorithm with get, set" Usage="System.Messaging.Message.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgHashAlgorithm")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.HashAlgorithm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia algorytmu, który używa Usługa Kolejkowanie komunikatów uwierzytelniania wiadomości mieszania lub tworzenia podpisu cyfrowego wiadomości.</summary>
        <value>Jeden z <see cref="T:System.Messaging.HashAlgorithm" /> wartości wyliczenia. Windows XP, wartością domyślną jest <see langword="SHA" />. W przeciwnym razie wartość domyślna to <see langword="MD5" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na komputerze źródłowym usługi kolejkowania komunikatów używa algorytmu wyznaczania wartości skrótu do utworzenia podpisu cyfrowego wiadomości. Element docelowy menedżera kolejek następnie używa tego samego algorytmu wyznaczania wartości skrótu do uwierzytelniania wiadomości, po odebraniu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.HashAlgorithm" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : string" Usage="System.Messaging.Message.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator komunikatu.</summary>
        <value>Komunikat Unikatowy identyfikator, który jest generowany przez usługę kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów generuje identyfikator komunikatu, gdy komunikat jest wysyłany. Identyfikator składa się z 20 bajtów i zawiera dwie pozycje: maszynie <xref:System.Guid> komputera wysyłającego i unikatowy identyfikator wiadomości na komputerze. Kombinacja dwóch elementów tworzy identyfikator wiadomości, która jest unikatowa w sieci.  
  
 Komunikatów usługi kolejkowania wiadomości generuje komunikat identyfikatorów dla wszystkich wiadomości — tym raport i potwierdzeń wiadomości. Wiadomości potwierdzającej zwykle wysyłane przez usługę kolejkowania wiadomości przyjęcia lub błąd oryginalny komunikat wysłany. Można znaleźć <xref:System.Messaging.Message.Id%2A> wartość właściwości oryginalnej wiadomości w <xref:System.Messaging.Message.CorrelationId%2A> właściwości wiadomością potwierdzającą.  
  
 Można również użyć <xref:System.Messaging.Message.Id%2A> właściwości podczas wysyłania komunikatu odpowiedzi do kolejki odpowiedzi. Aby dołączyć identyfikator oryginalnej wiadomości komunikat odpowiedzi, ustaw <xref:System.Messaging.Message.CorrelationId%2A> właściwości komunikat odpowiedzi do <xref:System.Messaging.Message.Id%2A> właściwości oryginalnej wiadomości. Aplikacja czytania wiadomości odpowiedzi służą następnie identyfikator korelacji wiadomości odpowiedzi do identyfikacji oryginalnej wiadomości.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.Id" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.Message.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteTimeout : TimeSpan" Usage="System.Messaging.Message.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy limit czasu nie istnieje.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> i <xref:System.Messaging.Message.TimeToReachQueue%2A> wymagają wartość, która określa limit czasu. Pierwsze, limit czasu jest maksymalny dozwolony czas realizacji wiadomości z kolejki. W przypadku drugiego nagłówka limit czasu jest czas przeznaczony na dotarcia wiadomości do kolejki. W obu przypadkach można określić jako liczbę sekund limitu czasu lub użyć <xref:System.Messaging.Message.InfiniteTimeout> aby wskazać, że limit czasu nie istnieje.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.Message.InfiniteTimeout> pola.  
  
  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
      </Docs>
    </Member>
    <Member MemberName="IsFirstInTransaction">
      <MemberSignature Language="C#" Value="public bool IsFirstInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFirstInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsFirstInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFirstInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFirstInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFirstInTransaction : bool" Usage="System.Messaging.Message.IsFirstInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsFirstInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była pierwszą wiadomością wysłaną w transakcji.</summary>
        <value>
          <see langword="true" /> Jeśli wiadomość była pierwszą wiadomością wysłaną w transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie używana aplikacji <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była pierwszą wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.  
  
 Aby sprawdzić granice transakcji, można użyć <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości wraz z dwóch innych właściwości: <xref:System.Messaging.Message.IsLastInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Używa pierwszej do sprawdzenia, czy wiadomość była ostatnią wiadomością wysłaną w transakcji i drugie można pobrać identyfikatora transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w transakcji, <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości są ustawione na `true`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.IsFirstInTransaction%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.IsFirstInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="IsLastInTransaction">
      <MemberSignature Language="C#" Value="public bool IsLastInTransaction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLastInTransaction" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.IsLastInTransaction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLastInTransaction As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLastInTransaction { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLastInTransaction : bool" Usage="System.Messaging.Message.IsLastInTransaction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgIsLastInTransaction")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy wiadomość była ostatnią wiadomością wysłaną w transakcji.</summary>
        <value>
          <see langword="true" /> Jeśli wiadomość była ostatnią wiadomością wysłaną w ramach jednej transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie używana aplikacji <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości, aby sprawdzić, czy wiadomość była ostatnią wiadomością wysłaną w ramach pojedynczej transakcji do pojedynczej kolejki.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.  
  
 Aby sprawdzić granice transakcji, można użyć <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości wraz z dwóch innych właściwości: <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.TransactionId%2A>. Używa pierwszej do sprawdzenia, czy wiadomość była pierwszą wiadomością wysłaną w transakcji i drugie można pobrać identyfikatora transakcji.  
  
 Jeśli tylko jeden komunikat jest wysyłany w transakcji, <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości są ustawione na `true`.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.IsLastInTransaction" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Label : string with get, set" Usage="System.Messaging.Message.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgLabel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia zdefiniowanym przez aplikację ciągu Unicode, który opisuje wiadomości.</summary>
        <value>Etykieta wiadomości. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Etykieta wiadomości służy do kilku celów. Na przykład służy ona do wyświetlania lub w celu przetworzenia selektywnie na podstawie wartości etykietę wiadomości. Etykieta nie musi być unikatowa w wiadomości.  
  
 Kolejki komunikatów i komunikat etykiety reprezentować zdefiniowanym przez aplikację wartości, które mogą ułatwić identyfikację kolejki lub wiadomości w kategoriach zrozumiałą dla użytkownika. Jest odpowiedzialny za aplikacji interpretować zawartość etykiety, która ma wewnętrznej znaczenia dla usługi kolejkowania komunikatów aplikacji.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.Label%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Label" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName="LookupId">
      <MemberSignature Language="C#" Value="public long LookupId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LookupId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.LookupId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LookupId As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LookupId { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LookupId : int64" Usage="System.Messaging.Message.LookupId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Pobiera identyfikator wyszukiwania wiadomości.</summary>
        <value>Identyfikator wyszukiwania wiadomości, który został wygenerowany przez MSMQ i jest unikatowa dla kolejki, gdzie znajduje się komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.LookupId%2A> Właściwości umożliwia dostęp tylko do odczytu do identyfikator wyszukiwania wiadomości. Identyfikator wyszukiwania, wprowadzone w 3.0 usługi MSMQ jest identyfikator 64-bitowym, który jest generowany przez usługę kolejkowania komunikatów i przypisane do każdego komunikatu, gdy wiadomość jest umieszczana w kolejce. Identyfikator wyszukiwania nie jest taki sam jak identyfikator wiadomości generowany, gdy komunikat jest wysyłany.  
  
 Usługa kolejkowania komunikatów generuje identyfikator wyszukiwania dla wszystkich wiadomości, które są umieszczane w kolejkach, tym wygenerowane w aplikacji docelowej, Administracja i kolejki raportu, a także generowanych przez system dziennika utraconych wiadomości, łącznik i kolejek wychodzących. Innymi słowy w tym komunikaty o błędach wysyłane przez wysyłanie aplikacje i usługi kolejkowania komunikatów. Identyfikator wyszukiwania jest unikatowy w kolejce i nie ma znaczenia poza kolejki.  
  
 Jeśli wiadomość jest wysyłana do kilku kolejek docelowych lub kopia wiadomości jest przechowywana w dzienniku komputera lub kolejki dziennika, każda kopia wiadomości będą mieli identyfikatora wyszukiwania, gdy znajduje się w jej w odpowiedniej kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  
  
 Identyfikator wyszukiwania jest używany do odczytu określonego komunikatu w kolejce. Gdy jest znany identyfikator wyszukiwania wiadomości, aplikacja odbierająca może wywołać <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> lub <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> funkcji, aby przejść bezpośrednio do tej wiadomości i wgląd lub pobrać ją z kolejki, w odróżnieniu od kursorów, które muszą być uruchomione na początek kolejki i Przejdź w końcowej kolejki  
  
 Uzyskiwanie identyfikatory wyszukiwania wiadomości w kolejce jest odpowiedzialny za aplikacji. Jest możliwe sposobem uzyskania identyfikatorów wyszukiwania można utworzyć wyzwalacza dla kolejki docelowej, która wywołuje składnik, który buforuje identyfikatory każdego komunikatu, ponieważ zostały one umieszczone w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.LookupId" /> właściwości.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="MessageType">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageType MessageType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessageType MessageType" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.MessageType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MessageType As MessageType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageType MessageType { System::Messaging::MessageType get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageType : System.Messaging.MessageType" Usage="System.Messaging.Message.MessageType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgMessageType")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera typ komunikatu: <see langword="Normal" />, <see langword="Acknowledgment" />, lub <see langword="Report" />.</summary>
        <value>Jeden z <see cref="P:System.Messaging.Message.MessageType" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usługa kolejkowania komunikatów zwykle ustawia tę właściwość podczas wysyłania wiadomości. Kolejkowania wiadomości nie może być jedną z następujących typów:  
  
-   `Normal`, która jest typowy wiadomość wysłana z aplikacji do kolejki lub komunikat odpowiedzi zwracany do wysyłania aplikacji.  
  
-   `Acknowledgement`, usługi kolejkowania wiadomości generowany zawsze, gdy aplikacja wysyłająca zażądają. Na przykład usługi kolejkowania komunikatów mogą generować komunikaty dodatnie lub ujemne, aby wskazywać, że oryginalnej wiadomości dotarły lub została odczytana. Usługa kolejkowania komunikatów zwraca komunikat potwierdzenia odpowiednie do kolejki administracyjnej określonej przez aplikację wysyłającą.  
  
-   `Report`, usługi kolejkowania wiadomości generowany zawsze, gdy nie jest zdefiniowany kolejki raportu źródłowego menedżera kolejek. Gdy śledzenie jest włączone, usługi kolejkowania komunikatów wysyła raport komunikat do kolejki raportu usługi kolejkowania komunikatów za każdym razem oryginalnej wiadomości wprowadza lub pozostawia serwer usługi kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.MessageType%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.MessageType" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessageType" />
        <altmember cref="P:System.Messaging.MessagePropertyFilter.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.MessagePriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As MessagePriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePriority Priority { System::Messaging::MessagePriority get(); void set(System::Messaging::MessagePriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Messaging.MessagePriority with get, set" Usage="System.Messaging.Message.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia priorytet wiadomości, która określa, gdzie w kolejce wiadomość jest umieszczana.</summary>
        <value>Jeden z <see cref="T:System.Messaging.MessagePriority" /> wartości, które reprezentują poziomy priorytetu wiadomości nietransakcyjnej. Wartość domyślna to <see langword="Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Priority%2A> Właściwość ma wpływ na sposób usługi kolejkowania komunikatów obsługi wiadomości obu, jest on drodze i po dotarciu serwerów do miejsca docelowego. Komunikaty o wyższym priorytecie są preferowane podczas routingu i dodaje do przodu kolejki docelowej. Wiadomości o takim samym priorytecie są umieszczane w kolejce zgodnie z ich Godzina nadejścia.  
  
 Można ustawić priorytet znaczący tylko dla wiadomości nietransakcyjnej. Usługa MSMQ automatycznie ustawia priorytet wiadomości transakcyjne do `Lowest`, co powoduje, że priorytet wiadomości transakcyjnych mają być ignorowane.  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła komunikaty dwóch różnych priorytetów do kolejki i pobiera je później.  
  
 [!code-cpp[Message.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CPP/message_defaultandpriority.cpp#1)]
 [!code-csharp[Message.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/CS/message_defaultandpriority.cs#1)]
 [!code-vb[Message.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.DefaultPropertiesToSend/VB/message_defaultandpriority.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Priority" /> właściwości.</exception>
        <altmember cref="T:System.Messaging.MessagePriority" />
        <altmember cref="P:System.Messaging.Message.MessageType" />
        <altmember cref="P:System.Messaging.MessageQueue.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="Recoverable">
      <MemberSignature Language="C#" Value="public bool Recoverable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Recoverable" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.Recoverable" />
      <MemberSignature Language="VB.NET" Value="Public Property Recoverable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Recoverable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Recoverable : bool with get, set" Usage="System.Messaging.Message.Recoverable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgRecoverable")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomość jest gwarantowana dostarczanych w przypadku problemu awarii lub sieci komputera.</summary>
        <value>
          <see langword="true" /> Jeśli dostarczania wiadomości jest gwarantowana (za pośrednictwem zapisywania wiadomości na dysku podczas dostarczania); <see langword="false" /> Jeśli nie jest zapewnione dostarczania. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.Recoverable%2A> Właściwość wskazuje, czy jest gwarantowane dostarczanie komunikatów, nawet jeśli komputer ulegnie awarii, gdy wiadomość jest na drodze do kolejki docelowej.  
  
 Jeśli jest gwarantowane dostarczanie komunikatów, wiadomości są przechowywane lokalnie na każdym etapie wzdłuż trasy, aż pomyślnie przekazano komunikat do następnego komputera. Ustawienie <xref:System.Messaging.Message.Recoverable%2A> właściwości `true` mogą wpłynąć na wydajność.  
  
 Jeśli komunikat jest transakcyjna, automatycznie kolejkowania wiadomości traktuje jako możliwe do odzyskania, niezależnie od wartości <xref:System.Messaging.Message.Recoverable%2A> właściwości.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.Recoverable%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.Recoverable" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="ResponseQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue ResponseQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue ResponseQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.ResponseQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property ResponseQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ ResponseQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ResponseQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.ResponseQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgResponseQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kolejkę, która odbiera wiadomości odpowiedzi generowane przez aplikację.</summary>
        <value>
          <see cref="T:System.Messaging.MessageQueue" /> Na które odpowiedzi generowane przez aplikacje są zwracane wiadomości. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.ResponseQueue%2A> Właściwość identyfikuje kolejkę, która odbiera wiadomości odpowiedzi generowane przez aplikacje, które aplikacja zwraca do aplikacji wysyłania. Aplikacja wysyłająca określa kolejki odpowiedzi, gdy aplikacja wysyła swoje wiadomości. Wszystkie dostępne kolejki można określić jako kolejkę odpowiedzi.  
  
 Komunikaty zwracane kolejki odpowiedzi są specyficzne dla aplikacji. Aplikacja musi definiować zawartość wiadomości, a także akcję do wykonania po otrzymaniu komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.ResponseQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.ResponseQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
      </Docs>
    </Member>
    <Member MemberName="SecurityContext">
      <MemberSignature Language="C#" Value="public System.Messaging.SecurityContext SecurityContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.SecurityContext SecurityContext" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Property SecurityContext As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::SecurityContext ^ SecurityContext { System::Messaging::SecurityContext ^ get(); void set(System::Messaging::SecurityContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SecurityContext : System.Messaging.SecurityContext with get, set" Usage="System.Messaging.Message.SecurityContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kontekst zabezpieczeń dla wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.SecurityContext" /> obiekt, który zawiera kontekstu zabezpieczeń wiadomości, jeśli wcześniej została ustawiona właściwość; w przeciwnym razie wartość NULL.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SenderCertificate">
      <MemberSignature Language="C#" Value="public byte[] SenderCertificate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderCertificate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Property SenderCertificate As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderCertificate { cli::array &lt;System::Byte&gt; ^ get(); void set(cli::array &lt;System::Byte&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SenderCertificate : byte[] with get, set" Usage="System.Messaging.Message.SenderCertificate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderCertificate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia certyfikat zabezpieczeń używany do uwierzytelniania wiadomości.</summary>
        <value>Tablica wartości bajtów reprezentujący certyfikatu zabezpieczeń, którego używa Usługa Kolejkowanie komunikatów, aby sprawdzić nadawcy wiadomości. Wartość domyślna jest tablicą o zerowej długości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja używa <xref:System.Messaging.Message.SenderCertificate%2A> właściwości, gdy komunikat zawiera certyfikat zabezpieczeń zewnętrznych.  
  
 Usługa kolejkowania komunikatów może uwierzytelniać wiadomości przy użyciu certyfikatu zabezpieczeń wewnętrznych lub zewnętrznych. Usługa kolejkowania komunikatów zapewnia certyfikaty wewnętrzne, które są używane w celu sprawdzenia integralności komunikatu. Urząd certyfikacji zawiera certyfikatu zewnętrznego, które jest dostępne za pośrednictwem <xref:System.Messaging.Message.SenderCertificate%2A> właściwości komunikatu. Oprócz umożliwienia usługi kolejkowania komunikatów do uwierzytelniania wiadomości, certyfikat zewnętrzny umożliwia aplikacji odbierającej dodatkową weryfikację nadawcy. Wewnętrzny certyfikat nie ma używać wartości do aplikacji odbierającej.  
  
 Certyfikat zewnętrzny musi zarejestrować w usłudze usługa katalogowa usługi kolejkowania komunikatów systemu. Certyfikat zewnętrzny zawiera informacje dotyczące urzędu certyfikacji, certyfikat użytkownika, okres ważności certyfikatu, klucza publicznego certyfikatu użytkownika i podpisu urzędu certyfikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.SenderCertificate" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseAuthentication" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.Message.Authenticated" />
      </Docs>
    </Member>
    <Member MemberName="SenderId">
      <MemberSignature Language="C#" Value="public byte[] SenderId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] SenderId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderId As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ SenderId { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderId : byte[]" Usage="System.Messaging.Message.SenderId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator użytkownika, wysyłania.</summary>
        <value>Tablica wartości bajtu identyfikuje nadawcę. Odbierającego menedżera kolejek używa identyfikatora podczas uwierzytelniania wiadomości zweryfikować nadawcy wiadomości i nadawcy prawa dostępu do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli <xref:System.Messaging.Message.AttachSenderId%2A> właściwość jest `false`, identyfikator nadawcy określone w <xref:System.Messaging.Message.SenderId%2A> właściwości nie jest dołączony do wiadomości, przed przesłaniem. Wskazuje usługi kolejkowania komunikatów że nadawca nie powinny być weryfikowane podczas wysyłania wiadomości do kolejki docelowej. Jeśli <xref:System.Messaging.Message.AttachSenderId%2A> właściwość jest `true`, <xref:System.Messaging.Message.SenderId%2A> wartość właściwości jest godne zaufania tylko wtedy, gdy wiadomość została uwierzytelniona. Użyj <xref:System.Messaging.Message.Authenticated%2A> właściwość w połączeniu z <xref:System.Messaging.Message.SenderId%2A> właściwości, aby sprawdzić prawa dostępu przez nadawcę.  
  
 Aplikacja łącznika jest aplikacji korzystającej z serwera łącznika w celu zapewnienia komunikacji między usługi kolejkowania komunikatów i innymi systemami kolejkowania. Usługa kolejkowania komunikatów wymaga łącznik aplikacje dostarczające identyfikator nadawcy. Należy ustawić <xref:System.Messaging.Message.ConnectorType%2A> właściwości podczas wysyłania wiadomości za pomocą łącznika aplikacji.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.SenderId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
      </Docs>
    </Member>
    <Member MemberName="SenderVersion">
      <MemberSignature Language="C#" Value="public long SenderVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 SenderVersion" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SenderVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SenderVersion As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long SenderVersion { long get(); };" />
      <MemberSignature Language="F#" Value="member this.SenderVersion : int64" Usage="System.Messaging.Message.SenderVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSenderVersion")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wersję usługi kolejkowania komunikatów używany do wysyłania wiadomości.</summary>
        <value>Wersja usługi kolejkowania komunikatów używany do wysyłania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SenderVersion%2A> Właściwość jest ważne w przypadku niektórych funkcji. Na przykład przetwarzanie transakcji jest obsługiwana tylko przez komunikatów usługi kolejkowania wiadomości 2.0 lub nowszy i podpisy cyfrowe są używane do uwierzytelniania wiadomości wysyłanych przez usługi MSMQ 1.0.  
  
 Wysyłanie zestawów menedżera kolejek <xref:System.Messaging.Message.SenderVersion%2A> właściwości, gdy komunikat jest wysyłany.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.SenderVersion%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.SenderVersion" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.Message.TransactionStatusQueue" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
      </Docs>
    </Member>
    <Member MemberName="SentTime">
      <MemberSignature Language="C#" Value="public DateTime SentTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime SentTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SentTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SentTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime SentTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.SentTime : DateTime" Usage="System.Messaging.Message.SentTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSentTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera datę i godzinę wysłania wiadomości przez źródłowego menedżera kolejek komputera wysyłającego.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentujący godzinę wysłania wiadomości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.SentTime%2A> Właściwość zostanie przesunięty na czas lokalny komputera, na którym znajduje się ten wystąpienia <xref:System.Messaging.Message> klasy został utworzony. Ta strefa czasowa może różnić się od wartości kolejek źródłowym i docelowym.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.SentTime%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.SentTime" /> właściwości.</exception>
      </Docs>
    </Member>
    <Member MemberName="SourceMachine">
      <MemberSignature Language="C#" Value="public string SourceMachine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SourceMachine" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.SourceMachine" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SourceMachine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SourceMachine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SourceMachine : string" Usage="System.Messaging.Message.SourceMachine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgSourceMachine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera komputera, z którego wiadomość pochodzi.</summary>
        <value>Nazwa komputera, z którego wiadomość została wysłana.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Format <xref:System.Messaging.Message.SourceMachine%2A> właściwość nie ma poprzedzających dwa ukośniki (\\\\). Na przykład `myServer` jest prawidłową <xref:System.Messaging.Message.SourceMachine%2A>.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.SourceMachine%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.SourceMachine" /> właściwości.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Nie można uzyskać dostępu do usługi informacji lub katalogu komputera.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="TimeToBeReceived">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToBeReceived { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToBeReceived" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToBeReceived" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToBeReceived As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToBeReceived { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToBeReceived : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToBeReceived" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToBeReceived")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną ilość czasu wiadomości z kolejki docelowej.</summary>
        <value>Łączny czas wiadomość z kolejki docelowej. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TimeToBeReceived%2A> Właściwość określa całkowity czas wiadomość z kolejki docelowej. Limit czasu obejmuje czas pobierania do kolejki docelowej, a czas oczekiwania w kolejce, zanim odebrać wiadomości.  
  
> [!CAUTION]
>  Korzystając z zależnych komputerów klienckich, upewnij się, że zegar komputera klienckiego jest zsynchronizowany z zegarem na serwerze jest uruchomiona usługa kolejkowania komunikatów. W przeciwnym razie może spowodować nieprzewidywalne zachowanie, podczas wysyłania komunikatu których <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość nie jest <xref:System.Messaging.Message.InfiniteTimeout>.  
  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości wygasa przed usunięciem wiadomości z kolejki, usługi kolejkowania komunikatów odrzuca komunikat w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość jest `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false`, komunikat zostanie zignorowany.  
  
 Można ustawić komunikatu <xref:System.Messaging.Message.AcknowledgeType%2A> żądania, że usługa kolejkowania komunikatów wysłać wiadomość negatywnego potwierdzenia dla właściwości z powrotem do aplikacja wysyłająca Jeśli wiadomość nie została pobrana przed wygaśnięciem.  
  
 Jeśli wartość jest określona przez <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości jest mniejsza niż wartość określoną przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwość <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 W przypadku kilku komunikaty są wysyłane w ramach jednej transakcji, usługi kolejkowania komunikatów używa <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości pierwszego komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.TimeToBeReceived" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <see cref="P:System.Messaging.Message.TimeToBeReceived" /> jest nieprawidłowy.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToReachQueue" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TimeToReachQueue">
      <MemberSignature Language="C#" Value="public TimeSpan TimeToReachQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TimeToReachQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TimeToReachQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TimeToReachQueue As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TimeToReachQueue { TimeSpan get(); void set(TimeSpan value); };" />
      <MemberSignature Language="F#" Value="member this.TimeToReachQueue : TimeSpan with get, set" Usage="System.Messaging.Message.TimeToReachQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.TimeoutConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTimeToReachQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalną ilość czasu dotarcia wiadomości do kolejki.</summary>
        <value>Limit czasu dotarcia wiadomości do kolejki docelowej, rozpoczynający się od czasu wiadomość zostanie wysłana. Wartość domyślna to <see cref="F:System.Messaging.Message.InfiniteTimeout" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli interwał określony przez <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości wygasa przed komunikat dociera do miejsca docelowego, usługi kolejkowania komunikatów odrzuca komunikat w jeden z dwóch sposobów. Jeśli komunikat <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość jest `true`, komunikat jest wysyłany do kolejki utraconych wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `false`, komunikat zostanie zignorowany.  
  
 Można ustawić komunikat he <xref:System.Messaging.Message.AcknowledgeType%2A> żądania, że usługa kolejkowania komunikatów wysłać wiadomość negatywnego potwierdzenia dla właściwości z powrotem do aplikacja wysyłająca Jeśli komunikat został odebrany przed wygaśnięciem.  
  
 Jeśli <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwość jest ustawiona na 0 sekund, usługi kolejkowania komunikatów próbuje raz do wysłania tej wiadomości do miejsca docelowego, jeśli kolejka oczekuje na komunikat. Jeśli kolejka jest lokalny, wiadomości zawsze osiągnie on.  
  
 Jeśli wartość jest określona przez <xref:System.Messaging.Message.TimeToReachQueue%2A> jest większa niż wartość określoną przez właściwość <xref:System.Messaging.Message.TimeToBeReceived%2A> właściwość <xref:System.Messaging.Message.TimeToBeReceived%2A> ma pierwszeństwo.  
  
 W przypadku kilku komunikaty są wysyłane w ramach jednej transakcji, usługi kolejkowania komunikatów używa <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości pierwszego komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.TimeToReachQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.TimeToReachQueue" /> właściwości.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <see cref="P:System.Messaging.Message.TimeToReachQueue" /> jest nieprawidłowy. Ten element reprezentuje może być liczbą ujemną.</exception>
        <altmember cref="P:System.Messaging.Message.TimeToBeReceived" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="TransactionId">
      <MemberSignature Language="C#" Value="public string TransactionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransactionId" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TransactionId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TransactionId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TransactionId : string" Usage="System.Messaging.Message.TransactionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera identyfikator transakcji, których wiadomość została części.</summary>
        <value>Identyfikator transakcji skojarzonych z wiadomością.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Odbieranie używana aplikacji <xref:System.Messaging.Message.TransactionId%2A> właściwości, aby sprawdzić, czy wiadomość została wysłana jako część określonej transakcji. Identyfikator transakcji zawiera identyfikator komputera wysyłającego (pierwszych 16 bitów) z numerem sekwencji 4-bajtowych transakcji.  
  
 Ta właściwość jest dostępna tylko w przypadku usługi kolejkowania komunikatów w wersji 2.0 lub nowszy.  
  
 Identyfikatory transakcji nie ma gwarancji być unikatowa, ponieważ numerów sekwencyjnych transakcji nie są trwałe i ich przerwanie 2 <sup>20</sup>. Usługa kolejkowania komunikatów gwarantuje tylko, że kolejnych transakcji numerów sekwencyjnych innej transakcji.  
  
 Można użyć <xref:System.Messaging.Message.TransactionId%2A> właściwości wraz z <xref:System.Messaging.Message.IsFirstInTransaction%2A> i <xref:System.Messaging.Message.IsLastInTransaction%2A> właściwości, aby sprawdzić granice transakcji.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.TransactionId%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.TransactionId" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="TransactionStatusQueue">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageQueue TransactionStatusQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessageQueue TransactionStatusQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.TransactionStatusQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property TransactionStatusQueue As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessageQueue ^ TransactionStatusQueue { System::Messaging::MessageQueue ^ get(); void set(System::Messaging::MessageQueue ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TransactionStatusQueue : System.Messaging.MessageQueue with get, set" Usage="System.Messaging.Message.TransactionStatusQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgTransactionStatusQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera kolejkę stanu transakcji na komputerze źródłowym.</summary>
        <value>Kolejkę stanu transakcji na komputerze źródłowym, który służy do wysyłania komunikatów potwierdzenia do aplikację wysyłającą. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.TransactionStatusQueue%2A> Właściwość identyfikuje transakcyjne kolejki na komputer źródłowy, który odbiera potwierdzenia potwierdzeń przeczytania z aplikacji łącznika. Usługa kolejkowania komunikatów ustawia właściwość i aplikacje łącznika, użyj właściwości podczas pobierania wiadomości transakcyjnych wysłanych do kolejki obcego.  
  
 Obcy kolejka istnieje w systemie kolejkowania innego niż usługi kolejkowania wiadomości firmy Microsoft. Usługa kolejkowania komunikatów komunikuje się z takich kolejek za pomocą łącznika aplikacji.  
  
 Aplikacja łącznika można użyć kolejkę stanu transakcji do wysyłania wiadomości potwierdzającej do wysyłania aplikacji. Nawet wtedy, gdy aplikacja wysyłająca żądanie nie innych potwierdzenia kolejkę stanu transakcji powinien zostać wyświetlony te potwierdzenia.  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość komunikat <xref:System.Messaging.Message.TransactionStatusQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wiadomość nie została wysłana. Tej właściwości mogą być odczytywane tylko na wiadomości pobierane z kolejki.  Kolejka komunikatów została odfiltrowana do ignorowania - lub - <see cref="P:System.Messaging.Message.TransactionStatusQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.AdministrationQueue" />
        <altmember cref="P:System.Messaging.Message.DestinationQueue" />
        <altmember cref="P:System.Messaging.Message.ResponseQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
      </Docs>
    </Member>
    <Member MemberName="UseAuthentication">
      <MemberSignature Language="C#" Value="public bool UseAuthentication { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseAuthentication" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseAuthentication" />
      <MemberSignature Language="VB.NET" Value="Public Property UseAuthentication As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseAuthentication { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseAuthentication : bool with get, set" Usage="System.Messaging.Message.UseAuthentication" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseAuthentication")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomość została (lub musi być) uwierzytelnionego przed wysyłane.</summary>
        <value>
          <see langword="true" /> Jeśli aplikacja wysyłająca żądanie uwierzytelniania dla message; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseAuthentication%2A> Właściwość określa, czy wiadomość wymaga uwierzytelniania. Jeśli aplikacja wysyłająca żąda uwierzytelniania, usługi kolejkowania komunikatów tworzy podpis cyfrowy i używa go do podpisania wiadomości, podczas wysyłania i uwierzytelniania wiadomości po odebraniu.  
  
 Jeśli <xref:System.Messaging.Message.UseAuthentication%2A> jest `false` i jest wysyłany komunikat do kolejki, która akceptuje tylko wiadomości uwierzytelnione, komunikat zostanie odrzucony, po osiągnięciu kolejki.  
  
 Nie można ustalić, czy wiadomość niepowodzenie uwierzytelniania analizując jego właściwości. Usługa kolejkowania komunikatów spowoduje odrzucenie tych wiadomości przed wysłaniem ich do kolejki. Można jednak żądanie wysłane wiadomości potwierdzającej Jeśli awarii dostarczania uniemożliwia wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.UseAuthentication" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.Authenticated" />
        <altmember cref="P:System.Messaging.Message.ConnectorType" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderName" />
        <altmember cref="P:System.Messaging.Message.AuthenticationProviderType" />
        <altmember cref="P:System.Messaging.Message.DigitalSignature" />
        <altmember cref="P:System.Messaging.MessageQueue.Authenticate" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="P:System.Messaging.Message.AttachSenderId" />
      </Docs>
    </Member>
    <Member MemberName="UseDeadLetterQueue">
      <MemberSignature Language="C#" Value="public bool UseDeadLetterQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDeadLetterQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseDeadLetterQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseDeadLetterQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseDeadLetterQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseDeadLetterQueue : bool with get, set" Usage="System.Messaging.Message.UseDeadLetterQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseDeadLetterQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kopia wiadomości, którego nie można dostarczyć mają być wysyłane do kolejki utraconych wiadomości.</summary>
        <value>
          <see langword="true" /> Jeśli kopia wiadomości wysyłanych do kolejki utraconych wiadomości; powinno spowodować niepowodzenie dostarczanie komunikatów w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości określają sposób śledzi kolejkowania wiadomości. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> jest `true`, dostarczania awarii (nietransakcyjnej komunikat), powoduje, że komunikat do wysłania do nietransakcyjnej kolejki utraconych wiadomości na komputerze, który nie może dostarczyć komunikatu. Błąd dostarczania może być spowodowana przez czasomierz komunikat wygasa, np.  
  
 W przypadku niepowodzenia dostarczania dla wiadomości transakcyjnych usługi kolejkowania komunikatów wysyła wiadomość do transakcyjnej kolejki utraconych wiadomości na komputerze źródłowym, we wszystkich przypadkach ujemna i wątpliwych.  
  
 Gdy wiadomości są przechowywane w kolejce wiadomości utraconych, należy wyczyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Przechowywane w liczbę przydział rozmiaru dla komputera, na którym znajduje się kolejka utraconych wiadomości. Przydział komputera jest ustawiany przez administratora i odwołuje się do rozmiar przydzielony do przechowywania wiadomości na całego komputera, a nie tylko w pojedynczej kolejki.  
  
 Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.UseDeadLetterQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
      </Docs>
    </Member>
    <Member MemberName="UseEncryption">
      <MemberSignature Language="C#" Value="public bool UseEncryption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseEncryption" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseEncryption" />
      <MemberSignature Language="VB.NET" Value="Public Property UseEncryption As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseEncryption { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseEncryption : bool with get, set" Usage="System.Messaging.Message.UseEncryption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseEncryption")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy wiadomości prywatnej.</summary>
        <value>
          <see langword="true" /> Aby wymagać usługi kolejkowania komunikatów do szyfrowania wiadomości; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli komunikat jest prywatny, przed wysyłanych i odszyfrować po odebraniu jego treść jest szyfrowane. Aby wysłać wiadomość prywatne, aplikacja wysyłająca musi określić, że szyfrowanie można użyć i, opcjonalnie, algorytm szyfrowania.  
  
 Podczas wysyłania wiadomości prywatne, aplikacja nie trzeba wykonywać szyfrowania wiadomości. Usługa kolejkowania komunikatów można zaszyfrować treść komunikatu dla Ciebie, jeśli aplikacja jest wysyłanie wiadomości w obrębie przedsiębiorstwa systemu Microsoft Windows 2000, który ma dostęp do usługi katalogowej. Podczas odbierania wiadomości, odbierającego menedżera kolejek zawsze Odszyfrowuje treść komunikatu.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseEncryption%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.UseEncryption" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.EncryptionAlgorithm" />
        <altmember cref="P:System.Messaging.MessageQueue.EncryptionRequired" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseJournalQueue : bool with get, set" Usage="System.Messaging.Message.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseJournalQueue")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kopia wiadomości powinna być przechowywana w dzienniku komputera na komputerze źródłowym.</summary>
        <value>
          <see langword="true" /> wymaganie zachowane kopia wiadomości w dzienniku komputera źródłowego komputera po wiadomości została pomyślnie przesłana (z komputera źródłowego do następnego serwera); w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseJournalQueue%2A> i <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwości określają sposób śledzi kolejkowania wiadomości. Jeśli <xref:System.Messaging.Message.UseJournalQueue%2A> jest `true`, a następnie kopia jest przechowywana w dzienniku komputera, z którego pochodzi wiadomość w każdym kroku wiadomości przesyłane.  
  
 Wysłany komunikat jest kopiowany do kolejki dziennika tylko, jeśli kolejka docelowa znajduje się na komputerze zdalnym. Jeśli elementem docelowym jest na komputerze lokalnym, komunikat jest wysyłany bezpośrednio do kolejki; Brak pośrednich sposobów wymagają rejestrowania.  
  
 Gdy wiadomości są przechowywane w kolejce dziennika, należy wyczyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Wiadomości przechowywanych w liczby kolejek dziennika względem limitu przydziału dla komputera, na którym znajduje się kolejka. (Przydział komputera jest ustawiany przez administratora).  
  
 Nie należy tworzyć dziennika lub kolejki utraconych wiadomości. Są to zarówno kolejki systemowe, generowane przez usługę kolejkowania komunikatów.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseJournalQueue%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.UseJournalQueue" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseTracing" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="UseTracing">
      <MemberSignature Language="C#" Value="public bool UseTracing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseTracing" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.Message.UseTracing" />
      <MemberSignature Language="VB.NET" Value="Public Property UseTracing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseTracing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseTracing : bool with get, set" Usage="System.Messaging.Message.UseTracing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MsgUseTracing")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy śledzenie wiadomości przesyłane do swojej kolejki docelowej.</summary>
        <value>
          <see langword="true" /> Jeśli każdego kroku pośredniego wprowadzone przez trasie oryginalnej wiadomości do kolejki docelowej generuje raport do wysłania do kolejki raportu systemu; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.Message.UseTracing%2A> Właściwość określa, czy śledzenie trasy wiadomości przesyłane do swojej kolejki docelowej. Jeśli `true`, raportu (generowane przez usługę kolejkowania wiadomości) jest wysyłany komunikat do kolejki raportu zawsze wiadomości przechodzi przez serwer routingu usługi kolejkowania komunikatów. Kolejka raportu jest określana przez źródłowego menedżera kolejek. Kolejki raportu nie są ograniczone do raportu komunikaty generowane przez usługę kolejkowania komunikatów; wiadomości generowany przez aplikację mogą być również wysyłane do kolejki raportu.  
  
 Korzystanie z funkcji śledzenia obejmuje skonfigurowanie usługi Active Directory i określenie kolejki raportu dla przedsiębiorstw usługi kolejkowania komunikatów. Administrator konfiguruje te ustawienia.  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość komunikatu <xref:System.Messaging.Message.UseTracing%2A> właściwości.  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Kolejka komunikatów została odfiltrowana do ignorowania <see cref="P:System.Messaging.Message.UseTracing" /> właściwości.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.UseJournalQueue" />
      </Docs>
    </Member>
  </Members>
</Type>
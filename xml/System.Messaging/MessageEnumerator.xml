<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30558781" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera tylko do przodu kursora do sortowania wiadomości z kolejki wiadomości.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageEnumerator> dynamiczne interakcji z wiadomości w kolejce. Dostępne za pośrednictwem metody <xref:System.Messaging.MessageQueue> klasy mogą zwracać <xref:System.Messaging.MessageEnumerator> wskazuje dynamiczną listę wiadomości w kolejce lub tablicę, która zawiera kopię w danej chwili - migawki - kolejki w czasie określonej metody została wywołana.  
  
 W odróżnieniu od statycznej migawki moduł wyliczający umożliwia modyfikowanie kolekcji. Przy użyciu <xref:System.Messaging.MessageEnumerator>, można usunąć wiadomości z kolejki i natychmiast znajduje odzwierciedlenie w kolejce.  
  
 Moduł wyliczający nie powoduje usunięcia wiadomości z kolejki, gdy wysyła zapytanie kolejki. Zwraca informacje o komunikacie w bieżącym położeniu kursora, ale pozostawia wiadomości w kolejce.  
  
 A <xref:System.Messaging.MessageEnumerator> jest kursor, zainicjować nagłówek listy dynamicznych. Na liście jest taka sama jak kolejność wiadomości w kolejce, zgodnie z priorytet wiadomości. Kursor można przenieść do pierwszej wiadomości w kolejce przez wywołanie metody <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Po zainicjowaniu modułu wyliczającego można użyć <xref:System.Messaging.MessageEnumerator.MoveNext%2A> do krok do przodu w pozostałych wiadomości. Można określić, czy oczekiwania na udostępnienie przez przekazanie przekroczenie limitu czasu w wiadomości <xref:System.Messaging.MessageEnumerator.MoveNext%2A> metody.  
  
 Ponieważ moduł wyliczający jest dynamiczny, komunikat, który jest dołączany poza bieżącej pozycji kursora (na przykład ze względu na niski priorytet), są dostępne przez moduł wyliczający. Komunikat, który zostanie wstawiony przed nie można uzyskać dostępu do bieżącego położenia kursora. Nie jest możliwe krok wstecz z <xref:System.Messaging.MessageEnumerator>. Kursor umożliwia przenoszenie tylko do przodu. <xref:System.Messaging.MessageEnumerator.Reset%2A> Metoda umożliwia umieść kursor wstecz na początek kolejki.  
  
 Wystąpienia <xref:System.Messaging.MessageEnumerator> do danej kolejki działać niezależnie. Należy utworzyć dwa <xref:System.Messaging.MessageEnumerator> wystąpień, które mają zastosowanie do tej samej kolejki. Zmiany jednym <xref:System.Messaging.MessageEnumerator> sprawia, że do wiadomości w kolejce zostaną natychmiast odzwierciedlone w drugim modułu wyliczającego Jeśli drugi moduł wyliczający jest ustawiony przed pierwszym krokiem. Jednak jeśli dwa moduły wyliczające mieć to samo położenie i jeden z nich usuwa komunikat na tej pozycji, jest zwracany wyjątek, jeśli inne modułu wyliczającego próbuje pobrać wartość <xref:System.Messaging.MessageEnumerator.Current%2A> właściwości wiadomości usunięty teraz.  
  
> [!NOTE]
>  W przypadku utworzenia wystąpienia <xref:System.Messaging.MessageQueue> z <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> ustawioną `true`, żadna inna aplikacja nie mogą modyfikować wiadomości w sieci modułu wyliczającego, gdy masz połączenie z kolejki.  
  
   
  
## Examples  
 W poniższym przykładzie pobiera dynamiczną listę komunikatów z kolejki i oblicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> ustawioną właściwość <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby skojarzone z modułu wyliczającego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny zachowuje otwarte dojście do kolejki przez cały okres istnienia kursora. Po zakończeniu pracy z modułu wyliczającego wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> aby zwolnić zasoby skojarzone z dojścia.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Messaging.Message" /> wskazuje dla tego modułu wyliczającego.</summary>
        <value>Bieżący komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego wskazuje head kolejki, w miejscu przed pierwszą wiadomością. W takim przypadku <xref:System.Messaging.MessageEnumerator.Current%2A> nie jest prawidłowy i zgłosi wyjątek, jeśli jest on dostępny. Należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aby umieść kursor wglądu do pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Należy wywołać <see cref="P:System.Messaging.MessageEnumerator.Current" /> przed pierwszym wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Kursor znajduje się przed pierwszym elementem wyliczenia wiadomości.  
  
 —lub—  
  
 Należy wywołać <see cref="P:System.Messaging.MessageEnumerator.Current" /> po wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> zwrócił <see langword="false" /> (wskazująca, gdy kursor znajduje się za ostatnim elementem wyliczenia komunikat.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat, który moduł wyliczający aktualnie wskazuje już istnieje. Być może został usunięty.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę kolejkowania komunikatów kursora uchwyt macierzysty używany do przeglądania wiadomości w kolejce.</summary>
        <value>Uchwyt macierzysty kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera uchwyt macierzysty do wyliczenia. Po zakończeniu pracy z modułu wyliczającego wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> zwolnienia tego zasobu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Dojście nie istnieje.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Messaging.MessageEnumerator.Dispose%2A> umożliwia zasoby używane przez <xref:System.Messaging.MessageEnumerator> odbiorczego do innych celów. Aby uzyskać więcej informacji na temat <xref:System.Messaging.MessageEnumerator.Dispose%2A>, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Messaging.MessageEnumerator" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.Messaging.MessageEnumerator.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Messaging.MessageEnumerator> odwołania. Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty. W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />. Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Moduł wyliczający należy przechodzi do następnej wiadomości w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnej wiadomości w kolejce modułu wyliczającego, jeśli jest obecnie dostępny.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie zaawansowane do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie zwraca natychmiast, jeśli nie ma w kolejce. Brak innego przeciążenia, które oczekuje określonej <xref:System.TimeSpan> na odbierane wiadomości.  
  
 Jeśli wiadomość nie jest obecnie dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca `false` do wywoływania metody.  
  
 Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomość z kolejki i w pierwszym wywołaniu <xref:System.Messaging.MessageEnumerator.MoveNext%2A> powoduje przeniesienie pierwszą wiadomość z kolejki do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Oczekiwania na jest dostępny, gdy moduł wyliczający jest umieszczony na końcu kolejki wiadomości.</param>
        <summary>Moduł wyliczający należy przechodzi do następnej wiadomości w kolejce. Jeśli moduł wyliczający jest umieszczony na końcu kolejki <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> czeka, aż wiadomości jest dostępna lub danego limitu czasu wygaśnięcia.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający pomyślnie poprawionym do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki wiadomości nie są dostępne w czasie określonym przez <paramref name="timeout" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie czeka, jeśli nie ma w kolejce lub kursor osiągnął koniec kolejki. Jeśli wiadomość nie jest obecnie dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> określony limit czasu oczekiwania.  
  
 Jeśli kursor znajduje się już na końcu kolejki <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca tylko `true` Jeśli nowy komunikat w określonym czasie, aktualnie ma niższy priorytet niż wszystkie wiadomości w kolejce i znajduje się na końcu kolejki. Przeciążenia z parametrem nie zwraca natychmiast, jeżeli w kolejce znajdują się dalsze komunikaty.  
  
 Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomością wyliczenia i w pierwszym wywołaniu <xref:System.Messaging.MessageEnumerator.MoveNext%2A> przełącza pierwszą wiadomością wyliczenie do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla parametru limitu czasu jest nieprawidłowa. Ten element reprezentuje może być liczbą ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Upłynął limit czasu.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Usuwając wiadomość usuwa ją z kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie opisane dla tych overloads ma zastosowanie tylko wtedy, gdy <xref:System.Messaging.MessageEnumerator> wystąpienia są pobierane przy użyciu <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Nie używaj <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> można pobrać wystąpienia <xref:System.Messaging.MessageEnumerator> jak ta metoda jest przestarzała.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bieżący komunikat z kolejki transakcyjnej lub nietransakcyjna i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa transakcji, w którym zostaną usunięte wiadomości.</param>
        <summary>Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki. Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Nie ma limitu czasu określona dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki. Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na wiadomość w kolejce.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na wiadomość do usunięcia.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa kontekst transakcji dla wiadomości.</param>
        <summary>Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki. Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na wiadomość do usunięcia.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio. W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru. Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki. Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.  
  
 Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości. Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje bieżącego modułu wyliczającego, więc wskazuje head kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający można przenieść tylko w kierunku do przodu. Użyj tej metody, aby rozpocząć od początku na początek kolejki.  
  
 Po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A>, kursor wskazuje pierwszego komunikatu. Nie należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A> Aby przesunąć kursor do przodu do pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca <see cref="T:System.Messaging.Message" /> , która odwołuje się komunikat w bieżącym położeniu kursora.</summary>
        <value>A <see cref="T:System.Messaging.Message" /> , która odwołuje się komunikat w bieżącym położeniu kursora.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
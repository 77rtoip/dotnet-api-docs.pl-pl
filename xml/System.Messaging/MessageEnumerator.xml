<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="23b91a2631794fe77c1398283e744a03f64ef34f" />
    <Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="09/22/2018" />
    <Meta Name="ms.locfileid" Value="46645658" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Zawiera tylko do przodu kursora wyliczyć za pośrednictwem wiadomości z kolejki komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageEnumerator> dynamiczne interakcji z komunikatów w kolejce. Dostępne za pośrednictwem metody <xref:System.Messaging.MessageQueue> klasy może zwracać albo <xref:System.Messaging.MessageEnumerator> wskazuje dynamiczną listę komunikatów w kolejce lub tablica, która zawiera kopię w danej chwili — migawki - kolejki w czasie określonej metody została wywołana.  
  
 W przeciwieństwie do statycznej migawki moduł wyliczający umożliwia modyfikowanie kolekcji. Za pomocą <xref:System.Messaging.MessageEnumerator>, możesz usunąć komunikaty z kolejki i zmiana jest natychmiast odzwierciedlana w kolejce.  
  
 Moduł wyliczający nie powoduje usunięcia komunikaty z kolejki, gdy wysyła zapytanie kolejki. Zwraca informacje o wiadomości w bieżącym położeniu kursora, ale pozostawia wiadomości w kolejce.  
  
 Element <xref:System.Messaging.MessageEnumerator> jest kursor, inicjowany do głowy listy dynamicznej. Kolejność na liście jest taka sama jak kolejność komunikatów w kolejce, na podstawie priorytetu wiadomości. Możesz przenieść kursor do pierwszej wiadomości w kolejce przez wywołanie metody <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Po zainicjowaniu modułu wyliczającego, można użyć <xref:System.Messaging.MessageEnumerator.MoveNext%2A> można przejść do przodu przez pozostałe komunikaty. Można określić, czy oczekiwania na udostępnienie przez przekazanie przekroczenie limitu czasu w wiadomości <xref:System.Messaging.MessageEnumerator.MoveNext%2A> metody.  
  
 Ponieważ moduł wyliczający jest dynamiczny, komunikat, który jest dołączany po bieżącej pozycji kursora (na przykład z powodu — niski priorytet), uzyskiwania dostępu przez moduł wyliczający. Komunikat, który jest wstawiany przed nie można uzyskać dostępu do bieżącego położenia kursora. Nie jest możliwe poruszać się za pomocą <xref:System.Messaging.MessageEnumerator>. Kursor zezwala na ruch tylko do przodu. <xref:System.Messaging.MessageEnumerator.Reset%2A> Metoda umożliwia umieść kursor ponownie na początku kolejki.  
  
 Wystąpienia elementu <xref:System.Messaging.MessageEnumerator> do danej kolejki działać niezależnie. Należy utworzyć dwa <xref:System.Messaging.MessageEnumerator> wystąpień, które są stosowane do tej samej kolejki. Zmiany jednego <xref:System.Messaging.MessageEnumerator> sprawia, że komunikaty w kolejce zostaną natychmiast odzwierciedlone w drugim modułu wyliczającego, jeśli drugi moduł wyliczający jest umieszczony przed pierwszym. Jednakże, jeśli dwa moduły wyliczające mają taką samą pozycję i jeden z nich usuwa komunikat w tej pozycji, wyjątek jest generowany, jeśli próbuje pobrać wartość modułu wyliczającego <xref:System.Messaging.MessageEnumerator.Current%2A> właściwości w komunikacie usunięty teraz.  
  
> [!NOTE]
>  Jeśli utworzysz wystąpienie <xref:System.Messaging.MessageQueue> z <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> równa `true`, żadna inna aplikacja nie mogą modyfikować wiadomości w sieci modułu wyliczającego, gdy masz połączenie do kolejki.  
  
   
  
## Examples  
 Poniższy przykład pobiera dynamiczną listę komunikatów w kolejce i zlicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> właściwością <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby skojarzone z modułu wyliczającego.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny zachowuje otwarte dojście do kolejki w okresie istnienia kursora. Po zakończeniu pracy z modułu wyliczającego, należy wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> aby zwolnić zasoby skojarzone z uchwytu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżący <see cref="T:System.Messaging.Message" /> wskazuje dla tego modułu wyliczającego.</summary>
        <value>Bieżący komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas tworzenia modułu wyliczającego wskazuje head kolejki, w miejscu przed pierwszą wiadomością. W tym przypadku <xref:System.Messaging.MessageEnumerator.Current%2A> jest nieprawidłowy i spowoduje zgłoszenie wyjątku, jeśli jest on dostępny. Należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aby umieść kursor wglądu do pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nastąpiło wywołanie <see cref="P:System.Messaging.MessageEnumerator.Current" /> przed pierwszym wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Kursor znajduje się przed pierwszym elementem wyliczenie wiadomości.  
  
—lub— 
Nastąpiło wywołanie <see cref="P:System.Messaging.MessageEnumerator.Current" /> po wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> zwrócił <see langword="false" /> (wskazujący kursor znajduje się po ostatnim elemencie wyliczenie komunikat.)</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat, który moduł wyliczający aktualnie wskazuje już nie istnieje. Być może został usunięty.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera usługę kolejkowania komunikatów kursora uchwyt macierzysty używane do przeglądania wiadomości w kolejce.</summary>
        <value>Uchwyt kursora natywnych.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera natywny dojścia do wyliczenia. Po zakończeniu pracy z modułu wyliczającego, należy wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> zwolnić tego zasobu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Dojście nie istnieje.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszelkie zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywoływanie <xref:System.Messaging.MessageEnumerator.Dispose%2A> umożliwia zasoby używane przez <xref:System.Messaging.MessageEnumerator> zostają przeniesione do innych celów. Aby uzyskać więcej informacji na temat <xref:System.Messaging.MessageEnumerator.Dispose%2A>, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko niezarządzane zasoby.</param>
        <summary>Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Messaging.MessageEnumerator" /> i opcjonalnie zwalnia zasoby zarządzane.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez publiczną <xref:System.Messaging.MessageEnumerator.Dispose%2A> metody i <xref:System.Object.Finalize%2A> metody. `Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` parametr `true`. <xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` równa `false`.  
  
 Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane że <xref:System.Messaging.MessageEnumerator> odwołania. Ta metoda wywołuje `Dispose()` metoda każdego obiektu, do którego istnieje odwołanie.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />, nie należy odwoływać się do obiektów, które zostały wcześniej zlikwidowane wcześniejszym wywołaniem do <see langword="Dispose" />. Aby uzyskać więcej informacji o sposobie wdrażania <see langword="Dispose" />, zobacz [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) i [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para>
        </block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementacja metody Dispose</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesuwa modułu wyliczającego do następnej wiadomości w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przechodzi do następnej wiadomości w kolejce, moduł wyliczający, jeśli jest aktualnie dostępna.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający został pomyślnie zaawansowane do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tego przeciążenia zwraca niezwłocznie, jeśli nie ma w kolejce. Brak innego przeciążenia metody, która czeka określoną <xref:System.TimeSpan> na odbierania wiadomości.  
  
 Jeśli komunikat jest obecnie niedostępna, ponieważ kolejka jest pusta lub przeniesiono za ostatnim elementem w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca `false` do metody wywołującej.  
  
 Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomość z kolejki, a pierwsze wywołanie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> wnosi pierwszy komunikat kolejki do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek, które są specyficzne dla usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <see cref="T:System.TimeSpan" /> Oczekiwania na udostępnienie, jeśli moduł wyliczający jest umieszczony na końcu kolejki wiadomości.</param>
        <summary>Przesuwa modułu wyliczającego do następnej wiadomości w kolejce. Jeśli moduł wyliczający jest umieszczony na końcu kolejki <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> czeka, aż komunikat jest dostępny lub upłynie limit czasu danego.</summary>
        <returns>
          <see langword="true" /> Jeśli moduł wyliczający pomyślnie zaawansowane do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki wiadomości nie są dostępne w czasie określonym przez <paramref name="timeout" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie czeka, jeśli nie ma w kolejce lub kursor osiągnął koniec kolejki. Jeśli komunikat jest obecnie niedostępna, ponieważ kolejka jest pusta lub przeniesiono za ostatnim elementem w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> określony limit czasu oczekiwania.  
  
 Jeśli kursor znajduje się już na końcu kolejki <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca tylko `true` Jeśli nowa wiadomość zostanie odebrana w określonym interwale, obecnie ma niższy priorytet niż wszystkie komunikaty w kolejce i znajduje się na końcu kolejki. Przeciążenie nie parametru zwraca niezwłocznie, jeśli żadne dalsze komunikaty nie znajdują się w kolejce.  
  
 Po utworzeniu, moduł wyliczający koncepcyjnie jest umieszczony przed pierwszą wiadomość wyliczenia, a pierwsze wywołanie <xref:System.Messaging.MessageEnumerator.MoveNext%2A> łączy pierwszy komunikat wyliczenia w widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla parametru limitu czasu jest nieprawidłowa. Może ona reprezentować liczbą ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek, które są specyficzne dla usługi kolejkowania komunikatów.  
  
—lub— 
Upłynął limit czasu.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Usuwanie wiadomości usuwa je z kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie opisane dla tych przeciążeń ma zastosowanie tylko wtedy, gdy <xref:System.Messaging.MessageEnumerator> wystąpienia jest pobierany za pomocą <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>. Nie używaj <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> można pobrać wystąpienia <xref:System.Messaging.MessageEnumerator> jak ta metoda jest przestarzała.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bieżący komunikat z kolejki transakcyjne i nietransakcyjnej i zwraca komunikat do aplikacji wywołującej. Brak limitu czasu określony dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Jeśli chcesz wywołać tego przeciążenia w kolejkę transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczą transakcję wewnętrznego.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa transakcji, w którym komunikat zostanie usunięty.</param>
        <summary>Usuwa bieżący komunikat z kolejki transakcyjne i zwraca komunikat do aplikacji wywołującej. Brak limitu czasu określony dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora, przy użyciu tego kontekstu transakcji wewnętrznej zdefiniowany przez `transaction` parametru.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywanie transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> zwracane do kolejki. Usunięcie jest nieodwracalne, dopóki transakcja została zatwierdzona.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Brak limitu czasu określony dla wiadomości w kolejce.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora, przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywanie transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> zwracane do kolejki. Usunięcie jest nieodwracalne, dopóki transakcja została zatwierdzona.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na komunikat w kolejce.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go natychmiast. W przeciwnym razie metoda czeka określony limit czasu dla nowych wiadomości dostarczenie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, tego przeciążenia metody czeka, aż komunikat jest dostępny lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 Jeśli chcesz wywołać tego przeciążenia w kolejkę transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczą transakcję wewnętrznego.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na komunikat, który ma zostać usunięty.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa kontekst transakcji dla wiadomości.</param>
        <summary>Usuwa bieżący komunikat z kolejki transakcyjne i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go natychmiast. W przeciwnym razie metoda czeka określony limit czasu dla nowych wiadomości dostarczenie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, tego przeciążenia metody czeka, aż komunikat jest dostępny lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywanie transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> zwracane do kolejki. Usunięcie jest nieodwracalne, dopóki transakcja została zatwierdzona.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Interwał czasu oczekiwania na komunikat, który ma zostać usunięty.</param>
        <param name="transactionType">Jedną z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, metoda zwraca go natychmiast. W przeciwnym razie metoda czeka określony limit czasu dla nowych wiadomości dostarczenie.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołujący się pierwszy komunikat dostępnymi w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat wyświetlany u bieżącej lokalizacji kursora, przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. Jeśli kursor znajduje się na końcu kolejki, tego przeciążenia metody czeka, aż komunikat jest dostępny lub interwału określonego przez `timeout` parametru utracił ważność.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli kontekst transakcji zewnętrznego istnieje już dołączone do wątku, który chcesz użyć do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrznego. Można określić `None` Aby komunikat o błędzie z kolejką transakcyjną poza kontekstem transakcji.  
  
 Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopii mają być przechowywane w kolejce dziennika, podobnie jak <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Podczas pracy z kolejek transakcyjnych, wycofywanie transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> zwracane do kolejki. Usunięcie jest nieodwracalne, dopóki transakcja została zatwierdzona.  
  
 Po usunięciu bieżącego komunikatu kursora jest przenoszona do następnego komunikatu. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametr nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje bieżącego modułu wyliczającego, więc wskazuje porównanie kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający można przenosić tylko w kierunku do przodu. Ta metoda zacząć od początku, na początku kolejki.  
  
 Po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A>, kursor wskazuje na pierwszy komunikat. Nie trzeba wywoływać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A> przenieść kursor do przodu do pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Zwraca <see cref="T:System.Messaging.Message" /> odwołujący się komunikat w bieżącym położeniu kursora.</summary>
        <value>A <see cref="T:System.Messaging.Message" /> odwołujący się komunikat w bieżącym położeniu kursora.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2e3490f70119c8c572eb3d2d44434ff7788fc926" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pl-PL" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69382649" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Udostępnia kursor tylko do przodu w celu wyliczenia komunikatów w kolejce komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Służy <xref:System.Messaging.MessageEnumerator> do interakcji dynamicznej z wiadomościami w kolejce. Metody dostępne za pomocą <xref:System.Messaging.MessageQueue> klasy mogą zwracać wynik <xref:System.Messaging.MessageEnumerator> wskazujący dynamiczną listę komunikatów w kolejce lub tablicę zawierającą kopię w danym momencie — migawką kolejki w czasie wywołania określonej metody.  
  
 W przeciwieństwie do migawki statycznej moduł wyliczający umożliwia modyfikowanie kolekcji. Przy użyciu <xref:System.Messaging.MessageEnumerator>, można usunąć komunikaty z kolejki, a zmiana zostanie natychmiast odzwierciedlona w kolejce.  
  
 Moduł wyliczający nie usuwa komunikatów z kolejki, gdy wysyła zapytanie do kolejki. Zwraca informacje o komunikacie w bieżącym położeniu kursora, ale pozostawia komunikat w kolejce.  
  
 A <xref:System.Messaging.MessageEnumerator> jest kursorem, zainicjowany do szefa listy dynamicznej. Kolejność list jest taka sama jak kolejność komunikatów w kolejce, zgodnie z priorytetem wiadomości. Możesz przenieść kursor do pierwszej wiadomości w kolejce przez wywołanie <xref:System.Messaging.MessageEnumerator.MoveNext%2A>. Po zainicjowaniu modułu wyliczającego możesz użyć <xref:System.Messaging.MessageEnumerator.MoveNext%2A> , aby krokowo przekazywać pozostałe komunikaty. Możesz określić, czy poczekać, aż komunikat stanie się dostępny, przekazując do <xref:System.Messaging.MessageEnumerator.MoveNext%2A> metody limit czasu.  
  
 Ponieważ moduł wyliczający jest dynamiczny, komunikat, który jest dołączany poza bieżącą pozycją kursora (na przykład ze względu na niski priorytet), może być dostępny przez moduł wyliczający. Nie można uzyskać dostępu do komunikatu wstawionego przed bieżącą pozycją kursora. Nie można przejść do tyłu <xref:System.Messaging.MessageEnumerator>. Kursor umożliwia przemieszczenie tylko do przodu. <xref:System.Messaging.MessageEnumerator.Reset%2A> Metoda umożliwia umieszczenie kursora z powrotem na początku kolejki.  
  
 <xref:System.Messaging.MessageEnumerator> Wystąpienia dla danej kolejki działają niezależnie. Można utworzyć dwa <xref:System.Messaging.MessageEnumerator> wystąpienia, które mają zastosowanie do tej samej kolejki. Zmiany <xref:System.Messaging.MessageEnumerator> wprowadzane do komunikatów w kolejce zostaną natychmiast odzwierciedlone w drugim wyliczeniu, jeśli drugi moduł wyliczający jest umieszczony przed pierwszym. Jeśli jednak dwa moduły wyliczające mają tę samą pozycję, a jeden z nich usunie komunikat w tym miejscu, zostanie zgłoszony wyjątek, jeśli inny moduł wyliczający spróbuje pobrać wartość <xref:System.Messaging.MessageEnumerator.Current%2A> właściwości w wiadomości teraz usuniętej.  
  
> [!NOTE]
>  Jeśli utworzysz wystąpienie <xref:System.Messaging.MessageQueue> <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> o wartości ustawiony na `true`, żadna inna aplikacja nie będzie mogła modyfikować komunikatów w module wyliczającym, gdy masz połączenie z kolejką.  
  
   
  
## Examples  
 Poniższy przykład pobiera dynamiczną listę komunikatów w kolejce i zlicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> właściwością ustawioną na. <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby skojarzone z modułem wyliczającym.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 System operacyjny zachowuje otwarte dojście do kolejki w czasie trwania kursora. Po zakończeniu pracy z modułem wyliczającym Wywołaj metodę <xref:System.Messaging.MessageEnumerator.Close%2A> zwolnienia zasobów skojarzonych z dojściem.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera bieżącą <see cref="T:System.Messaging.Message" /> , do której wskazuje ten moduł wyliczający.</summary>
        <value>Bieżący komunikat.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po utworzeniu modułu wyliczającego wskazuje on nagłówek kolejki w lokalizacji przed pierwszą wiadomością. W tym przypadku jest <xref:System.Messaging.MessageEnumerator.Current%2A> nieprawidłowa i zgłosi wyjątek, jeśli jest dostępny. Musisz wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> , aby umieścić kursor na pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Wywołano <see cref="P:System.Messaging.MessageEnumerator.Current" /> przed pierwszym wywołaniem do <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Kursor znajduje się przed pierwszym elementem wyliczenia komunikatów.  
  
—lub— 
Wywołano <see cref="P:System.Messaging.MessageEnumerator.Current" /> po <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> wywołaniu zwróconego <see langword="false" /> (wskazujące, że kursor znajduje się po ostatnim elemencie wyliczenia wiadomości).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat, który jest obecnie wskazywany przez moduł wyliczający, już nie istnieje. Mógł zostać usunięty.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera natywne dojście kursora usługi kolejkowania komunikatów używane do przeglądania komunikatów w kolejce.</summary>
        <value>Natywny uchwyt kursora.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta właściwość zawiera natywne dojście do wyliczenia. Po zakończeniu pracy z modułem wyliczającym Wywołaj <xref:System.Messaging.MessageEnumerator.Close%2A> polecenie Zwolnij ten zasób.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Dojście nie istnieje.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwalnia zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />program.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />program.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Messaging.MessageEnumerator.Dispose%2A> zezwala na przydzielenie zasobów używanych <xref:System.Messaging.MessageEnumerator> przez program do innych celów. Aby uzyskać więcej informacji <xref:System.Messaging.MessageEnumerator.Dispose%2A>na temat, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> do zwolnienia tylko zasobów niezarządzanych.</param>
        <summary>Zwalnia niezarządzane zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" /> program i opcjonalnie zwalnia zarządzane zasoby.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wywoływana przez metodę publiczną <xref:System.Messaging.MessageEnumerator.Dispose%2A> <xref:System.Object.Finalize%2A> i metodę. `Dispose()`wywołuje metodę chronioną `Dispose(Boolean)` `disposing` z parametrem ustawionym `true`na. <xref:System.Object.Finalize%2A>wywołuje `Dispose` `false`z `disposing` ustawionym na.  
  
 Gdy parametr ma wartość `true`, ta metoda zwalnia wszystkie zasoby przechowywane przez wszystkie obiekty zarządzane, do <xref:System.Messaging.MessageEnumerator> których odwołują się te odwołania. `disposing` Ta metoda wywołuje `Dispose()` metodę każdego przywoływanego obiektu.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" />może być wywoływana wiele razy przez inne obiekty. Podczas zastępowania <see langword="Dispose(Boolean)" />należy zachować ostrożność, aby nie odwoływać się do obiektów, które zostały wcześniej usunięte <see langword="Dispose" />w ramach wcześniejszego wywołania do. Aby uzyskać więcej informacji na temat sposobu <see langword="Dispose" />implementacji, zobacz [implementowanie metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Aby uzyskać więcej informacji <see langword="Dispose" /> na <see langword="Finalize" />temat i, zobacz [Oczyszczanie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [Zastępowanie metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md">Implementowanie metody Dispose</related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md">Oczyszczanie zasobów niezarządzanych</related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia zasoby przechowywane przez moduł wyliczający.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Ta metoda przesłania <xref:System.Object.Finalize>. Kod aplikacji nie powinien wywoływać tej metody; Metoda Finalize obiektu jest automatycznie wywoływana podczas wyrzucania elementów bezużytecznych, chyba że finalizacja przez moduł wyrzucania elementów bezużytecznych <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> została wyłączona przez wywołanie metody.

Aby uzyskać więcej informacji, zobacz [finalizowanie metod i destruktorów](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), Oczyszczanie zasobów niezarządzanych i zastępowanie [metody Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)). [](~/docs/standard/garbage-collection/unmanaged.md)

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Przesuwa moduł wyliczający do następnej wiadomości w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Przesuwa moduł wyliczający do następnej wiadomości w kolejce, jeśli jest ona obecnie dostępna.</summary>
        <returns><see langword="true" />Jeśli moduł wyliczający został pomyślnie zaawansowana do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie zwraca natychmiast, jeśli w kolejce nie ma komunikatu. Istnieje inne Przeciążenie, które oczekuje na nadejście określonego <xref:System.TimeSpan> komunikatu.  
  
 Jeśli komunikat nie jest obecnie dostępny, ponieważ kolejka jest pusta lub przeniesiono poza ostatni element w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> wraca `false` do metody wywołującej.  
  
 Po utworzeniu moduł wyliczający jest koncepcyjnie pozycjonowany przed pierwszym komunikatem kolejki, a pierwsze wywołanie, aby <xref:System.Messaging.MessageEnumerator.MoveNext%2A> przywrócić pierwszy komunikat kolejki do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek specyficzny dla usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><see cref="T:System.TimeSpan" /> Czas oczekiwania na udostępnienie komunikatu, jeśli moduł wyliczający jest umieszczony na końcu kolejki.</param>
        <summary>Przesuwa moduł wyliczający do następnej wiadomości w kolejce. Jeśli moduł wyliczający jest umieszczony na końcu kolejki, czeka, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> aż wiadomość zostanie udostępniona lub upłynie limit czasu.</summary>
        <returns><see langword="true" />Jeśli moduł wyliczający został pomyślnie zaawansowani do następnej wiadomości; Jeśli moduł wyliczający osiągnął koniec kolejki, a komunikat nie stanie się dostępny w czasie określonym <paramref name="timeout" /> przez parametr. <see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To Przeciążenie oczekuje, że w kolejce nie ma komunikatu lub jeśli kursor osiągnął koniec kolejki. Jeśli komunikat nie jest obecnie dostępny, ponieważ kolejka jest pusta lub przeniesiono poza ostatni element w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> czeka na określony limit czasu.  
  
 Jeśli kursor znajduje się już na końcu kolejki, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca `true` tylko wtedy, gdy nowy komunikat dociera do określonego interwału czasu, ma niższy priorytet niż wszystkie komunikaty w kolejce i są umieszczane na końcu kolejki. Przeciążenie bez parametru zwraca wartość natychmiast, jeśli w kolejce nie ma dalszych komunikatów.  
  
 Po utworzeniu moduł wyliczający jest koncepcyjnie pozycjonowany przed pierwszym komunikatem wyliczenia, a pierwsze wywołanie, aby <xref:System.Messaging.MessageEnumerator.MoveNext%2A> przywrócić pierwszy komunikat wyliczenia do widoku.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla parametru timeout jest nieprawidłowa. Może reprezentować liczbę ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Zgłoszono wyjątek specyficzny dla usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Upłynął limit czasu.</exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Usunięcie wiadomości spowoduje usunięcie jej z kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zachowanie opisane dla tych przeciążeń ma zastosowanie tylko wtedy <xref:System.Messaging.MessageEnumerator> , gdy wystąpienie jest pobierane przy <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>użyciu. Nie należy używać <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> do pobierania <xref:System.Messaging.MessageEnumerator> wystąpienia, ponieważ ta metoda jest przestarzała.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa bieżącą wiadomość z kolejki transakcyjnej lub nietransakcyjnej oraz zwraca komunikat do aplikacji wywołującej. Nie określono limitu czasu dla wiadomości, która ma zostać dostarczona do kolejki.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 W przypadku wywołania tego przeciążenia w kolejce transakcyjnej usługa kolejkowania komunikatów tworzy pojedynczą transakcję wewnętrzną.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa transakcję, w której zostanie usunięty komunikat.</param>
        <summary>Usuwa bieżącą wiadomość z kolejki transakcyjnej i zwraca komunikat do aplikacji wywołującej. Nie określono limitu czasu dla wiadomości, która ma zostać dostarczona do kolejki.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora przy użyciu wewnętrznego kontekstu transakcji zdefiniowanego przez `transaction` parametr.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Podczas pracy z kolejkami transakcyjnymi wycofywanie transakcji powoduje zwrócenie wszelkich komunikatów usuniętych przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> do kolejki. Usunięcie nie jest nieodwracalne, dopóki transakcja nie zostanie zatwierdzona.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Nie określono limitu czasu dla wiadomości, która ma zostać dostarczona do kolejki.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Podczas pracy z kolejkami transakcyjnymi wycofywanie transakcji powoduje zwrócenie wszelkich komunikatów usuniętych przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> do kolejki. Usunięcie nie jest nieodwracalne, dopóki transakcja nie zostanie zatwierdzona.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Przedział czasu oczekiwania na nadejście komunikatu w kolejce.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, Metoda natychmiast zwróci ją. W przeciwnym razie metoda czeka określony limit czasu na nadejście nowej wiadomości.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, to Przeciążenie metody będzie oczekiwać do momentu udostępnienia komunikatu lub interwału określonego przez `timeout` parametr.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 W przypadku wywołania tego przeciążenia w kolejce transakcyjnej usługa kolejkowania komunikatów tworzy pojedynczą transakcję wewnętrzną.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Przedział czasu oczekiwania na usunięcie wiadomości.</param>
        <param name="transaction"><see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa kontekst transakcji dla wiadomości.</param>
        <summary>Usuwa bieżącą wiadomość z kolejki transakcyjnej i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, Metoda natychmiast zwróci ją. W przeciwnym razie metoda czeka określony limit czasu na nadejście nowej wiadomości.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora. Jeśli kursor znajduje się na końcu kolejki, to Przeciążenie metody będzie oczekiwać do momentu udostępnienia komunikatu lub interwału określonego przez `timeout` parametr.  
  
 Podczas pracy z kolejkami transakcyjnymi wycofywanie transakcji powoduje zwrócenie wszelkich komunikatów usuniętych przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> do kolejki. Usunięcie nie jest nieodwracalne, dopóki transakcja nie zostanie zatwierdzona.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.ArgumentNullException">Parametr ma wartość <see langword="null" />. <paramref name="transaction" /></exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Przedział czasu oczekiwania na usunięcie wiadomości.</param>
        <param name="transactionType">Jedna z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisująca typ kontekstu transakcji, który ma zostać skojarzony z wiadomością.</param>
        <summary>Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej. Jeśli istnieje komunikat do usunięcia, Metoda natychmiast zwróci ją. W przeciwnym razie metoda czeka określony limit czasu na nadejście nowej wiadomości.</summary>
        <returns><see cref="T:System.Messaging.Message" /> , Który odwołuje się do pierwszego komunikatu dostępnego w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>usuwa i zwraca komunikat w bieżącej lokalizacji kursora przy użyciu kontekstu transakcji zdefiniowanego przez `transactionType` parametr. Jeśli kursor znajduje się na końcu kolejki, to Przeciążenie metody będzie oczekiwać do momentu udostępnienia komunikatu lub interwału określonego przez `timeout` parametr.  
  
 `Automatic` Określ`transactionType` dla parametru, jeśli istnieje już zewnętrzny kontekst transakcji dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` , czy chcesz otrzymywać komunikat jako pojedynczą transakcję wewnętrzną. Możesz określić `None` , czy chcesz otrzymywać komunikat z kolejki transakcyjnej poza kontekstem transakcji.  
  
 W przypadku korzystania z funkcji rejestrowania w kolejce usunięcie komunikatu powoduje, że kopia zostanie zachowana w kolejce dziennika, tak jak w <xref:System.Messaging.MessageQueue> przypadku <xref:System.Messaging.MessageQueue.Receive%2A> metody klasy.  
  
 Podczas pracy z kolejkami transakcyjnymi wycofywanie transakcji powoduje zwrócenie wszelkich komunikatów usuniętych przez wywołanie <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> do kolejki. Usunięcie nie jest nieodwracalne, dopóki transakcja nie zostanie zatwierdzona.  
  
 Po usunięciu bieżącej wiadomości kursor zostanie przeniesiony do następnego komunikatu. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu. <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametru jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Upłynął limit czasu.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Parametr nie jest jednym <see cref="T:System.Messaging.MessageQueueTransactionType" /> z elementów członkowskich. <paramref name="transactionType" /></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje bieżący moduł wyliczający, aby wskazywał na nagłówek kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Moduł wyliczający można przenieść tylko w kierunku do przodu. Użyj tej metody, aby zacząć od początku kolejki.  
  
 Po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A>kursor wskazuje pierwszy komunikat. Nie ma potrzeby wywoływania <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A> kursora do pierwszej wiadomości w kolejce.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Messaging.Message" /> Zwraca odwołanie odwołujące się do komunikatu w bieżącym położeniu kursora.</summary>
        <value>Obiekt <see cref="T:System.Messaging.Message" /> , który odwołuje się do komunikatu w bieżącym położeniu kursora.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Uzyskano dostęp do tej właściwości przed pierwszym wywołaniem do <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />. Kursor znajduje się przed pierwszym elementem wyliczenia komunikatów.-lub — uzyskano dostęp do tej właściwości po wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> zwraca wartość false (wskazującą, że kursor znajduje się po ostatnim elemencie wyliczenia wiadomości).</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat, który jest obecnie wskazywany przez moduł wyliczający, już nie istnieje. Mógł zostać usunięty.</exception>
      </Docs>
    </Member>
  </Members>
</Type>

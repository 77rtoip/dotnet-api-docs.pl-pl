<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6a3039a11d941cd3db611cb997eb17835525e4da" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="d431f-101">Zawiera tylko do przodu kursora do sortowania wiadomości z kolejki wiadomości.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d431f-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-102">Użyj <xref:System.Messaging.MessageEnumerator> dynamiczne interakcji z wiadomości w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="d431f-103">Dostępne za pośrednictwem metody <xref:System.Messaging.MessageQueue> klasy mogą zwracać <xref:System.Messaging.MessageEnumerator> wskazuje dynamiczną listę wiadomości w kolejce lub tablicę, która zawiera kopię w danej chwili - migawki - kolejki w czasie określonej metody została wywołana.</span><span class="sxs-lookup"><span data-stu-id="d431f-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="d431f-104">W odróżnieniu od statycznej migawki moduł wyliczający umożliwia modyfikowanie kolekcji.</span><span class="sxs-lookup"><span data-stu-id="d431f-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="d431f-105">Przy użyciu <xref:System.Messaging.MessageEnumerator>, można usunąć wiadomości z kolejki i natychmiast znajduje odzwierciedlenie w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="d431f-106">Moduł wyliczający nie powoduje usunięcia wiadomości z kolejki, gdy wysyła zapytanie kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="d431f-107">Zwraca informacje o komunikacie w bieżącym położeniu kursora, ale pozostawia wiadomości w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="d431f-108">A <xref:System.Messaging.MessageEnumerator> jest kursor, zainicjować nagłówek listy dynamicznych.</span><span class="sxs-lookup"><span data-stu-id="d431f-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="d431f-109">Na liście jest taka sama jak kolejność wiadomości w kolejce, zgodnie z priorytet wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="d431f-110">Kursor można przenieść do pierwszej wiadomości w kolejce przez wywołanie metody <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="d431f-111">Po zainicjowaniu modułu wyliczającego można użyć <xref:System.Messaging.MessageEnumerator.MoveNext%2A> do krok do przodu w pozostałych wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="d431f-112">Można określić, czy oczekiwania na udostępnienie przez przekazanie przekroczenie limitu czasu w wiadomości <xref:System.Messaging.MessageEnumerator.MoveNext%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="d431f-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="d431f-113">Ponieważ moduł wyliczający jest dynamiczny, komunikat, który jest dołączany poza bieżącej pozycji kursora (na przykład ze względu na niski priorytet), są dostępne przez moduł wyliczający.</span><span class="sxs-lookup"><span data-stu-id="d431f-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="d431f-114">Komunikat, który zostanie wstawiony przed nie można uzyskać dostępu do bieżącego położenia kursora.</span><span class="sxs-lookup"><span data-stu-id="d431f-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="d431f-115">Nie jest możliwe krok wstecz z <xref:System.Messaging.MessageEnumerator>.</span><span class="sxs-lookup"><span data-stu-id="d431f-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="d431f-116">Kursor umożliwia przenoszenie tylko do przodu.</span><span class="sxs-lookup"><span data-stu-id="d431f-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="d431f-117"><xref:System.Messaging.MessageEnumerator.Reset%2A> Metoda umożliwia umieść kursor wstecz na początek kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="d431f-118">Wystąpienia <xref:System.Messaging.MessageEnumerator> do danej kolejki działać niezależnie.</span><span class="sxs-lookup"><span data-stu-id="d431f-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="d431f-119">Należy utworzyć dwa <xref:System.Messaging.MessageEnumerator> wystąpień, które mają zastosowanie do tej samej kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="d431f-120">Zmiany jednym <xref:System.Messaging.MessageEnumerator> sprawia, że do wiadomości w kolejce zostaną natychmiast odzwierciedlone w drugim modułu wyliczającego Jeśli drugi moduł wyliczający jest ustawiony przed pierwszym krokiem.</span><span class="sxs-lookup"><span data-stu-id="d431f-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="d431f-121">Jednak jeśli dwa moduły wyliczające mieć to samo położenie i jeden z nich usuwa komunikat na tej pozycji, jest zwracany wyjątek, jeśli inne modułu wyliczającego próbuje pobrać wartość <xref:System.Messaging.MessageEnumerator.Current%2A> właściwości wiadomości usunięty teraz.</span><span class="sxs-lookup"><span data-stu-id="d431f-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d431f-122">W przypadku utworzenia wystąpienia <xref:System.Messaging.MessageQueue> z <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> ustawioną `true`, żadna inna aplikacja nie mogą modyfikować wiadomości w sieci modułu wyliczającego, gdy masz połączenie z kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d431f-123">W poniższym przykładzie pobiera dynamiczną listę komunikatów z kolejki i oblicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> ustawioną właściwość <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d431f-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d431f-124">Zwalnia zasoby skojarzone z modułu wyliczającego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-124">Frees the resources associated with the enumerator.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-125">System operacyjny zachowuje otwarte dojście do kolejki przez cały okres istnienia kursora.</span><span class="sxs-lookup"><span data-stu-id="d431f-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="d431f-126">Po zakończeniu pracy z modułu wyliczającego wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> aby zwolnić zasoby skojarzone z dojścia.</span><span class="sxs-lookup"><span data-stu-id="d431f-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-127">Pobiera bieżący <see cref="T:System.Messaging.Message" /> wskazuje dla tego modułu wyliczającego.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d431f-128">Bieżący komunikat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-128">The current message.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-129">Po utworzeniu modułu wyliczającego wskazuje head kolejki, w miejscu przed pierwszą wiadomością.</span><span class="sxs-lookup"><span data-stu-id="d431f-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="d431f-130">W takim przypadku <xref:System.Messaging.MessageEnumerator.Current%2A> nie jest prawidłowy i zgłosi wyjątek, jeśli jest on dostępny.</span><span class="sxs-lookup"><span data-stu-id="d431f-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="d431f-131">Należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aby umieść kursor wglądu do pierwszej wiadomości w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d431f-132">Należy wywołać <see cref="P:System.Messaging.MessageEnumerator.Current" /> przed pierwszym wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span>
          </span>
          <span data-ttu-id="d431f-133">Kursor znajduje się przed pierwszym elementem wyliczenia wiadomości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-133">The cursor is located before the first element of the message enumeration.</span>
          </span>
          <span data-ttu-id="d431f-134">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-134">-or-</span>
          </span>
          <span data-ttu-id="d431f-135">Należy wywołać <see cref="P:System.Messaging.MessageEnumerator.Current" /> po wywołaniu <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> zwrócił <see langword="false" /> (wskazująca, gdy kursor znajduje się za ostatnim elementem wyliczenia komunikat.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-136">Komunikat, który moduł wyliczający aktualnie wskazuje już istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-136">The message the enumerator is currently pointing to no longer exists.</span>
          </span>
          <span data-ttu-id="d431f-137">Być może został usunięty.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-137">It might have been deleted.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-138">Pobiera usługę kolejkowania komunikatów kursora uchwyt macierzysty używany do przeglądania wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d431f-139">Uchwyt macierzysty kursora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-139">The native cursor handle.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-140">Ta właściwość zawiera uchwyt macierzysty do wyliczenia.</span><span class="sxs-lookup"><span data-stu-id="d431f-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="d431f-141">Po zakończeniu pracy z modułu wyliczającego wywołać <xref:System.Messaging.MessageEnumerator.Close%2A> zwolnienia tego zasobu.</span><span class="sxs-lookup"><span data-stu-id="d431f-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-142">Dojście nie istnieje.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-142">The handle does not exist.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-143">Zwalnia zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d431f-144">Zwalnia wszelkie zasoby używane przez <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-145">Wywoływanie <xref:System.Messaging.MessageEnumerator.Dispose%2A> umożliwia zasoby używane przez <xref:System.Messaging.MessageEnumerator> odbiorczego do innych celów.</span><span class="sxs-lookup"><span data-stu-id="d431f-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="d431f-146">Aby uzyskać więcej informacji na temat <xref:System.Messaging.MessageEnumerator.Dispose%2A>, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="d431f-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <span data-ttu-id="d431f-147">
            <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-147">
              <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-148">Zwalnia zasoby niezarządzane używane przez <see cref="T:System.Messaging.MessageEnumerator" /> i opcjonalnie zwalnia zasoby zarządzane.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-148">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-149">Ta metoda jest wywoływana przez metodę publiczną <xref:System.Messaging.MessageEnumerator.Dispose%2A> — metoda i <xref:System.Object.Finalize%2A> metody.</span><span class="sxs-lookup"><span data-stu-id="d431f-149">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="d431f-150">`Dispose()` wywołuje chronioną metodę `Dispose(Boolean)` metody z `disposing` ustawiono parametr `true`.</span><span class="sxs-lookup"><span data-stu-id="d431f-150">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="d431f-151"><xref:System.Object.Finalize%2A> wywołuje `Dispose` z `disposing` ustawioną `false`.</span><span class="sxs-lookup"><span data-stu-id="d431f-151"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="d431f-152">Gdy `disposing` parametr jest `true`, ta metoda zwalnia wszystkie zasoby zajmowane przez wszelkie obiekty zarządzane przez to <xref:System.Messaging.MessageEnumerator> odwołania.</span><span class="sxs-lookup"><span data-stu-id="d431f-152">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="d431f-153">Ta metoda wywołuje `Dispose()` metody każdego odwołuje się do obiektu.</span><span class="sxs-lookup"><span data-stu-id="d431f-153">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d431f-154">
              <see langword="Dispose" /> można wywoływać wielokrotnie przez inne obiekty.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d431f-154">
                <see langword="Dispose" /> can be called multiple times by other objects.</span>
            </span>
            <span data-ttu-id="d431f-155">W przypadku przesłaniania <see langword="Dispose(Boolean)" />, nie odwołują się obiekty, które zostały wcześniej zlikwidowane w wywołaniu wcześniejszych <see langword="Dispose" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d431f-155">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span>
            </span>
            <span data-ttu-id="d431f-156">Aby uzyskać więcej informacji na temat sposobu wdrażania <see langword="Dispose" />, zobacz [implementacja metody Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            <span class="sxs-lookup">
              <span data-stu-id="d431f-156">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span>
            </span>
            <span data-ttu-id="d431f-157">Aby uzyskać więcej informacji na temat <see langword="Dispose" /> i <see langword="Finalize" />, zobacz [czyszczenie zasobów niezarządzanych](~/docs/standard/garbage-collection/unmanaged.md) i [przesłaniania metody Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span>
            <span class="sxs-lookup">
              <span data-stu-id="d431f-157">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-158">Moduł wyliczający należy przechodzi do następnej wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-158">Advances the enumerator to the next message in the queue.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d431f-159">Przechodzi do następnej wiadomości w kolejce modułu wyliczającego, jeśli jest obecnie dostępny.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-159">Advances the enumerator to the next message in the queue, if one is currently available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-160">
            <see langword="true" /> Jeśli moduł wyliczający został pomyślnie zaawansowane do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-160">
              <see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-161">To przeciążenie zwraca natychmiast, jeśli nie ma w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-161">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="d431f-162">Brak innego przeciążenia, które oczekuje określonej <xref:System.TimeSpan> na odbierane wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-162">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="d431f-163">Jeśli wiadomość nie jest obecnie dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca `false` do wywoływania metody.</span><span class="sxs-lookup"><span data-stu-id="d431f-163">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="d431f-164">Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomość z kolejki i w pierwszym wywołaniu <xref:System.Messaging.MessageEnumerator.MoveNext%2A> powoduje przeniesienie pierwszą wiadomość z kolejki do widoku.</span><span class="sxs-lookup"><span data-stu-id="d431f-164">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-165">Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-165">An exception specific to Message Queuing was thrown.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="d431f-166">
            <see cref="T:System.TimeSpan" /> Oczekiwania na jest dostępny, gdy moduł wyliczający jest umieszczony na końcu kolejki wiadomości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-166">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-167">Moduł wyliczający należy przechodzi do następnej wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-167">Advances the enumerator to the next message in the queue.</span>
          </span>
          <span data-ttu-id="d431f-168">Jeśli moduł wyliczający jest umieszczony na końcu kolejki <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> czeka, aż wiadomości jest dostępna lub danego limitu czasu wygaśnięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-168">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-169">
            <see langword="true" /> Jeśli moduł wyliczający pomyślnie poprawionym do następnej wiadomości; <see langword="false" /> Jeśli moduł wyliczający osiągnął koniec kolejki wiadomości nie są dostępne w czasie określonym przez <paramref name="timeout" /> parametru.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-169">
              <see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-170">To przeciążenie czeka, jeśli nie ma w kolejce lub kursor osiągnął koniec kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-170">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="d431f-171">Jeśli wiadomość nie jest obecnie dostępna, ponieważ kolejka jest pusta lub został przeniesiony poza ostatniego elementu w kolekcji, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> określony limit czasu oczekiwania.</span><span class="sxs-lookup"><span data-stu-id="d431f-171">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="d431f-172">Jeśli kursor znajduje się już na końcu kolejki <xref:System.Messaging.MessageEnumerator.MoveNext%2A> zwraca tylko `true` Jeśli nowy komunikat w określonym czasie, aktualnie ma niższy priorytet niż wszystkie wiadomości w kolejce i znajduje się na końcu kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-172">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="d431f-173">Przeciążenia z parametrem nie zwraca natychmiast, jeżeli w kolejce znajdują się dalsze komunikaty.</span><span class="sxs-lookup"><span data-stu-id="d431f-173">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="d431f-174">Po utworzeniu, moduł wyliczający jest koncepcyjnie umieszczony przed pierwszą wiadomością wyliczenia i w pierwszym wywołaniu <xref:System.Messaging.MessageEnumerator.MoveNext%2A> przełącza pierwszą wiadomością wyliczenie do widoku.</span><span class="sxs-lookup"><span data-stu-id="d431f-174">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d431f-175">Wartość określona dla parametru limitu czasu jest nieprawidłowa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-175">The value specified for the timeout parameter is invalid.</span>
          </span>
          <span data-ttu-id="d431f-176">Ten element reprezentuje może być liczbą ujemną.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-176">It might represent a negative number.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-177">Zgłoszono wyjątek specyficzne dla usługi kolejkowania komunikatów.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-177">An exception specific to Message Queuing was thrown.</span>
          </span>
          <span data-ttu-id="d431f-178">—lub—</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-178">-or-</span>
          </span>
          <span data-ttu-id="d431f-179">Upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-179">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-180">Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-180">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-181">Usuwając wiadomość usuwa ją z kolejki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-181">Removing the message deletes it from the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-182">Zachowanie opisane dla tych overloads ma zastosowanie tylko wtedy, gdy <xref:System.Messaging.MessageEnumerator> wystąpienia są pobierane przy użyciu <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-182">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="d431f-183">Nie używaj <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> można pobrać wystąpienia <xref:System.Messaging.MessageEnumerator> jak ta metoda jest przestarzała.</span><span class="sxs-lookup"><span data-stu-id="d431f-183">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d431f-184">Usuwa bieżący komunikat z kolejki transakcyjnej lub nietransakcyjna i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-184">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-185">Nie ma limitu czasu określona dla wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-185">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-186">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-186">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-187"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.</span><span class="sxs-lookup"><span data-stu-id="d431f-187"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="d431f-188">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-188">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-189">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-189">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-190">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-190">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="d431f-191">Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję.</span><span class="sxs-lookup"><span data-stu-id="d431f-191">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <span data-ttu-id="d431f-192">
            <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa transakcji, w którym zostaną usunięte wiadomości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-192">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-193">Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-193">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-194">Nie ma limitu czasu określona dla wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-194">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-195">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-195">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-196"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru.</span><span class="sxs-lookup"><span data-stu-id="d431f-196"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="d431f-197">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-197">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-198">Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-198">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="d431f-199">Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.</span><span class="sxs-lookup"><span data-stu-id="d431f-199">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="d431f-200">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-200">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-201">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-201">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d431f-202">
            <paramref name="transaction" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-202">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">
          <span data-ttu-id="d431f-203">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-203">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-204">Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-204">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-205">Nie ma limitu czasu określona dla wiadomości w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-205">There is no timeout specified for a message to arrive in the queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-206">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-206">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-207"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru.</span><span class="sxs-lookup"><span data-stu-id="d431f-207"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="d431f-208">Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-208">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="d431f-209">Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna.</span><span class="sxs-lookup"><span data-stu-id="d431f-209">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="d431f-210">Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.</span><span class="sxs-lookup"><span data-stu-id="d431f-210">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="d431f-211">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-211">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-212">Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-212">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="d431f-213">Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.</span><span class="sxs-lookup"><span data-stu-id="d431f-213">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="d431f-214">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-214">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-215">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-215">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="d431f-216">
            <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-216">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="d431f-217">Interwał czasu oczekiwania na wiadomość w kolejce.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-217">The interval of time to wait for a message to arrive in the queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-218">Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-218">Removes the current message from the queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-219">Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-219">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="d431f-220">W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-220">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-221">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-221">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-222"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.</span><span class="sxs-lookup"><span data-stu-id="d431f-222"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="d431f-223">Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.</span><span class="sxs-lookup"><span data-stu-id="d431f-223">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="d431f-224">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-224">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-225">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-225">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-226">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-226">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="d431f-227">Można wywołać tego przeciążenia na kolejką transakcyjną, usługi kolejkowania komunikatów tworzy pojedynczy wewnętrzną transakcję.</span><span class="sxs-lookup"><span data-stu-id="d431f-227">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d431f-228">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-228">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-229">Upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-229">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="d431f-230">Interwał czasu oczekiwania na wiadomość do usunięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-230">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transaction">
          <span data-ttu-id="d431f-231">
            <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiekt, który określa kontekst transakcji dla wiadomości.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-231">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-232">Usuwa bieżący komunikat z kolejką transakcyjną i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-232">Removes the current message from a transactional queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-233">Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-233">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="d431f-234">W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-234">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-235">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-235">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-236"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora.</span><span class="sxs-lookup"><span data-stu-id="d431f-236"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="d431f-237">Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.</span><span class="sxs-lookup"><span data-stu-id="d431f-237">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="d431f-238">Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-238">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="d431f-239">Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.</span><span class="sxs-lookup"><span data-stu-id="d431f-239">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="d431f-240">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-240">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-241">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-241">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-242">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-242">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d431f-243">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-243">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d431f-244">
            <paramref name="transaction" /> Parametr jest <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-244">The <paramref name="transaction" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-245">Upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-245">The timeout has expired.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="d431f-246">Interwał czasu oczekiwania na wiadomość do usunięcia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-246">The interval of time to wait for the message to be removed.</span>
          </span>
        </param>
        <param name="transactionType">
          <span data-ttu-id="d431f-247">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-247">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d431f-248">Usuwa bieżący komunikat z kolejki i zwraca komunikat do aplikacji wywołującej.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-248">Removes the current message from a queue and returns the message to the calling application.</span>
          </span>
          <span data-ttu-id="d431f-249">Jeśli istnieje komunikat do usunięcia, metoda zwraca go bezpośrednio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-249">If there is a message to remove, the method returns it immediately.</span>
          </span>
          <span data-ttu-id="d431f-250">W przeciwnym razie metoda oczekuje określony limit czasu dla nowej wiadomości do odbierania.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-250">Otherwise, the method waits the specified timeout for a new message to arrive.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d431f-251">A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-251">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-252"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Usuwa i zwraca komunikat w bieżącej lokalizacji kursora, w kontekście transakcji zdefiniowanych przez `transactionType` parametru.</span><span class="sxs-lookup"><span data-stu-id="d431f-252"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="d431f-253">Jeśli kursor znajduje się na końcu kolejki, to przeciążenie metody czeka, aż wiadomości jest dostępna lub interwału określonego przez `timeout` parametru utracił ważność.</span><span class="sxs-lookup"><span data-stu-id="d431f-253">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="d431f-254">Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-254">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="d431f-255">Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna.</span><span class="sxs-lookup"><span data-stu-id="d431f-255">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="d431f-256">Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.</span><span class="sxs-lookup"><span data-stu-id="d431f-256">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="d431f-257">Jeśli używasz rejestrowanie kolejki usuwając wiadomość powoduje, że kopia mają być przechowywane w kolejce dziennika, tak jak w przypadku <xref:System.Messaging.MessageQueue> klasy <xref:System.Messaging.MessageQueue.Receive%2A> metoda wykonuje.</span><span class="sxs-lookup"><span data-stu-id="d431f-257">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="d431f-258">Podczas pracy z kolejek transakcyjnych, wycofywania transakcji powoduje, że wszystkie komunikaty usunięte przez wywołanie do <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> ma zostać zwrócona do kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-258">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="d431f-259">Usuwanie nie jest nieodwracalne, dopóki transakcja została przekazana.</span><span class="sxs-lookup"><span data-stu-id="d431f-259">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="d431f-260">Po usunięciu bieżącego komunikatu, kursor jest przenoszony do następnej wiadomości.</span><span class="sxs-lookup"><span data-stu-id="d431f-260">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="d431f-261">Nie trzeba wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="d431f-261">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d431f-262">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-262">The value specified for the <paramref name="timeout" /> parameter is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <span data-ttu-id="d431f-263">Upłynął limit czasu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-263">The timeout has expired.</span>
          </span>
        </exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <span data-ttu-id="d431f-264">
            <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-264">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span>
          </span>
        </exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d431f-265">Resetuje bieżącego modułu wyliczającego, więc wskazuje head kolejki.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-265">Resets the current enumerator so it points to the head of the queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d431f-266">Moduł wyliczający można przenieść tylko w kierunku do przodu.</span><span class="sxs-lookup"><span data-stu-id="d431f-266">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="d431f-267">Użyj tej metody, aby rozpocząć od początku na początek kolejki.</span><span class="sxs-lookup"><span data-stu-id="d431f-267">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="d431f-268">Po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A>, kursor wskazuje pierwszego komunikatu.</span><span class="sxs-lookup"><span data-stu-id="d431f-268">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="d431f-269">Nie należy wywołać <xref:System.Messaging.MessageEnumerator.MoveNext%2A> po wywołaniu <xref:System.Messaging.MessageEnumerator.Reset%2A> Aby przesunąć kursor do przodu do pierwszej wiadomości w kolejce.</span><span class="sxs-lookup"><span data-stu-id="d431f-269">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IEnumerator.Current { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d431f-270">Zwraca <see cref="T:System.Messaging.Message" /> , która odwołuje się komunikat w bieżącym położeniu kursora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-270">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d431f-271">A <see cref="T:System.Messaging.Message" /> , która odwołuje się komunikat w bieżącym położeniu kursora.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d431f-271">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
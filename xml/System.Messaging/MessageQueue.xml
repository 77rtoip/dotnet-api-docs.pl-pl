<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f362dd97709b65574ff7b9474682818d0cb2c4b1" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="MT" />
    <Meta Name="ms.contentlocale" Value="pl-PL" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
    <Meta Name="ms.locfileid" Value="32038297" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageQueue&#xA;Inherits Component&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageQueue : System::ComponentModel::Component, System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Zapewnia dostęp do kolejki na serwerze usługi kolejkowania komunikatów.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Technologia usługi kolejkowania komunikatów umożliwia aplikacje uruchamiane o różnych porach komunikują się za pośrednictwem heterogenicznych sieci i systemów, które mogą być tymczasowo w trybie offline. Aplikacje będą wysyłać, odbieranie i wybieranie (odczytywanie bez usuwania) wiadomości z kolejki. Usługa kolejkowania komunikatów jest opcjonalnym składnikiem [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] i Windows NT i należy zainstalować osobno.  
  
 <xref:System.Messaging.MessageQueue> Klasa jest otokę usługi kolejkowania komunikatów. Istnieje wiele wersji usługi kolejkowania komunikatów i przy użyciu <xref:System.Messaging.MessageQueue> klasy może spowodować nieco inaczej, w zależności od systemu operacyjnego używasz. Aby uzyskać informacje dotyczące określonych funkcji poszczególnych wersji usługi kolejkowania komunikatów zobacz temat "What's New in Usługa kolejkowania komunikatów" w zestawu SDK platformy w witrynie MSDN.  
  
 <xref:System.Messaging.MessageQueue> Klasa zawiera odwołanie do kolejki usługi kolejkowania komunikatów. Można określić ścieżkę w <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora, aby połączyć się z istniejącego zasobu, lub można utworzyć nowej kolejki na serwerze. Przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, lub <xref:System.Messaging.MessageQueue.Receive%2A>, należy skojarzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy z istniejącej kolejki. W tym momencie można manipulować właściwości kolejki takich jak <xref:System.Messaging.MessageQueue.Category%2A> i <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue> obsługuje dwa rodzaje pobieranie wiadomości: synchroniczne i asynchroniczne. Metod synchronicznych <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.Receive%2A>, spowodować wątku procesu oczekiwania przedział czasu określony dla nowej wiadomości w kolejce. Metod asynchronicznych <xref:System.Messaging.MessageQueue.BeginPeek%2A> i <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Zezwalaj, aby kontynuować w oddzielnym wątku, aż do nadejścia wiadomości w kolejce zadania głównej aplikacji. Te metody pracy przy użyciu obiekty wywołania zwrotnego i stanu do przekazywania informacji między wątkami.  
  
 Po utworzeniu nowego wystąpienia <xref:System.Messaging.MessageQueue> klasa, nie tworzenia nowej kolejki usługi kolejkowania komunikatów. Zamiast tego można użyć <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, i <xref:System.Messaging.MessageQueue.Purge%2A> metody do kolejki na serwerze zarządzania.  
  
 W odróżnieniu od <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> i <xref:System.Messaging.MessageQueue.Delete%28System.String%29> są `static` członków, dlatego można ich wywołać bez tworzenia nowego wystąpienia klasy <xref:System.Messaging.MessageQueue> klasy.  
  
 Można ustawić <xref:System.Messaging.MessageQueue> obiektu <xref:System.Messaging.MessageQueue.Path%2A> właściwości z jednym z trzech nazw: Przyjazna nazwa <xref:System.Messaging.MessageQueue.FormatName%2A>, lub <xref:System.Messaging.MessageQueue.Label%2A>. Przyjaznej nazwy, która jest definiowana za pomocą kolejki <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości, jest <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> do kolejki publicznej i <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> dla kolejki prywatnej. <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość zezwala na dostęp offline do kolejki komunikatów. Ponadto można użyć kolejki <xref:System.Messaging.MessageQueue.Label%2A> właściwości można ustawić kolejki <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Aby uzyskać listę początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>, zobacz <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów składni nazwa ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 Poniższy przykład kodu wysyła komunikat do kolejki i odbiera wiadomości z kolejki przy użyciu klasy specyficzne dla aplikacji o nazwie `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Tylko <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> metoda jest bezpieczne dla wątków.</threadsafe>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="T:System.Messaging.DefaultPropertiesToSend" />
    <altmember cref="T:System.Messaging.MessageQueueException" />
    <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
    <altmember cref="M:System.Messaging.MessageQueue.Peek" />
    <altmember cref="M:System.Messaging.MessageQueue.Receive" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
    <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
    <altmember cref="P:System.Messaging.MessageQueue.Path" />
    <altmember cref="P:System.Messaging.MessageQueue.Label" />
    <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
    <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
    <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy. Po Konstruktor domyślny inicjuje nowe wystąpienie, należy ustawić na wystąpienie <see cref="P:System.Messaging.MessageQueue.Path" /> właściwości przed użyciem tego wystąpienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy, która nie jest od razu związana z kolejki na serwer usługi kolejkowania komunikatów. Przed użyciem tego wystąpienia, musisz połączyć go do istniejącej kolejki usługi kolejkowania komunikatów przez ustawienie <xref:System.Messaging.MessageQueue.Path%2A> właściwości. Alternatywnie, można ustawić <xref:System.Messaging.MessageQueue> odwołanie do <xref:System.Messaging.MessageQueue.Create%28System.String%29> wartość zwracaną metody, tworząc nowe kolejki usługi kolejkowania komunikatów.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktora tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowego kolejki usługi kolejkowania komunikatów.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy. Wszystkie wartości filtru są ustawiane na `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie należy użyć powiązać nowe <xref:System.Messaging.MessageQueue> wystąpienie do określonej kolejki usługi kolejkowania komunikatów, dla których znasz ścieżka, nazwa formatu lub etykiety. Jeśli chcesz udzielić wyłącznego dostępu do pierwszej aplikacji, która odwołuje się kolejka, należy ustawić <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwości `true` lub użyj konstruktora, który przekaże parametr ograniczenia dostępu do odczytu.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktora tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowego kolejki usługi kolejkowania komunikatów. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, użyj <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki on odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejki utraconych wiadomości maszyny|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisywania na ścieżkę kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwy formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Praca w trybie offline, należy użyć składni nazwę formatu, nie Składnia nazwy ścieżki dla konstruktora. W przeciwnym wypadku jest zwracany wyjątek, ponieważ podstawowy kontroler domeny nie jest dostępny, aby rozpoznać ścieżki do nazwy formatu.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>. Te wartości są oparte na właściwościach kolejki usługi kolejkowania komunikatów z ścieżka określona przez `path` parametru.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów "Treść"; w przeciwnym razie `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości nazwy komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli włączone jest ustawienie dziennika obiektu usługi kolejkowania komunikatów; w przeciwnym razie `false`.|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów składni nazwa ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwości nie są prawidłowe, prawdopodobnie ponieważ nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />, które mogą być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby przyznać wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy, która odwołuje się do kolejki usługi kolejkowania komunikatów w określonej ścieżce i z określonym ograniczeniem dostęp do odczytu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie należy użyć powiązać nowe <xref:System.Messaging.MessageQueue> do określonej kolejki usługi kolejkowania komunikatów, dla których znasz ścieżka, nazwa formatu lub etykiety. Jeśli chcesz udzielić wyłącznego dostępu do pierwszej aplikacji, która odwołuje się kolejka, ustaw `sharedModeDenyReceive` parametr `true`. W przeciwnym razie wartość `sharedModeDenyReceive` do `false` lub użyj konstruktora, który zawiera tylko `path` parametru.  
  
 Ustawienie `sharedModeDenyReceive` do `true` ma wpływ na wszystkie obiekty, które uzyskują dostęp do kolejki usługi kolejkowania komunikatów, łącznie z innych aplikacji. Efekty parametru nie są ograniczone do tej aplikacji.  
  
 <xref:System.Messaging.MessageQueue.%23ctor%2A> Konstruktor tworzy nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy; nie powoduje utworzenia nowego kolejki usługi kolejkowania komunikatów. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, użyj <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejki utraconych wiadomości maszyny|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Alternatywnie można użyć nazwy formatu lub etykieta kolejki usługi kolejkowania komunikatów do opisywania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwy formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Aby praca w trybie offline, należy użyć Składnia nazwy formatu zamiast składni przyjazną nazwę. W przeciwnym wypadku jest zwracany wyjątek, ponieważ podstawowy kontroler domeny (na którym usługa Active Directory) nie jest dostępny, aby rozpoznać ścieżki do nazwy formatu.  
  
 Jeśli <xref:System.Messaging.MessageQueue> Otwiera kolejkę z `sharedModeDenyReceive` ustawiona `true`oraz <xref:System.Messaging.MessageQueue> czy następnie próbuje odczytać z kolejki generuje <xref:System.Messaging.MessageQueueException> z powodu naruszenia zasad współużytkowania. A <xref:System.Messaging.MessageQueueException> jest również element zgłaszany, gdy <xref:System.Messaging.MessageQueue> podejmuje próbę dostępu do kolejki w trybie wyłączności podczas drugiego <xref:System.Messaging.MessageQueue> jest już otwarty dostępu do kolejki.  
  
 W poniższej tabeli przedstawiono początkowe wartości właściwości dla wystąpienia <xref:System.Messaging.MessageQueue>. Te wartości są oparte na właściwościach kolejki usługi kolejkowania komunikatów z ścieżka określona przez `path` parametru.  
  
|Właściwość|Wartość początkowa|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.DefaultPropertiesToSend> klasy.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, jeśli ustawienie poziomu prywatności kolejki usługi kolejkowania komunikatów "Treść"; w przeciwnym razie `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|Wartość właściwości nazwy komputera kolejki usługi kolejkowania komunikatów.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Wartościami ustawionymi przez domyślny konstruktor obiektu <xref:System.Messaging.MessagePropertyFilter> klasy.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, jeśli nie jest ustawiony przez konstruktora.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|Wartość `sharedModeDenyReceive` parametru.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, jeśli włączone jest ustawienie dziennika obiektu usługi kolejkowania komunikatów; w przeciwnym razie `false`.|  
  
   
  
## Examples  
 Poniższy przykładowy kod tworzy nową <xref:System.Messaging.MessageQueue> z wyłącznego dostępu, ustawia jego ścieżkę i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwości nie są prawidłowe, prawdopodobnie ponieważ nie została ustawiona.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />, które mogą być "." na komputerze lokalnym.</param>
        <param name="accessMode">Jeden z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />, które mogą być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby przyznać wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Poniższy przykładowy kod tworzy nową <xref:System.Messaging.MessageQueue> z wyłącznego dostępu do odczytu i włączone buforowanie połączenia.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, sharedModeDenyReceive As Boolean, enableCache As Boolean, accessMode As QueueAccessMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MessageQueue(System::String ^ path, bool sharedModeDenyReceive, bool enableCache, System::Messaging::QueueAccessMode accessMode);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizację kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />, które mogą być "." na komputerze lokalnym.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> Aby przyznać wyłączny dostęp do odczytu do pierwszej aplikacji, który uzyskuje dostęp do tej kolejki; w przeciwnym razie <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</param>
        <param name="accessMode">Jeden z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</param>
        <summary>Inicjuje nowe wystąpienie klasy <see cref="T:System.Messaging.MessageQueue" /> klasy.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessMode As QueueAccessMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::QueueAccessMode AccessMode { System::Messaging::QueueAccessMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość, która wskazuje poziom dostępu dla kolejki.</summary>
        <value>Jeden z <see cref="T:System.Messaging.QueueAccessMode" /> wartości.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jest to domyślny tryb dostępu dla kolejki `QueueAccessMode.SendAndReceive`, chyba że określono inaczej podczas wywoływania konstruktora.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberSignature Language="VB.NET" Value="Public Property Authenticate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Authenticate { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje tylko wiadomości uwierzytelnione.</summary>
        <value>
          <see langword="true" /> Jeśli kolejka akceptuje tylko wiadomości uwierzytelnione; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uwierzytelnianie wiadomości umożliwia do zapewnienia integralności komunikatu i sprawdzić, która wysłała wiadomość. Do żądania uwierzytelniania, aplikacja wysyłająca ustawia poziom uwierzytelniania wiadomości.  
  
 Podczas ustawiania <xref:System.Messaging.MessageQueue.Authenticate%2A> do `true`, jest ograniczenie dostępu do kolejki na serwerze, a nie tylko do to <xref:System.Messaging.MessageQueue> wystąpienia. Wszyscy klienci działać z tej samej kolejki usługi kolejkowania komunikatów będzie dotyczył.  
  
 Kolejka akceptuje tylko wiadomości uwierzytelnione spowoduje odrzucenie wiadomości nieuwierzytelnionych. Aby zażądać powiadomień odrzucenie wiadomości, można ustawić aplikacja wysyłająca <xref:System.Messaging.Message.AcknowledgeType%2A> właściwości komunikatu. Ponieważ żadnego wskazania odrzucenie wiadomości nie istnieje, aplikacja wysyłająca mogą stracić wiadomości, chyba że żądanie jest ona zostać wysłana do kolejki utraconych wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Authenticate%2A> właściwości.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.UseDeadLetterQueue" />
        <altmember cref="P:System.Messaging.Message.AcknowledgeType" />
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public Property BasePriority As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short BasePriority { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia podstawowy priorytet, którego używa Usługa Kolejkowanie komunikatów do rozsyłania wiadomości do kolejki publicznej za pośrednictwem sieci.</summary>
        <value>Pojedynczy podstawowy priorytet dla wszystkich wiadomości wysłanych do kolejki (publicznej). Wartość domyślna to zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Priorytet podstawowy kolejki komunikatów Określa jak wiadomość w trasie do tej kolejki jest traktowana jako przesyłane za pośrednictwem sieci. Można ustawić <xref:System.Messaging.MessageQueue.BasePriority%2A> właściwość, aby przyznać wyższy lub niższy priorytet wszystkich wiadomości wysłanych do określonej kolejki niż wysyłane do innych kolejek. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień dotyczy zmiana.  
  
 Kolejka komunikatów <xref:System.Messaging.MessageQueue.BasePriority%2A> nie jest powiązana z <xref:System.Messaging.Message.Priority%2A> właściwości wiadomości, która określa kolejność, w której wiadomości przychodzącej znajduje się w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A> ma zastosowanie tylko do kolejki publiczne którego ścieżki są określane nazwą formatu. Priorytet podstawowy kolejki prywatnej to zawsze zero (0).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.BasePriority%2A> właściwości.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Podstawowy priorytet został ustawiony na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginPeek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <summary>Inicjuje operację asynchroniczną peek przez informuje rozpocząć wybierania komunikat i powiadomienie po zakończeniu obsługi zdarzeń usługi kolejkowania komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje operację asynchroniczną peek mającej nie ma limitu. Operacji nie jest ukończone, dopóki komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat o stanie się dostępny w kolejce.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną peek; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez pobranie przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczne, można wywołać ją do wglądu kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie wgląd kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginPeek%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie ukończenia, ale zostanie wygenerowany wyjątek podczas wywoływania metody <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> zainicjować operacji asynchronicznych wglądu w kolejce, który znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, przykładzie dokonuje wiadomości i zapisuje jego treści do ekranu. Przykład wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie zainicjować nowej operacji asynchronicznych podglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <summary>Inicjuje operację asynchroniczną peek, która ma określony limit czasu. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony interwał czasu.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną peek; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez pobranie przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczne, można wywołać ją do wglądu kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie wgląd kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginPeek%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` parametru wygaśnie, ten składnik wywołuje <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie ukończenia, ale zostanie wygenerowany wyjątek podczas wywoływania metody <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operację asynchroniczną peek, przy użyciu ścieżki kolejki ". \myQueue". Tworzy program obsługi zdarzeń `MyPeekCompleted`i dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana z limitem czasu jedną minutę, zainicjować operacji asynchronicznych podglądu. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenia lub przekroczeniu limitu czasu, wiadomość zostanie pobrana, jeśli taki istnieje, a jego treść jest zapisywany do ekranu. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> zostanie ponownie wywołany, aby zainicjować nowej operacji asynchronicznych peek z tym samym limitu czasu.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <summary>Inicjuje operację asynchroniczną peek określony limit czasu i obiektu określonego stanu, który zawiera informacje skojarzone przez cały okres istnienia wykonać operację. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginPeek%2A> podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony interwał czasu.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 To przeciążenie umożliwia kojarzenie informacji z operacji, która zostanie zachowana przez cały okres istnienia wykonać operację. Program obsługi zdarzeń może dostęp do tych informacji, analizując <xref:System.IAsyncResult.AsyncState%2A> właściwość <xref:System.IAsyncResult> skojarzonego z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginPeek%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i skojarzyć go z Twojego delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginPeek%2A> Inicjuje operację asynchroniczną peek; <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lub przez pobranie przy użyciu wynik <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczne, można wywołać ją do wglądu kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie wgląd kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> , które identyfikują operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu i obiektu stanu. Jeśli interwał określony przez `timeout` parametru wygaśnie, ten składnik wywołuje <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana. Ilustracja tego scenariusza zobacz sekcję przykład.  
  
 Obiekt stanu służy również do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne w innym wątku asynchronicznego scenariusza, obiekt stanu jest przekazywane i przekazywane ponownie wraz z informacjami z zdarzenia.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie ukończenia, ale zostanie wygenerowany wyjątek podczas wywoływania metody <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operację asynchroniczną peek, przy użyciu ścieżki kolejki ". \myQueue". Tworzy program obsługi zdarzeń `MyPeekCompleted`i dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń. <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest wywoływana, z limitem czasu jednej minuty. Każde wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A> ma unikatowy skojarzone liczba całkowita, która identyfikuje tej operacji. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenia lub upłynął limit czasu, komunikat, jeśli istnieje, jest pobierana, a jego treść i identyfikator całkowitą specyficzne dla operacji są zapisywane do ekranu. Następnie <xref:System.Messaging.MessageQueue.BeginPeek%2A> zostanie ponownie wywołany, aby zainicjować nowej operacji asynchronicznych peek z tej samej limitu czasu i skojarzone całkowitej właśnie zakończono operację.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginPeek (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który otrzyma powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje operację asynchroniczną peek określony limit czasu i obiektu określonego stanu, który zawiera informacje skojarzone przez cały okres istnienia wykonać operację. To przeciążenie otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążenia, wywołania zwrotnego, określonego w parametrze wywołania zwrotnego bezpośrednio wywoływane, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony przedział czasu; <xref:System.Messaging.MessageQueue.PeekCompleted> nie zdarzenia. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginPeek%2A> polegać na ten element, aby podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczne, można wywołać ją do wglądu kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie wgląd kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> , które identyfikują operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy operacji asynchronicznych podglądu. Przykład kodu wysyła komunikat do kolejki wiadomości lokalnych, następnie wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu dziesięć sekund; unikatowa liczba całkowita, która identyfikuje tę wiadomość określonego; i nowe wystąpienie klasy <xref:System.AsyncCallback> obsługi zdarzeń, które identyfikują `MyPeekCompleted`. Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń dokonuje wglądu do wiadomości i zapisuje treść komunikatu i identyfikator wiadomości całkowitą na ekranie.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginPeek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <param name="action">Jeden z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy wglądu do bieżącej wiadomości w kolejce lub następny komunikat.</param>
        <param name="state">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który otrzyma powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje operację asynchroniczną peek mający określony limit czasu i który korzysta z określonego kursora, działania określonego wglądu i obiektu o określonym stanie. Obiekt stanu informacje skojarzone podczas trwania operacji. To przeciążenie otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążenia, wywołania zwrotnego, określonego w parametrze wywołania zwrotnego jest wywoływana bezpośrednio, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony interwał czasu. <xref:System.Messaging.MessageQueue.PeekCompleted> Nie zdarzenia. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginPeek%2A> polegać na ten element, aby podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest asynchroniczne, można wywołać ją do wglądu kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie wgląd kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> Zwraca <xref:System.IAsyncResult> , które identyfikują operację asynchroniczną, uruchamiany przez metodę. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginPeek%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inną niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> określono <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <summary>Inicjuje asynchroniczne operacji odbierania przez informuje rozpocząć odbieranie wiadomości i powiadomienie po zakończeniu obsługi zdarzeń usługi kolejkowania komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive () As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicjuje asynchroniczne odbieranie operacja, która ma nie ma limitu. Operacji nie jest ukończone, dopóki komunikat o stanie się dostępny w kolejce.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, gdy wiadomość została usunięta z kolejki.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i powiązać ją z sieci delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne odbieranie operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczne, można wywołać ją do odbierania wiadomości z kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginReceive%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie ukończenia, ale zostanie wygenerowany wyjątek podczas wywoływania metody <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Nie używaj wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> transakcji. Jeśli chcesz wykonać transakcyjna operacja asynchroniczna, wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieszcza transakcji i (synchroniczne) <xref:System.Messaging.MessageQueue.Receive%2A> metodę wewnątrz obsługi zdarzeń, należy utworzyć dla operacji podglądu. Obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod powiązany żądań asynchronicznych. Przyjęto założenie, że istnieje kolejki na komputerze lokalnym, o nazwie "Moja_kolejka". `Main` Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana przez `MyReceiveCompleted` procedury. `MyReceiveCompleted` przetwarzania bieżącego komunikatu i rozpocznie się nowy asynchronicznej operacji odbioru.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 Poniższy przykład kodu tworzy kolejki żądań asynchronicznych. Wywołanie <xref:System.Messaging.MessageQueue.BeginReceive%2A> używa <xref:System.IAsyncResult.AsyncWaitHandle%2A> w swojej zwracanej wartości. `Main` Oczekuje procedury dla wszystkich operacji asynchronicznych, należy wykonać przed zakończeniem.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <summary>Inicjuje asynchroniczne odbieranie operacja, która ma określony limit czasu. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony interwał czasu.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i powiązać ją z sieci delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne odbieranie operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wyniku <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczne, można wywołać ją do odbierania wiadomości z kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, wywoływane jest zdarzenie ukończenia, ale zostanie wygenerowany wyjątek podczas wywoływania metody <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginReceive%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu. Jeśli interwał określony przez `timeout` parametru wygaśnie, ten składnik wywołuje <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Nie używaj wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> transakcji. Jeśli chcesz wykonać transakcyjna operacja asynchroniczna, wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieszcza transakcji i (synchroniczne) <xref:System.Messaging.MessageQueue.Receive%2A> metodę wewnątrz obsługi zdarzeń, należy utworzyć dla operacji podglądu. Obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Przykład kodu tworzy program obsługi zdarzeń `MyReceiveCompleted`i dołącza go do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń. Przykład kodu wysyła komunikat do kolejki wiadomości lokalnych, następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, przekazując wartość limitu czasu dziesięć sekund. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera wiadomości i zapisuje treść komunikatu do ekranu.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie ponieważ reprezentuje ona liczbą ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczne operacji odbierania określony limit czasu i obiektu określonego stanu, który zawiera informacje skojarzone przez cały okres istnienia wykonać operację. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas przetwarzania asynchronicznego, użyj <xref:System.Messaging.MessageQueue.BeginReceive%2A> podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony interwał czasu.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 To przeciążenie umożliwia kojarzenie informacji z operacji, która zostanie zachowana przez cały okres istnienia wykonać operację. Program obsługi zdarzeń może wykryć te informacje, analizując <xref:System.IAsyncResult.AsyncState%2A> właściwość <xref:System.IAsyncResult> skojarzonego z operacją.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i powiązać ją z sieci delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne odbieranie operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wyniku <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczne, można wywołać ją do odbierania wiadomości z kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginReceive%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 To przeciążenie określa limit czasu i obiektu stanu. Jeśli interwał określony przez `timeout` parametru wygaśnie, ten składnik wywołuje <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń. Ponieważ żaden komunikat nie istnieje, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> spowoduje zgłoszenie wyjątku.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana.  
  
 Obiekt stanu służy również do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne w innym wątku asynchronicznego scenariusza, obiekt stanu jest przekazywane i przekazywane ponownie wraz z informacjami z zdarzenia.  
  
 Nie używaj wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> transakcji. Jeśli chcesz wykonać transakcyjna operacja asynchroniczna, wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieszcza transakcji i (synchroniczne) <xref:System.Messaging.MessageQueue.Receive%2A> metodę wewnątrz obsługi zdarzeń, należy utworzyć dla operacji podglądu. Obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Przykład kodu tworzy program obsługi zdarzeń `MyReceiveCompleted`i dołącza go do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń. Przykład kodu wysyła komunikat do kolejki wiadomości lokalnych, następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, przekazując wartość limitu czasu dziesięć sekund i unikatowa liczba całkowita, która identyfikuje tej konkretnej wiadomości. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera wiadomości i zapisuje treść komunikatu i identyfikator wiadomości całkowitą na ekranie.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (timeout As TimeSpan, stateObject As Object, callback As AsyncCallback) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Object ^ stateObject, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="stateObject">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który otrzyma powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczne operacji odbierania określony limit czasu i obiektu określonego stanu, który zawiera informacje skojarzone przez cały okres istnienia wykonać operację. To przeciążenie otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążenia, wywołania zwrotnego, określonego w parametrze wywołania zwrotnego bezpośrednio wywoływane, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony przedział czasu; <xref:System.Messaging.MessageQueue.ReceiveCompleted> nie zdarzenia. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginReceive%2A> polegać na ten element, aby podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i powiązać ją z sieci delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne odbieranie operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wyniku <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczne, można wywołać ją do odbierania wiadomości z kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginReceive%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana.  
  
 Obiekt stanu służy również do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne w innym wątku asynchronicznego scenariusza, obiekt stanu jest przekazywane i przekazywane ponownie wraz z informacjami z zdarzenia.  
  
 Nie używaj wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> transakcji. Jeśli chcesz wykonać transakcyjna operacja asynchroniczna, wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieszcza transakcji i (synchroniczne) <xref:System.Messaging.MessageQueue.Receive%2A> metodę wewnątrz obsługi zdarzeń, należy utworzyć dla operacji podglądu. Obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy asynchronicznej operacji odbioru. Przykład kodu wysyła komunikat do kolejki wiadomości lokalnych, następnie wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, przekazując: wartość limitu czasu dziesięć sekund; unikatowa liczba całkowita, która identyfikuje tę wiadomość określonego; i nowe wystąpienie klasy <xref:System.AsyncCallback> obsługi zdarzeń, które identyfikują `MyReceiveCompleted`. Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, program obsługi zdarzeń odbiera wiadomości i zapisuje treść komunikatu i identyfikator wiadomości całkowitą na ekranie.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Object ^ state, AsyncCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazujące przedział czasu oczekiwania na udostępnienie wiadomości.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <param name="state">Obiekt stanu określonym przez aplikację, który zawiera informacje związane z operacji asynchronicznej.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> Który otrzyma powiadomienie o ukończeniu operacji asynchronicznej.</param>
        <summary>Inicjuje asynchroniczne odbieranie operacja, która ma określony limit czasu i używa określonego kursora i obiektu o określonym stanie. Obiekt stanu informacje skojarzone podczas trwania operacji. To przeciążenie otrzymuje powiadomienie, poprzez wywołanie zwrotne, tożsamości programu obsługi zdarzeń dla tej operacji. Operacja nie jest pełną, aż do komunikat o stanie się dostępny w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.IAsyncResult" /> , Które identyfikują oczekujących na opublikowanie żądania asynchronicznego.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Korzystając z tego przeciążenia, wywołania zwrotnego, określonego w parametrze wywołania zwrotnego bezpośrednio wywoływane, gdy komunikat o stanie się dostępny, w kolejce lub upłynął określony przedział czasu; <xref:System.Messaging.MessageQueue.ReceiveCompleted> nie zdarzenia. Inne przeciążenia <xref:System.Messaging.MessageQueue.BeginReceive%2A> polegać na ten element, aby podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted> jest również wywoływany, gdy istnieje już wiadomości w kolejce.  
  
 Aby użyć <xref:System.Messaging.MessageQueue.BeginReceive%2A>, Tworzenie procedury obsługi zdarzeń, który przetwarza wyniki operacji asynchronicznych i powiązać ją z sieci delegata zdarzenia. <xref:System.Messaging.MessageQueue.BeginReceive%2A> Inicjuje asynchroniczne odbieranie operacji. <xref:System.Messaging.MessageQueue> zostanie powiadomiony poprzez gromadzenia <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzeń, po nadejściu wiadomości w kolejce. <xref:System.Messaging.MessageQueue> Następnie uzyskać dostęp do wiadomości, wywoływania <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lub pobierania za pomocą wyniku <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> Metoda zwraca natychmiast, ale operacja asynchroniczna nie jest ukończona, aż do obsługi zdarzeń jest wywoływana.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest asynchroniczne, można wywołać ją do odbierania wiadomości z kolejki bez blokowania bieżącego wątku do wykonania. Aby synchronicznie komunikat, należy użyć <xref:System.Messaging.MessageQueue.Receive%2A> metody.  
  
 Po zakończeniu operacji asynchronicznej, należy wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> lub <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie w obsłudze zdarzeń, aby zachować odbieranie powiadomień.  
  
 <xref:System.IAsyncResult> Który <xref:System.Messaging.MessageQueue.BeginReceive%2A> zwraca identyfikuje operację asynchroniczną, która metoda uruchomiona. Możesz użyć tej funkcji <xref:System.IAsyncResult> podczas trwania operacji, chociaż można zwykle nie jest używana do <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest wywoływana. Jednak po uruchomieniu kilku operacji asynchronicznych, możesz umieścić ich <xref:System.IAsyncResult> wartości w tablicy i określ, czy czekać na wszystkie operacje lub inne czynności do wykonania. W takim przypadku należy użyć <xref:System.IAsyncResult.AsyncWaitHandle%2A> właściwość <xref:System.IAsyncResult> do identyfikowania ukończoną operację.  
  
 Obiekt stanu kojarzy informacje o stanie operacji. Na przykład, jeśli wywołujesz <xref:System.Messaging.MessageQueue.BeginReceive%2A> kilka razy, aby zainicjować wiele operacji, można zidentyfikować każdej operacji za pośrednictwem obiektu oddzielnym stanie zdefiniowana.  
  
 Obiekt stanu służy również do przekazywania informacji między wątkami procesu. Jeśli wątek jest uruchomiony, ale wywołanie zwrotne w innym wątku asynchronicznego scenariusza, obiekt stanu jest przekazywane i przekazywane ponownie wraz z informacjami z zdarzenia.  
  
 Nie używaj wywołania asynchronicznego <xref:System.Messaging.MessageQueue.BeginReceive%2A> transakcji. Jeśli chcesz wykonać transakcyjna operacja asynchroniczna, wywołanie <xref:System.Messaging.MessageQueue.BeginPeek%2A>i umieszcza transakcji i (synchroniczne) <xref:System.Messaging.MessageQueue.Receive%2A> metodę wewnątrz obsługi zdarzeń, należy utworzyć dla operacji podglądu. Obsługi zdarzenia może zawierać funkcji, jak pokazano w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.TimeSpan" />
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRead As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRead { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> mogą być odczytywane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Messaging.MessageQueue" /> istnieje i aplikacji może odczytywać; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A> Wskazuje, czy aplikacja jest w stanie wgląd lub odbierać wiadomości z kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanRead%2A> jest `true`, <xref:System.Messaging.MessageQueue> można odbierać lub wgląd do wiadomości z kolejki. W przeciwnym razie nie.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false` Jeśli kolejka jest już otwarty z wyłącznego dostępu do odczytu (lub jeśli jest ona otwarta z dostępem otwarty i to <xref:System.Messaging.MessageQueue> żądań wyłącznego dostępu), lub jeśli aplikacja nie ma wystarczających praw dostępu do niego. Jeśli aplikacja próbuje odczytać z kolejki przy <xref:System.Messaging.MessageQueue.CanRead%2A> jest `false`, odmowa dostępu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CanRead%2A> właściwości.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanWrite As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanWrite { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy <see cref="T:System.Messaging.MessageQueue" /> mogą być zapisywane.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Messaging.MessageQueue" /> istnieje i aplikacji może zapisywać do niego; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> Wskazuje, czy aplikacja jest w stanie wysyłać wiadomości do kolejki. Jeśli <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `true`, <xref:System.Messaging.MessageQueue> będą mogły wysyłać wiadomości do kolejki. W przeciwnym razie nie.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `false` Jeśli kolejka jest już otwarty z wyłączny dostęp do zapisu (lub jeśli jest ona otwarta z dostępem otwarty i to <xref:System.Messaging.MessageQueue> żądań wyłącznego dostępu), lub jeśli aplikacja nie ma wystarczających praw dostępu do niego. Jeśli aplikacja próbuje zapisać do kolejki podczas <xref:System.Messaging.MessageQueue.CanWrite%2A> jest `false`, odmowa dostępu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CanWrite%2A> właściwości.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberSignature Language="VB.NET" Value="Public Property Category As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Category { Guid get(); void set(Guid value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia kategorię kolejki.</summary>
        <value>A <see cref="T:System.Guid" /> reprezentujący kategorii kolejki (usługi kolejkowania komunikatów typu identifier), który umożliwia aplikacjom kategoryzowanie kolejek jej. Wartość domyślna to <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Kategoria kolejki umożliwia aplikacjom kategoryzowanie kolejek jej. Na przykład można umieścić wszystkich kolejek rozliczeń w jednej kategorii i wszystkich kolejek kolejności w innym.  
  
 <xref:System.Messaging.MessageQueue.Category%2A> Właściwości zapewnia dostęp do właściwości identyfikator typu usługi kolejkowania komunikatów (czyli odczytu/zapisu), dostępna za pośrednictwem **właściwości kolejki** okno dialogowe, w konsoli zarządzania komputerem. Można zdefiniować nowej kategorii. Chociaż można używać <xref:System.Guid.NewGuid%2A> można utworzyć wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości, takie działanie nie jest konieczne. Wartość kategorii musi się różnić tylko z innych kategorii, nie za wszystkie inne <xref:System.Guid> wartości. Na przykład można przypisać {00000000-0000-0000-0000-000000000001} jako <xref:System.Messaging.MessageQueue.Category%2A> dla jednego zestawu, kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 Nie jest konieczne ustawić <xref:System.Messaging.MessageQueue.Category%2A>. Wartość może być `null`.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień dotyczy zmiana.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Category%2A> właściwości.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Kategoria kolejka została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Id" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ClearConnectionCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ClearConnectionCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Powoduje wyczyszczenie pamięci podręcznej połączenia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, nazwy formatu przechowywane w pamięci podręcznej są usuwane i zamykanie dojść otwarte i zapisane w pamięci podręcznej.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy kod przykładowy wywołania <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwalnia wszystkie zasoby przydzielone przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A> zwalnia wszystkie zasoby skojarzone z <xref:System.Messaging.MessageQueue>, łącznie z udostępnionych zasobów, w razie potrzeby. System ponownie wymaga tych zasobów, automatycznie, jeśli są one nadal dostępne, na przykład podczas wywoływania <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodę, tak jak w poniższym kodzie C#.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Podczas wywoływania <xref:System.Messaging.MessageQueue.Close%2A>, wszystkie <xref:System.Messaging.MessageQueue> właściwości, które bezpośrednio uzyskać dostępu do kolejki usługi kolejkowania komunikatów są wyczyszczone. <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, I <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> wszystkie jest zachowywana były.  
  
 <xref:System.Messaging.MessageQueue.Close%2A> nie zawsze Zwolnij odczytu i zapisu dojścia do kolejki, ponieważ mogą one być udostępniony. Można wykonać jedną z następujących czynności, aby upewnić się, że <xref:System.Messaging.MessageQueue.Close%2A> pozwala na odczyt i zapis dojścia do kolejki:  
  
-   Utwórz <xref:System.Messaging.MessageQueue> z wyłącznego dostępu. Aby to zrobić, należy wywołać <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> lub <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i zestaw `sharedModeDenyReceive` parametr `true`.  
  
-   Utwórz <xref:System.Messaging.MessageQueue> z połączenia Buforowanie wyłączone. Aby to zrobić, należy wywołać <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> Konstruktor i zestaw `enableConnectionCache` parametr `false`.  
  
-   Wyłącz buforowanie połączenia. Aby to zrobić, ustaw <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwości `false`.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Close%2A> dla kolejki, aby usunąć kolejkę na serwer usługi kolejkowania komunikatów. W przeciwnym razie wiadomości wysłanych do kolejki można zgłaszają wyjątki lub pojawiają się w kolejce wiadomości utraconych.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu zamyka kolejki usługi kolejkowania komunikatów.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy nową kolejkę w określonej ścieżce na serwerze usługi kolejkowania komunikatów.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do utworzenia kolejki.</param>
        <summary>Tworzy nietransakcyjnej kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> reprezentujący nowej kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie nietransakcyjnej kolejki usługi kolejkowania komunikatów.  
  
 Aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać go z istniejącą kolejkę, użyj <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy wywołać <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki on odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy kolejek publicznych i prywatnych. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest już istnieje w określonej ścieżce.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (path As String, transactional As Boolean) As MessageQueue" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueue ^ Create(System::String ^ path, bool transactional);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Ścieżka do utworzenia kolejki.</param>
        <param name="transactional">
          <see langword="true" /> Aby utworzyć kolejkę transakcyjną; <see langword="false" /> można utworzyć kolejki nietransakcyjnej.</param>
        <summary>Tworzy transakcyjnej lub nietransakcyjna kolejki usługi kolejkowania komunikatów w określonej ścieżce.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueue" /> reprezentujący nowej kolejki.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia utworzenie kolejką transakcyjną w usługi kolejkowania komunikatów. Można utworzyć kolejki nietransakcyjnej, ustawiając `transactional` parametr `false` , przez wywołanie inne przeciążenia <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Aby utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueue> klasy w aplikacji i powiązać go z istniejącą kolejkę, użyj <xref:System.Messaging.MessageQueue.%23ctor%2A> konstruktora. Aby utworzyć nową kolejkę w usługi kolejkowania komunikatów, należy wywołać <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Składnia `path` parametru zależy od typu kolejki on odwołania, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
  
 Użyj "." na komputerze lokalnym. Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy publiczny i prywatny kolejek transakcyjnych. Wysyła komunikat do wybranych kolejek.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest już istnieje w określonej ścieżce.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCursor () As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Cursor ^ CreateCursor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy nową <see cref="T:System.Messaging.Cursor" /> bieżącego kolejki wiadomości.</summary>
        <returns>Nowy <see cref="T:System.Messaging.Cursor" /> bieżącego kolejki wiadomości. Ten kursor jest używany do obsługi określonych lokalizacji w kolejce, podczas czytania wiadomości z kolejki.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Messaging.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreateTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime CreateTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera godzinę i datę utworzenia kolejki w usłudze kolejkowania.</summary>
        <value>A <see cref="T:System.DateTime" /> reprezentujący datę i godzinę utworzenia kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A> odwołuje się do kolejki na serwerze usługi kolejkowania komunikatów nie <xref:System.Messaging.MessageQueue> wystąpienia.  
  
 Jeśli kolejka istnieje, ta właściwość reprezentuje czas utworzenia kolejki dostosowana do czasu lokalnego serwera, na którym znajduje się kolejka.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.CreateTime%2A> właściwości.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.LastModifyTime" />
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultPropertiesToSend As DefaultPropertiesToSend" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::DefaultPropertiesToSend ^ DefaultPropertiesToSend { System::Messaging::DefaultPropertiesToSend ^ get(); void set(System::Messaging::DefaultPropertiesToSend ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartości właściwości używany domyślnie, gdy aplikacja wysyła wiadomości do kolejki wiadomości.</summary>
        <value>A <see cref="T:System.Messaging.DefaultPropertiesToSend" /> zawierający domyślne kolejkowania wiadomości wartości właściwości używany, gdy aplikacja wysyła obiekty inne niż <see cref="T:System.Messaging.Message" /> wystąpień do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po wysłaniu dowolnego obiektu, który nie jest typu <xref:System.Messaging.Message> do kolejki, <xref:System.Messaging.MessageQueue> Wstawia obiekt do komunikatów usługi kolejkowania komunikatów. W tym czasie <xref:System.Messaging.MessageQueue> dotyczy komunikat określonej w wartości właściwości <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> właściwości. Z drugiej strony Jeśli zostanie wysłana <xref:System.Messaging.Message> do kolejki, te właściwości są już określony dla tego wystąpienia, więc <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> jest ignorowany dla <xref:System.Messaging.Message>.  
  
 Mimo że można ustawić właściwości za pośrednictwem <xref:System.Messaging.MessageQueue> obiektu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> odwołuje się do właściwości wiadomości, które są wysyłane do kolejki, a nie kolejki.  
  
 W poniższej tabeli przedstawiono wartości domyślne dla właściwości.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|O zerowej długości tablicę bajtów|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Pusty ciąg ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje priorytet wiadomości, aby określić właściwości domyślnych do wysyłania wiadomości.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Domyślne właściwości nie można ustawić dla kolejki, prawdopodobnie ponieważ jedna z właściwości jest nieprawidłowa.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.AcknowledgeTypes" />
        <altmember cref="T:System.Messaging.EncryptionAlgorithm" />
        <altmember cref="T:System.Messaging.HashAlgorithm" />
        <altmember cref="F:System.Messaging.Message.InfiniteTimeout" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Lokalizacja kolejki do usunięcia.</param>
        <summary>Usuwa kolejkę na serwerze usługi kolejkowania komunikatów.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia `path` parametru zależy od typu kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisywania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Nazwa formatu|FormatName: [ *nazwy formatu* ]|  
|Etykieta|Etykiety: [ *etykiety* ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu usuwa kolejki usługi kolejkowania komunikatów, jeśli istnieje.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Parametr jest <see langword="null" /> lub jest pustym ciągiem ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Składnia <paramref name="path" /> parametr jest nieprawidłowy.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberSignature Language="VB.NET" Value="Public Property DenySharedReceive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DenySharedReceive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy to <see cref="T:System.Messaging.MessageQueue" /> ma już wyłączny dostęp do odbierania wiadomości z kolejki usługi kolejkowania komunikatów.</summary>
        <value>
          <see langword="true" /> Jeśli <see cref="T:System.Messaging.MessageQueue" /> ma prawa wyłączności do odbierania wiadomości z kolejki; w przeciwnym razie <see langword="false" />. Wartość domyślna to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> Określa tryb udostępnionego kolejki odwołuje się to <xref:System.Messaging.MessageQueue>. Ustaw <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> do `true` aby wskazać, że tylko to <xref:System.Messaging.MessageQueue> powinny mieć dostęp do wglądu lub odbierać komunikaty z kolejki z określonym <xref:System.Messaging.MessageQueue.Path%2A>. Jeśli inny <xref:System.Messaging.MessageQueue> lub innej aplikacji jest skojarzony z tego samego zasobu kolejki danego wystąpienia lub aplikacja nie będzie mogła wgląd ani odbierać wiadomości, ale nadal może wysyłać je.  
  
 Jeśli <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> jest `false`, kolejka jest dostępne w wielu aplikacjach do wysyłania, wybierania i odbierania wiadomości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> właściwości.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Aby zwolnić zasoby zarządzane i niezarządzane; <see langword="false" /> aby zwolnić tylko zasoby niezarządzane.</param>
        <summary>Usuwa zasoby (inne niż pamięć) używany przez <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wywołanie <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> po zakończeniu przy użyciu <xref:System.Messaging.MessageQueue>. <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> Pozostawia metody <xref:System.Messaging.MessageQueue> w stanie uniemożliwiającym jego używanie. Po wywołaniu <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, konieczne jest zwolnienie wszystkich odwołań do <xref:System.Messaging.MessageQueue> , można odzyskać pamięci, jej klasy przez wyrzucanie elementów bezużytecznych.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> przed zwolnieniem ostatniego odwołania do <xref:System.Messaging.MessageQueue>. W przeciwnym razie zasoby <xref:System.Messaging.MessageQueue> jest przy użyciu nie zostanie zwolniona, dopóki wywołania kolekcji pamięci <xref:System.Messaging.MessageQueue> destruktor obiektu.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property EnableConnectionCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool EnableConnectionCache { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy pamięć podręczna połączeń będzie obsługiwany przez aplikację.</summary>
        <value>
          <see langword="true" /> Tworzenie i używanie pamięci podręcznej połączenia; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Połączenie pamięci podręcznej znajduje się lista odwołań do struktur, które zawierają odczytu lub zapisu dojścia do kolejki. Gdy <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> jest `true`, <xref:System.Messaging.MessageQueue> pożycza uchwytów z pamięci podręcznej w każdym wywołaniu <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, lub <xref:System.Messaging.MessageQueue.Receive%2A>, zamiast otwartych dojść nowe. Może to poprawić wydajność. Przy użyciu pamięci podręcznej połączenia powoduje również <xref:System.Messaging.MessageQueue> ze zmian w topologii sieci.  
  
 Jeśli utworzysz nowe połączenie do kolejki po zapełnieniu pamięci podręcznej połączenia <xref:System.Messaging.MessageQueue> zastępuje najmniej ostatnio używanych struktury nowego połączenia. Można wyczyścić pamięć podręczną całkowicie przez wywołanie metody <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, na przykład, jeśli nazwy formatu kolejki pracujesz zostały zmienione tak, aby poprzedniej odczytu i zapisu dojść nie są już prawidłowe.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> właściwości.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberSignature Language="VB.NET" Value="Public Property EncryptionRequired As EncryptionRequired" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::EncryptionRequired EncryptionRequired { System::Messaging::EncryptionRequired get(); void set(System::Messaging::EncryptionRequired value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy kolejka akceptuje tylko nieprywatne (niezaszyfrowane) wiadomości.</summary>
        <value>Jeden z <see cref="T:System.Messaging.EncryptionRequired" /> wartości. Wartość domyślna to <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Po określeniu, że szyfrowanie jest wymagane dla komunikatów wysyłanych do kolejki, są szyfrowane tylko treści wiadomości. O innych elementach członkowskich (na przykład <xref:System.Messaging.Message.Label%2A> i <xref:System.Messaging.Message.SenderId%2A> właściwości) nie mogą być szyfrowane.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień dotyczy zmiana.  
  
 Szyfrowania wiadomości sprawia, że wiadomości prywatnej. Można określić wymaganie szyfrowania kolejki być `None`, `Body`, lub `Optional` przez ustawienie <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> właściwości odpowiednio. <xref:System.Messaging.Message.UseEncryption%2A> Ustawienie komunikacie musi odpowiadać Wymaganie szyfrowania kolejki. Jeśli wiadomość nie jest zaszyfrowany, ale Określa kolejki `Body`, lub jeśli komunikat jest zaszyfrowany, ale kolejka Określa `None`, komunikat zostanie odrzucony przez kolejkę. Aplikacja wysyłająca komunikat negatywnego potwierdzenia w takim przypadku na żądanie usługi kolejkowania komunikatów wskazuje odrzucenie wiadomości, aby aplikacja wysyłająca. Jeśli <xref:System.Messaging.Message.UseDeadLetterQueue%2A> właściwość jest `true`, na który zakończy się niepowodzeniem szyfrowania jest wysyłany komunikat do kolejki utraconych wiadomości. W przeciwnym razie wiadomość jest utracone.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> właściwości.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Acknowledgment" />
        <altmember cref="P:System.Messaging.Message.UseEncryption" />
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndPeek (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndPeek(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> , Które identyfikują na zakończenie operacji asynchronicznych wglądu i z którego można pobrać wyniku.</param>
        <summary>Kończy operację określonego peek asynchronicznego.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Skojarzone z ukończoną operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> wykonuje tę operację, który został zainicjowany przez <xref:System.Messaging.MessageQueue.BeginPeek%2A> wywołania. Aby to zrobić, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> dokonuje wiadomości.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> można określić limit czasu, co powoduje, że <xref:System.Messaging.MessageQueue.PeekCompleted> się sytuacji limit czasu, zanim pojawi się w kolejce zdarzenia. Jeśli upłynie limit czasu bez wiadomości przychodzącej w kolejce, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> zgłasza wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> jest używany do odczytu komunikat, który spowodował <xref:System.Messaging.MessageQueue.PeekCompleted> się zdarzenia.  
  
 Jeśli chcesz nadal asynchronicznie peek wiadomości, można ponownie wywołać <xref:System.Messaging.MessageQueue.BeginPeek%2A> po wywołaniu <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> zainicjować operacji asynchronicznych wglądu w kolejce, który znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, przykładzie dokonuje wiadomości i zapisuje jego treści do ekranu. Przykład wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie zainicjować nowej operacji asynchronicznych podglądu.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ EndReceive(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">
          <see cref="T:System.IAsyncResult" /> , Które identyfikują asynchroniczną na zakończenie operacji odbierania i z którego można pobrać wyniku.</param>
        <summary>Wykonuje określony asynchronicznej operacji odbioru.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Skojarzone z ukończoną operację asynchroniczną.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> wykonuje tę operację, który został zainicjowany przez <xref:System.Messaging.MessageQueue.BeginReceive%2A> wywołania. Aby to zrobić, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> odbiera wiadomości.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> można określić limit czasu, co powoduje, że <xref:System.Messaging.MessageQueue.ReceiveCompleted> się sytuacji limit czasu, zanim pojawi się w kolejce zdarzenia. Jeśli upłynie limit czasu bez wiadomości przychodzącej w kolejce, kolejne wywołanie <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> zgłasza wyjątek.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> jest używany do odczytu (usuwania z kolejki) komunikat, który spowodował <xref:System.Messaging.MessageQueue.ReceiveCompleted> się zdarzenia.  
  
 Jeśli chcesz kontynuować asynchronicznie otrzymywać wiadomości, można ponownie wywołać <xref:System.Messaging.MessageQueue.BeginReceive%2A> po wywołaniu <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod powiązany żądań asynchronicznych. Przyjęto założenie, że istnieje kolejki na komputerze lokalnym, o nazwie "Moja_kolejka". `Main` Funkcja rozpoczyna operację asynchroniczną, która jest obsługiwana przez `MyReceiveCompleted` procedury. `MyReceiveCompleted` przetwarzania bieżącego komunikatu i rozpocznie się nowy asynchronicznej operacji odbioru.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Składnia <paramref name="asyncResult" /> parametr jest nieprawidłowy.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (path As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Kolejki, aby znaleźć lokalizację.</param>
        <summary>Określa, czy kolejki usługi kolejkowania komunikatów istnieje w określonej ścieżce.</summary>
        <returns>
          <see langword="true" /> Jeśli istnieje kolejka z określoną ścieżką. w przeciwnym razie <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Metoda określa, czy kolejki usługi kolejkowania komunikatów istnieje w określonej ścieżce. Nie istnieje metoda można określić, czy istnieje kolejka o nazwie określonego formatu. Aby uzyskać więcej informacji na temat Składnia nazwy formatu i inne formy składnia ścieżki, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> jest kosztowna operacja. Używany tylko wtedy, gdy jest konieczne w aplikacji.  
  
> [!NOTE]
>  <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Metoda nie obsługuje <xref:System.Messaging.MessageQueue.FormatName%2A> prefiks.  
  
 Składnia `path` parametru zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29> Nie można wywołać sprawdzał zdalnego kolejki prywatnej.  
  
 Aby uzyskać więcej składni, zobacz <xref:System.Messaging.MessageQueue.Path%2A> właściwości.  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.Label%2A> do opisywania na ścieżkę kolejki.  
  
|Tematy pomocy|Składnia|  
|---------------|------------|  
|Etykieta|Etykiety: [ `label` ]|  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu sprawdza, czy istnieje, kolejki usługi kolejkowania komunikatów, a następnie usuwa je.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> Składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
 —lub—  
  
 <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> Metoda jest wywoływana na zdalnym kolejki prywatnej</exception>
        <exception cref="T:System.InvalidOperationException">Aplikacja używa Składnia nazwy formatu podczas sprawdzania istnienia kolejki.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FormatName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FormatName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera nazwę unikatowy kolejki usługi kolejkowania wiadomości generowany w momencie utworzenia kolejki.</summary>
        <value>Nazwa kolejki jest unikatowa w sieci.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.FormatName%2A> Właściwość zawiera nazwę formatu kolejki. Usługa kolejkowania komunikatów używa nazwy formatu do identyfikowania kolejki, które można otworzyć i dostępie do niego. W przeciwieństwie do większości właściwości kolejki nazwę formatu nie jest właściwością kolejkowania kolejki aplikacji, więc za pomocą narzędzia do zarządzania usługi kolejkowania komunikatów nie można do niego dostęp. Nazwa formatu jest po prostu unikatową nazwę kolejki usługi kolejkowania wiadomości generowany podczas tworzenia kolejki lub co aplikacja generuje później.  
  
 Jeśli można określić ścieżki przy użyciu składni nazwy ścieżki (takich jak `myComputer\myQueue`) zamiast używana jest składnia nazwy formatu podczas odczytu lub zapisu w kolejce, tłumaczy podstawowego kontrolera domeny (który korzysta z usługi Active Directory) <xref:System.Messaging.MessageQueue.Path%2A> do skojarzonego <xref:System.Messaging.MessageQueue.FormatName%2A> przed uzyskaniem dostępu do kolejki. Jeśli aplikacja działa w trybie offline, należy użyć składni nazwy formatu; w przeciwnym razie podstawowego kontrolera domeny nie będzie można wykonać translacji ścieżki.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.FormatName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Nie jest ustawiona.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="T:System.Messaging.MessageQueue" />
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberSignature Language="VB.NET" Value="Public Property Formatter As IMessageFormatter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::IMessageFormatter ^ Formatter { System::Messaging::IMessageFormatter ^ get(); void set(System::Messaging::IMessageFormatter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia element formatujący używany do serializacji obiektu do lub deserializacji obiektu z treści wiadomości odczytu lub zapisu w kolejce.</summary>
        <value>
          <see cref="T:System.Messaging.IMessageFormatter" /> Daje strumienia zapisywane lub odczytywać treść komunikatu. Wartość domyślna to <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Formatter%2A> Właściwość zawiera wystąpienie obiektu programu formatującego, który przekształca wiadomości, gdy aplikacja odczytuje i zapisuje do kolejki.  
  
 Gdy aplikacja wysyła wiadomość do kolejki, element formatujący serializuje obiekt do strumienia i wstawia je do treści wiadomości. Podczas czytania z kolejki, element formatujący deserializuje dane wiadomości do <xref:System.Messaging.Message.Body%2A> właściwość <xref:System.Messaging.Message>.  
  
 <xref:System.Messaging.XmlMessageFormatter> Jest luźno, więc nie ma tego samego obiektu typu na nadawcy i odbiorcy, korzystając z tego formatu. <xref:System.Messaging.ActiveXMessageFormatter> i <xref:System.Messaging.BinaryMessageFormatter> serializuje dane na reprezentacja binarna. <xref:System.Messaging.ActiveXMessageFormatter> Jest używany przy wysyłaniu lub odbieraniu składników COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter> i <xref:System.Messaging.ActiveXMessageFormatter> zapewniają większą przepustowość, niż <xref:System.Messaging.XmlMessageFormatter>. <xref:System.Messaging.ActiveXMessageFormatter> Umożliwia współdziałanie z aplikacjami usługi kolejkowania komunikatów w Visual Basic 6.0.  
  
 Gdy aplikacja wysyła wiadomości do kolejki, <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> ma zastosowanie tylko do tych wiadomości, korzystających z domyślnych właściwości komunikatu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. W przypadku wysłania <xref:System.Messaging.Message> do kolejki usługi kolejkowania komunikatów używa program formatujący zdefiniowane w <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwość, aby zamiast tego zserializować treść.  
  
 <xref:System.Messaging.MessageQueue> Klasy będzie zawsze używać <xref:System.Messaging.Message> do odbierania lub wgląd do wiadomości z kolejki. Komunikat jest deserializacji za pomocą <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 Poniższy przykład kodu pokazuje formatowania w treści wiadomości przy użyciu <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Messaging.XmlMessageFormatter" />
        <altmember cref="T:System.Messaging.ActiveXMessageFormatter" />
        <altmember cref="T:System.Messaging.BinaryMessageFormatter" />
        <altmember cref="P:System.Messaging.Message.Formatter" />
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllMessages () As Message()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Messaging::Message ^&gt; ^ GetAllMessages();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca wszystkie wiadomości w kolejce.</summary>
        <returns>Tablica typu <see cref="T:System.Messaging.Message" /> reprezentujący wszystkie wiadomości w kolejce, w takiej samej kolejności, w jakiej występują kolejki usługi kolejkowania komunikatów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> Zwraca statycznej migawki wiadomości w kolejce, linki nie dynamicznych do tych wiadomości. W związku z tym nie można użyć tablicy, aby zmodyfikować wiadomości w kolejce. Jeśli w czasie rzeczywistym, dynamicznych interakcji z kolejki (na przykład możliwość usunięcia wiadomości), należy wywołać <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> metodę, która zwraca listy dynamicznych wiadomości w kolejce.  
  
 Ponieważ <xref:System.Messaging.MessageQueue.GetAllMessages%2A> zwraca kopia wiadomości w kolejce w chwili metoda została wywołana, tablicy nie odzwierciedla nowe komunikaty przychodzące w kolejce lub wiadomości, które zostały usunięte z kolejki.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A> pobiera tylko te właściwości, które nie zostały odfiltrowane przez <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wylicza komunikaty w kolejce. <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> należy użyć.</summary>
        <returns>A <see cref="T:System.Collections.IEnumerator" /> zapewnia połączenie dynamiczne wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMachineId (machineName As String) As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Guid GetMachineId(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, który zawiera kolejki, bez dwa razy poprzedniego (\\\\).</param>
        <summary>Pobiera identyfikator komputera, na którym kolejki odwołuje się ten <see cref="T:System.Messaging.MessageQueue" /> znajduje się.</summary>
        <returns>A <see cref="T:System.Guid" /> reprezentujący Unikatowy identyfikator dla komputera, na którym znajduje się kolejka.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identyfikator komputera służy do dwóch celów, między innymi: można odczytać dziennika komputera i ustawić certyfikaty zabezpieczeń. Jednak nie można wywołać <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> dla komputera zdalnego podczas pracy w trybie offline, ponieważ aplikacja musi mieć dostęp do usługi katalogowej na kontrolerze domeny.  
  
 Identyfikator komputera (lub identyfikator maszyny) jest <xref:System.Guid> kolejkowania tworzącą po dodaniu komputera do organizacji. Usługa kolejkowania komunikatów łączy identyfikator komputera z `Machine` i `Journal` słowa kluczowe, aby utworzyć arkusz maszyny format nazwy, która ma składnię `Machine=<computeridentifier>;Journal`. Arkusza komputera, który jest również znane jako kolejki dziennika jest kolejki system, który przechowuje kopie generowany przez aplikację wiadomości, gdy <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> jest właściwość `true`.  
  
 Ta składnia dla dziennika jest prawidłowy tylko w przypadku, gdy konstruowania nazwy formatu dla kolejki. Składnia nazwy ścieżki jest `MachineName` \\ `Journal$`.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy kod przykładowy wywołania <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Identyfikator komputera nie można pobrać, prawdopodobnie ponieważ usługa katalogowa nie jest dostępna; na przykład, jeśli użytkownik pracuje w trybie offline.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich wiadomości w kolejce. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> jest przestarzały. <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> należy użyć.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> Zawierający wiadomości, które znajdują się w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> Tworzy listę dynamiczne wszystkie wiadomości w kolejce. Można usunąć z kolejki komunikatów w bieżącym położeniu modułu wyliczającego wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> dla <xref:System.Messaging.MessageEnumerator> który <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> zwraca.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę wiadomości w kolejce, wyliczenia odzwierciedla wszelkie zmiany wprowadzone w wiadomości w kolejce, jeśli komunikat jest poza bieżącym położeniu kursora. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp do wiadomości o niższym priorytecie umieszczone poza bieżącej pozycji kursora, ale nie komunikat o wyższym priorytecie wstawiony przed tym położeniu. Jednak można zresetować wyliczenia, a tym samym Przesuń kursor wstecz na początku listy, wywołując <xref:System.Messaging.MessageEnumerator.Reset%2A> dla <xref:System.Messaging.MessageEnumerator>.  
  
 Kolejność wiadomości w wyliczeniu odzwierciedla ich kolejność, w kolejce, więc przed o niższym priorytecie te pojawią się komunikaty o wyższym priorytecie.  
  
 Statyczne migawki do nich wiadomości w kolejce, a nie połączenia dynamicznego należy wywołać <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, które reprezentują wiadomości w czasie wywoływania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera dynamiczną listę komunikatów z kolejki i zlicza wszystkie komunikaty z <xref:System.Messaging.Message.Priority%2A> ustawioną właściwość <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMessageEnumerator2 () As MessageEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::MessageEnumerator ^ GetMessageEnumerator2();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla wszystkich wiadomości w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.MessageEnumerator" /> Zawierający wiadomości, które znajdują się w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> Tworzy listę dynamiczne wszystkie wiadomości w kolejce. Można usunąć z kolejki komunikatów w bieżącym położeniu modułu wyliczającego wywołując <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> dla <xref:System.Messaging.MessageEnumerator> który <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> zwraca.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę wiadomości w kolejce, wyliczenia odzwierciedla wszelkie zmiany wprowadzone w wiadomości w kolejce, jeśli komunikat jest poza bieżącym położeniu kursora. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp do wiadomości o niższym priorytecie umieszczone poza bieżącej pozycji kursora, ale nie komunikat o wyższym priorytecie wstawiony przed tym położeniu. Jednak można zresetować wyliczenia, a tym samym Przesuń kursor wstecz na początku listy, wywołując <xref:System.Messaging.MessageEnumerator.Reset%2A> dla <xref:System.Messaging.MessageEnumerator>.  
  
 Kolejność wiadomości w wyliczeniu odzwierciedla ich kolejność, w kolejce, więc przed o niższym priorytecie te pojawią się komunikaty o wyższym priorytecie.  
  
 Statyczne migawki do nich wiadomości w kolejce, a nie połączenia dynamicznego należy wywołać <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Ta metoda zwraca tablicę <xref:System.Messaging.Message> obiektów, które reprezentują wiadomości w czasie wywoływania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetAllMessages" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMessageQueueEnumerator">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tworzy obiekt modułu wyliczającego dla dynamiczną listę kolejek publicznych w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator () As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Udostępnia semantyki kursora tylko do przodu do sortowania wszystkich kolejek publicznych w sieci.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> zapewnia dynamiczną listę wszystkich kolejek publicznych wiadomości w sieci.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca wyliczenie wszystkich kolejek publicznych, które znajdują się w sieci.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę, wyliczenia odzwierciedla wszelkie zmiany wprowadzone do listy kolejki dla kolejek, usunięte lub dodane poza bieżącej pozycji kursora. Dodawania ani usuwania z kolejki znajdującej się przed bieżącej pozycji kursora nie zostaną uwzględnione. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp do kolejki dołączany poza pozycji kursora, ale nie jest elementem wstawiony przed tym położeniu. Jednak można zresetować wyliczenia, a tym samym Przesuń kursor wstecz na początku listy, wywołując <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> dla <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Nie ma zdefiniowanej kolejności kolejek w sieci. Moduł wyliczający nie zamówienia, na przykład przez komputer, etykiety, stan publicznych lub prywatnych lub innych kryteriów dostępny.  
  
 Statyczna migawka kolejek w sieci, a nie na dynamiczne połączenia do nich należy wywołać <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> lub <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, które reprezentują kolejkach w czasie wywoływania metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje kolejek wiadomości w sieci i sprawdza, czy ścieżka do każdej kolejki. Na koniec Wyświetla liczbę kolejek publicznych w sieci.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMessageQueueEnumerator (criteria As MessageQueueCriteria) As MessageQueueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::MessageQueueEnumerator ^ GetMessageQueueEnumerator(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> zawierający kryteria używane do filtrowania kolejki komunikatów dostępne.</param>
        <summary>Udostępnia semantyki kursora tylko do przodu do sortowania wszystkich kolejek publicznych w sieci, które spełniają określone kryteria.</summary>
        <returns>A <see cref="T:System.Messaging.MessageQueueEnumerator" /> zapewnia dynamiczną listę kolejek publicznych wiadomości w sieci, która spełnia określone przez ograniczenia <paramref name="criteria" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie metody <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> zwraca listę wszystkich kolejek publicznych w sieci, które spełniają kryteria zdefiniowane w kryteriach aplikacji. Można określić, że odpowiednie kryteria, aby uwzględnić, na przykład kolejka czas tworzenia i modyfikacji, nazwę komputera, etykiety, kategorii lub dowolnej ich kombinacji.  
  
 Ponieważ kursor jest skojarzony z dynamiczną listę, wyliczenie odzwierciedla wszystkie zmiany wprowadzone do kolejki, która występuje poza bieżącej pozycji kursora. Zmiany do kolejek znajdujących się przed bieżącą pozycją kursora nie są widoczne. Na przykład moduł wyliczający mogą automatycznie uzyskiwać dostęp do kolejki dołączany poza pozycji kursora, ale nie jest elementem wstawiony przed tym położeniu. Jednak można zresetować wyliczenia, a tym samym Przesuń kursor wstecz na początku listy, wywołując <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> dla <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Nie ma zdefiniowanej kolejności kolejek w sieci. Moduł wyliczający nie zamówienia, na przykład przez komputer, etykiety, stan publicznych lub prywatnych lub innych kryteriów dostępny.  
  
 Statyczna migawka kolejek w sieci, a nie na dynamiczne połączenia do nich należy określić kryteria <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> lub zadzwoń <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Każda z tych dwóch metod zwraca tablicę <xref:System.Messaging.MessageQueue> obiektów, które reprezentują kolejkach w czasie wywoływania metody. Wywoływanie <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, lub <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> zapewnia te same wyniki, co wywołanie <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> z kryteria filtrowania <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, i <xref:System.Messaging.MessageQueue.MachineName%2A>odpowiednio.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu iteruje kolejki komunikatów i jest wyświetlana ścieżka każdej kolejki, który został utworzony w ostatni dzień i która istnieje na komputerze "Mój komputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPrivateQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPrivateQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Komputer, z którego można pobrać znajdują się kolejki prywatne.</param>
        <summary>Pobiera wszystkich kolejek prywatnych na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiekty, które odwołują się kolejki prywatne pobrane.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29> pobiera migawkę statycznych kolejek na określonym komputerze.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr jest <see langword="null" /> lub ciąg pusty ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPublicQueues">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pobiera wszystkich kolejek publicznych w sieci.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues () As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera wszystkich kolejek publicznych w sieci.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów, które odwołują pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, jeśli chcesz, aby uzyskać pełną listę wszystkich kolejek publicznych w sieci. Jeśli chcesz ograniczyć listę według określonych kryteriów, takich jak <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, lub godzina ostatniej modyfikacji Użyj innego przeciążenia tej metody. (Można również użyć <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, lub <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> pobiera migawkę statycznych kolejek. Aby pracować interaktywnie z dynamiczną listę kolejek, użyj <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueues (criteria As MessageQueueCriteria) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueues(System::Messaging::MessageQueueCriteria ^ criteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">A <see cref="T:System.Messaging.MessageQueueCriteria" /> zawierający kryteria używane do filtrowania kolejek.</param>
        <summary>Pobiera wszystkich kolejek publicznych w sieci, które spełniają określone kryteria.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów, które odwołują pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeśli chcesz filtrować wszystkich kolejek publicznych w sieci przez etykiety, kategorii lub nazwa komputera <xref:System.Messaging.MessageQueue> klasa zawiera konkretnych metod, które zapewniają te funkcje (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, i <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>odpowiednio). To przeciążenie umożliwia wyświetlenie listy wszystkich kolejek publicznych w sieci spełniające więcej niż jedno z tych kryteriów (na przykład, jeśli chcesz określić kategorię i etykiety). Można również filtrować według kryteriów wiadomości innych niż <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, i <xref:System.Messaging.MessageQueue.MachineName%2A>. Na przykład użyć tego przeciążenia, aby filtrować według czasu ostatniej modyfikacji kolejki. Po prostu utworzyć nowe wystąpienie klasy <xref:System.Messaging.MessageQueueCriteria> klasy, ustaw odpowiednie właściwości w wystąpieniu, a następnie przekaż wystąpienie jako `criteria` parametru.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> pobiera migawkę statycznych kolejek. Aby pracować interaktywnie z dynamiczną listę kolejek, użyj <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueCriteria" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByCategory (category As Guid) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByCategory(Guid category);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">A <see cref="T:System.Guid" /> który grupy kolejek, które mają zostać pobrane.</param>
        <summary>Pobiera wszystkich kolejek publicznych w sieci należące do określonej kategorii.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów, które odwołują pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie według kategorii kolejek publicznych. <xref:System.Messaging.MessageQueue.Category%2A> Właściwości zapewnia dostęp do usługi kolejkowania komunikatów typu właściwości ID (czyli odczytu/zapisu) określonej kolejki. Chociaż można używać <xref:System.Guid.NewGuid%2A> można utworzyć wartości kategorii, która jest unikatowa dla wszystkich <xref:System.Guid> wartości, nie jest konieczne. Wartość kategorii musi się różnić tylko z innych kategorii, nie za wszystkie inne <xref:System.Guid> wartości. Na przykład można przypisać {00000000-0000-0000-0000-000000000001} jako <xref:System.Messaging.MessageQueue.Category%2A> dla jednego zestawu, kolejek i {00000000-0000-0000-0000-000000000002} jako <xref:System.Messaging.MessageQueue.Category%2A> dla innego zestawu.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29> pobiera migawkę statycznych kolejek. Aby pracować interaktywnie z dynamiczną listę kolejek, użyj <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Można określić kategorię jako część <xref:System.Messaging.MessageQueueCriteria> przekazywane do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByLabel (label As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByLabel(System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Etykiety, który grupuje zbiór kolejek, które mają zostać pobrane.</param>
        <summary>Pobiera wszystkich kolejek publicznych w sieci zawierających określonej etykiety.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów, które odwołują pobrane kolejek publicznych.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie kolejek publicznych przez etykietę.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29> pobiera migawkę statycznych kolejek. Aby pracować interaktywnie z dynamiczną listę kolejek, użyj <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Etykiety można określić jako część <xref:System.Messaging.MessageQueueCriteria> przekazywane do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPublicQueuesByMachine (machineName As String) As MessageQueue()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Messaging::MessageQueue ^&gt; ^ GetPublicQueuesByMachine(System::String ^ machineName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">Nazwa komputera, który zawiera zbiór kolejek publicznych, które mają zostać pobrane.</param>
        <summary>Pobiera wszystkich kolejek publicznych, które znajdują się na określonym komputerze.</summary>
        <returns>Tablica <see cref="T:System.Messaging.MessageQueue" /> obiektów, które odwołują się do kolejek publicznych, na komputerze.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia filtrowanie kolejek publicznych w przeliczeniu na komputer.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> pobiera migawkę statycznych kolejek. Aby pracować interaktywnie z dynamiczną listę kolejek, użyj <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Należy określić nazwę komputera, jako część <xref:System.Messaging.MessageQueueCriteria> przekazywane do metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Nie|  
|Komputer lokalny i bezpośredniej nazwy formatu|Nie|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera listę kolejek.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="machineName" /> Parametr ma niepoprawną składnię.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSecurityContext () As SecurityContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Messaging::SecurityContext ^ GetSecurityContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Pobiera kontekst zabezpieczeń, które MSMQ kojarzy z bieżącego użytkownika (tożsamość wątku) w czasie tego wywołania.</summary>
        <returns>A <see cref="T:System.Messaging.SecurityContext" /> obiekt, który zawiera kontekstu zabezpieczeń.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Messaging.Message.SecurityContext" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Guid Id { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera unikatowy identyfikator usługi kolejkowania komunikatów z kolejki.</summary>
        <value>A <see cref="P:System.Messaging.MessageQueue.Id" /> reprezentujący identyfikator wiadomości generowany przez aplikację usługi kolejkowania komunikatów.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ustawia usługi kolejkowania komunikatów <xref:System.Messaging.MessageQueue.Id%2A> właściwości podczas tworzenia kolejki. Ta właściwość jest dostępna tylko dla kolejek publicznych.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Id%2A> właściwości.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Category" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteQueueSize As Long " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly long InfiniteQueueSize;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy ma ograniczenia rozmiaru istnieje dla kolejki.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten element członkowski jest często używany podczas ustawiania <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> lub <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.InfiniteQueueSize> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteTimeout As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan InfiniteTimeout;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Określa, czy limit czasu nie istnieje dla metody peek lub odbierać wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue> obsługuje dwa rodzaje pobieranie wiadomości: synchroniczne i asynchroniczne. Metod synchronicznych <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.Receive%2A>, spowodować wątku procesu oczekiwania przedział czasu określony dla nowej wiadomości w kolejce. Jeśli jest określony interwał <xref:System.Messaging.MessageQueue.InfiniteTimeout>, wątku procesu pozostanie zablokowane do czasu udostępnienia nowego komunikatu. Z drugiej strony <xref:System.Messaging.MessageQueue.BeginPeek%2A> i <xref:System.Messaging.MessageQueue.BeginReceive%2A> (metod asynchronicznych), Zezwalaj, aby kontynuować w oddzielnym wątku, aż do nadejścia wiadomości w kolejce zadania głównej aplikacji.  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.InfiniteTimeout> elementu członkowskiego.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberSignature Language="VB.NET" Value="Public Property Label As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Label { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia opis kolejki.</summary>
        <value>Etykieta dla kolejki wiadomości. Wartością domyślną jest ciąg pusty ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Maksymalna długość etykiety kolejki wiadomość jest 124 znaki.  
  
 <xref:System.Messaging.MessageQueue.Label%2A> Właściwości nie musi być unikatowy w obrębie wszystkich kolejek. Jednak jeśli wielu kolejek mają takie same <xref:System.Messaging.MessageQueue.Label%2A>, nie można użyć <xref:System.Messaging.MessageQueue.Send%28System.Object%29> metodę, aby emitować wiadomość do wszystkich z nich. Jeśli używasz składnia etykiety <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania wiadomości, zostanie wygenerowany wyjątek Jeśli <xref:System.Messaging.MessageQueue.Label%2A> nie jest unikatowa.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Label%2A> właściwości.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Etykieta została ustawiona na nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastModifyTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime LastModifyTime { DateTime get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera czasu ostatniej modyfikacji właściwości kolejki.</summary>
        <value>A <see cref="T:System.DateTime" /> wskazujące ostatniej modyfikacji właściwości kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czas ostatniej modyfikacji obejmuje podczas tworzenia kolejki i wszelkie <xref:System.Messaging.MessageQueue> właściwości, które modyfikuje kolejki usługi kolejkowania komunikatów, takie jak <xref:System.Messaging.MessageQueue.BasePriority%2A>. Wartość <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwość reprezentuje czas systemowy na komputerze lokalnym.  
  
 Należy wywołać <xref:System.Messaging.MessageQueue.Refresh%2A> przed pobraniem <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwość; w przeciwnym razie czas modyfikacji skojarzonych z tym <xref:System.Messaging.MessageQueue> mogą być nieaktualne.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CreateTime" />
        <altmember cref="P:System.Messaging.MessageQueue.DenySharedReceive" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia nazwę komputera, na którym znajduje się kolejki usługi kolejkowania komunikatów.</summary>
        <value>Nazwa komputera, na którym znajduje się kolejka. Domyślnie usługi kolejkowania komunikatów ".", komputer lokalny.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MachineName%2A> Jest integralnym składnikiem składni przyjazną nazwę kolejki <xref:System.Messaging.MessageQueue.Path%2A>. W poniższej tabeli przedstawiono składnię, które powinny być używane dla kolejki o określonym typie należy zidentyfikować przy użyciu przyjaznej nazwy ścieżki kolejki.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejki utraconych wiadomości maszyny|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Użyj "." na komputerze lokalnym, określając <xref:System.Messaging.MessageQueue.MachineName%2A>. Nazwę komputera został rozpoznany dla tej właściwości, na przykład `Server0`. <xref:System.Messaging.MessageQueue.MachineName%2A> Właściwość nie obsługuje format adresu IP.  
  
 W przypadku definiowania <xref:System.Messaging.MessageQueue.Path%2A> w postaci liczby <xref:System.Messaging.MessageQueue.MachineName%2A>, aplikacja zgłasza wyjątek podczas pracy w trybie offline, ponieważ kontroler domeny jest wymagany do tłumaczenia ścieżki. W związku z tym należy użyć <xref:System.Messaging.MessageQueue.FormatName%2A> dla <xref:System.Messaging.MessageQueue.Path%2A> składni w trybie offline.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, I <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości są powiązane. Zmiana <xref:System.Messaging.MessageQueue.MachineName%2A> powoduje, że właściwość <xref:System.Messaging.MessageQueue.Path%2A> właściwości do zmiany. Jest ona wbudowana w ramach nowego <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A>. Zmiana <xref:System.Messaging.MessageQueue.Path%2A> (na przykład użyć składni nazwy formatu) resetuje <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości do odwoływania się do nowej kolejki. Jeśli <xref:System.Messaging.MessageQueue.QueueName%2A> właściwość jest pusta, <xref:System.Messaging.MessageQueue.Path%2A> jest ustawiona w kolejce dziennika komputera możesz określić.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MachineName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa komputera jest nieprawidłowa, prawdopodobnie ponieważ składnia jest nieprawidłowa.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumJournalSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumJournalSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki dziennika.</summary>
        <value>Maksymalny rozmiar w kilobajtach kolejki dziennika. Domyślnie usługi kolejkowania komunikatów Określa, że nie istnieje limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> zapewnia dostęp do limitu magazynu usługi kolejkowania komunikatów dziennika. Jest odpowiednie tylko wtedy, gdy <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> jest `true`. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień wpływa zmiana  
  
 Jeśli przechowujesz komunikaty w dzienniku lub kolejki utraconych wiadomości, należy okresowo czyścić kolejki, aby usunąć wiadomości, które nie są już potrzebne. Wiadomości w kolejce takie wliczane przydział wiadomości dla komputera, na którym znajduje się kolejka. (Administrator ustawia przydział komputera).  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> właściwości.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Rozmiar kolejki dziennika maksymalna ustawiono nieprawidłową wartość.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.UseJournalQueue" />
        <altmember cref="P:System.Messaging.MessageQueue.MaximumQueueSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumQueueSize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumQueueSize { long get(); void set(long value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia maksymalny rozmiar kolejki.</summary>
        <value>Maksymalny rozmiar w kilobajtach kolejki. Domyślnie usługi kolejkowania komunikatów Określa, że nie istnieje limit.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> Zapewnia dostęp do kolejkowania komunikatów limit magazynu, niezależnie od tego komputera komunikat przydział administrator definiuje. Aby uzyskać więcej informacji na temat przydział wiadomości, zobacz <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień wpływa zmiana  
  
 Jeśli podjęta próba przekracza maksymalny rozmiar kolejki i zasoby komputera wiadomości, komunikaty mogą zostać utracone. Po osiągnięciu limitu kolejki usługi kolejkowania komunikatów powiadamia kolejkę administracyjną wysyłania aplikacji, która wskazuje, czy kolejka jest pełna, zwracając komunikat negatywnego potwierdzenia. Usługa kolejkowania komunikatów będzie kontynuowane do wysyłania potwierdzeń ujemna, dopóki całkowity rozmiar wiadomości w kolejce nie spadnie poniżej limitu.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> właściwości.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Maksymalny rozmiar kolejki zawiera wartość ujemną.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberSignature Language="VB.NET" Value="Public Property MessageReadPropertyFilter As MessagePropertyFilter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::MessagePropertyFilter ^ MessageReadPropertyFilter { System::Messaging::MessagePropertyFilter ^ get(); void set(System::Messaging::MessagePropertyFilter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia filtr właściwości odbieranie lub wgląd do wiadomości.</summary>
        <value>
          <see cref="T:System.Messaging.MessagePropertyFilter" /> Używane przez kolejkę do filtrowania zbiór właściwości odbiera lub dokonuje dla każdego komunikatu.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ten filtr jest zestawem wartościami logicznymi ograniczanie właściwości wiadomości który <xref:System.Messaging.MessageQueue> odbiera lub dokonuje. Gdy <xref:System.Messaging.MessageQueue> odbiera lub dokonuje wiadomości z kolejki serwera pobiera tylko te właściwości, dla którego <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> wartość jest `true`.  
  
 Poniżej pokazano początkowe wartości właściwości dla <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> właściwości. Te ustawienia są identyczne z wywołaniem <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> na <xref:System.Messaging.MessagePropertyFilter>.  
  
|Właściwość|Wartość domyślna|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bajty|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bajtów|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> do ograniczenia właściwości wiadomości odebrane.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Filtr jest <see langword="null" />.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastAddress As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MulticastAddress { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Pobiera lub ustawia adres multiemisji skojarzony z kolejką.</summary>
        <value>A <see cref="T:System.String" /> zawiera nieprawidłowy adres multiemisji (w postaci pokazano poniżej) lub <see langword="null" />, co oznacza, że kolejka nie jest skojarzony z adresem multiemisji.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MulticastAddress%2A> Właściwość jest używana do skojarzenia z adresem multiemisji, który może być używana podczas wysyłania wiadomości-transakcyjne kolejki. Nie można skojarzyć kolejką transakcyjną z adresem multiemisji. Gdy aplikacja wysyłająca wysyła komunikaty do adresu multiemisji, usługi kolejkowania komunikatów wysyła kopię wiadomości do kolejki, co skojarzony z tym adresem.  
  
 Multiemisja IP adresy muszą być w zakresie klasy D od 224.0.0.0 do 239.255.255.255, który odpowiada ustawieniu pierwsze cztery bardziej znaczących bitów na wartość 1110. Jednak tylko określonych zakresów adresów w tym zakresie są bezwarunkowe i dostępne do wysyłania komunikatów multiemisji. Aby uzyskać najnowszą listę zarezerwowanych adresów multiemisji, zobacz [adresy multiemisji Internet Assigned numer Authority (IANA) Internet](http://go.microsoft.com/fwlink/?linkid=3859) strony sieci Web. Nie ma żadnych ograniczeń na numer portu.  
  
 Jeśli kilka komputerów źródłowych są wysyłanie komunikatów multiemisji i ma określonych kolejkę do odbierania wiadomości z tylko jednego komputera źródłowego, każdy komputer źródłowy musi wysyłać komunikaty do różnych kombinacji adres IP i port numer.  
  
 Aby usunąć skojarzenie kolejki z adresem multiemisji, należy ustawić <xref:System.Messaging.MessageQueue.MulticastAddress%2A> właściwości na ciąg o zerowej długości. Nie należy ustawiać na `null`, ponieważ spowoduje to <xref:System.ArgumentNullException>.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberSignature Language="VB.NET" Value="Public Property Path As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Path { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia ścieżkę kolejki. Ustawienie <see cref="P:System.Messaging.MessageQueue.Path" /> powoduje, że <see cref="T:System.Messaging.MessageQueue" /> aby wskazywał nową kolejkę.</summary>
        <value>Kolejki, do której odwołuje się do niego <see cref="T:System.Messaging.MessageQueue" />. Wartość domyślna zależy, która <see cref="M:System.Messaging.MessageQueue.#ctor" /> Użyj konstruktora; jest ona <see langword="null" /> lub jest określony przez konstruktora <paramref name="path" /> parametru.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Składnia <xref:System.Messaging.MessageQueue.Path%2A> właściwości zależy od typu kolejki go punktów do, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
|Kolejki dziennika komputera|`MachineName`\\`Journal$`|  
|Kolejki utraconych wiadomości maszyny|`MachineName`\\`Deadletter$`|  
|Kolejka utraconych wiadomości transakcyjnych komputera|`MachineName`\\`XactDeadletter$`|  
  
 Użyj "." do reprezentowania na komputerze lokalnym.  
  
 <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, I <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości są powiązane. Zmiana <xref:System.Messaging.MessageQueue.MachineName%2A> powoduje, że właściwość <xref:System.Messaging.MessageQueue.Path%2A> właściwości do zmiany. Jest ona wbudowana w ramach nowego <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A>. Zmiana <xref:System.Messaging.MessageQueue.Path%2A> (na przykład użyć składni nazwy formatu) resetuje <xref:System.Messaging.MessageQueue.MachineName%2A> i <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości do odwoływania się do nowej kolejki.  
  
 Alternatywnie można użyć <xref:System.Messaging.MessageQueue.FormatName%2A> lub <xref:System.Messaging.MessageQueue.Label%2A> do opisywania na ścieżkę kolejki, jak pokazano w poniższej tabeli.  
  
|Tematy pomocy|Składnia|Przykład|  
|---------------|------------|-------------|  
|Nazwa formatu|`FormatName:` [ *nazwy formatu* ]|`FormatName:Public=` 5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Etykieta|`Label:` [ *etykiety* ]|`Label:` TheLabel|  
  
 Jeśli używasz składnia etykiety <xref:System.Messaging.MessageQueue.Path%2A> właściwości podczas wysyłania wiadomości, zostanie wygenerowany wyjątek Jeśli <xref:System.Messaging.MessageQueue.Label%2A> nie jest unikatowa.  
  
 Aby praca w trybie offline, należy użyć Składnia nazwy formatu zamiast składni przyjazną nazwę w pierwszej tabeli. W przeciwnym wypadku jest zwracany wyjątek, ponieważ podstawowy kontroler domeny (na którym usługa Active Directory) nie jest dostępny, aby rozpoznać ścieżki do nazwy formatu.  
  
 Ustawianie nowej ścieżki zamyka kolejki komunikatów i zwalnia wszystkie dojścia.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
> [!NOTE]
>  W trybie grupy roboczej można używać tylko kolejek prywatnych. Określ ścieżkę przy użyciu składni kolejki prywatnej `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy nowy <xref:System.Messaging.MessageQueue> obiektów przy użyciu różnych typów składni nazwa ścieżki. W każdym przypadku wysyła komunikat do kolejki, których ścieżka jest zdefiniowana w konstruktorze.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ścieżka nie jest prawidłowa, prawdopodobnie ponieważ składnia jest nieprawidłowa.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.QueueName" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
        <altmember cref="P:System.Messaging.MessageQueue.FormatName" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.#ctor" />
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Peek">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <summary>Zwraca kopię pierwszej wiadomości w kolejce bez usuwania komunikatu z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Zwraca bez usuwania (dokonuje) to odwołanie do pierwszej wiadomości w kolejce <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> — Metoda jest synchroniczne, więc blokuje bieżącego wątku, dopóki komunikat o stanie się dostępny.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Reprezentujący do pierwszej wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia wgląd kolejki lub poczekaj, aż istnieje wiadomości w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa pierwszą wiadomość z kolejki. W związku z tym powtarzane wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracać ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. <xref:System.Messaging.MessageQueue.Receive%2A> Metody z drugiej strony, odczytuje i usuwa pierwszą wiadomość z kolejki. Powtarzane wywołania <xref:System.Messaging.MessageQueue.Receive%2A>, w związku z tym zwraca różnych wiadomości.  
  
 Usługa kolejkowania komunikatów zamówień wiadomości w kolejce według priorytetu i przyjęcia czasu. Nowsze wiadomość jest umieszczana przed stary tylko wtedy, gdy jest o wyższym priorytecie.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Ponieważ to przeciążenie nie określa limit czasu, aplikacja może czekać w nieskończoność. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody. Alternatywnie możesz określić limit czasu oczekiwania na odebranie w kolejce za pomocą przeciążenia wiadomości <xref:System.Messaging.MessageQueue.Peek%2A> , który określa limit czasu.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 W poniższych przykładach użyto <xref:System.Messaging.MessageQueue.Peek%2A> metody dla kolejki.  
  
 W pierwszym przykładzie aplikacja oczekuje, aż komunikat o stanie się dostępny w kolejce. Należy pamiętać, że pierwszym przykładzie nie dostępu do komunikat przychodzący; wstrzymuje jedynie przetwarzania do momentu nadejścia wiadomości. Jeśli komunikat już istnieje w kolejce, zwróci natychmiast.  
  
 W drugim przykładzie komunikat, który zawiera zdefiniowane przez aplikację `Order` klasy wysłanych do kolejki, a następnie przybywającej z kolejki.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Peek (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazuje, że maksymalny czas oczekiwania w kolejce zawiera komunikat.</param>
        <summary>Zwraca bez usuwania (dokonuje) to odwołanie do pierwszej wiadomości w kolejce <see cref="T:System.Messaging.MessageQueue" />. <see cref="M:System.Messaging.MessageQueue.Peek" /> — Metoda jest synchroniczne, więc blokuje bieżącego wątku do momentu wystąpienia określonego limitu czasu lub komunikat o stanie się dostępny.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Reprezentujący do pierwszej wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia podgląd kolejki lub istnieje w kolejce oczekiwania w określonym przedziale czasu, aż do wiadomości. Metoda zwraca natychmiast, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa pierwszą wiadomość z kolejki. W związku z tym powtarzane wywołania <xref:System.Messaging.MessageQueue.Peek%2A> zwracać ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. <xref:System.Messaging.MessageQueue.Receive%2A> Metody z drugiej strony, odczytuje i usuwa pierwszą wiadomość z kolejki. Powtarzane wywołania <xref:System.Messaging.MessageQueue.Receive%2A>, w związku z tym zwraca różnych wiadomości.  
  
 Usługa kolejkowania komunikatów zamówień wiadomości w kolejce według priorytetu i przyjęcia czasu. Nowsze wiadomość jest umieszczana przed stary tylko wtedy, gdy jest o wyższym priorytecie.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek będzie zablokowany do określonego okresu czasu lub nieskończoność Jeśli wskazana <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wykorzystuje <xref:System.Messaging.MessageQueue.Peek%2A> metody za pomocą limitu czasu o wartości zero, aby sprawdzić, czy kolejka jest pusta.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Peek(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::PeekAction action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazuje, że maksymalny czas oczekiwania w kolejce zawiera komunikat.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <param name="action">Jeden z <see cref="T:System.Messaging.PeekAction" /> wartości. Wskazuje, czy wglądu do bieżącej wiadomości w kolejce lub następny komunikat.</param>
        <summary>Zwraca bez usuwania (dokonuje) bieżącego lub dalej wiadomości z kolejki przy użyciu określonego kursora. <see cref="M:System.Messaging.MessageQueue.Peek" /> — Metoda jest synchroniczne, więc blokuje bieżącego wątku do momentu wystąpienia określonego limitu czasu lub komunikat o stanie się dostępny.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> reprezentujący wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia podgląd kolejki lub istnieje w kolejce oczekiwania w określonym przedziale czasu, aż do wiadomości. Metoda zwraca natychmiast, jeśli komunikat już istnieje w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Peek%2A> Metoda odczytuje, ale nie usuwa komunikat z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metody z drugiej strony, odczytuje i usuwa komunikat z kolejki.  
  
 Użyj <xref:System.Messaging.MessageQueue.Peek%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek jest zablokowana do określonego okresu czasu lub nieskończoność Jeśli wskazana <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Jeśli potrzebujesz przetwarzania aplikacji, aby kontynuować bez oczekiwania na użycie asynchronicznego <xref:System.Messaging.MessageQueue.BeginPeek%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Wartość inną niż <see langword="PeekAction.Current" /> lub <see langword="PeekAction.Next" /> określono <paramref name="action" /> parametru.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.PeekAction" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dokonuje wiadomość, która spełnia identyfikator korelacji danego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wgląd wiadomości.</param>
        <summary>Dokonuje komunikat, który jest zgodny z identyfikatorem korelacji danego i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem określonym korelacji nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, które odpowiadają `correlationID` parametru, jest zgłaszany wyjątek.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają peek wiadomości z kolejki. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Wgląd wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <summary>Dokonuje komunikat, który jest zgodny z identyfikatorem korelacji danego i oczekuje na komunikat z identyfikatorem korelacji określony jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, które odpowiadają `correlationID` parametr, a nie nowy komunikat dociera w kolejce w okresie wskazanym przez `timeout` parametru, jest zgłaszany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.CorrelationId%2A> wiadomości czy odpowiada `correlationId` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają peek wiadomości z kolejki. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie istnieje w kolejce, a nie przyszła przed wygaśnięciem limit czasu.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie przyszła przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.CorrelationId" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Zwraca kopia wiadomości, która zawiera identyfikator określony komunikat, nie usuwając wiadomość z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wgląd wiadomości.</param>
        <summary>Dokonuje komunikat, którego identyfikator komunikatu jest zgodna <paramref name="id" /> parametru.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu, bez usuwania z kolejki, komunikat, który ma identyfikator komunikatu znane. Identyfikator komunikatu jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. To przeciążenie zgłasza wyjątek, jeśli kolejka nie zawiera aktualnie wiadomości.  
  
 Dwie dodatkowe metody umożliwiają peek wiadomości w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszej wiadomości w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Żaden komunikat z określonym <paramref name="id" /> istnieje.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Wgląd wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <summary>Dokonuje komunikat, którego identyfikator komunikatu jest zgodna <paramref name="id" /> parametru. Oczekuje, aż pojawi się w kolejce lub przekroczenia limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> parametru.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> do odczytu, bez usuwania z kolejki, komunikat, który ma identyfikator komunikatu znane. Identyfikator komunikatu jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. To przeciążenie zgłasza wyjątek, jeśli kolejka nie zawiera aktualnie wiadomości i nowy komunikat został odebrany, zanim upłynie limit czasu.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.Id%2A> wiadomości czy odpowiada `id` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 Dwie dodatkowe metody umożliwiają peek wiadomości w kolejce: <xref:System.Messaging.MessageQueue.Peek%2A> i <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zwraca pierwszej wiadomości w kolejce; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> zwraca potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="id" /> nie istnieje w kolejce, a nie przyszła przed w okresie zdefiniowanym przez <paramref name="timeout" /> parametru wygasł.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="P:System.Messaging.Message.Id" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PeekByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu określonego komunikatu z kolejki. Można określić przez identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Wiadomości wglądu.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu do wiadomości, który jest zgodny z identyfikatorem danego wyszukiwania z kolejki nietransakcyjnej.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.LookupId" /> dopasowania właściwości <paramref name="lookupId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znane wyszukiwania bez jego usuwania z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce którym znajduje się komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytać wiadomość z określonemu identyfikatorowi przeszukiwania i usunąć go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="lookupId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function PeekByLookupId (action As MessageLookupAction, lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ PeekByLookupId(System::Messaging::MessageLookupAction action, long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Jeden z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określając sposób odczytywania komunikatu w kolejce. Określ jedną z następujących czynności:  
  
 <see langword="MessageLookupAction.Current" />: Dokonuje wglądu do wiadomości, określonej przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.Next" />: Dokonuje wglądu do wiadomości po wiadomości określonej przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.Previous" />: Dokonuje wglądu do wiadomości poprzedzającej wiadomość, określony przez <c>Lookupld</c>.  
  
 <see langword="MessageLookupAction.First" />: Dokonuje wglądu do pierwszej wiadomości w kolejce. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Dokonuje wglądu do ostatniej wiadomości w kolejce. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Komunikat do wglądu lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Dokonuje wglądu określonego komunikatu z kolejki. Można określić przez identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki wiadomości.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określonego przez <paramref name="action" /> i <paramref name="lookupId" /> przekazano parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znane wyszukiwania bez jego usuwania z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce którym znajduje się komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytać wiadomość z określonym identyfikatorem i usunąć go z kolejki, użyj <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="lookupId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.ReceiveByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PeekCompleted As PeekCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::PeekCompletedEventHandler ^ PeekCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wiadomość zostanie odczytana bez usuwania z kolejki. Jest to wynik operacji asynchronicznej <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A> jest używany podczas przetwarzania asynchronicznego podnieść <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie, gdy komunikat jest dostępna w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> Służy do przeprowadzenia operacji inicjowane przez wywołanie do <xref:System.Messaging.MessageQueue.BeginPeek%2A> i wgląd do wiadomości gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenia.  
  
 Po utworzeniu <xref:System.Messaging.PeekCompletedEventHandler> delegata, należy określić metodę, która obsłuży zdarzenie. Aby skojarzyć zdarzenie z obsługi zdarzenia, należy dodać wystąpienia delegata zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyPeekCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.PeekCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginPeek%2A> zainicjować operacji asynchronicznych wglądu w kolejce, który znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.PeekCompleted> zdarzenie jest zgłaszane, przykładzie dokonuje wiadomości i zapisuje jego treści do ekranu. Przykład wywołuje <xref:System.Messaging.MessageQueue.BeginPeek%2A> ponownie zainicjować nowej operacji asynchronicznych podglądu  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberSignature Language="VB.NET" Value="Public Sub Purge ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Purge();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usuwa wszystkie komunikaty znajdujące się w kolejce.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Czyszczenie kolejki powoduje, że można ustawić flagi modyfikacji kolejki, który ma wpływ na usługi kolejkowania komunikatów <xref:System.Messaging.MessageQueue.LastModifyTime%2A> właściwości. Wiadomości, które zostaną usunięte z kolejki są tracone; nie są wysyłane do kolejki utraconych wiadomości lub kolejki dziennika.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Close" />
        <altmember cref="M:System.Messaging.MessageQueue.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberSignature Language="VB.NET" Value="Public Property QueueName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ QueueName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia przyjazną nazwę identyfikującą kolejkę.</summary>
        <value>Nazwę identyfikującą kolejkę odwołuje się to <see cref="T:System.Messaging.MessageQueue" />. Wartość nie może być <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Możesz połączyć ze sobą <xref:System.Messaging.MessageQueue.QueueName%2A> z <xref:System.Messaging.MessageQueue.MachineName%2A> utworzyć przyjazną nazwę w polu <xref:System.Messaging.MessageQueue.Path%2A> nazwę kolejki. Składnia zmiany przyjazną nazwę <xref:System.Messaging.MessageQueue.Path%2A> właściwości zależy od typu kolejki, jak pokazano w poniższej tabeli.  
  
|Typ kolejki|Składnia|  
|----------------|------------|  
|Kolejki publicznej|`MachineName`\\`QueueName`|  
|Kolejki prywatnej|`MachineName`\\`Private$`\\`QueueName`|  
|Kolejki dziennika|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Użyj "." do reprezentowania na komputerze lokalnym.  
  
 Zmiana <xref:System.Messaging.MessageQueue.QueueName%2A> właściwość ma wpływ na <xref:System.Messaging.MessageQueue.Path%2A> właściwości. Jeśli ustawisz <xref:System.Messaging.MessageQueue.QueueName%2A> bez ustawienia <xref:System.Messaging.MessageQueue.MachineName%2A> właściwość <xref:System.Messaging.MessageQueue.Path%2A> staje się właściwości.\\ `QueueName`. W przeciwnym razie <xref:System.Messaging.MessageQueue.Path%2A> staje się `MachineName` \\ `QueueName`.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Tak|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.QueueName%2A> właściwości.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nazwa kolejki jest <see langword="null" />.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="P:System.Messaging.MessageQueue.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ReadHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty używany do odczytu wiadomości z kolejki wiadomości.</summary>
        <value>Dojście do obiektu kolejki natywnego służące do wybierania i odbierania wiadomości z kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.ReadHandle%2A> Zapewnia uchwyt macierzysty systemu Windows do obiektu kolejki komunikatów, który służy do wybierania i odbierania wiadomości z kolejki. W przypadku zmiany ścieżki do kolejki, dojście jest zamknięte i ponownie otworzyć z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanRead" />
        <altmember cref="P:System.Messaging.MessageQueue.WriteHandle" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <summary>Odbiera pierwszej wiadomości w kolejce usuwając ją z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżącego wątku wykonywania, dopóki wiadomości jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikatu z kolejki lub poczekaj, aż są wiadomości w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwrócą komunikaty, które należy wykonać w kolejce lub nowe, wyższy priorytet wiadomości.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Ponieważ to przeciążenia z <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończonego limitu czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wiadomości z kolejki i wyświetla informacje o tej wiadomości do ekranu.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce transakcyjne odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżącego wątku wykonywania, dopóki wiadomości jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikat o błędzie z kolejką transakcyjną przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametr lub zaczekaj, aż są wiadomości w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci komunikatów, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłoby niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Ponieważ to przeciążenia z <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończonego limitu czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykładowy kod łączy się kolejką transakcyjną na komputerze lokalnym i wysyła komunikat do kolejki. Odbiera komunikat, który zawiera zamówienia. W przypadku napotkania nietransakcyjnej kolejki zgłosi i wyjątku i wycofywania transakcji.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Kolejka jest transakcyjna.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i blokuje bieżącego wątku wykonywania, dopóki wiadomości jest dostępna.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można odebrać wiadomości z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametr lub zaczekaj, aż są wiadomości w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci komunikatów, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłoby niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Ponieważ to przeciążenia z <xref:System.Messaging.MessageQueue.Receive%2A> metody określa nieskończonego limitu czasu, aplikacja może czekać w nieskończoność. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" /> i czeka, aż do wiadomości jest dostępna w kolejce, lub przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikat o błędzie i zwraca w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwa ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwrócą komunikaty, które należy wykonać w kolejce lub nowe, wyższy priorytet wiadomości.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek będzie zablokowany dla podanego okresu czasu lub przez czas nieokreślony, jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu odbiera wiadomości z kolejki i wyświetla informacje o tej wiadomości do ekranu. Przykład wstrzymuje wykonywanie do pięciu sekund czasu oczekiwania na wiadomość w kolejce.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <summary>Odbiera bieżącej wiadomości w kolejce, przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda oczekuje, aż wiadomości jest dostępna, albo przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów  
  
 To przeciążenie umożliwia komunikat o błędzie i zwraca w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce transakcyjne odwołuje się <see cref="T:System.Messaging.MessageQueue" /> i czeka, aż do wiadomości jest dostępna w kolejce, lub przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikat o błędzie z kolejką transakcyjną przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametr i zwracany w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci komunikatów, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłoby niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek będzie zablokowany dla podanego okresu czasu lub przez czas nieokreślony, jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje korzystać z tej metody.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat pierwszy dostępny w kolejce odwołuje się <see cref="T:System.Messaging.MessageQueue" />. To wywołanie jest synchroniczne i czeka, aż do wiadomości jest dostępna w kolejce, lub przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> który odwołuje się do pierwszej wiadomości w kolejce dostępne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można odebrać wiadomości z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametr i zwracany w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwróci komunikatów, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać do pierwszej wiadomości w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. <xref:System.Messaging.MessageQueue.Peek%2A> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie byłoby niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek będzie zablokowany dla podanego okresu czasu lub przez czas nieokreślony, jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje korzystać z tej metody.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera bieżącej wiadomości w kolejce, przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda oczekuje, aż wiadomości jest dostępna, albo przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołującą wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia komunikat o błędzie z kolejką transakcyjną przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametr i zwracany w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwraca wiadomości, które należy wykonać w kolejce.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu jest zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać wiadomość w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie ma niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek jest zablokowana dla podanego okresu czasu lub przez czas nieokreślony, jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ Receive(TimeSpan timeout, System::Messaging::Cursor ^ cursor, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="cursor">A <see cref="T:System.Messaging.Cursor" /> który przechowuje określone miejsce w kolejce wiadomości.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości, które opisuje typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera bieżącej wiadomości w kolejce, przy użyciu określonego kursora. Jeśli żaden komunikat nie jest dostępny, ta metoda oczekuje, aż wiadomości jest dostępna, albo przekroczeniu limitu czasu.</summary>
        <returns>A <see cref="T:System.Messaging.Message" /> odwołującą wiadomości w kolejce.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia można odebrać wiadomości z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametr i zwracany w danym okresie czasu, jeśli nie ma żadnych komunikatów w kolejce.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.MessageQueue.Receive%2A> Metoda umożliwia synchroniczne odczytywanie wiadomości, usuwając ją z kolejki. Kolejne wywołania <xref:System.Messaging.MessageQueue.Receive%2A> zwraca wiadomości, które należy wykonać w kolejce.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu jest zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać wiadomość w kolejce bez usuwania go z kolejki, użyj <xref:System.Messaging.MessageQueue.Peek%2A> metody. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.Peek%2A>. Ponieważ <xref:System.Messaging.MessageQueue.Peek%2A> nie usuwa wszystkie wiadomości w kolejce, nie ma niczego do przywrócenia przez wywołanie do <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Użyj wywołania <xref:System.Messaging.MessageQueue.Receive%2A> gdy jest akceptowalne dla bieżącego wątku być blokowane podczas oczekiwania na odebranie w kolejce wiadomości. Wątek jest zablokowana dla podanego okresu czasu lub przez czas nieokreślony, jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametru. Jeśli przetwarzanie aplikacji powinno być kontynuowane bez oczekiwania na wiadomość, należy rozważyć użycie metody asynchronicznej <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="cursor" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy. Prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat nie został odebrany w kolejce, przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <threadsafe>Metoda nie jest bezpieczne dla wątków.</threadsafe>
        <altmember cref="T:System.Messaging.Cursor" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByCorrelationId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat, który odpowiada identyfikator korelacji danego.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejki nietransakcyjnej) i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem określonym korelacji nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce nietransakcyjnej odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, które odpowiadają `correlationID` parametru, jest zgłaszany wyjątek. W przeciwnym razie wiadomość jest usuwane z kolejki i zwrócony do aplikacji.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda pobiera komunikat, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła i odbiera wiadomość zawierającą kolejność do i z kolejki. Go zażąda potwierdzenia dodatnią oryginalnej wiadomości osiągnie lub jest pobierane z kolejki.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejką transakcyjną) i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem określonym korelacji nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w transakcyjnej kolejki odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, które odpowiadają `correlationID` parametru, jest zgłaszany wyjątek. W przeciwnym razie usuniętych z kolejki i powrót do aplikacji przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez komunikat `transaction` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego i natychmiast zgłasza wyjątek, jeśli żaden komunikat z identyfikatorem określonym korelacji nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Jeśli żaden komunikat nie zostanie znaleziony, które odpowiadają `correlationID` parametru, jest zgłaszany wyjątek. W przeciwnym razie usuniętych z kolejki i powrót do aplikacji w kontekście transakcji zdefiniowanych przez komunikat `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejki nietransakcyjnej) i oczekuje na komunikat z identyfikatorem korelacji określony jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce nietransakcyjnej odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametru jest w kolejce. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.CorrelationId%2A> wiadomości czy odpowiada `correlationId` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> nie istnieje w kolejce, a nie przyszła przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego (z kolejką transakcyjną) i oczekuje na komunikat z identyfikatorem korelacji określony jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w transakcyjnej kolejki odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametru jest w kolejce, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.CorrelationId%2A> wiadomości czy odpowiada `correlationId` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> nie istnieje w kolejce, a nie przyszła przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByCorrelationId (correlationId As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByCorrelationId(System::String ^ correlationId, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">
          <see cref="P:System.Messaging.Message.CorrelationId" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z identyfikatorem korelacji danego i oczekuje na komunikat z identyfikatorem korelacji określony jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.CorrelationId" /> odpowiada <paramref name="correlationId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda jest wyszukiwany w kolejce odwołuje się <xref:System.Messaging.MessageQueue> wiadomości których <xref:System.Messaging.Message.CorrelationId%2A> jest zgodna z określoną `correlationId` parametru. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem korelacji określony przez `correlationId` parametr jest w kolejce w kontekście transakcji zdefiniowanych przez `transactionType` parametru. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.CorrelationId%2A> wiadomości czy odpowiada `correlationId` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.CorrelationId%2A> Dopasowuje `correlationId` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 <xref:System.Messaging.Message.CorrelationId%2A> Właściwość jest używana do powiązania komunikatu wysłanego do kolejki, aby skojarzone wiadomości odpowiedzi, raportu lub potwierdzenia.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> metoda służy do pobierania wiadomości, określając jego unikatowy identyfikator.  
  
 Aby odczytać wiadomość z identyfikatorem korelacji określony bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="correlationId" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="correlationId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="correlationId" /> nie istnieje w kolejce, a nie przyszła przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveById">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem, usuwa ją z kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem z nietransakcyjnej kolejki i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="id" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejką transakcyjną) i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru. Ta metoda zwraca natychmiast wyjątek, jeśli komunikat nie jest w kolejce  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="id" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem i natychmiast zgłasza wyjątek, jeśli żaden komunikat o podanym identyfikatorze nie istnieje w kolejce.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce. W przeciwnym razie usuniętych z kolejki i powrót do aplikacji w kontekście transakcji zdefiniowanych przez komunikat `transactionType` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. Jeśli komunikat o podanym identyfikatorze jest w kolejce innego niż ten, który został skojarzony z tym <xref:System.Messaging.MessageQueue> wystąpienia, wiadomości nie zostaną znalezione.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="id" /> nie można odnaleźć.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejki nietransakcyjnej) i oczekuje na komunikat o podanym identyfikatorze jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem określony przez `id` parametru jest w kolejce. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.Id%2A> wiadomości czy odpowiada `id` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest akceptowalne dla bieżącego wątku zablokowanie tak długo, jak nowe wiadomości nadal nadchodzą w kolejce w ramach limitu czasu określonego przez `timeout` parametru. Wątek będzie zablokowany dla co najmniej podanego okresu czasu lub nieskończoność Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe komunikaty w dalszym ciągu odbierane w kolejce w ramach limitu czasu określonego przez `timeout` parametr.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> nie został odebrany w kolejce przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem (z kolejką transakcyjną) i oczekuje na komunikat o podanym identyfikatorze jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem określony przez `id` parametru jest w kolejce. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.Id%2A> wiadomości czy odpowiada `id` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest akceptowalne dla bieżącego wątku zablokowanie tak długo, jak nowe wiadomości nadal nadchodzą w kolejce w ramach limitu czasu określonego przez `timeout` parametru. Wątek będzie zablokowany dla co najmniej podanego okresu czasu lub nieskończoność Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe komunikaty w dalszym ciągu odbierane w kolejce przed upływem limitu czasu określonego przez `timeout` parametr.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> nie został odebrany w kolejce przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Kolejka jest transakcyjna.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveById (id As String, timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveById(System::String ^ id, TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">
          <see cref="P:System.Messaging.Message.Id" /> Do odbierania wiadomości.</param>
        <param name="timeout">A <see cref="T:System.TimeSpan" /> wskazująca czas oczekiwania, aż do nowej wiadomości jest dostępna dla kontroli.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Odbiera komunikat, który jest zgodny z danym identyfikatorem i oczekuje na komunikat o podanym identyfikatorze jest dostępne w kolejce albo przekroczeniu limitu czasu.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.Id" /> dopasowania właściwości <paramref name="id" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znanych i usunąć go z kolejki. Ta metoda zwraca natychmiast, jeśli komunikat z identyfikatorem określony przez `id` parametr jest w kolejce w kontekście transakcji zdefiniowanych przez `transactionType` parametru. W przeciwnym razie metoda oczekuje podanego okresu czasu na odebranie nowych wiadomości. Jeśli nowy komunikat został odebrany przed upływem limitu czasu, jest zwracany wyjątek.  
  
 `timeout` Parametr określa całkowita czasu dla tej metody. Zamiast określa czas oczekiwania na nowe wiadomości w kolejce. Zawsze nadejścia nowych wiadomości, ta metoda sprawdza <xref:System.Messaging.Message.Id%2A> wiadomości czy odpowiada `id` parametru. Jeśli nie, ta metoda rozpoczyna się okres limitu czasu przez i czeka na innej nowej wiadomości do odbierania. W związku z tym nowe komunikaty kontynuowania odebranie w tym czasie, istnieje możliwość tę metodę, aby kontynuować, dopóki nie upłynie limit czasu bez nowych wiadomości przychodzących lub aż do nadejścia wiadomości, których <xref:System.Messaging.Message.Id%2A> Dopasowuje `id` parametru.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 <xref:System.Messaging.Message.Id%2A> Właściwości wiadomości jest unikatowa w przedsiębiorstwie usługi kolejkowania komunikatów, więc będzie istnieć co najwyżej jeden komunikat w kolejce, który odpowiada danym `id` parametru. Jeśli komunikat o podanym identyfikatorze jest w kolejce innego niż ten, który został skojarzony z tym <xref:System.Messaging.MessageQueue> wystąpienia, wiadomości nie zostaną znalezione.  
  
 Użyj tego przeciążenia <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> gdy jest akceptowalne dla bieżącego wątku zablokowanie tak długo, jak nowe wiadomości nadal nadchodzą w kolejce w ramach limitu czasu określonego przez `timeout` parametru. Wątek będzie zablokowany dla co najmniej podanego okresu czasu lub nieskończoność Jeśli określona wartość <xref:System.Messaging.MessageQueue.InfiniteTimeout> dla `timeout` parametr, lub jeśli nowe komunikaty w dalszym ciągu odbierane w kolejce w ramach limitu czasu określonego przez `timeout` parametr.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Dwa inne metody umożliwiają odbieranie komunikatów z kolejki. <xref:System.Messaging.MessageQueue.Receive%2A> Metoda zwraca pierwszej wiadomości w kolejce i <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> metoda jest używana do pobrania potwierdzenia, raportu lub wiadomości odpowiedzi generowane przez aplikację, który został utworzony w wyniku komunikatu wysłanego do kolejki.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> metody. <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> Metoda zawsze zwraca pierwszej wiadomości w kolejce, więc kolejne wywołania metody zwrócić ten sam komunikat, chyba że dociera wyższy priorytet wiadomości w kolejce. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Ponieważ <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> nie usuwa wszystkie wiadomości w kolejce, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Wartość określona dla <paramref name="timeout" /> parametr jest nieprawidłowy, prawdopodobnie <paramref name="timeout" /> jest mniejsza niż <see cref="F:System.TimeSpan.Zero" /> lub większa niż <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Komunikat z określonym <paramref name="id" /> nie został odebrany w kolejce przed wygaśnięciem limit czasu.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveByLookupId">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera określonego komunikatu z kolejki. Można określić przez identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki wiadomości.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (lookupId As Long) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(long lookupId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Do odbierania wiadomości.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera komunikat, który jest zgodny z identyfikatorem danego wyszukiwania z kolejki nietransakcyjnej.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Których <see cref="P:System.Messaging.Message.LookupId" /> dopasowania właściwości <paramref name="lookupId" /> przekazany parametr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znane wyszukiwania i usunąć go z kolejki. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce którym znajduje się komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytać wiadomość z określonemu identyfikatorowi przeszukiwania, bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="lookupId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Jeden z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określając sposób odczytywania komunikatu w kolejce. Określ jedną z następujących czynności:  
  
 <see langword="MessageLookupAction.Current" />: Odbiera wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Odbiera wiadomość następującą wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Odbiera wiadomość poprzedzającą wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszej wiadomości w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatniej wiadomości w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Do odbierania wiadomości lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera określonego komunikatu z kolejką transakcyjną. Można określić przez identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki wiadomości.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określonego przez <paramref name="lookupId" /> i <paramref name="action" /> przekazano parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znane wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transaction` parametru. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce którym znajduje się komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Ponieważ ta metoda jest wywoływana na kolejką transakcyjną, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nie usuwa wszystkie wiadomości z kolejki, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="lookupId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.  
  
 —lub—  
  
 Kolejka jest transakcyjna.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveByLookupId (action As MessageLookupAction, lookupId As Long, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ ReceiveByLookupId(System::Messaging::MessageLookupAction action, long lookupId, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Jeden z <see cref="T:System.Messaging.MessageLookupAction" /> wartości, określając sposób odczytywania komunikatu w kolejce. Określ jedną z następujących czynności:  
  
 <see langword="MessageLookupAction.Current" />: Odbiera wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Next" />: Odbiera wiadomość następującą wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.Previous" />: Odbiera wiadomość poprzedzającą wiadomość, określony przez <c>Lookupld</c> i usuwa go z kolejki.  
  
 <see langword="MessageLookupAction.First" />: Odbiera pierwszej wiadomości w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.  
  
 <see langword="MessageLookupAction.Last" />: Odbiera ostatniej wiadomości w kolejce i usuwa go z kolejki. <c>Lookupld</c> parametru musi być równa 0.</param>
        <param name="lookupId">
          <see cref="P:System.Messaging.Message.LookupId" /> Do odbierania wiadomości lub 0. 0 jest używany podczas uzyskiwania dostępu do pierwszej lub ostatniej wiadomości w kolejce.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wprowadzono w usłudze MSMQ 3.0. Odbiera określonego komunikatu z kolejki przy użyciu kontekstu określonej transakcji. Można określić przez identyfikator wyszukiwania lub położenia na wierzch lub na końcu kolejki wiadomości.</summary>
        <returns>
          <see cref="T:System.Messaging.Message" /> Określonego przez <paramref name="action" /> i <paramref name="lookupId" /> przekazano parametrów.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ta metoda umożliwia Przeczytaj wiadomość z identyfikatorem znane wyszukiwania i usunąć go z kolejki przy użyciu kontekstu transakcji, zdefiniowane przez `transactionType` parametru. Ta metoda zgłasza wyjątek natychmiast, jeśli komunikat nie jest w kolejce.  
  
 <xref:System.Messaging.Message.LookupId%2A> Właściwość wiadomości jest unikatowa w kolejce którym znajduje się komunikat zostanie co najwyżej jeden komunikat w kolejce, który odpowiada danym `lookupId` parametru.  
  
 Aby odczytać wiadomość z określonym identyfikatorem bez jego usuwania z kolejki, użyj <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> metody. Nie jest skojarzony z komunikatem zwrócony przez wywołanie do kontekst transakcji <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Ponieważ <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> nie usuwa wszystkie wiadomości z kolejki, nie byłoby nic wycofanie ponownie, jeśli transakcja zostało przerwane.  
  
 Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do odbierania wiadomości. Określ `Single` Jeśli chcesz otrzymywać wiadomości jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz otrzymywać wiadomość z kolejki transakcyjnej poza kontekstem transakcji.  
  
 Jeśli ta metoda jest wywoływana, aby otrzymywać wiadomość z kolejki transakcyjnej, odebranego komunikatu czy zwracana do kolejki, jeśli transakcja została przerwana. Komunikat nie zostanie trwale usunięta z kolejki, dopóki transakcja została przekazana.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Usługa MSMQ 3.0 nie jest zainstalowany.</exception>
        <exception cref="T:System.InvalidOperationException">Komunikat z określonym <paramref name="lookupId" /> nie można odnaleźć.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="action" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageLookupAction" /> elementów członkowskich.  
  
 —lub—  
  
 <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <altmember cref="P:System.Messaging.Message.LookupId" />
        <altmember cref="M:System.Messaging.MessageQueue.PeekByLookupId" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReceiveCompleted As ReceiveCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Messaging::ReceiveCompletedEventHandler ^ ReceiveCompleted;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Występuje, gdy wiadomość została usunięta z kolejki. To zdarzenie jest wywoływane przez operację asynchroniczną, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A> jest używany podczas przetwarzania asynchronicznego podnieść <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie, gdy komunikat jest dostępna w kolejce.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> Służy do przeprowadzenia operacji inicjowane przez wywołanie do <xref:System.Messaging.MessageQueue.BeginReceive%2A> i wgląd do wiadomości gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenia.  
  
 Po utworzeniu <xref:System.Messaging.ReceiveCompletedEventHandler> delegata, należy określić metodę, która obsłuży zdarzenie. Aby skojarzyć zdarzenie z obsługi zdarzenia, należy dodać wystąpienia delegata zdarzenia. Program obsługi zdarzeń jest wywoływany przy każdym wystąpieniu zdarzenia, o ile nie usunięto delegata. Aby uzyskać więcej informacji na temat delegatów obsługi zdarzeń, zobacz [Obsługa i wywoływanie zdarzeń](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Poniższy przykład kodu tworzy program obsługi zdarzeń o nazwie `MyReceiveCompleted`, dołącza go do <xref:System.Messaging.MessageQueue.ReceiveCompleted> delegata obsługi zdarzeń i wywołania <xref:System.Messaging.MessageQueue.BeginReceive%2A> zainicjować asynchronicznego odbioru operacji w kolejce, który znajduje się w ścieżce ". \myQueue". Gdy <xref:System.Messaging.MessageQueue.ReceiveCompleted> zdarzenie jest zgłaszane, przykładzie odbiera wiadomości i zapisuje jego treści ekranu. Przykład wywołuje <xref:System.Messaging.MessageQueue.BeginReceive%2A> ponownie zainicjować nowe asynchronicznej operacji odbioru.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="T:System.TimeSpan" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Odświeża właściwości przedstawiony przez <see cref="T:System.Messaging.MessageQueue" /> aby odzwierciedlały bieżący stan zasobu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A> Synchronizuje właściwości <xref:System.Messaging.MessageQueue> z jego skojarzonych zasobów usługi kolejkowania komunikatów serwera. Jeśli wszystkie właściwości, takie jak <xref:System.Messaging.MessageQueue.Label%2A> lub <xref:System.Messaging.MessageQueue.Category%2A>, na serwerze został zmieniony od czasu <xref:System.Messaging.MessageQueue> został utworzony, <xref:System.Messaging.MessageQueue.Refresh%2A> aktualizacje <xref:System.Messaging.MessageQueue> przy użyciu nowych informacji.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageQueue.GetPublicQueues" />
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetPermissions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetPermissions();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resetuje listę uprawnień do wartości domyślnych systemu operacyjnego. Usuwa wszystkie uprawnienia kolejki, który ma być dołączany do listy domyślnych.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Podczas wywoływania <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, zwróć listy uprawnień do jego wartości domyślnych. Ogólnie rzecz biorąc, to przyznaje wszystkie uprawnienia twórca kolejki i zapewnia grupy Wszyscy następujące uprawnienia:  
  
-   Pobierz właściwości kolejki.  
  
-   Pobierz uprawnienia kolejki.  
  
-   Zapis do kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wysyła obiekt do kolejki.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej odwołuje się to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do kolejki odwołuje się <xref:System.Messaging.MessageQueue>. Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message> lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli używasz tego przeciążenia do wysyłania wiadomości do kolejki transakcyjnej wiadomość zostanie wysłana do kolejki utraconych wiadomości. Komunikat, który ma być częścią transakcji, które zawiera inne komunikaty, należy użyć przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu łączy do kolejki komunikatów i wysyła komunikat do kolejki.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 Poniższy przykład kodu wysyła zdefiniowane przez aplikację `Order` klasy do kolejki, a następnie odbiera wiadomości z tej kolejki.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Path" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wysyła obiekt do transakcyjnej kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do transakcyjnej kolejki odwołuje się <xref:System.Messaging.MessageQueue>, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru. Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message> lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli używasz tego przeciążenia do wysyłania wiadomości do kolejki nietransakcyjnej może wysłać komunikatu do kolejki utraconych wiadomości bez generowania wyjątku.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości typu apartment wiedzieć, tak więc jeśli nazwa stanu apartamentu jest `STA`, transakcji nie można używać w wielu wątków. Visual Basic ustawia stan wątku głównego do `STA`, więc należy zastosować <xref:System.MTAThreadAttribute> w `Main` procedury. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> za pomocą następującego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu wysyła ciąg do kolejką transakcyjną, a następnie odbiera wiadomości z tej kolejki.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Aplikacja usługi kolejkowania komunikatów wskazane Użyj niepoprawne transakcji.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wysyła obiekt do kolejki odwołuje się to <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do kolejki odwołuje się <xref:System.Messaging.MessageQueue>, w kontekście transakcji zdefiniowanych przez `transactionType` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do wysłania tej wiadomości. Określ `Single` Jeśli chcesz wysłać wiadomość jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz wysłać wiadomości transakcyjnych nietransakcyjnej wątku.  
  
 Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message> lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <summary>Wysyła obiekt do kolejki nietransakcyjnej odwołuje się ten <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do kolejki odwołuje się <xref:System.Messaging.MessageQueue>. Z tego przeciążenia można określić etykiety ciąg identyfikujący wiadomości. Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message>, struktury, obiektu danych lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki wiadomości, ale obie te są zależne od aplikacji, a nie dziedziczenie znaczenia usługi kolejkowania komunikatów.  
  
 Jeśli używasz tego przeciążenia do wysyłania wiadomości do kolejki transakcyjnej wiadomość zostanie wysłana do kolejki utraconych wiadomości. Komunikat, który ma być częścią transakcji, które zawiera inne komunikaty, należy użyć przeciążenia, które przyjmuje <xref:System.Messaging.MessageQueueTransaction> lub <xref:System.Messaging.MessageQueueTransactionType> jako parametr.  
  
 <xref:System.Messaging.MessageQueue.Path%2A> Właściwości dla tego <xref:System.Messaging.MessageQueue> wystąpienie musi zostać podane przed wysłaniem wiadomości. Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transaction As MessageQueueTransaction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <param name="transaction">
          <see cref="T:System.Messaging.MessageQueueTransaction" /> Obiektu.</param>
        <summary>Wysyła obiekt do transakcyjnej kolejki odwołuje się ten <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do transakcyjnej kolejki odwołuje się <xref:System.Messaging.MessageQueue>, przy użyciu kontekstu wewnętrzną transakcję zdefiniowane przez `transaction` parametru. Z tego przeciążenia można określić etykiety ciąg identyfikujący wiadomości. Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message>, struktury, obiektu danych lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki wiadomości, ale obie te są zależne od aplikacji, a nie dziedziczenie znaczenia usługi kolejkowania komunikatów.  
  
 Jeśli używasz tego przeciążenia do wysyłania wiadomości do kolejki nietransakcyjnej może wysłać komunikatu do kolejki utraconych wiadomości bez generowania wyjątku.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości typu apartment wiedzieć, tak więc jeśli nazwa stanu apartamentu jest `STA`, transakcji nie można używać w wielu wątków. Visual Basic ustawia stan wątku głównego do `STA`, więc należy zastosować <xref:System.MTAThreadAttribute> w `Main` procedury. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> za pomocą następującego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr jest <see langword="null" />.  
  
 —lub—  
  
 <paramref name="transaction" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Aplikacja usługi kolejkowania komunikatów wskazane użycie transakcji niepoprawne.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Send (obj As Object, label As String, transactionType As MessageQueueTransactionType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Send(System::Object ^ obj, System::String ^ label, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">Obiekt do wysyłania do kolejki.</param>
        <param name="label">Etykieta wiadomości.</param>
        <param name="transactionType">Jeden z <see cref="T:System.Messaging.MessageQueueTransactionType" /> wartości opisujące typ kontekstu transakcji do skojarzenia z komunikatem.</param>
        <summary>Wysyła obiekt do kolejki odwołuje się ten <see cref="T:System.Messaging.MessageQueue" /> i Określa etykietę wiadomości.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby wysłać wiadomość, która zawiera `obj` parametru do kolejki odwołuje się <xref:System.Messaging.MessageQueue>, w kontekście transakcji zdefiniowanych przez `transactionType` parametru. Określ `Automatic` dla `transactionType` parametru, jeśli istnieje już w kontekście transakcji zewnętrznej dołączony do wątku, który ma być używany do wysłania tej wiadomości. Określ `Single` Jeśli chcesz wysłać wiadomość jako jedna transakcja wewnętrzna. Można określić `None` Jeśli chcesz wysłać wiadomości transakcyjnych nietransakcyjnej wątku.  
  
 Obiekt wysyłać do kolejki, może być <xref:System.Messaging.Message> lub dowolny obiekt zarządzany. W przypadku wysłania dowolny obiekt inny niż <xref:System.Messaging.Message>, obiekt jest serializowany i wstawione do treści wiadomości. Z tego przeciążenia można określić etykiety ciąg identyfikujący wiadomości.  
  
 Etykieta wiadomości różni się od etykietę kolejki wiadomości, ale obie te są zależne od aplikacji, a nie dziedziczenie znaczenia usługi kolejkowania komunikatów.  
  
 Jeśli nie ustawisz <xref:System.Messaging.MessageQueue.Formatter%2A> właściwość przed wywołaniem <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, domyślnie program formatujący <xref:System.Messaging.XmlMessageFormatter>.  
  
 <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> Właściwość ma zastosowanie do wszystkich obiektów innej niż <xref:System.Messaging.Message>. Jeśli określisz, na przykład etykietę lub priorytetu przy użyciu <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> członka, te wartości stosowana do wiadomości, która zawiera obiekt, który nie jest typu <xref:System.Messaging.Message> po aplikacji wysyła je do kolejki. Podczas wysyłania <xref:System.Messaging.Message>, ustawić wartości właściwości dla <xref:System.Messaging.Message> pierwszeństwo <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>i komunikatu <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> właściwości mają pierwszeństwo przed kolejki <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> właściwości.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="label" /> Parametr jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">Aplikacja usługi kolejkowania komunikatów wskazane użycie transakcji niepoprawne.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">
          <paramref name="transactionType" /> Parametru nie jest jednym z <see cref="T:System.Messaging.MessageQueueTransactionType" /> elementów członkowskich.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">
          <see cref="P:System.Messaging.MessageQueue.Path" /> Właściwość nie została ustawiona.  
  
 —lub—  
  
 Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
        <altmember cref="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
        <altmember cref="T:System.Messaging.Message" />
        <altmember cref="P:System.Messaging.MessageQueue.Transactional" />
        <altmember cref="P:System.Messaging.MessageQueue.Label" />
        <altmember cref="M:System.Messaging.MessageQueue.Peek" />
        <altmember cref="M:System.Messaging.MessageQueue.Receive" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginPeek" />
        <altmember cref="M:System.Messaging.MessageQueue.BeginReceive" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetPermissions">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Dodaje uprawnienia w bieżącym zestawie. Ten można kontrolować, kto ma prawa dostępu do właściwości kolejki i wiadomości w kolejce.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (dacl As AccessControlList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::AccessControlList ^ dacl);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">A <see cref="T:System.Messaging.AccessControlList" /> zawiera jeden lub więcej wpisów kontroli dostępu, określające stron zaufanych, a uprawnienia można przyznać.</param>
        <summary>Przypisuje uprawnienia do kolejki na podstawie zawartości listy kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Użyj tego przeciążenia, aby przydzielić, Odmów lub odwołać prawa przy użyciu kolekcji wpisów kontroli dostępu pozwala określić informacje o uprawnienia i zarządca. Służy to, na przykład, aby udzielić uprawnień do wielu użytkowników jednocześnie.  
  
 Zarządca należy określić podczas tworzenia `ace` parametru może być poszczególnych użytkowników, grupy użytkowników lub komputera. Jeśli osoby zaufanej osoby, użyj formatu `DOMAIN` \\ `user`. Można określić "." dla zarządcy wskazują na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> dodać prawa do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę i grupy domeny każdy ma uprawnienia do pobrania właściwości kolejki, uprawnienia i zapisu do kolejki. Podczas wywoływania <xref:System.Messaging.MessageQueue.SetPermissions%2A>, uprawnień użytkowników i informacji jest dołączany na końcu listy.  
  
 System sprawdza, czy każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednej z stron zaufanych, wymienione w wątku tokenu dostępu.  
  
-   Co najmniej jeden dostępu dozwolone <xref:System.Messaging.AccessControlEntry> elementów dla stron zaufanych, jawnie wymieniony w tokenie dostępu wątku przyznać prawa dostępu do żądanej.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i jest nadal co najmniej jeden żądanego prawo dostępu, który nie został jawnie zezwolił, w takim przypadku niejawnie odmowa dostępu.  
  
 Podczas konstruowania `dacl` parametr, Dodaj <xref:System.Messaging.AccessControlEntry> wystąpień do Twojej <xref:System.Messaging.AccessControlList> kolekcji. Podczas tworzenia każdego wpisu kontroli dostępu, można określić prawa dostępu ogólnego lub standard. Prawa do kolejki może być dowolną kombinacją z następujących czynności:  
  
-   Usuwanie  
  
-   Odczyt zabezpieczeń  
  
-   Zapis zabezpieczeń  
  
-   Synchronizuj  
  
-   Modyfikacja właściciela  
  
-   Odczyt  
  
-   Write  
  
-   Wykonanie  
  
-   Wymagane  
  
-   Wszystkie  
  
-   Brak  
  
 Te uprawnienia są zestawem flagi bitów, które można łączyć przy użyciu bitowego operatora OR.  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Komunikat  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmowanie na własność kolejki  
  
-   Napisz wiadomość  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.AccessControlList" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (ace As MessageQueueAccessControlEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::Messaging::MessageQueueAccessControlEntry ^ ace);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">A <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> , który określa użytkownika, typ dostępu i typ uprawnienia.</param>
        <summary>Przypisuje uprawnienia do kolejki na podstawie zawartości wpisu kontroli dostępu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia udzielić, odmówić lub odwołania praw za pomocą wpisu kontroli dostępu, aby określić zarządca i informacji o prawach.  
  
 Zarządca należy określić podczas tworzenia `ace` parametru może być poszczególnych użytkowników, grupy użytkowników lub komputera. Jeśli osoby zaufanej osoby, użyj formatu `DOMAIN` \\ `user`. Można określić "." dla zarządcy wskazują na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> dodać prawa do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę i grupy domeny każdy ma uprawnienia do pobrania właściwości kolejki, uprawnienia i zapisu do kolejki. Podczas wywoływania <xref:System.Messaging.MessageQueue.SetPermissions%2A>, uprawnień użytkowników i informacji jest dołączany na końcu listy.  
  
 System sprawdza, czy każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednej z stron zaufanych, wymienione w wątku tokenu dostępu.  
  
-   Co najmniej jeden dostępu dozwolone <xref:System.Messaging.AccessControlEntry> elementów dla stron zaufanych, jawnie wymieniony w tokenie dostępu wątku przyznać prawa dostępu do żądanej.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i jest nadal co najmniej jeden żądanego prawo dostępu, który nie został jawnie zezwolił, w takim przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, które należy określić w `rights` parametru utworzenia użytkownika <xref:System.Messaging.MessageQueueAccessControlEntry>, może być dowolną kombinację następujących:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Komunikat  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmowanie na własność kolejki  
  
-   Napisz wiadomość  
  
 `rights` Parametr należy określić w Konstruktorze `ace` parametru jest flagą <xref:System.Messaging.MessageQueueAccessRights> wyliczenia. Reprezentuje zestaw flagi bitów, które można łączyć przy użyciu bitowego operatora lub podczas budowania `rights` parametru.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.MessageQueueAccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">Osoby, grupy lub komputera, który pobiera dodatkowych praw do kolejki.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> wskazujący zestaw praw do kolejki usługi kolejkowania komunikatów przypisuje <c>użytkownika</c> przekazany.</param>
        <summary>Zapewnia komputera, grupy lub użytkownika określonego uprawnienia.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia przyznanie praw określonego użytkownika. Użytkownik może być żadnych zarządca prawidłową, w tym poszczególnych użytkowników, grup użytkowników lub komputera. Jeśli użytkownik jest osoba, użyj formatu `DOMAIN` \\ `user` dla `user` parametru. Można określić "." dla `user` parametr, aby wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> dodać prawa do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę i grupy domeny każdy ma uprawnienia do pobrania właściwości kolejki, uprawnienia i zapisu do kolejki. Podczas wywoływania <xref:System.Messaging.MessageQueue.SetPermissions%2A>, uprawnień użytkowników i informacji jest dołączany na końcu listy.  
  
 System sprawdza, czy każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednej z stron zaufanych, wymienione w wątku tokenu dostępu.  
  
-   Co najmniej jeden dostępu dozwolone <xref:System.Messaging.AccessControlEntry> elementów dla stron zaufanych, jawnie wymieniony w tokenie dostępu wątku przyznać prawa dostępu do żądanej.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i jest nadal co najmniej jeden żądanego prawo dostępu, który nie został jawnie zezwolił, w takim przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, określona w `rights` parametr, może być dowolną kombinację następujących czynności:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Komunikat  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmowanie na własność kolejki  
  
-   Napisz wiadomość  
  
 <xref:System.Messaging.MessageQueueAccessRights> Wyliczenie reprezentuje zestaw z bitowego flagi, które można łączyć przy użyciu bitowego operatora lub kompilacji `rights` parametru.  
  
 Z tego przeciążenia tylko uprawnienia można przyznać; Nie można odwołać lub je zablokować. Należy użyć innego przeciążenia, aby jawnie udzielić żadnego <xref:System.Messaging.AccessControlEntryType> innych niż `Allow`.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="user" /> Jest <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPermissions (user As String, rights As MessageQueueAccessRights, entryType As AccessControlEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPermissions(System::String ^ user, System::Messaging::MessageQueueAccessRights rights, System::Messaging::AccessControlEntryType entryType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">Osoby, grupy lub komputera, który pobiera dodatkowych praw do kolejki.</param>
        <param name="rights">A <see cref="T:System.Messaging.MessageQueueAccessRights" /> wskazujący zestaw praw do kolejki usługi kolejkowania komunikatów przypisuje <c>użytkownika</c> przekazany.</param>
        <param name="entryType">A <see cref="T:System.Messaging.AccessControlEntryType" /> Określa, czy należy udzielić, odmówić lub odwołać uprawnienia określone przez <c>prawa</c> parametru.</param>
        <summary>Zapewnia komputera, grupy lub użytkownika praw dostępu do określonego typu kontroli dostępu do określonego (Zezwalaj, Odmów, odwoływanie lub ustaw).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To przeciążenie umożliwia udzielić, odmówić lub odwołać określonych uprawnień dla poszczególnych użytkowników. Użytkownik może być żadnych zarządca prawidłową, w tym poszczególnych użytkowników, grup użytkowników lub komputera. Jeśli użytkownik jest osoba, użyj formatu `DOMAIN` \\ `user` dla `user` parametru. Można określić "." dla `user` parametr, aby wskazać na komputerze lokalnym.  
  
 Uprawnienia można przypisać za pomocą <xref:System.Messaging.MessageQueue.SetPermissions%2A> dodać prawa do istniejącej listy. Domyślnie twórca kolejki publicznej lub prywatnej ma pełną kontrolę i grupy domeny każdy ma uprawnienia do pobrania właściwości kolejki, uprawnienia i zapisu do kolejki. Podczas wywoływania <xref:System.Messaging.MessageQueue.SetPermissions%2A>, uprawnień użytkowników i informacji jest dołączany na końcu listy.  
  
 System sprawdza, czy każdy <xref:System.Messaging.AccessControlEntry> w sekwencji, dopóki nie wystąpi jedno z następujących zdarzeń:  
  
-   Odmowa dostępu <xref:System.Messaging.AccessControlEntry> wyraźnie zabrania żadnych praw żądany dostęp do jednej z stron zaufanych, wymienione w wątku tokenu dostępu.  
  
-   Co najmniej jeden dostępu dozwolone <xref:System.Messaging.AccessControlEntry> elementów dla stron zaufanych, jawnie wymieniony w tokenie dostępu wątku przyznać prawa dostępu do żądanej.  
  
-   Wszystkie <xref:System.Messaging.AccessControlEntry> elementy zostały sprawdzone i jest nadal co najmniej jeden żądanego prawo dostępu, który nie został jawnie zezwolił, w takim przypadku niejawnie odmowa dostępu.  
  
 Prawa do kolejki, określona w `rights` parametr, może być dowolną kombinację następujących czynności:  
  
-   Pełna kontrola  
  
-   Usuwanie wiadomości  
  
-   Komunikat  
  
-   Wgląd do wiadomości  
  
-   Odbieranie wiadomości dziennika  
  
-   Pobierz właściwości kolejki  
  
-   Ustaw właściwości kolejki  
  
-   Uzyskaj uprawnienia  
  
-   Ustawianie uprawnień  
  
-   Przejmowanie na własność kolejki  
  
-   Napisz wiadomość  
  
 <xref:System.Messaging.MessageQueueAccessRights> Wyliczenie reprezentuje zestaw z bitowego flagi, które można łączyć przy użyciu bitowego operatora lub kompilacji `rights` parametru.  
  
 W poniższej tabeli przedstawiono, czy ta metoda jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykład kodu pokazuje użycie <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueue.ResetPermissions" />
        <altmember cref="T:System.Messaging.Trustee" />
        <altmember cref="T:System.Messaging.MessageQueueAccessRights" />
        <altmember cref="T:System.Messaging.AccessControlEntry" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia obiekt, który marshals wywołań obsługi zdarzeń, wynikające z <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> lub <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> zdarzeń.</summary>
        <value>A <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, który reprezentuje obiekt, który marshals wywołań obsługi zdarzeń, wynikające z <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> lub <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> zdarzeń. Wartość domyślna to <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A <xref:System.Messaging.MessageQueue.ReceiveCompleted> lub <xref:System.Messaging.MessageQueue.PeekCompleted> wynikiem zdarzeń <xref:System.Messaging.MessageQueue.BeginReceive%2A> lub <xref:System.Messaging.MessageQueue.BeginPeek%2A> żądania odpowiednio z konkretnym wątkiem. Zazwyczaj <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> jest ustawiona, gdy jego powiązanych składnika jest umieszczony wewnątrz formantu lub formularza, ponieważ te składniki są powiązane z konkretnym wątkiem.  
  
 Zazwyczaj obiekt synchronizacji marshals wywołanie metody do jednego wątku.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Messaging.MessageQueue.PeekCompleted" />
        <altmember cref="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Transactional As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Transactional { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera wartość wskazującą, czy kolejka akceptuje tylko transakcje.</summary>
        <value>
          <see langword="true" /> Jeśli kolejka akceptuje tylko wiadomości wysyłane jako część transakcji; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wiadomości transakcyjne odwołuje się do sprzężenia powiązane komunikaty w pojedynczą transakcję. Wysyłanie wiadomości jako część transakcji gwarantuje, że komunikaty są dostarczane w kolejności, dostarczane tylko raz i pomyślnie pobrał z kolejki docelowej.  
  
 Jeśli kolejka jest transakcyjna, akceptuje tylko wiadomości, które są wysyłane jako część transakcji. Jednak nietransakcyjnej wiadomości mogą być wysyłane lub odbierane z kolejki transakcji lokalnej bez jawnie za pomocą transakcyjne <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, i <xref:System.Messaging.MessageQueueTransaction.Abort%2A> składni. Jeśli nietransakcyjnej komunikatów są wysyłane do kolejki transakcyjnej, ten składnik tworzy transakcji pojedynczej wiadomości, z wyjątkiem w przypadku odwołania do kolejki na komputerze zdalnym przy użyciu bezpośredniej nazwy formatu. W takiej sytuacji jeśli nie określisz kontekst transakcji podczas wysyłania wiadomości, co nie jest tworzony automatycznie i wiadomość zostanie wysłana do kolejki utraconych wiadomości.  
  
 Po wysłaniu nietransakcyjnej wiadomości do kolejki transakcyjnej, nie można przywrócić komunikatu w razie Wystąpił wyjątek.  
  
 <xref:System.Messaging.MessageQueueTransaction> jest wątkowości typu apartment wiedzieć, tak więc jeśli nazwa stanu apartamentu jest `STA`, transakcji nie można używać w wielu wątków. Visual Basic ustawia stan wątku głównego do `STA`, więc należy zastosować <xref:System.MTAThreadAttribute> w `Main` procedury. W przeciwnym razie wysyła wiadomości transakcyjne przy użyciu innego wątku zgłasza <xref:System.Messaging.MessageQueueException> wyjątku. Należy zastosować <xref:System.MTAThreadAttribute> za pomocą następującego fragmentu.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod przedstawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.Transactional%2A> właściwości.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Begin" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Commit" />
        <altmember cref="M:System.Messaging.MessageQueueTransaction.Abort" />
        <altmember cref="P:System.Messaging.Message.TransactionId" />
        <altmember cref="P:System.Messaging.Message.IsFirstInTransaction" />
        <altmember cref="P:System.Messaging.Message.IsLastInTransaction" />
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberSignature Language="VB.NET" Value="Public Property UseJournalQueue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseJournalQueue { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera lub ustawia wartość wskazującą, czy odebranej wiadomości są kopiowane do kolejki dziennika.</summary>
        <value>
          <see langword="true" /> Jeśli odbierać wiadomości z kolejki są kopiowane do kolejki dziennika; w przeciwnym razie <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aplikacja usługi kolejkowania komunikatów tworzy nową kolejkę w aplikacji, automatycznie tworzy skojarzonych kolejki w tej samej lokalizacji. Kolejki dziennika służy do śledzenia komunikatów usuniętych z kolejki. Ustawienie tej właściwości modyfikuje kolejki usługi kolejkowania komunikatów. W związku z tym każdy inny <xref:System.Messaging.MessageQueue> wystąpień dotyczy zmiana.  
  
 Kolejki dziennika nie śledzi komunikatów usuniętych z kolejki, ponieważ wygasła ważność zegara ich czas do odbioru, ani nie jest śledzenie wiadomości usunięte z kolejki przy użyciu usługa katalogowa usługi MSMQ (magazyn informacji programu lub usługi Active Directory).  
  
 Aplikacje nie mogą wysyłać wiadomości do kolejki dziennika; są one ograniczone do dostęp tylko do odczytu tych kolejek. Ponadto usługi kolejkowania komunikatów nigdy nie powoduje usunięcie wiadomości z kolejki dziennika. Do aplikacji przy użyciu kolejki należy wyczyścić te komunikaty przez ich odbierania lub czyszczenie kolejki.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Nie|  
  
   
  
## Examples  
 Poniższy przykładowy kod pobiera i ustawia wartość kolejki komunikatów <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> właściwości.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Wystąpił błąd podczas uzyskiwania dostępu do metody usługi kolejkowania komunikatów.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriteHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr WriteHandle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Pobiera uchwyt macierzysty używany do wysyłania wiadomości do kolejki wiadomości.</summary>
        <value>Dojście do obiektu kolejki macierzystego, używanej do wysyłania wiadomości do kolejki.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.WriteHandle%2A> Zapewnia uchwyt macierzysty systemu Windows do obiektu kolejki komunikatów, który jest używany do wysyłania wiadomości do kolejki. W przypadku zmiany ścieżki do kolejki, dojście jest zamknięte i ponownie otworzyć z nową wartością.  
  
 W poniższej tabeli przedstawiono, czy ta właściwość jest dostępna w różnych trybach grupy roboczej.  
  
|Trybie grupy roboczej|Dostępne|  
|--------------------|---------------|  
|Komputer lokalny|Tak|  
|Komputer lokalny i bezpośredniej nazwy formatu|Tak|  
|Komputer zdalny|Nie|  
|Komputer zdalny i bezpośredniej nazwy formatu|Tak|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Kolejka komunikatów nie jest dostępna dla zapisu.</exception>
        <altmember cref="P:System.Messaging.MessageQueue.CanWrite" />
        <altmember cref="P:System.Messaging.MessageQueue.ReadHandle" />
      </Docs>
    </Member>
  </Members>
</Type>